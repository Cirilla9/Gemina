diff --color -ruN -w -B '--exclude-from=.diff-exclude' linux-5.10/arch/x86/entry/syscalls/syscall_64.tbl HawkEye-5.10-cow/arch/x86/entry/syscalls/syscall_64.tbl
--- linux-5.10/arch/x86/entry/syscalls/syscall_64.tbl	2020-12-13 22:41:30.000000000 +0000
+++ HawkEye-5.10-cow/arch/x86/entry/syscalls/syscall_64.tbl	2025-03-23 07:53:41.079275921 +0000
@@ -362,6 +362,7 @@
 438	common	pidfd_getfd		sys_pidfd_getfd
 439	common	faccessat2		sys_faccessat2
 440	common	process_madvise		sys_process_madvise
+441 common  update_mm_ohp_stats	sys_update_mm_ohp_stats
 
 #
 # Due to a historical design error, certain syscalls are numbered differently
diff --color -ruN -w -B '--exclude-from=.diff-exclude' linux-5.10/ftrace-pgfault-latency-tracker/compile_commands.json HawkEye-5.10-cow/ftrace-pgfault-latency-tracker/compile_commands.json
--- linux-5.10/ftrace-pgfault-latency-tracker/compile_commands.json	1970-01-01 00:00:00.000000000 +0000
+++ HawkEye-5.10-cow/ftrace-pgfault-latency-tracker/compile_commands.json	2025-03-23 07:54:12.349887470 +0000
@@ -0,0 +1,24 @@
+[
+    {
+        "arguments": [
+            "gcc",
+            "-c",
+            "-o",
+            "faultpages",
+            "vm-pgfault.c"
+        ],
+        "directory": "/home/zz/2024data/HawkEye-5.10/ftrace-pgfault-latency-tracker",
+        "file": "vm-pgfault.c"
+    },
+    {
+        "arguments": [
+            "gcc",
+            "-c",
+            "-o",
+            "tracer",
+            "vm-pgfault-tracer.c"
+        ],
+        "directory": "/home/zz/2024data/HawkEye-5.10/ftrace-pgfault-latency-tracker",
+        "file": "vm-pgfault-tracer.c"
+    }
+]
\ No newline at end of file
Binary files linux-5.10/ftrace-pgfault-latency-tracker/faultpages and HawkEye-5.10-cow/ftrace-pgfault-latency-tracker/faultpages differ
diff --color -ruN -w -B '--exclude-from=.diff-exclude' linux-5.10/ftrace-pgfault-latency-tracker/filter.txt HawkEye-5.10-cow/ftrace-pgfault-latency-tracker/filter.txt
--- linux-5.10/ftrace-pgfault-latency-tracker/filter.txt	1970-01-01 00:00:00.000000000 +0000
+++ HawkEye-5.10-cow/ftrace-pgfault-latency-tracker/filter.txt	2025-03-23 07:54:12.347471414 +0000
@@ -0,0 +1,59059 @@
+__traceiter_initcall_level
+__traceiter_initcall_start
+__traceiter_initcall_finish
+trace_initcall_finish_cb
+trace_initcall_start_cb
+initcall_blacklisted
+do_one_initcall
+do_one_initcall
+match_dev_by_label
+match_dev_by_uuid
+rootfs_init_fs_context
+name_to_dev_t
+name_to_dev_t
+calibration_delay_done
+calibrate_delay
+vdso_mremap
+vvar_mremap
+vdso_fault
+map_vdso
+map_vdso_randomized
+find_timens_vvar_page
+vvar_fault
+arch_get_vdso_data
+vdso_join_timens
+map_vdso_once
+arch_setup_additional_pages
+compat_arch_setup_additional_pages
+gate_vma_name
+__traceiter_emulate_vsyscall
+write_ok_or_segv
+warn_bad_vsyscall
+emulate_vsyscall
+get_gate_vma
+in_gate_area
+in_gate_area_no_mm
+x86_pmu_dead_cpu
+x86_pmu_starting_cpu
+x86_pmu_dying_cpu
+x86_pmu_swap_task_ctx
+x86_pmu_sched_task
+x86_pmu_prepare_cpu
+x86_pmu_event_idx
+get_segment_base
+perf_get_x86_pmu_capability
+x86_pmu_commit_txn
+x86_pmu_read
+x86_pmu_online_cpu
+x86_pmu_disable
+get_attr_rdpmc
+max_precise_show
+set_attr_rdpmc
+perf_assign_events
+events_sysfs_show
+x86_pmu_extra_regs
+x86_pmu_check_period
+x86_pmu_aux_output_match
+collect_event
+collect_events
+x86_pmu_add
+is_visible
+x86_pmu_cancel_txn
+x86_pmu_start_txn
+x86_pmu_event_unmapped
+perf_event_nmi_handler
+perf_events_lapic_init.part.0
+allocate_fake_cpuc
+x86_pmu_event_mapped
+x86_perf_event_update
+x86_pmu_stop
+x86_pmu_del
+_x86_pmu_read
+x86_reserve_hardware
+x86_pmu_event_init
+x86_release_hardware
+hw_perf_event_destroy
+x86_add_exclusive
+x86_del_exclusive
+hw_perf_lbr_event_destroy
+x86_setup_perfctr
+x86_pmu_max_precise
+x86_pmu_hw_config
+x86_pmu_disable_all
+x86_pmu_enable_all
+x86_get_pmu
+x86_schedule_events
+x86_perf_rdpmc_index
+x86_perf_event_set_period
+x86_pmu_start
+x86_pmu_enable
+x86_pmu_enable_event
+perf_event_print_debug
+x86_pmu_handle_irq
+perf_events_lapic_init
+events_ht_sysfs_show
+x86_event_sysfs_show
+perf_check_microcode
+arch_perf_update_userpage
+perf_callchain_kernel
+perf_callchain_user
+perf_instruction_pointer
+perf_misc_flags
+not_visible
+perf_msr_probe
+amd_pmu_event_map
+amd_event_sysfs_show
+cmask_show
+inv_show
+edge_show
+umask_show
+event_show
+amd_pmu_wait_on_overflow
+amd_pmu_disable_all
+amd_put_event_constraints
+amd_get_event_constraints_f15h
+amd_put_event_constraints_f17h
+amd_pmu_cpu_starting
+amd_pmu_disable_event
+amd_pmu_enable_virt
+amd_pmu_disable_virt
+amd_pmu_handle_irq
+amd_pmu_cpu_dead
+amd_pmu_hw_config
+amd_get_event_constraints
+amd_pmu_cpu_prepare
+amd_get_event_constraints_f17h
+__uncore_threadmask8_show
+__uncore_slicemask_show
+__uncore_threadmask2_show
+__uncore_sliceid_show
+__uncore_enallcores_show
+__uncore_enallslices_show
+__uncore_coreid_show
+__uncore_umask_show
+__uncore_event8_show
+__uncore_event14_show
+__uncore_event12_show
+amd_uncore_alloc
+amd_uncore_read
+uncore_down_prepare
+amd_uncore_cpu_down_prepare
+amd_uncore_find_online_sibling
+amd_uncore_cpu_starting
+amd_uncore_cpu_up_prepare
+amd_uncore_attr_show_cpumask
+event_to_amd_uncore
+amd_uncore_event_init
+amd_uncore_start
+amd_uncore_add
+amd_uncore_stop
+amd_uncore_del
+uncore_online
+amd_uncore_cpu_online
+uncore_dead
+amd_uncore_cpu_dead
+get_ibs_fetch_count
+perf_ibs_read
+get_ibs_caps
+rand_en_show
+cnt_ctl_show
+perf_ibs_init
+get_ibs_op_count
+setup_APIC_ibs
+x86_pmu_amd_ibs_starting_cpu
+perf_ibs_event_update
+clear_APIC_ibs
+x86_pmu_amd_ibs_dying_cpu
+perf_ibs_suspend
+perf_ibs_start
+perf_ibs_add
+force_ibs_eilvt_setup
+perf_ibs_resume
+perf_ibs_stop
+perf_ibs_del
+perf_ibs_handle_irq
+perf_ibs_nmi_handler
+domid_mask_show
+pasid_mask_show
+devid_mask_show
+domid_show
+pasid_show
+devid_show
+csource_show
+_iommu_cpumask_show
+perf_iommu_event_init
+_iommu_event_show
+perf_iommu_read
+perf_iommu_stop
+perf_iommu_start
+perf_iommu_del
+perf_iommu_add
+test_aperfmperf
+test_ptsc
+test_irperf
+test_therm_status
+event_show
+msr_event_init
+test_intel
+msr_event_add
+msr_event_update
+msr_event_stop
+msr_event_del
+msr_event_start
+intel_pmu_event_map
+nhm_limit_period
+intel_event_sysfs_show
+branches_show
+pmu_name_show
+freeze_on_smi_store
+freeze_on_smi_show
+frontend_show
+ldlat_show
+offcore_rsp_show
+in_tx_cp_show
+in_tx_show
+cmask_show
+inv_show
+any_show
+pc_show
+edge_show
+umask_show
+event_show
+intel_pmu_aux_output_match
+intel_pmu_swap_task_ctx
+intel_pmu_sched_task
+core_pmu_enable_event
+__intel_pmu_disable_all
+intel_pmu_disable_all
+intel_pmu_del_event
+intel_pmu_add_event
+intel_pmu_check_period
+__intel_shared_reg_get_constraints
+intel_pebs_aliases_core2
+intel_pebs_aliases_snb
+intel_guest_get_msrs
+bdw_limit_period
+pebs_is_visible
+lbr_is_visible
+exra_is_visible
+dyn_constraint
+intel_commit_scheduling
+intel_start_scheduling
+core_guest_get_msrs
+perf_guest_get_msrs
+tsx_is_visible
+__icl_update_topdown_event
+free_excl_cntrs
+intel_pmu_reset
+update_saved_topdown_regs
+icl_update_topdown_event
+intel_pmu_read_event
+intel_check_pebs_isolation
+intel_put_event_constraints
+show_sysctl_tfa
+set_sysctl_tfa
+update_tfa_sched
+intel_pebs_aliases_ivb
+intel_pebs_aliases_skl
+default_is_visible
+flip_smm_bit
+intel_pmu_bts_config
+core_pmu_hw_config
+intel_pmu_hw_config
+hsw_hw_config
+intel_snb_check_microcode
+intel_get_event_constraints
+hsw_get_event_constraints
+icl_get_event_constraints
+tfa_get_event_constraints
+tnt_get_event_constraints
+glp_get_event_constraints
+intel_stop_scheduling
+__intel_pmu_enable_all.constprop.0
+intel_pmu_enable_all
+core_pmu_enable_all
+intel_pmu_cpu_dying
+intel_tfa_commit_scheduling
+intel_tfa_pmu_enable_all
+intel_pmu_nhm_enable_all
+intel_pmu_disable_event
+intel_pmu_cpu_starting
+icl_set_topdown_event_period
+intel_pmu_enable_event
+intel_pmu_save_and_restart
+handle_pmi_common
+intel_pmu_handle_irq_v4
+intel_pmu_handle_irq
+x86_get_event_constraints
+intel_cpuc_prepare
+intel_pmu_cpu_prepare
+intel_cpuc_finish
+intel_pmu_cpu_dead
+bts_event_read
+bts_buffer_free_aux
+bts_event_destroy
+bts_event_init
+bts_update
+bts_event_stop
+bts_event_del
+buf_nr_pages.part.0
+__bts_event_start
+bts_buffer_reset
+bts_event_start
+bts_event_add
+bts_buffer_setup_aux
+intel_bts_enable_local
+intel_bts_disable_local
+intel_bts_interrupt
+ds_clear_cea
+ds_update_cea
+pebs_update_state
+intel_pmu_save_and_restart_reload
+intel_pmu_pebs_event_update_no_drain
+intel_pmu_pebs_fixup_ip
+get_data_src
+setup_pebs_fixed_sample_data
+setup_pebs_adaptive_sample_data
+release_bts_buffer
+intel_pmu_drain_pebs_nhm
+intel_pmu_drain_pebs_icl
+intel_pmu_drain_pebs_core
+dsalloc_pages
+release_pebs_buffer
+init_debug_store_on_cpu
+fini_debug_store_on_cpu
+release_ds_buffers
+reserve_ds_buffers
+intel_pmu_enable_bts
+intel_pmu_disable_bts
+intel_pmu_drain_bts_buffer
+intel_pebs_constraints
+intel_pmu_pebs_sched_task
+intel_pmu_pebs_add
+intel_pmu_pebs_enable
+intel_pmu_pebs_del
+intel_pmu_pebs_disable
+intel_pmu_pebs_enable_all
+intel_pmu_pebs_disable_all
+intel_pmu_auto_reload_read
+perf_restore_debug_store
+knc_pmu_event_map
+knc_pmu_disable_all
+cmask_show
+inv_show
+edge_show
+umask_show
+event_show
+knc_pmu_enable_event
+knc_pmu_enable_all
+knc_pmu_handle_irq
+intel_pmu_arch_lbr_xsaves
+intel_pmu_arch_lbr_xrstors
+intel_pmu_store_lbr
+intel_pmu_arch_lbr_read
+x86_perf_get_lbr
+branch_type
+intel_pmu_lbr_filter
+intel_pmu_arch_lbr_read_xsave
+intel_pmu_arch_lbr_save
+intel_pmu_arch_lbr_reset
+intel_pmu_arch_lbr_restore
+intel_pmu_lbr_reset_32
+intel_pmu_lbr_reset_64
+intel_pmu_lbr_reset
+intel_pmu_lbr_restore
+intel_pmu_lbr_save
+intel_pmu_lbr_swap_task_ctx
+intel_pmu_lbr_sched_task
+intel_pmu_lbr_add
+release_lbr_buffers
+intel_pmu_lbr_del
+intel_pmu_lbr_enable_all
+intel_pmu_lbr_disable_all
+intel_pmu_lbr_read_32
+intel_pmu_lbr_read_64
+intel_pmu_lbr_read
+intel_pmu_setup_lbr_filter
+intel_pmu_store_pebs_lbrs
+intel_pmu_lbr_init_hsw
+intel_pmu_lbr_init_knl
+ht_show
+escr_show
+cccr_show
+p4_pmu_event_map
+p4_pmu_handle_irq
+p4_pmu_disable_all
+p4_hw_config
+p4_pmu_enable_event
+p4_pmu_enable_all
+p4_pmu_schedule_events
+p6_pmu_event_map
+cmask_show
+inv_show
+pc_show
+edge_show
+umask_show
+event_show
+p6_pmu_enable_event
+p6_pmu_enable_all
+p6_pmu_disable_all
+pt_event_read
+pt_event_addr_filters_sync
+intel_pt_validate_cap
+intel_pt_validate_hw_cap
+pt_topa_dump
+pt_topa_entry_for_page
+pt_event_addr_filters_validate
+topa_insert_table
+pt_event_destroy
+psb_period_show
+cyc_thresh_show
+mtc_period_show
+branch_show
+ptw_show
+noretcomp_show
+tsc_show
+mtc_show
+fup_on_ptw_show
+pwr_evt_show
+cyc_show
+pt_show
+pt_cap_show
+pt_read_offset
+pt_event_init
+pt_update_head
+intel_pt_handle_vmx
+pt_buffer_reset_offsets
+pt_buffer_reset_markers
+pt_timing_attr_show
+pt_buffer_fini_topa
+pt_buffer_free_aux
+topa_alloc.constprop.0
+pt_buffer_setup_aux
+pt_config_start
+pt_config_buffer
+pt_event_start
+pt_event_add
+pt_handle_status
+pt_config_stop
+pt_event_stop
+pt_event_del
+pt_event_snapshot_aux
+intel_pt_interrupt
+cpu_emergency_stop_pt
+is_intel_pt_event
+uncore_collect_events
+uncore_pci_find_dev_pmu
+uncore_pmu_disable
+uncore_pmu_enable
+uncore_pmu_event_start
+uncore_change_type_ctx
+uncore_pmu_register
+uncore_get_attr_cpumask
+uncore_pmu_unregister
+uncore_alloc_box
+allocate_boxes
+uncore_pci_pmu_register
+uncore_assign_events
+uncore_pmu_event_init
+uncore_box_ref.part.0
+uncore_box_unref
+uncore_event_cpu_offline
+uncore_pci_pmu_unregister
+uncore_event_cpu_online
+uncore_pcibus_to_physid
+uncore_pci_get_dev_die_info
+uncore_pci_remove
+uncore_pci_probe
+uncore_bus_notify
+__find_pci2phy_map
+uncore_event_show
+uncore_pmu_to_box
+uncore_msr_read_counter
+uncore_mmio_exit_box
+uncore_mmio_read_counter
+uncore_get_constraint
+uncore_put_constraint
+uncore_shared_reg_config
+uncore_perf_event_update
+uncore_pmu_event_read
+uncore_pmu_hrtimer
+uncore_pmu_event_stop
+uncore_pmu_event_add
+uncore_pmu_event_del
+uncore_pmu_start_hrtimer
+uncore_pmu_cancel_hrtimer
+nhmex_uncore_msr_init_box
+nhmex_uncore_msr_exit_box
+__uncore_thresh8_show
+__uncore_inv_show
+__uncore_edge_show
+__uncore_umask_show
+__uncore_event_show
+__uncore_qlx_cfg_show
+__uncore_xbr_mm_cfg_show
+__uncore_event5_show
+__uncore_mask_show
+__uncore_match_show
+__uncore_counter_show
+__uncore_pld_show
+__uncore_dsp_show
+__uncore_filter_mask_show
+__uncore_filter_match_show
+__uncore_filter_cfg_en_show
+__uncore_set_flag_sel_show
+__uncore_inc_sel_show
+__uncore_flag_mode_show
+__uncore_wrap_mode_show
+__uncore_storage_mode_show
+__uncore_count_mode_show
+nhmex_uncore_msr_disable_event
+nhmex_bbox_hw_config
+nhmex_sbox_hw_config
+nhmex_rbox_hw_config
+nhmex_rbox_put_constraint
+nhmex_mbox_hw_config
+nhmex_mbox_alter_er
+nhmex_mbox_get_shared_reg
+nhmex_mbox_put_shared_reg
+nhmex_mbox_put_constraint
+nhmex_mbox_get_constraint
+nhmex_rbox_get_constraint
+__uncore_iss_show
+__uncore_iperf_cfg_show
+__uncore_thr_show
+__uncore_fvc_show
+__uncore_pgt_show
+__uncore_map_show
+__uncore_xbr_match_show
+__uncore_xbr_mask_show
+nhmex_bbox_msr_enable_event
+nhmex_sbox_msr_enable_event
+nhmex_uncore_msr_enable_event
+nhmex_uncore_msr_disable_box
+nhmex_uncore_msr_enable_box
+nhmex_mbox_msr_enable_event
+nhmex_rbox_msr_enable_event
+nhmex_uncore_cpu_init
+snb_uncore_msr_enable_box
+skl_uncore_msr_enable_box
+icl_get_cbox_num
+snb_uncore_imc_enable_box
+snb_uncore_imc_enable_event
+snb_uncore_imc_hw_config
+nhm_uncore_msr_disable_box
+nhm_uncore_msr_enable_box
+__uncore_cmask5_show
+__uncore_inv_show
+__uncore_edge_show
+__uncore_umask_show
+__uncore_event_show
+__uncore_cmask8_show
+snb_uncore_msr_disable_event
+skl_uncore_msr_init_box
+nhm_uncore_msr_enable_event
+snb_uncore_imc_event_init
+snb_uncore_imc_init_box
+tgl_uncore_imc_freerunning_init_box
+snb_uncore_msr_init_box
+snb_uncore_msr_exit_box
+skl_uncore_msr_exit_box
+snb_uncore_imc_disable_event
+snb_uncore_imc_disable_box
+snb_uncore_msr_enable_event
+snb_uncore_cpu_init
+skl_uncore_cpu_init
+icl_uncore_cpu_init
+tgl_uncore_cpu_init
+snb_pci2phy_map_init
+snb_uncore_pci_init
+ivb_uncore_pci_init
+hsw_uncore_pci_init
+bdw_uncore_pci_init
+skl_uncore_pci_init
+nhm_uncore_cpu_init
+tgl_l_uncore_mmio_init
+tgl_uncore_mmio_init
+snbep_cbox_filter_mask
+ivbep_cbox_filter_mask
+knl_cha_filter_mask
+hswep_cbox_filter_mask
+skx_cha_filter_mask
+__uncore_filter_band3_show
+__uncore_filter_band2_show
+__uncore_filter_band1_show
+__uncore_filter_band0_show
+__uncore_occ_edge_show
+__uncore_occ_invert_show
+__uncore_thresh5_show
+__uncore_inv_show
+__uncore_edge_show
+__uncore_occ_sel_show
+__uncore_event_show
+__uncore_umask_show
+__uncore_filter_opc_show
+__uncore_filter_state_show
+__uncore_filter_nid_show
+__uncore_filter_tid_show
+__uncore_thresh8_show
+__uncore_tid_en_show
+__uncore_mask1_show
+__uncore_mask0_show
+__uncore_mask_vnw_show
+__uncore_mask_opc_show
+__uncore_mask_mc_show
+__uncore_mask_dnid_show
+__uncore_mask_rnid4_show
+__uncore_mask_rnid30_show
+__uncore_mask_rds_show
+__uncore_match1_show
+__uncore_match0_show
+__uncore_match_vnw_show
+__uncore_match_mc_show
+__uncore_match_dnid_show
+__uncore_match_rnid4_show
+__uncore_match_rnid30_show
+__uncore_match_rds_show
+__uncore_event_ext_show
+__uncore_filter_isoc_show
+__uncore_filter_c6_show
+__uncore_filter_nc_show
+__uncore_filter_opc2_show
+__uncore_filter_nid2_show
+__uncore_filter_state2_show
+__uncore_filter_link_show
+__uncore_occ_edge_det_show
+__uncore_thresh6_show
+__uncore_use_occ_ctr_show
+__uncore_event2_show
+__uncore_filter_opc3_show
+__uncore_filter_all_op_show
+__uncore_filter_state4_show
+__uncore_filter_link3_show
+__uncore_filter_tid4_show
+__uncore_qor_show
+__uncore_filter_cid_show
+__uncore_filter_tid2_show
+__uncore_filter_state3_show
+__uncore_filter_link2_show
+__uncore_filter_tid3_show
+__uncore_fc_mask_show
+__uncore_ch_mask_show
+__uncore_thresh9_show
+__uncore_filter_opc_1_show
+__uncore_filter_opc_0_show
+__uncore_filter_not_nm_show
+__uncore_filter_nm_show
+__uncore_filter_loc_show
+__uncore_filter_rem_show
+__uncore_filter_state5_show
+__uncore_umask_ext_show
+__uncore_fc_mask2_show
+__uncore_ch_mask2_show
+__uncore_filter_tid5_show
+__uncore_umask_ext2_show
+__uncore_umask_ext3_show
+__uncore_umask_ext4_show
+snbep_uncore_msr_enable_box
+snbep_uncore_msr_init_box
+ivbep_uncore_msr_init_box
+snbep_cbox_hw_config
+snbep_qpi_hw_config
+ivbep_cbox_hw_config
+knl_cha_hw_config
+hswep_ubox_hw_config
+hswep_cbox_hw_config
+skx_cha_hw_config
+snr_cha_hw_config
+snr_uncore_mmio_disable_box
+snr_uncore_mmio_enable_box
+icx_cha_hw_config
+snbep_pcu_put_constraint
+snbep_pcu_alter_er
+snbep_pcu_get_constraint
+snbep_pcu_hw_config
+snbep_cbox_put_constraint
+__snbep_cbox_get_constraint
+snbep_cbox_get_constraint
+ivbep_cbox_get_constraint
+knl_cha_get_constraint
+hswep_cbox_get_constraint
+skx_cha_get_constraint
+hswep_pcu_hw_config
+snr_pcu_hw_config
+snbep_uncore_pci_read_counter
+ivbep_uncore_irp_read_counter
+hswep_uncore_irp_read_counter
+snbep_uncore_pci_enable_event
+snbep_uncore_pci_disable_event
+snbep_uncore_pci_enable_box
+snbep_uncore_pci_disable_box
+snbep_uncore_pci_init_box
+snbep_qpi_enable_event
+ivbep_uncore_pci_init_box
+ivbep_uncore_irp_enable_event
+ivbep_uncore_irp_disable_event
+knl_uncore_imc_enable_event
+knl_uncore_imc_enable_box
+skx_upi_uncore_pci_init_box
+skx_m2m_uncore_pci_init_box
+snr_uncore_pci_enable_event
+snr_m2m_uncore_pci_init_box
+skx_iio_cleanup_mapping
+skx_iio_mapping_show
+__snr_uncore_mmio_init_box
+snr_uncore_mmio_init_box
+icx_uncore_imc_freerunning_init_box
+icx_uncore_imc_init_box
+snr_uncore_mmio_enable_event
+skx_iio_set_mapping
+__uncore_match_opc_show
+__uncore_filter_local_show
+__uncore_filter_nnm_show
+skx_iio_mapping_visible
+snr_uncore_mmio_disable_event
+snbep_pci2phy_map_init
+snbep_uncore_msr_disable_event
+skx_iio_enable_event
+hswep_uncore_sbox_msr_init_box
+snr_cha_enable_event
+snbep_uncore_msr_enable_event
+hswep_cbox_enable_event
+ivbep_cbox_enable_event
+snbep_uncore_msr_disable_box
+snbep_uncore_cpu_init
+snbep_uncore_pci_init
+ivbep_uncore_cpu_init
+ivbep_uncore_pci_init
+knl_uncore_cpu_init
+knl_uncore_pci_init
+hswep_uncore_cpu_init
+hswep_uncore_pci_init
+bdx_uncore_cpu_init
+bdx_uncore_pci_init
+skx_uncore_cpu_init
+skx_uncore_pci_init
+snr_uncore_cpu_init
+snr_uncore_pci_init
+snr_uncore_mmio_init
+icx_uncore_cpu_init
+icx_uncore_pci_init
+icx_uncore_mmio_init
+zhaoxin_pmu_disable_all
+zhaoxin_pmu_event_map
+zhaoxin_event_sysfs_show
+cmask_show
+inv_show
+edge_show
+umask_show
+event_show
+zhaoxin_get_event_constraints
+zhaoxin_pmu_enable_all
+zhaoxin_pmu_enable_event
+zhaoxin_pmu_handle_irq
+zhaoxin_pmu_disable_event
+xen_cpu_up_online
+xen_arch_register_cpu
+xen_arch_unregister_cpu
+xen_cpuhp_setup
+xen_vcpu_info_reset
+xen_vcpu_setup
+xen_vcpu_restore
+xen_reboot
+xen_panic_event
+xen_emergency_restart
+xen_panic_handler_init
+xen_pin_vcpu
+xen_unmap_domain_gfn_range
+arbitrary_virt_to_machine
+arbitrary_virt_to_mfn
+gnttab_apply
+arch_gnttab_valloc
+arch_gnttab_map_shared
+arch_gnttab_map_status
+arch_gnttab_unmap
+arch_gnttab_init
+xen_vcpu_notify_suspend
+xen_vcpu_notify_restore
+xen_arch_pre_suspend
+xen_arch_post_suspend
+xen_arch_resume
+xen_arch_suspend
+__sysvec_xen_hvm_callback
+xen_hvm_crash_shutdown
+xen_cpu_up_prepare_hvm
+xen_hvm_shutdown
+xen_cpu_dead_hvm
+xen_hvm_init_shared_info
+xen_oldmem_pfn_is_ram
+xen_hvm_exit_mmap
+xen_hvm_post_suspend
+xen_has_pv_and_legacy_disk_devices
+xen_has_pv_devices
+xen_has_pv_disk_devices
+xen_has_pv_nic_devices
+xen_unplug_emulated_devices
+xen_enable_sysenter.part.0
+xen_enable_sysenter
+xen_enable_syscall
+xen_set_apic_id
+xen_get_apic_id
+xen_apic_read
+xen_apic_icr_read
+xen_apic_icr_write
+xen_safe_apic_wait_icr_idle
+xen_apic_probe_pv
+xen_madt_oem_check
+xen_id_always_valid
+xen_id_always_registered
+xen_noop
+xen_silent_inquire
+xen_phys_pkg_id
+xen_apic_write
+xen_cpu_present_to_apicid
+xen_io_apic_read
+xen_intel_pmu_emulate
+xen_amd_pmu_emulate
+is_intel_pmu_msr
+xen_get_guest_ip
+xen_is_user_mode
+xen_is_in_guest
+pmu_msr_read
+pmu_msr_write
+xen_read_pmc
+pmu_apic_update
+xen_pmu_irq_handler
+is_xen_pmu
+xen_pmu_init
+xen_pmu_finish
+xen_pv_pre_suspend
+xen_pv_post_suspend
+get_phys_to_machine
+p2m_mid_mfn_init
+xen_alloc_p2m_entry
+xen_setup_mfn_list_list
+__set_phys_to_machine
+set_phys_to_machine
+set_foreign_p2m_mapping
+clear_foreign_p2m_mapping
+xen_set_debugreg
+xen_get_debugreg
+xen_store_tr
+xen_invalidate_io_bitmap
+xen_io_delay
+xen_cpu_dead_pv
+xen_crash_shutdown
+xen_machine_power_off
+xen_machine_halt
+xen_restart
+xen_end_context_switch
+xen_write_msr_safe
+xen_write_msr
+xen_get_nmi_reason
+xen_cpuid
+xen_read_msr_safe
+xen_read_msr
+xen_update_io_bitmap
+xen_write_cr4
+xen_read_cr0
+xen_load_gs_index
+xen_cpu_up_prepare_pv
+load_TLS_descriptor
+xen_write_ldt_entry
+cvt_gate_to_trap.part.0
+xen_write_idt_entry
+xen_convert_trap_info
+xen_running_on_version_or_later.part.0
+xen_load_idt
+xen_load_gdt
+xen_load_tls
+xen_write_gdt_entry
+set_aliased_prot
+xen_free_ldt
+xen_alloc_ldt
+xen_load_sp0
+xen_write_cr0
+xen_set_ldt
+xen_running_on_version_or_later
+xen_copy_trap_info
+xen_read_cr3
+set_current_cr3
+xen_exchange_memory
+xen_write_cr2
+xen_get_user_pgd
+xen_leave_lazy_mmu
+xen_pgd_free
+xen_pgd_alloc
+drop_mm_ref_this_cpu
+xen_page_pinned
+pte_pfn_to_mfn.part.0
+xen_pte_unlock
+__xen_pgd_walk
+remap_area_pfn_pte_fn
+pte_mfn_to_pfn.part.0
+xen_flush_tlb
+xen_flush_tlb_all
+xen_remap_pfn
+xen_flush_tlb_one_user
+xen_remap_exchanged_ptes
+xen_alloc_pmd
+xen_alloc_pud
+xen_zap_pfn_range
+xen_extend_mmu_update
+__xen_set_p4d_hyper
+xen_set_pud_hyper
+xen_set_pud
+xen_set_pmd_hyper
+xen_set_pmd
+xen_alloc_pte
+xen_extend_mmuext_op
+xen_do_pin
+xen_pin_page
+xen_unpin_page
+__xen_write_cr3
+xen_write_cr3
+__xen_pgd_unpin
+xen_exit_mmap
+__xen_pgd_pin
+xen_activate_mm
+xen_dup_mmap
+xen_set_fixmap
+xen_release_pmd
+xen_release_pte
+xen_release_pud
+xen_set_pte
+xen_set_p4d
+xen_flush_tlb_others
+make_lowmem_page_readonly
+make_lowmem_page_readwrite
+set_pte_mfn
+xen_ptep_modify_prot_start
+xen_ptep_modify_prot_commit
+xen_pte_val
+xen_pgd_val
+xen_make_pte
+xen_make_pgd
+xen_pmd_val
+xen_make_pmd
+xen_pud_val
+xen_make_pud
+xen_p4d_val
+xen_make_p4d
+xen_mm_pin_all
+xen_mm_unpin_all
+xen_make_pte_init
+xen_create_contiguous_region
+xen_destroy_contiguous_region
+paddr_vmcoreinfo_note
+xen_mc_flush
+__xen_mc_entry
+xen_mc_extend_args
+xen_mc_callback
+__traceiter_xen_mc_batch
+__traceiter_xen_mc_issue
+__traceiter_xen_mc_entry
+__traceiter_xen_mc_entry_alloc
+__traceiter_xen_mc_callback
+__traceiter_xen_mc_flush_reason
+__traceiter_xen_mc_flush
+__traceiter_xen_mc_extend_args
+__traceiter_xen_mmu_set_pte
+__traceiter_xen_mmu_set_pmd
+__traceiter_xen_mmu_set_pud
+__traceiter_xen_mmu_set_p4d
+__traceiter_xen_mmu_ptep_modify_prot_start
+__traceiter_xen_mmu_ptep_modify_prot_commit
+__traceiter_xen_mmu_alloc_ptpage
+__traceiter_xen_mmu_release_ptpage
+__traceiter_xen_mmu_pgd_pin
+__traceiter_xen_mmu_pgd_unpin
+__traceiter_xen_mmu_flush_tlb_one_user
+__traceiter_xen_mmu_flush_tlb_others
+__traceiter_xen_mmu_write_cr3
+__traceiter_xen_cpu_write_ldt_entry
+__traceiter_xen_cpu_write_idt_entry
+__traceiter_xen_cpu_load_idt
+__traceiter_xen_cpu_write_gdt_entry
+__traceiter_xen_cpu_set_ldt
+xen_call_function_interrupt
+__xen_send_IPI_mask
+xen_reschedule_interrupt
+xen_call_function_single_interrupt
+xen_smp_intr_free
+xen_smp_intr_init
+xen_smp_send_reschedule
+xen_smp_send_call_function_ipi
+xen_smp_send_call_function_single_ipi
+xen_send_IPI_mask
+xen_send_IPI_all
+xen_send_IPI_self
+xen_send_IPI_mask_allbutself
+xen_send_IPI_allbutself
+xen_irq_work_interrupt
+cpu_bringup
+xen_pv_cpu_die
+xen_pv_stop_other_cpus
+stop_self
+xen_pv_play_dead
+xen_pv_cpu_disable
+xen_pv_cpu_up
+cpu_bringup_and_idle
+xen_smp_intr_free_pv
+xen_smp_intr_init_pv
+xen_hvm_cpu_die
+pci_xen_swiotlb_init_late
+pvh_get_root_pointer
+hv_reenlightenment_notify
+hv_free_hyperv_page
+hv_alloc_hyperv_page
+hv_alloc_hyperv_zeroed_page
+hv_is_hibernation_supported
+__sysvec_hyperv_reenlightenment
+hv_is_hyperv_initialized
+hyperv_cleanup
+set_hv_tscchange_cb
+hyperv_stop_tsc_emulation
+clear_hv_tscchange_cb
+hyperv_report_panic
+hyperv_report_panic_msg
+hv_cpu_init
+hv_resume
+hv_cpu_die
+hv_suspend
+__traceiter_hyperv_mmu_flush_tlb_others
+__traceiter_hyperv_nested_flush_guest_mapping
+__traceiter_hyperv_nested_flush_guest_mapping_range
+__traceiter_hyperv_send_ipi_mask
+__traceiter_hyperv_send_ipi_one
+hyperv_flush_tlb_others
+hyperv_setup_mmu_ops
+hyperv_fill_flush_guest_mapping_list
+hyperv_flush_guest_mapping
+hyperv_flush_guest_mapping_range
+hv_apic_icr_read
+hv_apic_eoi_write
+hv_apic_write
+hv_apic_read
+hv_send_ipi_mask_allbutself.part.0
+hv_apic_icr_write
+__send_ipi_mask_ex.part.0
+__send_ipi_mask
+hv_send_ipi_all
+hv_send_ipi_mask_allbutself
+hv_send_ipi_allbutself
+hv_send_ipi_mask
+__send_ipi_one
+hv_send_ipi_self
+hv_send_ipi
+hv_qlock_kick
+hv_qlock_wait
+hv_vcpu_is_preempted
+__ia32_compat_sys_arch_prctl
+__x32_compat_sys_arch_prctl
+start_thread_common.constprop.0
+start_thread
+set_personality_ia32
+current_save_fsgs
+__show_regs
+release_thread
+x86_fsgsbase_read_task
+x86_gsbase_read_cpu_inactive
+x86_gsbase_write_cpu_inactive
+x86_fsbase_read_task
+x86_gsbase_read_task
+x86_fsbase_write_task
+x86_gsbase_write_task
+compat_start_thread
+set_personality_64bit
+do_arch_prctl_64
+__ia32_sys_arch_prctl
+__x64_sys_arch_prctl
+KSTK_ESP
+x32_copy_siginfo_to_user
+restore_sigcontext
+get_sigframe
+copy_siginfo_to_user32
+arch_do_signal
+signal_fault
+__do_sys_rt_sigreturn
+__do_compat_sys_x32_rt_sigreturn
+sigaction_compat_abi
+get_kernel_gp_address
+do_int3
+show_signal
+do_trap
+do_error_trap
+math_error
+handle_stack_overflow
+load_current_idt
+idt_invalidate
+dummy_handler
+kvm_set_posted_intr_wakeup_handler
+__sysvec_kvm_posted_intr_wakeup_ipi
+perf_perm_irq_work_exit
+__traceiter_local_timer_entry
+__traceiter_local_timer_exit
+__traceiter_spurious_apic_entry
+__traceiter_spurious_apic_exit
+__traceiter_error_apic_entry
+__traceiter_error_apic_exit
+__traceiter_x86_platform_ipi_entry
+__traceiter_x86_platform_ipi_exit
+__traceiter_irq_work_entry
+__traceiter_irq_work_exit
+__traceiter_reschedule_entry
+__traceiter_reschedule_exit
+__traceiter_call_function_entry
+__traceiter_call_function_exit
+__traceiter_call_function_single_entry
+__traceiter_call_function_single_exit
+__traceiter_threshold_apic_entry
+__traceiter_threshold_apic_exit
+__traceiter_deferred_error_apic_entry
+__traceiter_deferred_error_apic_exit
+__traceiter_thermal_apic_entry
+__traceiter_thermal_apic_exit
+__traceiter_vector_config
+__traceiter_vector_update
+__traceiter_vector_clear
+__traceiter_vector_reserve_managed
+__traceiter_vector_reserve
+__traceiter_vector_alloc
+__traceiter_vector_alloc_managed
+__traceiter_vector_activate
+__traceiter_vector_deactivate
+__traceiter_vector_teardown
+__traceiter_vector_setup
+__traceiter_vector_free_moved
+__sysvec_x86_platform_ipi
+ack_bad_irq
+arch_show_interrupts
+arch_irq_stat_cpu
+arch_irq_stat
+fixup_irqs
+irq_init_percpu_irqstack
+do_softirq_own_stack
+stack_type_name
+get_stack_info
+timer_interrupt
+profile_pc
+clocksource_arch_init
+task_update_io_bitmap
+__x64_sys_iopl
+__ia32_sys_iopl
+io_bitmap_share
+io_bitmap_exit
+ksys_ioperm
+__x64_sys_ioperm
+__ia32_sys_ioperm
+oops_begin
+oops_end
+__die_header
+show_opcodes
+show_ip
+show_iret_regs
+show_stack
+show_regs
+__die_body
+__die
+die
+die_addr
+local_touch_nmi
+__traceiter_nmi_handler
+__register_nmi_handler
+nmi_handle
+unregister_nmi_handler
+pci_serr_error
+unknown_nmi_error
+io_check_error
+stop_nmi
+restart_nmi
+finalize_ldt_struct
+alloc_ldt_struct
+free_ldt_pgtables
+read_ldt
+free_ldt_struct.part.0
+map_ldt_struct.part.0
+write_ldt
+__ia32_sys_modify_ldt
+__x64_sys_modify_ldt
+load_mm_ldt
+flush_ldt
+switch_ldt
+ldt_dup_context
+destroy_context_ldt
+ldt_arch_exit_mmap
+x86_init_noop
+x86_op_int_noop
+default_nmi_init
+iommu_shutdown_noop
+arch_restore_msi_irqs
+i8259A_suspend
+i8259A_shutdown
+mask_8259A
+unmask_8259A
+legacy_pic_noop
+legacy_pic_uint_noop
+legacy_pic_int_noop
+legacy_pic_irq_pending_noop
+legacy_pic_probe
+i8259A_irq_pending
+unmask_8259A_irq
+mask_8259A_irq
+make_8259A_irq
+init_8259A
+i8259A_resume
+probe_8259A
+enable_8259A_irq
+disable_8259A_irq
+mask_and_ack_8259A
+__jump_label_set_jump_code
+arch_jump_label_transform
+arch_jump_label_transform_queue
+arch_jump_label_transform_apply
+arch_jump_label_transform_static
+__sysvec_irq_work
+arch_irq_work_raise
+pci_unmap_biosrom
+match_id
+find_oprom
+pci_biosrom_size
+pci_map_biosrom
+__x64_sys_ia32_truncate64
+__ia32_sys_ia32_truncate64
+__x64_sys_ia32_ftruncate64
+__ia32_sys_ia32_ftruncate64
+__x64_sys_ia32_pread64
+__ia32_sys_ia32_pread64
+__x64_sys_ia32_pwrite64
+__ia32_sys_ia32_pwrite64
+__x64_sys_ia32_fadvise64_64
+__ia32_sys_ia32_fadvise64_64
+__x64_sys_ia32_fadvise64
+__ia32_sys_ia32_fadvise64
+__x64_sys_ia32_readahead
+__ia32_sys_ia32_readahead
+__x64_sys_ia32_sync_file_range
+__ia32_sys_ia32_sync_file_range
+__x64_sys_ia32_fallocate
+__ia32_sys_ia32_fallocate
+cp_stat64
+__ia32_compat_sys_ia32_stat64
+__x32_compat_sys_ia32_stat64
+__ia32_compat_sys_ia32_lstat64
+__x32_compat_sys_ia32_lstat64
+__ia32_compat_sys_ia32_fstatat64
+__x32_compat_sys_ia32_fstatat64
+__ia32_compat_sys_ia32_fstat64
+__x32_compat_sys_ia32_fstat64
+__ia32_compat_sys_ia32_mmap
+__ia32_compat_sys_ia32_clone
+__x32_compat_sys_ia32_clone
+__x32_compat_sys_ia32_mmap
+__x64_sys_mmap
+__ia32_sys_mmap
+get_align_mask
+align_vdso_addr
+arch_get_unmapped_area
+arch_get_unmapped_area_topdown
+init_espfix_ap
+boot_params_data_read
+version_show
+get_setup_data_paddr
+type_show
+setup_data_data_read
+e820__mapped_raw_any
+e820__mapped_any
+e820__get_entry_type
+via_no_dac_cb
+via_no_dac
+force_disable_hpet_msi
+ich_force_enable_hpet
+old_ich_force_enable_hpet
+amd_disable_seq_and_redirect_scrub
+quirk_intel_brickland_xeon_ras_cap
+quirk_intel_purley_xeon_ras_cap
+quirk_amd_nb_node
+old_ich_force_enable_hpet_user
+ati_force_enable_hpet
+e6xx_force_enable_hpet
+quirk_intel_irqbalance
+nvidia_force_enable_hpet
+vt8237_force_enable_hpet
+force_hpet_resume
+arch_unregister_cpu
+arch_register_cpu
+add_nops
+text_poke_loc_init
+do_sync_core
+optimize_nops
+__text_poke
+text_poke_bp_batch
+alternatives_smp_module_add
+alternatives_smp_module_del
+alternatives_enable_smp
+alternatives_text_reserved
+text_poke_early
+apply_alternatives
+apply_paravirt
+text_poke
+text_poke_kgdb
+text_poke_sync
+text_poke_finish
+hw_breakpoint_restore
+encode_dr7
+decode_dr7
+arch_install_hw_breakpoint
+arch_uninstall_hw_breakpoint
+arch_bp_generic_fields
+arch_check_bp_in_kernelspace
+hw_breakpoint_arch_parse
+flush_ptrace_hw_breakpoint
+hw_breakpoint_exceptions_notify
+hw_breakpoint_pmu_read
+cpu_khz_from_msr
+native_io_delay
+rtc_cmos_read
+rtc_cmos_write
+mach_set_rtc_mmss
+mach_get_cmos_time
+update_persistent_clock64
+read_persistent_clock64
+arch_remove_reservations
+__static_call_validate
+arch_static_call_transform
+speculation_ctrl_update_tif
+amd_e400_idle
+enable_cpuid
+arch_dup_task_struct
+exit_thread
+copy_thread
+flush_thread
+disable_TSC
+get_tsc_mode
+set_tsc_mode
+native_tss_update_io_bitmap
+speculative_store_bypass_ht_init
+speculation_ctrl_update
+arch_setup_new_exec
+speculation_ctrl_update_current
+__switch_to_xtra
+arch_cpu_idle_enter
+arch_cpu_idle_dead
+arch_cpu_idle
+xen_set_default_idle
+stop_this_cpu
+select_idle_routine
+amd_e400_c1e_apic_setup
+arch_align_stack
+arch_randomize_brk
+get_wchan
+do_arch_prctl_common
+fpu__init_cpu_generic
+fpu__init_cpu
+irq_fpu_usable
+__traceiter_x86_fpu_before_save
+__traceiter_x86_fpu_after_save
+__traceiter_x86_fpu_before_restore
+__traceiter_x86_fpu_after_restore
+__traceiter_x86_fpu_regs_activated
+__traceiter_x86_fpu_regs_deactivated
+__traceiter_x86_fpu_init_state
+__traceiter_x86_fpu_dropped
+__traceiter_x86_fpu_copy_src
+__traceiter_x86_fpu_copy_dst
+__traceiter_x86_fpu_xstate_check_failed
+copy_fpregs_to_fpstate
+kernel_fpu_end
+fpstate_init
+fpregs_assert_state_consistent
+kernel_fpu_begin
+fpregs_mark_activate
+fpu__clear
+switch_fpu_return
+fpu__save
+fpu__copy
+fpu__prepare_read
+fpu__prepare_write
+fpu__drop
+fpu__clear_user_states
+fpu__clear_all
+fpu__exception_code
+regset_fpregs_active
+regset_xregset_fpregs_active
+xfpregs_get
+xfpregs_set
+xstateregs_get
+xstateregs_set
+convert_from_fxsr
+convert_to_fxsr
+fpregs_get
+fpregs_set
+__fpu__restore_sig
+copy_fpstate_to_sigframe
+fpu__restore_sig
+fpu__alloc_mathframe
+fpu__init_prepare_fx_sw_frame
+cpu_has_xfeatures
+__raw_xsave_addr
+get_xsave_addr
+copy_part
+fpstate_sanitize_xstate
+fpu__init_cpu_xstate
+xfeature_size
+using_compacted_format
+validate_user_xstate_header
+fpu__resume_cpu
+get_xsave_field_ptr
+arch_set_user_pkey_access
+copy_xstate_to_kernel
+copy_kernel_to_xstate
+copy_user_to_xstate
+copy_supervisor_to_kernel
+copy_dynamic_supervisor_to_kernel
+copy_kernel_to_dynamic_supervisor
+proc_pid_arch_status
+update_pasid
+ioperm_active
+getreg32
+ptrace_triggered
+set_segment_reg
+genregs32_get
+ptrace_register_breakpoint
+ptrace_set_breakpoint_addr
+ptrace_modify_breakpoint
+ptrace_set_debugreg
+getreg
+genregs_get
+ioperm_get
+set_flags
+putreg32
+genregs32_set
+putreg
+genregs_set
+regs_query_register_offset
+regs_query_register_name
+ptrace_disable
+arch_ptrace
+compat_arch_ptrace
+task_user_regset_view
+send_sigtrap
+user_single_step_report
+set_tls_desc
+fill_user_desc
+tls_desc_okay
+do_set_thread_area
+__x64_sys_set_thread_area
+__ia32_sys_set_thread_area
+do_get_thread_area
+__x64_sys_get_thread_area
+__ia32_sys_get_thread_area
+regset_tls_active
+regset_tls_get
+regset_tls_set
+convert_ip_to_linear
+set_task_blockstep
+enable_step
+user_enable_single_step
+user_enable_block_step
+user_disable_single_step
+tboot_extended_sleep
+tboot_log_read
+tboot_dying_cpu
+tboot_enabled
+tboot_shutdown
+tboot_sleep
+tboot_get_dmar_table
+tboot_force_iommu
+i8237A_resume
+arch_stack_walk
+arch_stack_walk_reliable
+arch_stack_walk_user
+subcaches_store
+subcaches_show
+find_num_cache_leaves
+cache_private_attrs_is_visible
+amd_get_l3_disable_slot
+store_cache_disable
+cache_disable_1_store
+cache_disable_0_store
+show_cache_disable
+cache_disable_1_show
+cache_disable_0_show
+amd_init_l3_cache.part.0
+cpuid4_cache_lookup_regs
+cache_get_priv_group
+cacheinfo_amd_init_llc_id
+cacheinfo_hygon_init_llc_id
+init_amd_cacheinfo
+init_hygon_cacheinfo
+init_intel_cacheinfo
+init_cache_level
+populate_cache_leaves
+init_scattered_cpuid_features
+check_extended_topology_leaf
+detect_extended_topology_leaf
+detect_extended_topology_early
+detect_extended_topology
+x86_init_rdrand
+x86_cpu_has_min_microcode_rev
+x86_match_cpu
+cpu_show_common.isra.0
+task_update_spec_tif
+ssb_prctl_set
+ib_prctl_set
+update_stibp_msr
+x86_amd_ssb_disable
+x86_virt_spec_ctrl
+update_srbds_msr
+retpoline_module_ok
+cpu_bugs_smt_update
+arch_prctl_spec_ctrl_set
+arch_seccomp_spec_mitigate
+arch_prctl_spec_ctrl_get
+x86_spec_ctrl_setup_ap
+cpu_show_meltdown
+cpu_show_spectre_v1
+cpu_show_spectre_v2
+cpu_show_spec_store_bypass
+cpu_show_l1tf
+cpu_show_mds
+cpu_show_tsx_async_abort
+cpu_show_itlb_multihit
+cpu_show_srbds
+aperfmperf_snapshot_khz
+aperfmperf_snapshot_cpu
+aperfmperf_get_khz
+arch_freq_prepare_all
+arch_freq_get_on_cpu
+do_clear_cpu_cap
+clear_cpu_cap
+setup_clear_cpu_cap
+umwait_update_control_msr
+umwait_cpu_online
+umwait_cpu_offline
+umwait_syscore_resume
+max_time_store
+max_time_show
+enable_c02_show
+enable_c02_store
+c_stop
+show_cpuinfo
+c_start
+c_next
+init_ia32_feat_ctl
+split_lock_verify_msr
+bsp_init_intel
+early_init_intel
+split_lock_warn
+handle_guest_split_lock
+intel_detect_tlb
+init_intel
+handle_user_split_lock
+switch_to_sld
+pconfig_target_supported
+tsx_disable
+tsx_enable
+intel_epb_save
+energy_perf_bias_store
+energy_perf_bias_show
+intel_epb_offline
+intel_epb_restore
+intel_epb_online
+amd_get_nodes_per_socket
+amd_get_nb_id
+cpu_detect_tlb_amd
+cpu_has_amd_erratum
+bsp_init_amd
+clear_rdrand_cpuid_bit
+early_init_amd
+init_amd
+set_dr_addr_mask
+bsp_init_hygon
+cpu_detect_tlb_hygon
+early_init_hygon
+init_hygon
+early_init_centaur
+init_centaur
+early_init_zhaoxin
+init_zhaoxin
+msr_to_offset
+mce_adjust_timer_default
+fake_panic_set
+__traceiter_mce_record
+mce_is_correctable
+fake_panic_get
+mce_read_aux
+mce_log
+mce_register_decode_chain
+mce_unregister_decode_chain
+__print_mce
+wait_for_panic
+queue_task_work
+kill_me_now
+__start_timer
+__mce_disable_bank
+mce_timer_delete_all
+mce_device_release
+fake_panic_fops_open
+vendor_disable_error_reporting
+mce_syscore_suspend
+mce_syscore_shutdown
+mce_default_notifier
+mce_start_timer
+__mcheck_cpu_init_timer
+set_cmci_disabled
+set_ignore_ce
+set_bank
+mce_cpu_dead
+show_bank
+mce_device_remove
+kill_me_maybe
+mce_usable_address
+quirk_sandybridge_ifu
+mce_is_memory_error
+print_mce
+mce_panic
+mce_timed_out
+mce_notify_irq
+mce_early_notifier
+__mcheck_cpu_init_vendor
+store_int_with_restart
+mce_available.part.0
+mce_cpu_pre_down
+mce_disable_cmci
+mce_enable_ce
+mce_cpu_online
+mce_irq_work_cb
+__mcheck_cpu_init_clear_banks
+uc_decode_notifier
+machine_check_poll
+__mcheck_cpu_init_generic
+mce_syscore_resume
+mce_cpu_restart
+mce_timer_fn
+ex_handler_rdmsr_fault
+ex_handler_wrmsr_fault
+mce_available
+mce_timer_kick
+filter_mce
+mcheck_cpu_init
+mcheck_cpu_clear
+mce_disable_bank
+mce_get_debugfs_dir
+s_stop
+severities_coverage_write
+severities_coverage_open
+s_start
+s_next
+is_copy_from_user
+s_show
+error_context
+mce_severity_intel
+mce_severity_amd
+mce_gen_pool_prepare_records
+mce_gen_pool_process
+mce_gen_pool_empty
+mce_gen_pool_add
+mce_gen_pool_init
+lmce_supported
+cmci_supported
+intel_init_lmce.part.0
+cmci_toggle_interrupt_mode
+intel_threshold_interrupt
+intel_clear_lmce.part.0
+cmci_discover
+cmci_rediscover_work_func
+__cmci_disable_bank
+mce_intel_cmci_poll
+mce_intel_hcpu_update
+cmci_recheck
+cmci_intel_adjust_timer
+cmci_clear
+cmci_rediscover
+cmci_reenable
+cmci_disable_bank
+intel_init_cmci
+intel_init_lmce
+intel_clear_lmce
+mce_intel_feature_init
+mce_intel_feature_clear
+intel_filter_mce
+smca_get_long_name
+show
+store
+__log_error
+umc_normaddr_to_sysaddr
+threshold_block_release
+store_threshold_limit
+show_interrupt_enable
+show_threshold_limit
+show_error_count
+store_interrupt_enable
+get_block_address.isra.0
+get_name
+threshold_restart_bank.part.0
+threshold_restart_bank
+prepare_threshold_block
+log_and_reset_block
+amd_threshold_interrupt
+__sysvec_deferred_error
+allocate_threshold_blocks
+amd_deferred_error_interrupt
+amd_filter_mce
+mce_amd_feature_init
+amd_mce_is_memory_error
+mce_threshold_remove_device
+mce_threshold_create_device
+__sysvec_threshold
+get_therm_status
+thermal_throttle_offline
+therm_throt_device_show_core_throttle_total_time_ms
+therm_throt_device_show_core_throttle_max_time_ms
+therm_throt_device_show_core_throttle_count
+therm_throt_device_show_package_power_limit_count
+therm_throt_device_show_package_throttle_total_time_ms
+therm_throt_device_show_package_throttle_max_time_ms
+therm_throt_device_show_package_throttle_count
+therm_throt_device_show_core_power_limit_count
+throttle_active_work
+thermal_throttle_online
+therm_throt_process
+intel_thermal_interrupt
+__sysvec_thermal
+intel_init_thermal
+apei_mce_report_mem_error.part.0
+apei_mce_report_mem_error
+apei_write_mce
+apei_read_mce
+apei_check_mce
+apei_clear_mce
+mce_do_trigger
+set_trigger
+show_trigger
+mce_register_injector_chain
+mce_unregister_injector_chain
+dev_mce_log
+mce_chrdev_ioctl
+__mce_read_apei
+mce_chrdev_read
+mce_chrdev_poll
+mce_chrdev_write
+mce_chrdev_release
+mce_chrdev_open
+mce_work_trigger
+arch_phys_wc_index
+mtrr_restore
+mtrr_save
+mtrr_rendezvous_handler
+mtrr_add_page
+mtrr_add
+arch_phys_wc_add
+mtrr_del_page
+mtrr_del
+arch_phys_wc_del
+mtrr_ap_init
+mtrr_save_state
+set_mtrr_aps_delayed_init
+mtrr_aps_init
+mtrr_bp_restore
+mtrr_file_del
+mtrr_close
+mtrr_write
+mtrr_open
+mtrr_seq_show
+mtrr_file_add.constprop.0
+mtrr_ioctl
+mtrr_attrib_to_str
+generic_have_wrcomb
+generic_get_free_region
+generic_validate_add_page
+generic_get_mtrr
+check_type_overlap
+mtrr_type_lookup_variable
+mtrr_type_lookup
+fill_mtrr_var_range
+mtrr_wrmsr
+prepare_set
+post_set
+generic_set_all
+generic_set_mtrr
+get_fixed_ranges.constprop.0
+mtrr_save_fixed_ranges
+positive_have_wrcomb
+mc_cpu_online
+collect_cpu_info_local
+apply_microcode_local
+pf_show
+version_show
+mc_device_remove
+collect_cpu_info
+apply_microcode_on_target
+mc_cpu_down_prep
+microcode_init_cpu
+mc_device_add
+mc_cpu_starting
+reload_store
+__wait_for_cpus.constprop.0
+__reload_late
+get_builtin_firmware
+load_ucode_ap
+find_microcode_in_initrd
+reload_early_microcode
+mc_bp_resume
+microcode_sanity_check
+load_builtin_intel_microcode
+is_blacklisted
+print_ucode_info
+memdup_patch
+collect_cpu_info
+find_matching_signature
+find_patch
+save_microcode_patch
+generic_load_microcode
+request_microcode_fw
+request_microcode_user
+scan_microcode
+collect_cpu_info_early
+__load_ucode_intel
+apply_microcode_intel
+apply_microcode_early
+load_ucode_intel_ap
+reload_ucode_intel
+request_microcode_user
+microcode_fini_cpu_amd
+__apply_microcode_amd
+find_patch
+apply_microcode_amd
+free_cache
+verify_patch
+free_equiv_cpu_table
+__load_ucode_amd
+verify_container
+verify_equivalence_table.part.0
+scan_containers
+apply_microcode_early_amd
+load_microcode_amd.part.0
+collect_cpu_info_amd
+__load_microcode_amd
+request_microcode_amd
+load_ucode_amd_ap
+reload_ucode_amd
+clear_closid_rmid.isra.0
+resctrl_offline_cpu
+delay_bw_map.part.0
+mba_wrmsr_intel
+mba_wrmsr_amd
+cat_wrmsr
+resctrl_online_cpu
+is_mba_sc
+delay_bw_map
+get_domain_from_cpu
+rdt_ctrl_update
+rdt_find_domain
+setup_default_ctrlval
+resctrl_cpu_detect
+rdtgroup_seqfile_show
+rdtgroup_file_write
+set_mba_sc
+free_all_child_rdtgrp
+__resctrl_sched_in
+move_myself
+max_threshold_occ_show
+rdt_delay_linear_show
+rdt_bw_gran_show
+rdt_min_bw_show
+rdt_shareable_bits_show
+rdt_min_cbm_bits_show
+rdt_default_ctrl_show
+rdt_num_rmids_show
+rdt_mon_features_show
+rdt_num_closids_show
+is_mon_groups
+max_threshold_occ_write
+rdt_thread_throttle_mode_show
+rdt_last_cmd_status_show
+rdt_bit_usage_show
+rdtgroup_kn_set_ugid
+rdtgroup_add_files
+rdtgroup_mkdir_info_resdir
+mongroup_create_dir
+mkdir_mondata_subdir
+rdt_parse_param
+rdt_fs_context_free
+rdt_cdp_peer_get
+is_closid_match
+is_rmid_match
+l2_qos_cfg_update
+rdtgroup_show_options
+mkdir_mondata_all
+rdt_init_fs_context
+__rdtgroup_cbm_overlaps
+update_cpu_closid_rmid
+update_closid_rmid
+l3_qos_cfg_update
+set_cache_qos_cfg
+cdp_disable
+cdp_disable_all
+cdp_enable
+rdt_get_tree
+rdt_move_group_tasks
+rdt_kill_sb
+rdt_last_cmd_clear
+rdt_last_cmd_puts
+rdt_last_cmd_printf
+closids_supported
+closid_free
+rdtgroup_mode_by_closid
+rdtgroup_tasks_assigned
+proc_resctrl_show
+rdtgroup_cbm_overlaps
+rdtgroup_cbm_to_size
+rdtgroup_kn_mode_restrict
+rdtgroup_kn_mode_restore
+rdt_domain_reconfigure_cdp
+rdtgroup_kn_lock_live
+rdtgroup_kn_unlock
+rdtgroup_size_show
+rdtgroup_mode_write
+rdtgroup_mode_show
+rdtgroup_tasks_write
+rdtgroup_tasks_show
+rdtgroup_cpus_write
+rdtgroup_cpus_show
+rdtgroup_rmdir
+mkdir_rdt_prepare
+rdtgroup_mkdir
+rmdir_mondata_subdir_allrdtgrp
+mkdir_mondata_subdir_allrdtgrp
+__rmid_read
+mbm_overflow_count
+__mon_event_count
+mbm_update.constprop.0
+__check_limbo
+has_busy_rmid
+alloc_rmid
+mon_event_count
+cqm_handle_limbo
+cqm_setup_limbo_handler
+free_rmid
+mbm_handle_overflow
+mbm_setup_overflow_handler
+rdt_get_mon_l3_config
+parse_bw
+parse_cbm
+update_domains
+rdtgroup_schemata_write
+rdtgroup_schemata_show
+mon_event_read
+rdtgroup_mondata_show
+pseudo_lock_dev_mremap
+__traceiter_pseudo_lock_mem_latency
+__traceiter_pseudo_lock_l2
+__traceiter_pseudo_lock_l3
+pseudo_lock_region_clear
+pseudo_lock_dev_release
+pseudo_lock_dev_open
+pseudo_lock_measure_trigger
+pseudo_lock_cstates_relax
+pseudo_lock_devnode
+pseudo_lock_dev_mmap
+rdtgroup_locksetup_user_restore
+pseudo_lock_fn
+measure_cycles_lat_fn
+measure_residency_fn.constprop.0
+measure_l2_residency
+measure_l3_residency
+rdtgroup_locksetup_enter
+rdtgroup_locksetup_exit
+rdtgroup_cbm_overlaps_pseudo_locked
+rdtgroup_pseudo_locked_in_hierarchy
+rdtgroup_pseudo_lock_create
+rdtgroup_pseudo_lock_remove
+rdt_pseudo_lock_init
+rdt_pseudo_lock_release
+avail_to_resrv_perfctr_nmi_bit
+reserve_perfctr_nmi
+reserve_evntsel_nmi
+release_perfctr_nmi
+release_evntsel_nmi
+vmware_get_tsc_khz
+vmware_cmd_stealclock
+vmware_sev_es_hcall_prepare
+vmware_steal_clock
+vmware_guest_cpu_init
+vmware_pv_reboot_notify
+vmware_sev_es_hcall_finish
+vmware_disable_steal_time
+vmware_pv_guest_cpu_reboot
+vmware_cpu_online
+vmware_cpu_down_prepare
+hv_setup_vmbus_irq
+hv_remove_vmbus_irq
+hv_remove_stimer0_irq
+hv_setup_kexec_handler
+hv_remove_kexec_handler
+hv_setup_crash_handler
+hv_remove_crash_handler
+hv_get_nmi_reason
+hv_get_tsc_khz
+hv_machine_crash_shutdown
+__sysvec_hyperv_callback
+__sysvec_hyperv_stimer0
+hv_setup_stimer0_irq
+hv_machine_shutdown
+hv_nmi_unknown
+acrn_x2apic_available
+__sysvec_acrn_hv_callback
+acpi_register_gsi
+acpi_unregister_gsi
+acpi_register_gsi_pic
+acpi_unregister_ioapic
+acpi_unregister_gsi_ioapic
+acpi_register_gsi_ioapic
+acpi_register_ioapic
+acpi_gsi_to_irq
+acpi_register_lapic
+acpi_map_cpu
+acpi_unmap_cpu
+acpi_isa_irq_to_gsi
+acpi_ioapic_registered
+__acpi_acquire_global_lock
+__acpi_release_global_lock
+x86_default_set_root_pointer
+x86_default_get_root_pointer
+acpi_get_wakeup_address
+x86_acpi_enter_sleep_state
+x86_acpi_suspend_lowlevel
+arch_apei_enable_cmcff
+arch_apei_report_mem_error
+cpc_ffh_supported
+cpc_read_ffh
+cpc_write_ffh
+acpi_processor_power_init_bm_check
+acpi_processor_ffh_cstate_probe_cpu
+acpi_processor_ffh_cstate_probe
+native_machine_power_off
+native_machine_halt
+native_machine_shutdown
+machine_real_restart
+crash_nmi_callback
+vmxoff_nmi
+mach_reboot_fixups
+machine_power_off
+machine_shutdown
+machine_emergency_restart
+machine_restart
+machine_halt
+machine_crash_shutdown
+nmi_shootdown_cpus
+native_machine_emergency_restart
+run_crash_ipi_callback
+nmi_panic_self_stop
+__sysvec_call_function_single
+__sysvec_call_function
+smp_stop_nmi_callback
+native_stop_other_cpus
+__sysvec_reboot
+x86_core_flags
+x86_smt_flags
+init_counter_refs
+cpu_coregroup_mask
+topology_phys_to_logical_pkg
+topology_phys_to_logical_die
+skx_set_max_freq_ratio
+disable_freq_invariance_workfn
+topology_sane
+wakeup_cpu0_nmi
+init_freq_invariance
+arch_update_cpu_topology
+topology_is_primary_thread
+topology_smt_supported
+topology_update_package_map
+topology_update_die_map
+smp_store_cpu_info
+set_cpu_sibling_map
+wakeup_secondary_cpu_via_nmi
+common_cpu_up
+native_cpu_up
+arch_disable_smp_support
+arch_thaw_secondary_cpus_begin
+arch_thaw_secondary_cpus_end
+cpu_disable_common
+native_cpu_disable
+common_cpu_die
+native_cpu_die
+play_dead_common
+hlt_play_dead
+native_play_dead
+arch_set_max_freq_ratio
+arch_scale_freq_tick
+check_tsc_warp
+mark_tsc_async_resets
+tsc_verify_tsc_adjust
+tsc_store_and_check_tsc_adjust
+check_tsc_sync_source
+check_tsc_sync_target
+__lapic_update_tsc_freq
+lapic_next_event
+lapic_timer_broadcast
+lapic_setup_esr
+setup_APIC_timer
+setup_local_APIC
+__setup_APIC_LVTT
+lapic_timer_shutdown.part.0
+lapic_timer_shutdown
+set_multi
+__sysvec_error_interrupt
+__sysvec_apic_timer_interrupt
+setup_APIC_eilvt
+lapic_timer_set_periodic
+lapic_timer_set_oneshot
+lapic_next_deadline
+__x2apic_enable
+__x2apic_disable.part.0
+lapic_resume
+native_apic_wait_icr_idle
+native_safe_apic_wait_icr_idle
+native_apic_icr_write
+native_apic_icr_read
+lapic_get_maxlvt
+lapic_update_tsc_freq
+setup_secondary_APIC_clock
+setup_profiling_timer
+clear_local_APIC
+apic_soft_disable
+lapic_suspend
+disable_local_APIC
+lapic_shutdown
+apic_ap_setup
+x2apic_setup
+disconnect_bsp_APIC
+apic_id_is_primary_thread
+generic_processor_info
+hard_smp_processor_id
+apic_is_clustered_box
+default_cpu_present_to_apicid
+apic_default_calc_apicid
+apic_flat_calc_apicid
+default_check_apicid_used
+default_ioapic_phys_id_map
+default_check_phys_apicid_present
+default_apic_id_valid
+noop_init_apic_ldr
+noop_send_IPI
+noop_send_IPI_mask
+noop_send_IPI_allbutself
+noop_apic_icr_write
+noop_wakeup_secondary_cpu
+noop_safe_apic_wait_icr_idle
+noop_apic_icr_read
+noop_phys_pkg_id
+noop_get_apic_id
+noop_probe
+noop_apic_id_registered
+noop_apic_read
+noop_apic_write
+noop_send_IPI_mask_allbutself
+noop_send_IPI_all
+noop_send_IPI_self
+noop_apic_wait_icr_idle
+apic_smt_update
+apic_send_IPI_allbutself
+native_smp_send_reschedule
+native_send_call_func_single_ipi
+native_send_call_func_ipi
+__default_send_IPI_shortcut
+__default_send_IPI_dest_field
+default_send_IPI_single_phys
+default_send_IPI_mask_sequence_phys
+default_send_IPI_mask_allbutself_phys
+default_send_IPI_single
+default_send_IPI_allbutself
+default_send_IPI_all
+default_send_IPI_self
+free_moved_vector
+apic_chip_data.part.0
+irqd_cfg
+apic_retrigger_irq
+apic_update_irq_cfg
+vector_assign_managed_shutdown
+clear_irq_vector
+apic_update_vector
+assign_vector_locked
+x86_vector_free_irqs
+reserve_irq_vector_locked
+x86_vector_deactivate
+x86_vector_alloc_irqs
+assign_managed_vector
+assign_irq_vector_any_locked
+x86_vector_activate
+__send_cleanup_vector
+irq_complete_move.part.0
+apic_set_affinity
+__sysvec_irq_move_cleanup
+lock_vector_lock
+unlock_vector_lock
+init_irq_alloc_info
+copy_irq_alloc_info
+irq_cfg
+lapic_assign_legacy_vector
+lapic_online
+lapic_offline
+apic_ack_irq
+apic_ack_edge
+send_cleanup_vector
+irq_complete_move
+irq_force_complete_move
+lapic_can_unplug_cpu
+nmi_cpu_backtrace_handler
+nmi_raise_cpu_backtrace
+hw_nmi_get_sample_period
+arch_trigger_cpumask_backtrace
+__ioapic_read_entry
+ioapic_read_entry
+__ioapic_write_entry
+ioapic_write_entry
+ioapic_mask_entry
+mask_lapic_irq
+unmask_lapic_irq
+ack_lapic_irq
+save_ioapic_entries
+io_apic_modify_irq
+unmask_ioapic_irq
+startup_ioapic_irq
+mask_ioapic_irq
+io_apic_sync
+mp_irqdomain_deactivate
+irq_trigger
+__add_pin_to_irq_node
+mp_register_handler
+mp_check_pin_attr
+ioapic_configure_entry
+ioapic_set_affinity
+mp_irqdomain_activate
+mp_irqdomain_create
+alloc_isa_irq_from_domain.isra.0
+__eoi_ioapic_pin
+clear_IO_APIC_pin
+eoi_ioapic_pin
+ioapic_ir_ack_level
+ioapic_ack_level
+mp_irqdomain_free
+find_irq_entry.constprop.0
+alloc_ioapic_saved_registers
+ioapic_irq_get_chip_state
+mpc_ioapic_id
+mpc_ioapic_addr
+disable_ioapic_support
+mp_save_irq
+native_io_apic_read
+clear_IO_APIC
+mask_ioapic_entries
+restore_ioapic_entries
+ioapic_resume
+ioapic_set_alloc_attr
+mp_unmap_irq
+ioapic_zap_locks
+native_restore_boot_irq_mode
+restore_boot_irq_mode
+arch_dynirq_lower_bound
+mp_find_ioapic
+mp_find_ioapic_pin
+acpi_get_override_irq
+mp_map_pin_to_irq
+pin_2_irq
+IO_APIC_get_PCI_irq_vector
+mp_irqdomain_alloc
+mp_map_gsi_to_irq
+mp_register_ioapic
+mp_unregister_ioapic
+mp_ioapic_registered
+mp_irqdomain_ioapic_idx
+hpet_msi_free
+hpet_msi_write_msg
+__irq_msi_compose_msg
+irq_msi_update_msg
+msi_set_affinity
+dmar_msi_write_msg
+dmar_msi_init
+hpet_msi_init
+pci_msi_prepare
+x86_vector_msi_compose_msg
+arch_create_remap_msi_irq_domain
+dmar_alloc_hwirq
+dmar_free_hwirq
+hpet_create_irq_domain
+hpet_assign_irq
+numachip1_get_apic_id
+numachip1_set_apic_id
+numachip2_get_apic_id
+numachip_apic_id_valid
+numachip_apic_id_registered
+numachip2_apic_icr_write
+numachip_wakeup_secondary
+numachip_apic_wait_icr_idle
+numachip_safe_apic_wait_icr_idle
+numachip_phys_pkg_id
+numachip1_apic_icr_write
+numachip1_acpi_madt_oem_check
+numachip2_acpi_madt_oem_check
+numachip_send_IPI_self
+fixup_cpu_id
+numachip_send_IPI_one
+numachip_send_IPI_allbutself
+numachip_send_IPI_mask_allbutself
+numachip_send_IPI_mask
+numachip_send_IPI_all
+numachip2_set_apic_id
+uv_is_untracked_pat_range
+is_uv_system
+is_uv_hubbed
+uv_apic_id_valid
+uv_apic_id_registered
+uv_init_apic_ldr
+x2apic_get_apic_id
+set_apic_id
+uv_probe
+uv_phys_pkg_id
+uv_send_IPI_self
+proc_hubbed_show
+proc_hubless_show
+proc_archtype_show
+apic_uv_calc_apicid
+uv_set_vga_state
+uv_cpu_init.part.0
+uv_wakeup_secondary
+uv_send_IPI_one
+uv_send_IPI_allbutself
+uv_send_IPI_mask_allbutself
+uv_send_IPI_mask
+uv_send_IPI_all
+get_uv_system_type
+uv_cpu_init
+init_x2apic_ldr
+x2apic_apic_id_valid
+x2apic_apic_id_registered
+x2apic_get_apic_id
+x2apic_set_apic_id
+x2apic_phys_pkg_id
+x2apic_send_IPI_self
+x2apic_phys_probe
+x2apic_send_IPI
+x2apic_acpi_madt_oem_check
+__x2apic_send_IPI_mask
+x2apic_send_IPI_mask_allbutself
+x2apic_send_IPI_mask
+x2apic_send_IPI_all
+x2apic_send_IPI_allbutself
+__x2apic_send_IPI_dest
+__x2apic_send_IPI_shorthand
+x2apic_send_IPI_all
+x2apic_send_IPI_allbutself
+x2apic_calc_apicid
+init_x2apic_ldr
+x2apic_dead_cpu
+x2apic_send_IPI
+__x2apic_send_IPI_mask
+x2apic_send_IPI_mask_allbutself
+x2apic_send_IPI_mask
+x2apic_acpi_madt_oem_check
+x2apic_cluster_probe
+x2apic_prepare_cpu
+flat_acpi_madt_oem_check
+flat_get_apic_id
+set_apic_id
+flat_probe
+physflat_init_apic_ldr
+flat_phys_pkg_id
+flat_apic_id_registered
+flat_init_apic_ldr
+_flat_send_IPI_mask
+flat_send_IPI_mask_allbutself
+flat_send_IPI_mask
+physflat_acpi_madt_oem_check
+physflat_probe
+arch_crash_save_vmcoreinfo
+alloc_pgt_page
+mem_region_callback
+kexec_mark_range.part.0
+kexec_mark_crashkres
+machine_kexec_prepare
+machine_kexec_cleanup
+machine_kexec
+arch_kexec_kernel_image_load
+arch_kexec_apply_relocations_add
+arch_kexec_protect_crashkres
+arch_kexec_unprotect_crashkres
+arch_kexec_post_alloc_pages
+arch_kexec_pre_free_pages
+get_nr_ram_ranges_callback
+prepare_elf64_ram_headers_callback
+add_e820_entry
+memmap_entry_callback
+crash_smp_send_stop.part.0
+kdump_nmi_callback
+kdump_nmi_shootdown_cpus
+crash_smp_send_stop
+native_machine_crash_shutdown
+crash_setup_memmap_entries
+crash_load_segments
+bzImage64_verify_sig
+bzImage64_probe
+bzImage64_cleanup
+bzImage64_load
+__copy_oldmem_page.part.0
+copy_oldmem_page
+copy_oldmem_page_encrypted
+elfcorehdr_read
+synthesize_reljump
+synthesize_relcall
+arch_prepare_kretprobe
+skip_prefixes
+kprobe_fault_handler
+trampoline_handler
+resume_execution
+kprobe_debug_handler
+setup_singlestep
+reenter_kprobe
+kprobe_int3_handler
+can_boost
+recover_probed_instruction
+can_probe
+__copy_instruction
+arch_copy_kprobe
+alloc_insn_page
+free_insn_page
+arch_prepare_kprobe
+arch_arm_kprobe
+arch_disarm_kprobe
+arch_remove_kprobe
+arch_trampoline_kprobe
+optimized_callback
+copy_optimized_instructions
+insn_jump_into_range
+can_optimize
+setup_detour_execution
+__recover_optprobed_insn
+arch_check_optimized_kprobe
+arch_within_optimized_kprobe
+arch_remove_optimized_kprobe
+arch_prepare_optimized_kprobe
+arch_optimize_kprobes
+arch_unoptimize_kprobe
+arch_unoptimize_kprobes
+kprobe_ftrace_handler
+arch_prepare_kprobe_ftrace
+module_alloc
+apply_relocate_add
+module_finalize
+module_arch_cleanup
+kgdb_hw_overflow_handler
+kgdb_correct_hw_break
+kgdb_disable_hw_debug
+kgdb_set_hw_break
+kgdb_arch_init
+hw_break_release_slot
+kgdb_remove_hw_break
+kgdb_remove_all_hw_break
+kgdb_nmi_handler
+dbg_set_reg
+dbg_get_reg
+sleeping_thread_to_gdb_regs
+kgdb_roundup_cpus
+kgdb_arch_handle_exception
+__kgdb_notify
+kgdb_notify
+kgdb_ll_trap
+kgdb_arch_exit
+kgdb_arch_late
+kgdb_skipexception
+kgdb_arch_pc
+kgdb_arch_set_pc
+kgdb_arch_set_breakpoint
+kgdb_arch_remove_breakpoint
+hpet_restart_counter
+hpet_resume_counter
+hpet_clkevt_set_state_shutdown
+hpet_clkevt_set_next_event
+hpet_clkevt_set_state_oneshot
+hpet_cpuhp_dead
+hpet_clkevt_msi_resume
+hpet_cpuhp_online
+hpet_rtc_interrupt
+hpet_clkevt_set_state_periodic
+hpet_msi_interrupt_handler
+is_hpet_enabled.part.0
+hpet_clkevt_legacy_resume
+read_hpet
+is_hpet_enabled
+hpet_rtc_dropped_irq
+hpet_unregister_irq_handler
+hpet_rtc_timer_init
+hpet_set_alarm_time
+hpet_register_irq_handler
+hpet_mask_rtc_irq_bit
+hpet_set_periodic_freq
+hpet_set_rtc_irq_bit
+hpet_msi_unmask
+hpet_msi_mask
+hpet_msi_write
+hpet_disable
+amd_nb_num
+amd_nb_has_feature
+node_to_amd_nb
+next_northbridge
+__fix_erratum_688
+__amd_smn_rw
+amd_smn_read
+amd_smn_write
+amd_df_indirect_read
+amd_flush_garts
+amd_cache_northbridges.part.0
+amd_cache_northbridges
+amd_get_mmconfig_range
+amd_get_subcaches
+amd_set_subcaches
+kvm_io_delay
+kvm_sev_es_hcall_finish
+kvm_disable_host_haltpoll
+kvm_enable_host_haltpoll
+apf_task_wake_one
+kvm_steal_clock
+kvm_sev_es_hcall_prepare
+kvm_flush_tlb_others
+kvm_pv_disable_apf.part.0
+kvm_pv_reboot_notify
+kvm_disable_steal_time.part.0
+kvm_kick_cpu
+kvm_smp_send_call_func_ipi
+__kvm_cpuid_base
+kvm_para_available
+kvm_arch_para_hints
+apf_task_wake_all
+__send_ipi_mask
+kvm_send_ipi_mask_allbutself
+kvm_send_ipi_mask
+kvm_wait
+kvm_async_pf_task_wait_schedule
+kvm_async_pf_task_wake
+__sysvec_kvm_asyncpf_interrupt
+kvm_disable_steal_time
+kvm_arch_para_features
+kvm_cpu_down_prepare
+kvm_guest_cpu_init
+kvm_cpu_online
+kvm_pv_guest_cpu_reboot
+arch_haltpoll_enable
+arch_haltpoll_disable
+native_steal_clock
+leave_lazy.part.0
+paravirt_patch_insns
+paravirt_patch_default
+paravirt_disable_iospace
+paravirt_enter_lazy_mmu
+paravirt_leave_lazy_mmu
+paravirt_flush_lazy_mmu
+paravirt_start_context_switch
+paravirt_end_context_switch
+paravirt_get_lazy_mode
+paravirt_patch_ident_64
+native_patch
+found
+jailhouse_get_tsc
+jailhouse_get_wallclock
+jailhouse_serial_fixup
+jailhouse_paravirt
+start_periodic_check_for_corruption
+check_corruption
+default_pre_xol_op
+default_abort_op
+emulate_push_stack
+default_post_xol_op
+branch_emulate_op
+push_emulate_op
+branch_post_xol_op
+arch_uprobe_analyze_insn
+arch_uprobe_pre_xol
+arch_uprobe_xol_was_trapped
+arch_uprobe_post_xol
+arch_uprobe_exception_notify
+arch_uprobe_abort_xol
+arch_uprobe_skip_sstep
+arch_uretprobe_hijack_return_addr
+arch_uretprobe_is_alive
+efifb_setup_from_dmi
+perf_reg_value
+perf_reg_validate
+perf_reg_abi
+perf_get_regs_user
+trace_pagefault_reg
+trace_pagefault_unreg
+sched_itmt_update_handler
+sched_set_itmt_support
+sched_clear_itmt_support
+arch_asym_cpu_priority
+sched_set_itmt_core_prio
+umip_printk
+fixup_umip_exception
+update_stack_state
+unwind_dump
+unwind_next_frame
+__unwind_start
+unwind_get_return_address
+unwind_get_return_address_ptr
+audit_classify_arch
+audit_classify_syscall
+gart_unmap_page
+gart_unmap_sg
+gart_free_coherent
+flush_gart
+gart_iommu_shutdown
+alloc_iommu
+__dma_map_cont
+dma_map_area.isra.0
+gart_map_sg
+gart_map_page
+gart_alloc_coherent
+set_up_gart_resume
+gart_mem_pfn_is_ram
+get_fam10h_pci_mmconf_base
+cmp_range
+fam10h_check_enable_mmcfg
+apicid_phys_pkg_id
+vsmp_apic_post_init
+cachemode2protval
+__traceiter_tlb_flush
+x86_has_pat_wp
+pgprot2cachemode
+pfn_range_is_mapped
+devmem_is_allowed
+free_init_pages
+free_kernel_image_pages
+update_cache_mode_entry
+max_swapfile_size
+ident_pmd_init
+fill_pte
+fill_pud
+ident_pud_init
+ident_p4d_init
+fill_pmd
+__set_pte_vaddr
+kernel_ident_mapping_init
+set_pte_vaddr_p4d
+set_pte_vaddr_pud
+set_pte_vaddr
+add_pages
+arch_add_memory
+kern_addr_valid
+memory_block_size_bytes
+register_page_bootmem_memmap
+__traceiter_page_fault_user
+__traceiter_page_fault_kernel
+set_signal_archinfo
+spurious_kernel_fault_check
+is_prefetch.isra.0
+spurious_kernel_fault
+dump_pagetable
+pgtable_bad
+no_context
+__bad_area_nosemaphore
+bad_area_nosemaphore
+do_kern_addr_fault
+bad_area
+bad_area_access_error
+mm_fault_error
+fault_in_kernel_space
+__ioremap_collect_map_flags
+__ioremap_caller
+ioremap
+ioremap_uc
+ioremap_wc
+ioremap_wt
+ioremap_encrypted
+ioremap_cache
+ioremap_prot
+iounmap
+memremap_is_efi_data.isra.0
+memremap_should_map_decrypted
+ioremap_change_attr
+xlate_dev_mem_ptr
+unxlate_dev_mem_ptr
+arch_memremap_can_ram_remap
+phys_mem_access_encrypted
+ex_handler_default
+ex_handler_clear_fs
+ex_handler_fault
+ex_handler_uaccess
+ex_handler_copy
+ex_handler_rdmsr_unsafe
+ex_handler_wrmsr_unsafe
+ex_handler_fprestore
+ex_get_fault_handler_type
+fixup_exception
+mmap_base
+arch_rnd.part.0
+task_size_32bit
+task_size_64bit
+arch_mmap_rnd
+arch_pick_mmap_layout
+get_mmap_base
+arch_vma_name
+mmap_address_hint_valid
+valid_phys_addr_range
+valid_mmap_phys_addr_range
+pfn_modify_allowed
+free_pmds.constprop.0
+preallocate_pmds.constprop.0
+pte_alloc_one
+___pte_free_tlb
+___pmd_free_tlb
+___pud_free_tlb
+___p4d_free_tlb
+pgd_page_get_mm
+pgd_alloc
+pgd_free
+ptep_set_access_flags
+pmdp_set_access_flags
+pudp_set_access_flags
+ptep_test_and_clear_young
+pmdp_test_and_clear_young
+pudp_test_and_clear_young
+ptep_clear_flush_young
+pmdp_clear_flush_young
+__native_set_fixmap
+native_set_fixmap
+p4d_set_huge
+p4d_clear_huge
+pud_set_huge
+pmd_set_huge
+pud_clear_huge
+pmd_clear_huge
+p4d_free_pud_page
+pud_free_pmd_page
+pmd_free_pte_page
+__virt_addr_valid
+x86_configure_nx
+tlbflush_write_file
+tlbflush_read_file
+tlb_is_not_lazy
+__flush_tlb_all
+do_flush_tlb_all
+__get_current_cr3_fast
+load_new_mm_cr3
+cr4_update_pce
+switch_mm_irqs_off
+switch_mm
+leave_mm
+flush_tlb_func_common.constprop.0
+flush_tlb_func_remote
+enter_lazy_tlb
+initialize_tlbstate_and_flush
+native_flush_tlb_others
+flush_tlb_others
+flush_tlb_mm_range
+flush_tlb_all
+flush_tlb_kernel_range
+flush_tlb_one_kernel
+do_kernel_range_flush
+native_flush_tlb_one_user
+flush_tlb_one_user
+native_flush_tlb_global
+native_flush_tlb_local
+flush_tlb_local
+arch_tlbbatch_flush
+nmi_uaccess_okay
+cea_set_pte
+copy_from_kernel_nofault_allowed
+clflush_cache_range
+arch_invalidate_pmem
+__cpa_flush_all
+alloc_pmd_page
+alloc_pte_page
+try_to_free_pmd_page
+__cpa_addr
+__cpa_flush_tlb
+cpa_flush_all
+populate_pte
+__unmap_pmd_range
+unmap_pmd_range
+populate_pmd
+__cpa_process_fault
+update_page_count
+arch_report_meminfo
+lookup_address_in_pgd
+lookup_address
+protect_kernel_text_ro
+slow_virt_to_phys
+cpa_flush
+_lookup_address_cpa
+__change_page_attr_set_clr
+__set_pages_np
+__set_pages_p
+change_page_attr_set_clr
+_set_pages_array
+set_pages_array_uc
+set_pages_array_wc
+set_pages_array_wt
+set_pages_array_wb
+set_memory_wb
+set_pages_wb
+__set_memory_enc_dec
+set_memory_encrypted
+set_memory_decrypted
+lookup_address_in_mm
+lookup_pmd_address
+__set_memory_prot
+_set_memory_uc
+set_memory_uc
+set_pages_uc
+_set_memory_wc
+set_memory_wc
+_set_memory_wt
+_set_memory_wb
+set_memory_x
+set_memory_nx
+set_memory_ro
+set_memory_rw
+set_memory_np
+set_memory_np_noalias
+set_memory_4k
+set_memory_nonglobal
+set_memory_global
+set_pages_ro
+set_pages_rw
+set_direct_map_invalid_noflush
+set_direct_map_default_noflush
+__kernel_map_pages
+kernel_page_present
+memtype_seq_stop
+pagerange_is_ram_callback
+pat_pagerange_is_ram
+pgprot_writecombine
+pgprot_writethrough
+memtype_seq_open
+memtype_seq_show
+pat_enabled
+__init_cache_modes
+memtype_get_idx
+memtype_seq_next
+memtype_seq_start
+lookup_memtype
+pat_pfn_immune_to_uc_mtrr
+pat_disable
+init_cache_modes
+pat_init
+memtype_reserve
+memtype_free
+arch_io_free_memtype_wc
+memtype_free_io
+phys_mem_access_prot
+phys_mem_access_prot_allowed
+memtype_kernel_map_sync
+memtype_reserve_io
+arch_io_reserve_memtype_wc
+reserve_pfn_range
+track_pfn_copy
+track_pfn_remap
+track_pfn_insert
+untrack_pfn
+untrack_pfn_moved
+interval_augment_rotate
+interval_subtree_search
+interval_iter_next
+interval_iter_first.constprop.0
+interval_insert.constprop.0
+interval_remove.constprop.0
+memtype_check_insert
+memtype_erase
+memtype_lookup
+memtype_copy_nth_element
+pmd_huge
+pud_huge
+hugetlb_get_unmapped_area
+ptdump_walk_pgd_level_core
+effective_prot
+ptdump_walk_pgd_level_debugfs
+note_page
+ptdump_walk_pgd_level
+ptdump_walk_user_pgd_level_checkwx
+ptdump_walk_pgd_level_checkwx
+kmmio_page_list
+get_kmmio_fault_page
+clear_page_presence
+remove_kmmio_fault_pages
+disarm_kmmio_fault_page
+arm_kmmio_fault_page
+unregister_kmmio_probe
+rcu_free_kmmio_fault_pages
+register_kmmio_probe
+kmmio_die_notifier
+kmmio_handler
+kmmio_init
+kmmio_cleanup
+get_reg_w32
+skip_prefix
+get_ins_reg_width
+get_ins_type
+get_ins_mem_width
+get_ins_reg_val
+get_ins_imm_val
+mmiotrace_printk
+pre
+post
+mmiotrace_ioremap
+mmiotrace_iounmap
+enable_mmiotrace
+disable_mmiotrace
+memory_add_physaddr_to_nid
+__node_distance
+phys_to_target_node
+numa_set_node.part.0
+numa_cpu_node
+numa_set_node
+numa_clear_node
+numa_add_cpu
+numa_remove_cpu
+init_pkru_write_file
+init_pkru_read_file
+__execute_only_pkey
+__arch_override_mprotect_pkey
+copy_init_pkru_to_fpregs
+pti_user_pagetable_walk_p4d
+pti_user_pagetable_walk_pmd
+pti_clone_pgtable.constprop.0
+__pti_set_user_pgtbl
+pti_finalize
+crypto_blake2s_setkey
+crypto_blake2s_init
+blake2s_compress_arch
+crypto_blake2s_update
+crypto_blake2s_final
+crc32c_intel_setkey
+crc32c_intel_init
+crc32c_intel_update
+crc32c_intel_finup
+crc32c_intel_final
+crc32c_intel_digest
+crc32c_intel_cra_init
+crc32c_pcl_intel_update
+__crc32c_pcl_intel_finup
+crc32c_pcl_intel_finup
+crc32c_pcl_intel_digest
+ia32_restore_sigcontext
+__do_compat_sys_sigreturn
+__do_compat_sys_rt_sigreturn
+get_sigframe.constprop.0
+ia32_setup_frame
+ia32_setup_rt_frame
+ia32_classify_syscall
+efi_delete_dummy_variable
+efi_query_variable_store
+efi_reboot_required
+efi_poweroff_required
+efi_recover_from_page_fault
+fw_vendor_show
+runtime_show
+config_table_show
+efi_is_table_address
+efi_systab_show_arch
+efi_attr_is_visible
+efi_thunk_get_time
+efi_thunk_set_time
+efi_thunk_get_wakeup_time
+efi_thunk_set_wakeup_time
+efi_thunk_update_capsule
+efi_thunk_query_capsule_caps
+efi_thunk_get_next_high_mono_count
+efi_sync_low_kernel_mappings
+efi_thunk_query_variable_info_nonblocking
+efi_thunk_query_variable_info
+efi_thunk_reset_system
+efi_thunk_set_variable_nonblocking
+efi_thunk_set_variable
+efi_thunk_get_next_variable
+efi_thunk_get_variable
+efi_switch_mm
+iosf_mbi_available
+iosf_mbi_pci_read_mdr
+iosf_mbi_pci_write_mdr
+iosf_mbi_modify
+iosf_mbi_punit_acquire
+iosf_mbi_reset_semaphore
+iosf_mcr_fops_open
+mcr_get
+iosf_mbi_probe
+iosf_mbi_assert_punit_acquired.part.0
+iosf_mbi_assert_punit_acquired
+iosf_mbi_unregister_pmic_bus_access_notifier_unlocked
+iosf_mbi_read
+iosf_mbi_get_sem
+iosf_mbi_write
+mcr_set
+iosf_mbi_unblock_punit_i2c_access
+iosf_mbi_block_punit_i2c_access
+iosf_mbi_punit_release
+iosf_mbi_register_pmic_bus_access_notifier
+iosf_mbi_unregister_pmic_bus_access_notifier
+__uv_bios_call.constprop.0
+uv_bios_call_irqsave.constprop.0
+uv_bios_reserved_page_pa
+uv_bios_change_memprotect
+uv_bios_mq_watchlist_free
+uv_bios_mq_watchlist_alloc
+uv_bios_get_sn_info
+uv_bios_freq_base
+uv_bios_set_legacy_vga_target
+get_uv_systab_phys
+uv_bios_init
+uv_noop
+uv_teardown_irq
+uv_program_mmr
+uv_domain_deactivate
+uv_domain_activate
+uv_domain_alloc
+uv_set_irq_affinity
+uv_setup_irq
+uv_domain_free
+coherence_id_show
+partition_id_show
+uv_read_rtc
+uv_setup_intr
+uv_rtc_find_next_timer
+uv_rtc_unset_timer
+uv_rtc_shutdown
+uv_rtc_interrupt
+uv_rtc_next_event
+param_get_action
+param_set_local64
+param_get_local64
+param_set_action
+uv_set_in_nmi
+uv_nmi_sync_exit
+uv_nmi_wait_cpus
+uv_nmi_dump_state_cpu
+uv_handle_nmi
+uv_handle_nmi_ping
+uv_nmi_init
+ex_handler_bpf
+emit_nops
+cmp_ips
+__bpf_arch_text_poke
+add_2mod
+emit_mov_imm32
+emit_mov_imm64
+emit_mov_reg
+emit_ldx
+restore_regs
+emit_stx
+jit_fill_hole
+pop_callee_regs
+get_pop_bytes
+emit_align.constprop.0
+emit_bpf_dispatcher
+invoke_bpf_prog.constprop.0
+invoke_bpf
+do_jit
+bpf_arch_text_poke
+arch_prepare_bpf_trampoline
+arch_prepare_bpf_dispatcher
+bpf_int_jit_compile
+__traceiter_task_newtask
+__traceiter_task_rename
+free_vm_stack_cache
+get_mm_exe_file
+__x64_sys_set_tid_address
+__ia32_sys_set_tid_address
+pidfd_show_fdinfo
+pidfd_release
+pidfd_poll
+sighand_ctor
+copy_clone_args_from_user
+mm_init
+__mmdrop
+mmdrop_async_fn
+account_kernel_stack
+get_task_exe_file
+get_task_mm
+mmput_async_fn
+mm_release
+mmput
+nr_processes
+arch_release_task_struct
+free_task
+__put_task_struct
+__delayed_free_task
+vm_area_alloc
+vm_area_dup
+dup_mm
+vm_area_free
+put_task_stack
+put_task_stack
+set_task_stack_end_magic
+mm_alloc
+mmput_async
+set_mm_exe_file
+mm_access
+exit_mm_release
+exec_mm_release
+__cleanup_sighand
+copy_process
+pidfd_pid
+fork_idle
+copy_init_mm
+kernel_clone
+__do_sys_fork
+__do_sys_vfork
+__x64_sys_clone
+__ia32_sys_clone
+__x64_sys_clone3
+__ia32_sys_clone3
+kernel_thread
+walk_process_tree
+unshare_fd
+ksys_unshare
+__x64_sys_unshare
+__ia32_sys_unshare
+unshare_files
+sysctl_max_threads
+execdomains_proc_show
+__x64_sys_personality
+__ia32_sys_personality
+no_blink
+test_taint
+clear_warn_once_fops_open
+clear_warn_once_set
+init_oops_id
+print_oops_end_marker
+do_oops_enter_exit.part.0
+panic_smp_self_stop
+panic_smp_self_stop
+panic_smp_self_stop
+nmi_panic
+add_taint
+print_tainted
+get_taint
+oops_may_print
+oops_enter
+oops_exit
+__warn
+cpu_smt_possible
+cpu_mitigations_off
+cpu_mitigations_auto_nosmt
+__traceiter_cpuhp_enter
+__traceiter_cpuhp_multi_enter
+__traceiter_cpuhp_exit
+cpuhp_create
+takedown_cpu
+finish_cpu
+cpuhp_complete_idle_dead
+cpu_hotplug_disable
+cpus_read_trylock
+remove_cpu
+add_cpu
+write_cpuhp_fail
+show_cpuhp_fail
+show_cpuhp_target
+show_cpuhp_state
+show_cpuhp_states
+show_smt_active
+show_smt_control
+cpuhp_should_run
+__cpuhp_kick_ap
+__cpu_hotplug_enable
+cpu_hotplug_enable
+cpu_hotplug_pm_callback
+cpus_read_lock
+cpus_read_unlock
+bringup_cpu
+cpuhp_kick_ap_work
+cpuhp_invoke_callback
+take_cpu_down
+cpuhp_issue_call
+cpuhp_rollback_install
+__cpuhp_state_remove_instance
+__cpuhp_setup_state_cpuslocked
+__cpuhp_setup_state
+__cpuhp_remove_state_cpuslocked
+__cpuhp_remove_state
+cpuhp_thread_fun
+cpu_maps_update_begin
+cpu_maps_update_done
+cpus_write_lock
+cpus_write_unlock
+lockdep_assert_cpus_held
+lockdep_assert_cpus_held
+cpu_down
+_cpu_up
+cpu_up
+write_cpuhp_target
+clear_tasks_mm_cpumask
+cpuhp_report_idle_dead
+cpu_device_down
+smp_shutdown_nonboot_cpus
+notify_cpu_starting
+cpuhp_online_idle
+cpu_device_up
+bringup_hibernate_cpu
+bringup_nonboot_cpus
+freeze_secondary_cpus
+freeze_secondary_cpus
+freeze_secondary_cpus
+thaw_secondary_cpus
+__cpuhp_state_add_instance_cpuslocked
+__cpuhp_state_add_instance
+cpuhp_smt_disable
+cpuhp_smt_enable
+store_smt_control
+init_cpu_present
+init_cpu_possible
+init_cpu_online
+set_cpu_online
+will_become_orphaned_pgrp
+rcuwait_wake_up
+kill_orphaned_pgrp
+thread_group_exited
+task_stopped_code
+child_wait_callback
+delayed_put_task_struct
+put_task_struct_rcu_user
+release_task
+wait_consider_task
+do_wait
+kernel_waitid
+__x64_sys_waitid
+__ia32_sys_waitid
+__ia32_compat_sys_waitid
+__x32_compat_sys_waitid
+is_current_pgrp_orphaned
+mm_update_next_owner
+do_exit
+complete_and_exit
+__ia32_sys_exit
+__x64_sys_exit
+do_group_exit
+__ia32_sys_exit_group
+__x64_sys_exit_group
+__wake_up_parent
+kernel_wait4
+__x64_sys_wait4
+__ia32_sys_wait4
+__x64_sys_waitpid
+__ia32_sys_waitpid
+__ia32_compat_sys_wait4
+__x32_compat_sys_wait4
+kernel_wait
+ksoftirqd_should_run
+__traceiter_irq_handler_entry
+__traceiter_irq_handler_exit
+__traceiter_softirq_entry
+__traceiter_softirq_exit
+__traceiter_softirq_raise
+tasklet_setup
+tasklet_init
+_local_bh_enable
+wakeup_softirqd
+ksoftirqd_running
+tasklet_kill
+do_softirq.part.0
+__local_bh_enable_ip
+run_ksoftirqd
+do_softirq
+irq_enter_rcu
+irq_enter
+irq_exit_rcu
+irq_exit
+__raise_softirq_irqoff
+tasklet_action_common.isra.0
+tasklet_hi_action
+tasklet_action
+raise_softirq
+__tasklet_schedule_common
+__tasklet_schedule
+__tasklet_hi_schedule
+takeover_tasklets
+open_softirq
+tasklet_kill_immediate
+tasklet_kill_immediate
+r_stop
+__is_ram
+__request_resource
+__release_resource
+release_resource
+remove_resource
+region_intersects
+simple_align_resource
+__adjust_resource
+adjust_resource
+devm_resource_release
+devm_resource_match
+devm_region_match
+r_show
+__release_child_resources
+__insert_resource
+resource_list_create_entry
+resource_list_free
+next_resource.part.0
+r_next
+find_next_iomem_res
+__walk_iomem_res_desc
+walk_iomem_res_desc
+r_start
+devm_release_resource
+free_resource
+__release_region
+devm_region_release
+__devm_release_region
+alloc_resource
+__request_region
+__devm_request_region
+__request_free_mem_region
+devm_request_free_mem_region
+request_free_mem_region
+release_child_resources
+request_resource_conflict
+request_resource
+devm_request_resource
+walk_system_ram_res
+walk_mem_res
+walk_system_ram_range
+page_is_ram
+page_is_ram
+__find_resource
+reallocate_resource
+allocate_resource
+lookup_resource
+insert_resource_conflict
+insert_resource
+insert_resource_expand_to_fit
+resource_alignment
+release_mem_region_adjustable
+merge_system_ram_resource
+iomem_map_sanity_check
+iomem_is_exclusive
+do_proc_douintvec_conv
+do_proc_douintvec_minmax_conv
+proc_put_long
+validate_coredump_safety.part.0
+proc_put_char.part.0
+do_proc_dopipe_max_size_conv
+do_proc_dointvec_conv
+do_proc_dointvec_minmax_conv
+do_proc_dointvec_jiffies_conv
+proc_first_pos_non_zero_ignore.part.0
+proc_dostring
+do_proc_dointvec_userhz_jiffies_conv
+do_proc_dointvec_ms_jiffies_conv
+proc_get_long.constprop.0
+proc_do_large_bitmap
+__do_proc_doulongvec_minmax
+proc_doulongvec_minmax
+proc_doulongvec_ms_jiffies_minmax
+proc_taint
+__do_proc_douintvec
+proc_douintvec
+proc_douintvec_minmax
+proc_dopipe_max_size
+__do_proc_dointvec
+proc_dointvec
+proc_dointvec_minmax
+proc_dointvec_minmax_warn_RT_change
+proc_dointvec_minmax_coredump
+proc_dointvec_minmax_sysadmin
+bpf_stats_handler
+proc_dointvec_jiffies
+proc_dointvec_userhz_jiffies
+proc_dointvec_ms_jiffies
+proc_do_cad_pid
+sysrq_sysctl_handler
+proc_dostring_coredump
+proc_do_static_key
+file_ns_capable
+cap_validate_magic
+__ia32_sys_capget
+__ia32_sys_capset
+ns_capable_common
+ns_capable
+capable
+ns_capable_noaudit
+ns_capable_setid
+__x64_sys_capget
+__x64_sys_capset
+has_ns_capability
+has_capability
+has_ns_capability_noaudit
+has_capability_noaudit
+privileged_wrt_inode_uidgid
+capable_wrt_inode_uidgid
+ptracer_capable
+ptrace_get_syscall_info_entry
+ptrace_get_syscall_info
+ptrace_getsiginfo
+ptrace_regset
+__ptrace_may_access
+ptrace_setsiginfo
+ptrace_peek_siginfo
+ptrace_unfreeze_traced
+ptrace_resume
+ptrace_check_attach
+ptrace_access_vm
+__ptrace_link
+ptrace_traceme
+ptrace_attach
+__ia32_sys_ptrace
+__x32_compat_sys_ptrace
+__ia32_compat_sys_ptrace
+__x64_sys_ptrace
+__ptrace_unlink
+__ptrace_detach
+ptrace_may_access
+exit_ptrace
+ptrace_readdata
+ptrace_writedata
+ptrace_request
+generic_ptrace_peekdata
+generic_ptrace_pokedata
+compat_ptrace_request
+uid_hash_find
+find_user
+free_uid
+alloc_uid
+known_siginfo_layout
+__traceiter_signal_generate
+__traceiter_signal_deliver
+__do_sys_restart_syscall
+__do_sys_sgetmask
+__do_sys_pause
+post_copy_siginfo_from_user.part.0
+__copy_siginfo_from_user
+__sigqueue_free.part.0
+flush_sigqueue_mask
+check_kill_permission
+__sigqueue_alloc
+recalc_sigpending_tsk
+recalc_sigpending
+do_sigaltstack.constprop.0
+do_compat_sigaltstack
+__ia32_compat_sys_sigaltstack
+__x32_compat_sys_sigaltstack
+__ia32_sys_sigaltstack
+__flush_itimer_signals
+__x64_sys_sigaltstack
+do_sigpending
+__ia32_sys_rt_sigpending
+__ia32_compat_sys_rt_sigpending
+__ia32_sys_sigpending
+__ia32_compat_sys_sigpending
+__x32_compat_sys_sigpending
+__x32_compat_sys_rt_sigpending
+__x64_sys_sigpending
+__x64_sys_rt_sigpending
+kernel_sigaction
+__dequeue_signal
+dequeue_signal
+calculate_sigpending
+next_signal
+task_set_jobctl_pending
+task_clear_jobctl_trapping
+task_clear_jobctl_pending
+task_participate_group_stop
+task_join_group_stop
+flush_sigqueue
+flush_signals
+flush_itimer_signals
+ignore_signals
+flush_signal_handlers
+unhandled_signal
+signal_wake_up_state
+recalc_sigpending_and_wake
+complete_signal
+retarget_shared_pending
+__set_task_blocked
+do_sigtimedwait
+__ia32_compat_sys_rt_sigtimedwait_time64
+__ia32_compat_sys_rt_sigtimedwait_time32
+__x32_compat_sys_rt_sigtimedwait_time64
+__x32_compat_sys_rt_sigtimedwait_time32
+ptrace_trap_notify
+prepare_signal
+__send_signal
+zap_other_threads
+__lock_task_sighand
+kill_pid_usb_asyncio
+sigqueue_alloc
+sigqueue_free
+send_sigqueue
+do_notify_parent
+do_no_restart_syscall
+__set_current_blocked
+set_current_blocked
+__ia32_sys_sigprocmask
+__x64_sys_ssetmask
+__ia32_sys_ssetmask
+sigsuspend
+__ia32_sys_rt_sigsuspend
+__ia32_compat_sys_rt_sigsuspend
+__x64_sys_sigsuspend
+__ia32_sys_sigsuspend
+__x32_compat_sys_rt_sigsuspend
+__x64_sys_rt_sigsuspend
+sigprocmask
+__ia32_sys_rt_sigprocmask
+__ia32_compat_sys_rt_sigprocmask
+__x32_compat_sys_rt_sigprocmask
+__x64_sys_rt_sigprocmask
+__x64_sys_sigprocmask
+set_user_sigmask
+set_compat_user_sigmask
+siginfo_layout
+send_signal
+__group_send_sig_info
+do_notify_parent_cldstop
+ptrace_stop
+ptrace_do_notify
+ptrace_notify
+do_signal_stop
+exit_signals
+do_send_sig_info
+group_send_sig_info
+__kill_pgrp_info
+kill_pgrp
+kill_pid_info
+kill_pid
+do_rt_sigqueueinfo
+__ia32_sys_rt_sigqueueinfo
+__x64_sys_rt_sigqueueinfo
+kill_something_info
+__x64_sys_kill
+__ia32_sys_kill
+send_sig_info
+send_sig
+send_sig_fault
+send_sig_mceerr
+do_send_specific
+do_tkill
+__x64_sys_tgkill
+__ia32_sys_tgkill
+__x64_sys_tkill
+__ia32_sys_tkill
+do_rt_tgsigqueueinfo
+__ia32_sys_rt_tgsigqueueinfo
+__x64_sys_rt_tgsigqueueinfo
+force_sig_info_to_task
+force_sig_info
+force_sig
+force_sigsegv
+signal_setup_done
+force_sig_mceerr
+force_sig_bnderr
+force_sig_pkuerr
+force_sig_ptrace_errno_trap
+force_sig_fault_to_task
+force_sig_fault
+get_signal
+post_copy_siginfo_from_user32
+__copy_siginfo_from_user32
+__ia32_compat_sys_rt_sigqueueinfo
+__ia32_compat_sys_rt_tgsigqueueinfo
+__x32_compat_sys_rt_sigqueueinfo
+__x32_compat_sys_rt_tgsigqueueinfo
+copy_siginfo_to_user
+__ia32_sys_rt_sigtimedwait
+__ia32_sys_rt_sigtimedwait_time32
+__x64_sys_rt_sigtimedwait
+__x64_sys_rt_sigtimedwait_time32
+copy_siginfo_from_user
+copy_siginfo_to_external32
+__copy_siginfo_to_user32
+copy_siginfo_from_user32
+copy_siginfo_from_user_any
+__ia32_sys_pidfd_send_signal
+__x64_sys_pidfd_send_signal
+__x64_sys_pidfd_send_signal
+do_sigaction
+__ia32_sys_rt_sigaction
+__ia32_compat_sys_rt_sigaction
+__ia32_compat_sys_sigaction
+__x64_sys_signal
+__ia32_sys_signal
+__x64_sys_rt_sigaction
+__x32_compat_sys_rt_sigaction
+__x32_compat_sys_sigaction
+restore_altstack
+__save_altstack
+compat_restore_altstack
+__compat_save_altstack
+__compat_save_altstack
+kdb_send_sig
+__do_sys_gettid
+__do_sys_getpid
+__x64_sys_umask
+__ia32_sys_umask
+propagate_has_child_subreaper
+set_one_prio
+__ia32_sys_setpriority
+__x64_sys_getpriority
+__do_sys_getppid
+set_user
+__do_sys_getuid
+__do_sys_geteuid
+__ia32_sys_getresuid
+__x64_sys_getcpu
+__ia32_sys_getcpu
+__ia32_sys_getresgid
+__do_sys_getgid
+__do_sys_getegid
+do_sys_times
+__ia32_sys_times
+validate_prctl_map_addr
+__ia32_compat_sys_times
+__x64_sys_setpgid
+do_getpgid
+__x64_sys_getpgid
+__ia32_sys_getpgid
+__do_sys_getpgrp
+__ia32_sys_getsid
+__ia32_sys_sethostname
+__ia32_sys_setdomainname
+__ia32_sys_gethostname
+check_prlimit_permission
+prctl_set_mm_exe_file
+do_sysinfo
+__x64_sys_sysinfo
+__ia32_sys_sysinfo
+__ia32_compat_sys_sysinfo
+__x32_compat_sys_sysinfo
+override_release.part.0
+__x64_sys_newuname
+__ia32_sys_newuname
+__x64_sys_uname
+__ia32_sys_uname
+__ia32_sys_olduname
+__x64_sys_times
+__x64_sys_getsid
+__x64_sys_getresuid
+__x64_sys_getresgid
+__x32_compat_sys_old_getrlimit
+__x64_sys_old_getrlimit
+__x32_compat_sys_times
+__ia32_compat_sys_old_getrlimit
+__ia32_sys_old_getrlimit
+prctl_set_auxv
+__x64_sys_gethostname
+__x64_sys_setdomainname
+__x64_sys_sethostname
+prctl_set_mm_map
+prctl_set_mm
+__ia32_sys_setpgid
+__x64_sys_olduname
+__ia32_sys_getpriority
+__x64_sys_setpriority
+__sys_setregid
+__x64_sys_setregid
+__ia32_sys_setregid
+__sys_setgid
+__x64_sys_setgid
+__ia32_sys_setgid
+__sys_setreuid
+__x64_sys_setreuid
+__ia32_sys_setreuid
+__sys_setuid
+__x64_sys_setuid
+__ia32_sys_setuid
+__sys_setresuid
+__x64_sys_setresuid
+__ia32_sys_setresuid
+__sys_setresgid
+__x64_sys_setresgid
+__ia32_sys_setresgid
+__sys_setfsuid
+__x64_sys_setfsuid
+__ia32_sys_setfsuid
+__sys_setfsgid
+__x64_sys_setfsgid
+__ia32_sys_setfsgid
+ksys_setsid
+__do_sys_setsid
+do_prlimit
+__ia32_sys_getrlimit
+__ia32_compat_sys_setrlimit
+__ia32_compat_sys_getrlimit
+__ia32_sys_prlimit64
+__ia32_sys_setrlimit
+__x64_sys_setrlimit
+__x64_sys_getrlimit
+__x32_compat_sys_setrlimit
+__x32_compat_sys_getrlimit
+__x64_sys_prlimit64
+getrusage
+__x64_sys_getrusage
+__ia32_sys_getrusage
+__ia32_compat_sys_getrusage
+__x32_compat_sys_getrusage
+__x32_compat_sys_getrusage
+__x32_compat_sys_getrusage
+__ia32_sys_prctl
+__x64_sys_prctl
+usermodehelper_read_unlock
+usermodehelper_read_lock_wait
+usermodehelper_read_trylock
+call_usermodehelper_exec
+umh_complete
+call_usermodehelper_exec_work
+call_usermodehelper
+call_usermodehelper_setup
+proc_cap_handler.part.0
+proc_cap_handler
+call_usermodehelper_exec_async
+__usermodehelper_set_disable_depth
+__usermodehelper_disable
+__traceiter_workqueue_queue_work
+__traceiter_workqueue_activate_work
+__traceiter_workqueue_execute_start
+__traceiter_workqueue_execute_end
+work_for_cpu_fn
+set_pf_worker
+worker_enter_idle
+destroy_worker
+insert_work
+pr_cont_pool_info
+alloc_worker
+queue_rcu_work
+wq_device_release
+rcu_free_pwq
+worker_attach_to_pool
+worker_detach_from_pool
+wq_barrier_func
+get_work_pool
+workqueue_congested
+work_busy
+cwt_wakefn
+wq_unbound_cpumask_show
+max_active_show
+per_cpu_show
+wq_cpumask_show
+wq_nice_show
+wq_pool_ids_show
+wq_numa_show
+init_pwq
+init_rescuer.part.0
+free_workqueue_attrs.part.0
+rcu_free_pool
+rcu_free_wq
+show_pwq
+current_work
+set_worker_desc
+pwq_activate_delayed_work
+pwq_adjust_max_active
+link_pwq
+check_flush_dependency
+copy_workqueue_attrs
+apply_wqattrs_commit
+wq_calc_node_cpumask
+flush_workqueue_prep_pwqs
+flush_workqueue
+drain_workqueue
+idle_worker_timeout
+pool_mayday_timeout
+__queue_work
+queue_work_on
+put_pwq
+put_pwq_unlocked.part.0
+apply_wqattrs_cleanup.part.0
+pwq_dec_nr_in_flight
+try_to_grab_pending
+cancel_delayed_work
+execute_in_process_context
+queue_work_node
+delayed_work_timer_fn
+rcu_work_rcufn
+__queue_delayed_work
+queue_delayed_work_on
+mod_delayed_work_on
+create_worker
+process_one_work
+worker_thread
+rescuer_thread
+put_unbound_pool
+pwq_unbound_release_workfn
+__flush_work
+flush_work
+flush_delayed_work
+work_on_cpu
+work_on_cpu_safe
+flush_rcu_work
+__cancel_work_timer
+cancel_work_sync
+cancel_delayed_work_sync
+wq_clamp_max_active
+workqueue_set_max_active
+max_active_store
+wq_worker_running
+wq_worker_sleeping
+wq_worker_last_func
+schedule_on_each_cpu
+free_workqueue_attrs
+alloc_workqueue_attrs
+init_worker_pool
+alloc_unbound_pwq
+wq_update_unbound_numa
+apply_wqattrs_prepare
+apply_workqueue_attrs_locked
+wq_sysfs_prep_attrs
+wq_numa_store
+wq_cpumask_store
+wq_nice_store
+apply_workqueue_attrs
+current_is_workqueue_rescuer
+print_worker_info
+show_workqueue_state
+destroy_workqueue
+wq_worker_comm
+workqueue_prepare_cpu
+workqueue_online_cpu
+workqueue_offline_cpu
+freeze_workqueues_begin
+freeze_workqueues_busy
+thaw_workqueues
+workqueue_set_unbound_cpumask
+wq_unbound_cpumask_store
+workqueue_sysfs_register
+alloc_workqueue
+find_pid_ns
+task_active_pid_ns
+find_vpid
+pid_task
+pid_nr_ns
+pid_vnr
+__task_pid_nr_ns
+put_pid.part.0
+put_pid
+delayed_put_pid
+find_get_pid
+get_task_pid
+pidfd_create
+__ia32_sys_pidfd_open
+__x64_sys_pidfd_open
+get_pid_task
+pidfd_getfd
+__ia32_sys_pidfd_getfd
+__x64_sys_pidfd_getfd
+free_pid
+__change_pid
+alloc_pid
+disable_pid_allocation
+attach_pid
+detach_pid
+change_pid
+exchange_tids
+transfer_pid
+find_task_by_pid_ns
+find_task_by_vpid
+find_get_task_by_vpid
+find_ge_pid
+pidfd_get_pid
+task_work_add
+task_work_cancel
+task_work_run
+search_kernel_exception_table
+search_exception_tables
+init_kernel_text
+core_kernel_data
+kernel_text_address
+__kernel_text_address
+func_ptr_is_kernel_text
+uevent_filter
+param_array_free
+module_attr_show
+module_attr_store
+param_set_byte
+param_get_byte
+param_get_short
+param_get_ushort
+param_get_int
+param_get_uint
+param_get_long
+param_get_ulong
+param_get_ullong
+param_get_hexint
+param_get_charp
+param_get_string
+param_set_short
+param_set_ushort
+param_set_int
+param_set_uint
+param_set_hexint
+param_set_long
+param_set_ulong
+param_set_ullong
+free_module_param_attrs
+param_set_copystring
+param_set_bool
+kernel_param_lock
+kernel_param_unlock
+param_attr_show
+module_kobj_release
+param_set_bool_enable_only
+param_set_invbool
+param_set_bint
+param_get_bool
+param_get_invbool
+param_check_unsafe
+param_attr_store
+param_array_get
+param_array_set
+add_sysfs_param
+maybe_kfree_parameter
+param_set_charp
+param_free_charp
+parameqn
+parameq
+parse_args
+module_param_sysfs_setup
+module_param_sysfs_remove
+destroy_params
+__modver_version_show
+kthread_flush_work_fn
+kthread_should_stop
+__kthread_should_park
+kthread_should_park
+kthread_func
+kthread_data
+kthread_blkcg
+kthread_freezable_should_stop
+__kthread_parkme
+kthread_parkme
+kthread_park
+__kthread_init_worker
+__kthread_cancel_work
+kthread_insert_work_sanity_check
+kthread_insert_work
+kthread_queue_work
+kthread_flush_worker
+kthread_delayed_work_timer_fn
+__kthread_queue_delayed_work
+kthread_queue_delayed_work
+kthread_mod_delayed_work
+__kthread_bind_mask
+kthread_bind
+kthread_unpark
+kthread
+kthread_stop
+kthread_destroy_worker
+kthread_associate_blkcg
+kthread_flush_work
+__kthread_cancel_work_sync
+kthread_cancel_work_sync
+kthread_cancel_delayed_work_sync
+kthread_worker_fn
+kthread_unuse_mm
+kthread_use_mm
+__kthread_create_on_node
+kthread_create_on_node
+__kthread_create_worker
+kthread_create_worker
+kthread_create_worker_on_cpu
+free_kthread_struct
+kthread_probe_data
+tsk_fork_get_node
+kthread_bind_mask
+kthread_create_on_cpu
+kthreadd
+sys_ni_syscall
+sys_ni_syscall
+sys_ni_syscall
+sys_ni_syscall
+sys_ni_syscall
+sys_ni_syscall
+sys_ni_syscall
+sys_ni_syscall
+sys_ni_syscall
+sys_ni_syscall
+sys_ni_syscall
+sys_ni_syscall
+sys_ni_syscall
+sys_ni_syscall
+sys_ni_syscall
+sys_ni_syscall
+sys_ni_syscall
+__x64_sys_io_pgetevents_time32
+__ia32_sys_io_pgetevents_time32
+__ia32_sys_io_pgetevents_time32
+__ia32_sys_io_pgetevents_time32
+__ia32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x32_compat_sys_io_pgetevents_time32
+__x64_sys_old_msgctl
+__ia32_sys_old_msgctl
+__ia32_sys_old_msgctl
+__ia32_sys_old_msgctl
+__ia32_sys_old_msgctl
+__ia32_sys_old_msgctl
+__ia32_sys_old_msgctl
+__ia32_sys_old_msgctl
+__ia32_sys_old_msgctl
+__ia32_sys_old_msgctl
+__ia32_sys_old_msgctl
+__ia32_sys_old_msgctl
+__ia32_sys_old_msgctl
+__ia32_sys_old_msgctl
+__ia32_sys_old_msgctl
+__ia32_sys_old_msgctl
+__ia32_sys_old_msgctl
+__ia32_sys_old_msgctl
+__x64_sys_old_semctl
+__ia32_sys_old_semctl
+__ia32_sys_old_semctl
+__ia32_sys_old_semctl
+__ia32_sys_old_semctl
+__ia32_sys_old_semctl
+__ia32_sys_old_semctl
+__ia32_sys_old_semctl
+__ia32_sys_old_semctl
+__ia32_sys_old_semctl
+__ia32_sys_old_semctl
+__ia32_sys_old_semctl
+__ia32_sys_old_semctl
+__ia32_sys_old_semctl
+__ia32_sys_old_semctl
+__ia32_sys_old_semctl
+__x64_sys_old_shmctl
+__ia32_sys_old_shmctl
+__ia32_sys_old_shmctl
+__ia32_sys_old_shmctl
+__ia32_sys_old_shmctl
+__ia32_sys_old_shmctl
+__ia32_sys_old_shmctl
+__ia32_sys_old_shmctl
+__ia32_sys_old_shmctl
+__ia32_sys_old_shmctl
+__ia32_sys_old_shmctl
+__ia32_sys_old_shmctl
+__ia32_sys_old_shmctl
+__ia32_sys_old_shmctl
+__ia32_sys_old_shmctl
+__ia32_sys_old_shmctl
+__ia32_sys_old_shmctl
+__ia32_sys_old_shmctl
+__ia32_sys_old_shmctl
+__ia32_sys_old_shmctl
+__ia32_sys_old_shmctl
+__ia32_sys_old_shmctl
+__ia32_sys_old_shmctl
+__ia32_sys_old_shmctl
+__ia32_sys_old_shmctl
+__ia32_sys_old_shmctl
+__ia32_sys_old_shmctl
+__ia32_sys_old_shmctl
+__ia32_sys_old_shmctl
+__ia32_sys_old_shmctl
+__ia32_sys_old_shmctl
+__ia32_sys_old_shmctl
+__ia32_compat_sys_setsockopt
+__x32_compat_sys_setsockopt
+__x32_compat_sys_setsockopt
+__x32_compat_sys_setsockopt
+__ia32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__x32_compat_sys_getsockopt
+__ia32_compat_sys_process_vm_readv
+__x32_compat_sys_process_vm_readv
+__x32_compat_sys_process_vm_readv
+__x32_compat_sys_process_vm_readv
+__ia32_compat_sys_process_vm_writev
+__x32_compat_sys_process_vm_writev
+__x32_compat_sys_process_vm_writev
+__x32_compat_sys_process_vm_writev
+__x32_compat_sys_process_vm_writev
+__x32_compat_sys_process_vm_writev
+__x32_compat_sys_process_vm_writev
+__x32_compat_sys_process_vm_writev
+__x32_compat_sys_process_vm_writev
+__x32_compat_sys_process_vm_writev
+__x32_compat_sys_process_vm_writev
+__x32_compat_sys_process_vm_writev
+__x32_compat_sys_process_vm_writev
+__x32_compat_sys_process_vm_writev
+__x32_compat_sys_process_vm_writev
+__x32_compat_sys_process_vm_writev
+__x32_compat_sys_process_vm_writev
+__x32_compat_sys_process_vm_writev
+__x32_compat_sys_process_vm_writev
+__x32_compat_sys_process_vm_writev
+__x32_compat_sys_process_vm_writev
+__x32_compat_sys_process_vm_writev
+__x32_compat_sys_process_vm_writev
+__x32_compat_sys_process_vm_writev
+__x32_compat_sys_process_vm_writev
+__x32_compat_sys_process_vm_writev
+__x32_compat_sys_process_vm_writev
+__x32_compat_sys_process_vm_writev
+__x64_sys_pciconfig_read
+__ia32_sys_pciconfig_read
+__x64_sys_pciconfig_write
+__ia32_sys_pciconfig_write
+__x64_sys_pciconfig_iobase
+__ia32_sys_pciconfig_iobase
+__ia32_sys_pciconfig_iobase
+__ia32_sys_pciconfig_iobase
+__ia32_sys_pciconfig_iobase
+__ia32_sys_pciconfig_iobase
+__ia32_sys_pciconfig_iobase
+__ia32_sys_pciconfig_iobase
+__x64_sys_vm86old
+__ia32_sys_vm86old
+__ia32_sys_vm86old
+__ia32_sys_vm86old
+__x64_sys_vm86
+__ia32_sys_vm86
+__ia32_sys_vm86
+__ia32_sys_vm86
+__x64_sys_s390_pci_mmio_read
+__ia32_sys_s390_pci_mmio_read
+__x64_sys_s390_pci_mmio_write
+__ia32_sys_s390_pci_mmio_write
+__x64_sys_s390_ipc
+__ia32_sys_s390_ipc
+__ia32_compat_sys_s390_ipc
+__x32_compat_sys_s390_ipc
+__x64_sys_rtas
+__ia32_sys_rtas
+__x64_sys_spu_run
+__ia32_sys_spu_run
+__x64_sys_spu_create
+__ia32_sys_spu_create
+__x64_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__ia32_sys_subpage_prot
+__x64_sys_pselect6_time32
+__ia32_sys_pselect6_time32
+__ia32_sys_pselect6_time32
+__ia32_sys_pselect6_time32
+__x64_sys_ppoll_time32
+__ia32_sys_ppoll_time32
+__ia32_sys_ppoll_time32
+__ia32_sys_ppoll_time32
+__ia32_sys_ppoll_time32
+__ia32_sys_ppoll_time32
+__ia32_sys_ppoll_time32
+__ia32_sys_ppoll_time32
+__ia32_sys_ppoll_time32
+__ia32_sys_ppoll_time32
+__ia32_sys_ppoll_time32
+__ia32_sys_ppoll_time32
+__ia32_sys_ppoll_time32
+__ia32_sys_ppoll_time32
+__x64_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+__ia32_sys_ipc
+create_new_namespaces
+free_nsproxy
+copy_namespaces
+validate_nsset
+put_nsset
+prepare_nsset
+unshare_nsproxy_namespaces
+switch_task_namespaces
+commit_nsset
+__ia32_sys_setns
+__x64_sys_setns
+exit_task_namespaces
+raw_notifier_chain_unregister
+atomic_notifier_chain_unregister
+unregister_die_notifier
+notifier_call_chain
+notifier_call_chain_robust
+atomic_notifier_call_chain_robust
+raw_notifier_call_chain_robust
+raw_notifier_call_chain
+atomic_notifier_call_chain
+srcu_notifier_call_chain
+blocking_notifier_call_chain_robust
+blocking_notifier_call_chain
+blocking_notifier_chain_unregister
+srcu_notifier_chain_unregister
+notifier_chain_register
+atomic_notifier_chain_register
+register_die_notifier
+raw_notifier_chain_register
+blocking_notifier_chain_register
+srcu_notifier_chain_register
+srcu_init_notifier_head
+uevent_helper_store
+notes_read
+rcu_normal_store
+rcu_expedited_store
+rcu_normal_show
+rcu_expedited_show
+kexec_loaded_show
+profiling_show
+uevent_helper_show
+uevent_seqnum_show
+fscaps_show
+vmcoreinfo_show
+kexec_crash_size_store
+kexec_crash_size_show
+kexec_crash_loaded_show
+profiling_store
+override_creds
+put_cred_rcu
+set_security_override
+set_security_override_from_ctx
+set_create_files_as
+cred_fscmp
+__put_cred
+abort_creds.part.0
+get_task_cred
+revert_creds
+abort_creds
+commit_creds
+prepare_creds
+prepare_kernel_cred
+exit_creds
+cred_alloc_blank
+prepare_exec_creds
+copy_creds
+emergency_restart
+register_reboot_notifier
+unregister_reboot_notifier
+register_restart_handler
+unregister_restart_handler
+orderly_poweroff
+orderly_reboot
+devm_register_reboot_notifier
+run_cmd
+devm_unregister_reboot_notifier
+kernel_restart_prepare
+do_kernel_restart
+migrate_to_reboot_cpu
+kernel_restart
+deferred_cad
+reboot_work_func
+kernel_halt
+kernel_power_off
+__x64_sys_reboot
+__ia32_sys_reboot
+poweroff_work_func
+ctrl_alt_del
+lowest_in_progress
+current_is_async
+async_run_entry_fn
+async_synchronize_cookie_domain
+async_synchronize_full_domain
+async_synchronize_full
+async_synchronize_cookie
+async_schedule_node_domain
+async_schedule_node
+async_unregister_domain
+cmp_range
+add_range
+add_range_with_merge
+subtract_range
+clean_sort_range
+sort_range
+smpboot_thread_fn
+smpboot_unpark_thread
+smpboot_destroy_threads
+smpboot_unregister_percpu_thread
+__smpboot_create_thread
+smpboot_register_percpu_thread
+idle_thread_get
+smpboot_create_threads
+smpboot_unpark_threads
+smpboot_park_threads
+cpu_report_state
+cpu_check_up_prepare
+cpu_set_state_online
+cpu_wait_death
+cpu_report_death
+set_lookup
+set_is_seen
+put_ucounts
+set_permissions
+setup_userns_sysctls
+retire_userns_sysctls
+inc_ucount
+dec_ucount
+__regset_get
+regset_get
+regset_get_alloc
+copy_regset_to_user
+umd_load_blob
+umd_unload_blob
+fork_usermode_driver
+umd_cleanup
+umd_setup
+free_modprobe_argv
+__request_module
+groups_free
+gid_cmp
+groups_alloc
+set_groups
+set_current_groups
+groups_sort
+groups_to_user
+__ia32_sys_getgroups
+groups_from_user
+in_group_p
+in_egroup_p
+__x64_sys_getgroups
+groups_search
+may_setgroups
+__ia32_sys_setgroups
+__x64_sys_setgroups
+tg_nop
+preempt_notifier_unregister
+__traceiter_sched_kthread_stop
+__traceiter_sched_kthread_stop_ret
+__traceiter_sched_waking
+__traceiter_sched_wakeup
+__traceiter_sched_wakeup_new
+__traceiter_sched_switch
+__traceiter_sched_migrate_task
+__traceiter_sched_process_free
+__traceiter_sched_process_exit
+__traceiter_sched_wait_task
+__traceiter_sched_process_wait
+__traceiter_sched_process_fork
+__traceiter_sched_process_exec
+__traceiter_sched_stat_wait
+__traceiter_sched_stat_sleep
+__traceiter_sched_stat_iowait
+__traceiter_sched_stat_blocked
+__traceiter_sched_stat_runtime
+__traceiter_sched_pi_setprio
+__traceiter_sched_process_hang
+__traceiter_sched_move_numa
+__traceiter_sched_stick_numa
+__traceiter_sched_swap_numa
+__traceiter_sched_wake_idle_without_ipi
+__traceiter_pelt_cfs_tp
+__traceiter_pelt_rt_tp
+__traceiter_pelt_dl_tp
+__traceiter_pelt_thermal_tp
+__traceiter_pelt_irq_tp
+__traceiter_pelt_se_tp
+__traceiter_sched_cpu_capacity_tp
+__traceiter_sched_overutilized_tp
+__traceiter_sched_util_est_cfs_tp
+__traceiter_sched_util_est_se_tp
+__traceiter_sched_update_nr_running_tp
+__balance_callback
+single_task_running
+__x64_sys_sched_get_priority_max
+__ia32_sys_sched_get_priority_max
+__x64_sys_sched_get_priority_min
+__ia32_sys_sched_get_priority_min
+cpu_shares_read_u64
+cpu_weight_nice_read_s64
+cpu_cfs_period_read_u64
+cpu_cfs_quota_read_s64
+cpu_weight_read_u64
+kick_process
+tg_cfs_schedulable_down
+preempt_notifier_register
+check_same_owner
+set_load_weight
+__sched_fork
+preempt_notifier_inc
+preempt_notifier_dec
+__schedule_bug
+sched_copy_attr
+__ia32_sys_sched_getscheduler
+__ia32_sys_sched_getparam
+sched_free_group
+sched_free_group_rcu
+cpu_cgroup_css_free
+cpu_cfs_stat_show
+cpu_max_show
+cpu_extra_stat_show
+cpu_shares_write_u64
+cpu_weight_nice_write_s64
+cpu_weight_write_u64
+sched_change_group
+ttwu_queue_wakelist
+can_nice.part.0
+sched_set_normal.part.0
+sched_show_task
+cpu_uclamp_max_show
+__x64_sys_sched_getscheduler
+cpu_cgroup_can_attach
+cpu_uclamp_min_show
+__x64_sys_sched_getparam
+get_user_cpu_mask
+sched_attr_copy_to_user
+__ia32_sys_sched_getattr
+__x64_sys_sched_getattr
+finish_task_switch
+__hrtick_start
+__task_rq_lock
+task_rq_lock
+cpu_util_update_eff
+cpu_uclamp_write.isra.0
+cpu_uclamp_max_write
+cpu_uclamp_min_write
+uclamp_update_util_min_rt_default.part.0
+sched_rr_get_interval
+__ia32_sys_sched_rr_get_interval
+__ia32_sys_sched_rr_get_interval_time32
+__x64_sys_sched_rr_get_interval
+__x64_sys_sched_rr_get_interval_time32
+update_rq_clock
+set_user_nice
+__ia32_sys_nice
+__x64_sys_nice
+hrtick
+cpu_cgroup_fork
+__sched_setscheduler
+_sched_setscheduler
+do_sched_setscheduler
+__x64_sys_sched_setscheduler
+__ia32_sys_sched_setscheduler
+__x64_sys_sched_setparam
+__ia32_sys_sched_setparam
+sched_set_fifo
+sched_set_fifo_low
+__ia32_sys_sched_setattr
+sched_set_normal
+__x64_sys_sched_setattr
+do_sched_yield
+__do_sys_sched_yield
+__cond_resched_lock
+hrtick_start
+wake_q_add
+wake_q_add_safe
+resched_curr
+resched_cpu
+wake_up_nohz_cpu
+walk_tg_tree_from
+tg_set_cfs_bandwidth
+cpu_cfs_period_write_u64
+cpu_cfs_quota_write_s64
+cpu_max_write
+uclamp_eff_value
+sysctl_sched_uclamp_handler
+activate_task
+deactivate_task
+check_preempt_curr
+ttwu_do_wakeup
+ttwu_do_activate
+set_cpus_allowed_common
+do_set_cpus_allowed
+select_fallback_rq
+set_task_cpu
+move_queued_task
+__set_cpus_allowed_ptr
+set_cpus_allowed_ptr
+migration_cpu_stop
+__migrate_swap_task
+migrate_swap_stop
+try_to_wake_up
+wake_up_process
+wake_up_q
+default_wake_function
+migrate_swap
+wait_task_inactive
+sched_set_stop_task
+sched_ttwu_pending
+send_call_function_single_ipi
+wake_up_if_idle
+cpus_share_cache
+try_invoke_on_locked_down_task
+wake_up_state
+set_numabalancing_state
+sysctl_numa_balancing
+force_schedstat_enabled
+sysctl_schedstats
+sched_fork
+sched_post_fork
+to_ratio
+wake_up_new_task
+schedule_tail
+nr_running
+nr_context_switches
+nr_iowait_cpu
+nr_iowait
+sched_exec
+task_sched_runtime
+do_task_dead
+rt_mutex_setprio
+can_nice
+task_prio
+idle_cpu
+get_nohz_timer_target
+scheduler_tick
+nohz_csd_func
+available_idle_cpu
+idle_task
+sched_setscheduler
+sched_setattr
+sched_setattr_nocheck
+sched_setscheduler_nocheck
+sched_setaffinity
+__ia32_sys_sched_setaffinity
+__x64_sys_sched_setaffinity
+sched_getaffinity
+__ia32_sys_sched_getaffinity
+__x64_sys_sched_getaffinity
+io_schedule_prepare
+io_schedule_finish
+show_state_filter
+init_idle
+cpuset_cpumask_can_shrink
+task_can_attach
+migrate_task_to
+sched_setnuma
+idle_task_exit
+set_rq_online
+set_rq_offline
+sched_cpu_activate
+sched_cpu_deactivate
+sched_cpu_starting
+sched_cpu_dying
+in_sched_functions
+normalize_rt_tasks
+curr_task
+sched_create_group
+cpu_cgroup_css_alloc
+sched_online_group
+cpu_cgroup_css_online
+sched_destroy_group
+sched_offline_group
+cpu_cgroup_css_released
+sched_move_task
+cpu_cgroup_attach
+call_trace_sched_update_nr_running
+calc_load_nohz_fold
+fixed_power_int.constprop.0
+get_avenrun
+calc_load_fold_active
+calc_load_n
+calc_load_nohz_start
+calc_load_nohz_remote
+calc_load_nohz_stop
+calc_global_load
+calc_global_load_tick
+account_user_time
+account_guest_time
+account_system_index_time
+account_system_time
+account_steal_time
+account_idle_time
+thread_group_cputime
+account_process_tick
+account_idle_ticks
+cputime_adjust
+task_cputime_adjusted
+thread_group_cputime_adjusted
+balance_idle
+put_prev_task_idle
+task_tick_idle
+update_curr_idle
+prio_changed_idle
+switched_to_idle
+check_preempt_curr_idle
+select_task_rq_idle
+set_next_task_idle
+pick_next_task_idle
+idle_inject_timer_fn
+dequeue_task_idle
+call_cpuidle
+sched_idle_set_state
+cpu_idle_poll_ctrl
+arch_cpu_idle_prepare
+arch_cpu_idle_prepare
+arch_cpu_idle_exit
+arch_cpu_idle_exit
+arch_cpu_idle_exit
+do_idle
+play_idle_precise
+cpu_in_idle
+cpu_startup_entry
+sched_trace_cfs_rq_avg
+sched_trace_rq_avg_rt
+sched_trace_rq_avg_dl
+sched_trace_rq_avg_irq
+get_update_sysctl_factor
+update_sysctl
+sched_trace_cfs_rq_cpu
+sched_trace_rq_cpu
+update_min_vruntime
+cpu_util_next
+sched_trace_rq_cpu_capacity
+sched_trace_rd_span
+sched_trace_rq_nr_running
+task_h_load
+__calc_delta
+sched_slice
+get_rr_interval_fair
+remove_entity_load_avg
+task_dead_fair
+compute_energy
+kick_ilb
+__enqueue_entity
+sched_trace_cfs_rq_path
+hrtick_start_fair
+clear_buddies
+check_spread.part.0
+prio_changed_fair
+score_nearby_nodes.part.0
+attach_task
+task_nr_scan_windows
+task_scan_min
+task_scan_max
+wakeup_preempt_entity
+pick_next_entity
+hrtick_update
+task_numa_assign
+task_scan_start
+task_numa_work
+rq_online_fair
+update_numa_stats
+find_idlest_group
+tg_throttle_down
+select_task_rq_fair
+preferred_group_nid
+set_next_buddy
+tg_unthrottle_up
+attach_entity_load_avg
+propagate_entity_cfs_rq
+detach_entity_cfs_rq
+detach_task_cfs_rq
+switched_from_fair
+migrate_task_rq_fair
+update_blocked_averages
+update_nohz_stats
+attach_entity_cfs_rq
+attach_task_cfs_rq
+switched_to_fair
+task_change_group_fair
+task_numa_find_cpu
+task_numa_migrate
+set_next_entity
+can_migrate_task
+active_load_balance_cpu_stop
+active_load_balance_cpu_stop
+__pick_first_entity
+__pick_last_entity
+sched_proc_update_handler
+init_entity_runnable_average
+post_init_entity_util_avg
+task_numa_group_id
+should_numa_migrate_memory
+task_numa_free
+task_numa_fault
+init_numa_balancing
+set_task_rq_fair
+cfs_bandwidth_usage_inc
+cfs_bandwidth_usage_dec
+__refill_cfs_bandwidth_runtime
+init_cfs_bandwidth
+start_cfs_bandwidth
+__account_cfs_rq_runtime
+set_next_task_fair
+update_curr
+update_curr_fair
+reweight_entity
+update_cfs_group
+reweight_task
+task_fork_fair
+yield_task_fair
+yield_to_task_fair
+dequeue_entity
+dequeue_task_fair
+throttle_cfs_rq
+check_cfs_rq_runtime
+check_preempt_wakeup
+task_tick_fair
+put_prev_entity
+put_prev_task_fair
+enqueue_entity
+enqueue_task_fair
+unthrottle_cfs_rq
+rq_offline_fair
+distribute_cfs_runtime
+sched_cfs_slack_timer
+sched_cfs_period_timer
+__update_idle_core
+update_group_capacity
+find_busiest_group
+load_balance
+rebalance_domains
+_nohz_idle_balance
+run_rebalance_domains
+newidle_balance
+balance_fair
+pick_next_task_fair
+__pick_next_task_fair
+update_max_interval
+nohz_balance_exit_idle
+nohz_balance_enter_idle
+trigger_load_balance
+init_cfs_rq
+free_fair_sched_group
+online_fair_sched_group
+unregister_fair_sched_group
+init_tg_cfs_entry
+alloc_fair_sched_group
+sched_group_set_shares
+print_cfs_stats
+show_numa_stats
+get_rr_interval_rt
+rto_next_cpu
+pick_next_pushable_task
+find_lowest_rq
+update_rt_migration
+requeue_task_rt.isra.0
+yield_task_rt
+check_preempt_curr_rt
+prio_changed_rt
+switched_from_rt
+switched_to_rt
+dequeue_top_rt_rq
+dequeue_rt_stack
+select_task_rq_rt
+pick_next_task_rt
+enqueue_top_rt_rq
+rq_online_rt
+enqueue_task_rt
+rq_offline_rt
+balance_runtime
+sched_rt_period_timer
+update_curr_rt
+task_tick_rt
+put_prev_task_rt
+dequeue_task_rt
+push_rt_task
+push_rt_tasks
+task_woken_rt
+pull_rt_task
+balance_rt
+init_rt_bandwidth
+init_rt_rq
+free_rt_sched_group
+alloc_rt_sched_group
+sched_rt_bandwidth_account
+rto_push_irq_work_func
+sched_rt_handler
+sched_rr_handler
+print_rt_stats
+task_fork_dl
+init_dl_rq_bw_ratio
+pick_next_pushable_dl_task
+check_preempt_curr_dl
+find_later_rq
+update_dl_migration
+prio_changed_dl
+select_task_rq_dl
+enqueue_pushable_dl_task
+__dequeue_dl_entity
+dequeue_pushable_dl_task
+rq_offline_dl
+rq_online_dl
+switched_to_dl
+start_dl_timer
+set_next_task_dl
+pick_next_task_dl
+task_contending
+replenish_dl_entity
+set_cpus_allowed_dl
+migrate_task_rq_dl
+find_lock_later_rq
+push_dl_task.part.0
+push_dl_tasks
+task_woken_dl
+pull_dl_task
+balance_dl
+inactive_task_timer
+task_non_contending
+switched_from_dl
+enqueue_task_dl
+dl_task_timer
+update_curr_dl
+yield_task_dl
+put_prev_task_dl
+task_tick_dl
+dequeue_task_dl
+init_dl_bandwidth
+init_dl_bw
+init_dl_rq
+init_dl_task_timer
+init_dl_inactive_task_timer
+dl_add_task_root_domain
+dl_clear_root_domain
+sched_dl_global_validate
+sched_dl_do_global
+sched_dl_overflow
+__setparam_dl
+__getparam_dl
+__checkparam_dl
+__dl_clear_params
+dl_param_changed
+dl_task_can_attach
+dl_cpuset_cpumask_can_shrink
+dl_cpu_busy
+print_dl_stats
+remove_wait_queue
+do_wait_intr
+do_wait_intr_irq
+__init_waitqueue_head
+add_wait_queue
+add_wait_queue_exclusive
+__wake_up_common
+__wake_up_common_lock
+__wake_up
+__wake_up_sync_key
+__wake_up_sync
+__wake_up_locked
+__wake_up_locked_key
+__wake_up_locked_key_bookmark
+__wake_up_locked_sync_key
+prepare_to_wait
+prepare_to_wait_exclusive
+init_wait_entry
+finish_wait
+prepare_to_wait_event
+woken_wake_function
+wait_woken
+autoremove_wake_function
+bit_waitqueue
+__var_waitqueue
+__wake_up_bit
+wake_up_bit
+wake_up_var
+init_wait_var_entry
+var_wake_function
+wake_bit_function
+__init_swait_queue_head
+finish_swait
+swake_up_locked
+swake_up_one
+prepare_to_swait_exclusive
+prepare_to_swait_event
+swake_up_all
+swake_up_all_locked
+__prepare_to_swait
+__finish_swait
+try_wait_for_completion
+complete
+complete_all
+completion_done
+cpupri_find_fitness
+cpupri_find
+cpupri_set
+cpupri_init
+cpupri_cleanup
+cpudl_heapify_up
+cpudl_heapify
+cpudl_find
+cpudl_clear
+cpudl_set
+cpudl_set_freecpu
+cpudl_clear_freecpu
+cpudl_init
+cpudl_cleanup
+sd_numa_mask
+destroy_perf_domain_rcu
+free_rootdomain
+init_rootdomain
+dattrs_equal.part.0
+free_sched_groups.part.0
+destroy_sched_domain
+destroy_sched_domains_rcu
+sd_degenerate
+sched_energy_aware_handler
+rq_attach_root
+cpu_attach_domain
+build_sched_domains
+sched_get_rd
+sched_put_rd
+init_defrootdomain
+group_balance_cpu
+set_sched_topology
+find_numa_distance
+sched_init_numa
+sched_domains_numa_masks_set
+sched_domains_numa_masks_clear
+sched_numa_find_closest
+sched_numa_find_closest
+free_sched_domains
+alloc_sched_domains
+sched_init_domains
+partition_sched_domains_locked
+partition_sched_domains
+check_preempt_curr_stop
+update_curr_stop
+prio_changed_stop
+switched_to_stop
+yield_task_stop
+select_task_rq_stop
+balance_stop
+task_tick_stop
+dequeue_task_stop
+enqueue_task_stop
+set_next_task_stop
+pick_next_task_stop
+put_prev_task_stop
+decay_load
+__accumulate_pelt_segments
+__update_load_avg_blocked_se
+__update_load_avg_se
+__update_load_avg_cfs_rq
+update_rt_rq_load_avg
+update_dl_rq_load_avg
+autogroup_move_group
+sched_autogroup_create_attach
+sched_autogroup_detach
+autogroup_free
+task_wants_autogroup
+sched_autogroup_exit_task
+sched_autogroup_fork
+sched_autogroup_exit
+proc_sched_autogroup_set_nice
+proc_sched_autogroup_show_task
+autogroup_path
+schedstat_stop
+show_schedstat
+schedstat_start
+schedstat_next
+sched_debug_stop
+sched_feat_open
+sched_feat_show
+sched_feat_write
+sd_free_ctl_entry
+sched_debug_start
+sched_debug_next
+sched_debug_header
+task_group_path
+print_cpu
+sched_debug_show
+sd_ctl_doflags
+register_sched_domain_sysctl
+dirty_sched_domain_sysctl
+unregister_sched_domain_sysctl
+print_cfs_rq
+print_rt_rq
+print_dl_rq
+sysrq_sched_debug_show
+print_numa_stats
+proc_sched_show_task
+proc_sched_set_task
+cpuusage_write
+cpuacct_stats_show
+cpuacct_all_seq_show
+cpuacct_css_free
+cpuacct_cpuusage_read
+__cpuacct_percpu_seq_show
+cpuacct_percpu_sys_seq_show
+cpuacct_percpu_user_seq_show
+cpuacct_percpu_seq_show
+__cpuusage_read
+cpuusage_sys_read
+cpuusage_user_read
+cpuusage_read
+cpuacct_css_alloc
+cpuacct_charge
+cpuacct_account_field
+cpufreq_remove_update_util_hook
+cpufreq_add_update_util_hook
+cpufreq_this_cpu_can_update
+sugov_work
+sugov_start
+rate_limit_us_store
+rate_limit_us_show
+sugov_irq_work
+rebuild_sd_workfn
+sugov_iowait_boost
+sugov_iowait_apply
+sugov_limits
+sugov_stop
+sugov_fast_switch
+get_next_freq
+sugov_should_update_freq
+sugov_kthread_stop
+sugov_init
+sugov_deferred_update
+sugov_exit
+schedutil_cpu_util
+sugov_get_util
+sugov_update_single
+sugov_update_shared
+cpufreq_default_governor
+sched_cpufreq_governor_change
+ipi_mb
+ipi_sync_core
+membarrier_global_expedited
+membarrier_private_expedited
+ipi_sync_rq_state
+sync_runqueues_membarrier_state
+membarrier_register_global_expedited
+membarrier_register_private_expedited
+__ia32_sys_membarrier
+ipi_rseq
+__x64_sys_membarrier
+membarrier_exec_mmap
+housekeeping_enabled
+housekeeping_cpumask
+housekeeping_test_cpu
+housekeeping_any_cpu
+housekeeping_affine
+record_times
+group_init
+psi_flags_change
+poll_timer_fn
+psi_cpu_open
+psi_memory_open
+psi_io_open
+psi_schedule_poll_work.part.0
+psi_group_change
+collect_percpu_times
+psi_poll_worker
+psi_trigger_destroy
+update_averages
+psi_avgs_work
+psi_task_change
+psi_task_switch
+psi_memstall_tick
+psi_memstall_enter
+psi_memstall_leave
+psi_cgroup_alloc
+psi_cgroup_free
+cgroup_move_task
+psi_show
+psi_cpu_show
+psi_memory_show
+psi_io_show
+psi_trigger_create
+psi_trigger_replace
+psi_fop_release
+psi_write
+psi_cpu_write
+psi_memory_write
+psi_io_write
+psi_trigger_poll
+psi_fop_poll
+__mutex_init
+mutex_is_locked
+__ww_mutex_wound
+mutex_spin_on_owner
+mutex_trylock_recursive
+atomic_dec_and_mutex_lock
+down_trylock
+up
+down
+down_killable
+down_timeout
+down_interruptible
+down_write_trylock
+__init_rwsem
+down_read_trylock
+rwsem_spin_on_owner
+rwsem_optimistic_spin
+rwsem_mark_wake
+rwsem_wake.isra.0
+up_read
+up_write
+downgrade_write
+rwsem_down_write_slowpath
+percpu_up_write
+__percpu_init_rwsem
+percpu_free_rwsem
+__percpu_down_read_trylock
+percpu_rwsem_wait
+percpu_down_write
+__percpu_down_read
+percpu_rwsem_wake_function
+osq_lock
+osq_unlock
+pv_hash
+native_queued_spin_lock_slowpath
+__pv_queued_spin_lock_slowpath
+__pv_queued_spin_unlock_slowpath
+__rt_mutex_init
+rt_mutex_enqueue
+rt_mutex_enqueue_pi
+rt_mutex_destroy
+mark_wakeup_next_waiter
+try_to_take_rt_mutex
+rt_mutex_adjust_prio_chain
+task_blocks_on_rt_mutex
+remove_waiter
+rt_mutex_timed_lock
+rt_mutex_adjust_pi
+rt_mutex_init_waiter
+rt_mutex_postunlock
+rt_mutex_init_proxy_locked
+rt_mutex_proxy_unlock
+__rt_mutex_start_proxy_lock
+rt_mutex_start_proxy_lock
+rt_mutex_next_owner
+rt_mutex_wait_proxy_lock
+rt_mutex_cleanup_proxy_lock
+queued_write_lock_slowpath
+queued_read_lock_slowpath
+cpu_latency_qos_request_active
+pm_qos_get_value
+cpu_latency_qos_read
+freq_qos_add_notifier
+freq_qos_remove_notifier
+pm_qos_read_value
+pm_qos_update_target
+cpu_latency_qos_apply
+cpu_latency_qos_add_request
+cpu_latency_qos_open
+cpu_latency_qos_update_request
+cpu_latency_qos_write
+cpu_latency_qos_remove_request
+cpu_latency_qos_release
+pm_qos_update_flags
+cpu_latency_qos_limit
+freq_constraints_init
+freq_qos_read_value
+freq_qos_apply
+freq_qos_add_request
+freq_qos_update_request
+freq_qos_remove_request
+register_pm_notifier
+unregister_pm_notifier
+suspend_stats_show
+last_failed_step_show
+last_failed_errno_show
+last_failed_dev_show
+failed_resume_noirq_show
+failed_resume_early_show
+failed_resume_show
+failed_suspend_noirq_show
+failed_suspend_late_show
+failed_suspend_show
+failed_prepare_show
+failed_freeze_show
+fail_show
+success_show
+pm_freeze_timeout_show
+pm_wakeup_irq_show
+pm_async_show
+pm_trace_show
+pm_freeze_timeout_store
+pm_debug_messages_store
+pm_print_times_store
+sync_on_suspend_store
+pm_async_store
+lock_system_sleep
+unlock_system_sleep
+suspend_stats_open
+pm_test_show
+mem_sleep_show
+mem_sleep_store
+pm_test_store
+wake_unlock_store
+wake_unlock_show
+wake_lock_show
+wake_lock_store
+pm_trace_store
+wakeup_count_store
+wakeup_count_show
+pm_trace_dev_match_show
+state_store
+state_show
+pm_debug_messages_show
+pm_print_times_show
+sync_on_suspend_show
+ksys_sync_helper
+pm_notifier_call_chain_robust
+pm_notifier_call_chain
+__pm_pr_dbg
+pm_vt_switch_required
+pm_vt_switch_unregister
+pm_vt_switch
+pm_prepare_console
+pm_restore_console
+try_to_freeze_tasks
+thaw_processes
+freeze_processes
+pm_suspend_default_s2idle
+suspend_valid_only_mem
+s2idle_wake
+suspend_set_ops
+s2idle_set_ops
+arch_suspend_disable_irqs
+arch_suspend_enable_irqs
+suspend_devices_and_enter
+pm_suspend
+reserved_size_store
+image_size_store
+reserved_size_show
+image_size_show
+resume_show
+resume_offset_show
+resume_offset_store
+disk_store
+system_entering_hibernation
+platform_begin.part.0
+platform_end.part.0
+platform_pre_snapshot.part.0
+platform_finish.part.0
+hibernation_set_ops
+disk_show
+hibernate_acquire
+hibernate_quiet_exec
+hibernate_release
+hibernation_available
+swsusp_show_speed
+swsusp_show_speed
+hibernation_snapshot
+hibernation_snapshot
+hibernation_restore
+software_resume
+resume_store
+hibernation_platform_enter
+hibernate
+memory_bm_find_bit
+free_mem_extents
+memory_bm_next_pfn
+memory_bm_test_bit
+memory_bm_set_bit
+get_image_page
+memory_bm_clear_bit
+__get_safe_page
+chain_alloc
+alloc_rtree_node
+duplicate_memory_bitmap.constprop.0
+free_zone_bm_rtree
+memory_bm_free
+memory_bm_create
+enable_restore_image_protection
+get_safe_page
+swsusp_set_page_free
+swsusp_unset_page_free
+swsusp_page_is_forbidden
+create_basic_memory_bitmaps
+free_basic_memory_bitmaps
+clear_free_pages
+snapshot_additional_pages
+swsusp_free
+get_buffer.constprop.0
+snapshot_get_image_size
+snapshot_read_next
+snapshot_write_next
+snapshot_write_finalize
+snapshot_image_loaded
+release_swap_reader
+hib_submit_io
+swap_read_page
+hib_wait_io
+write_page
+hib_init_batch
+crc32_threadfn
+lzo_compress_threadfn
+load_image
+hib_end_io
+lzo_decompress_threadfn
+load_image_lzo
+alloc_swapdev_block
+swap_write_page
+save_image
+save_image_lzo
+free_all_swap_pages
+swsusp_swap_in_use
+swsusp_read
+swsusp_check
+swsusp_close
+swsusp_write
+swsusp_unmark
+snapshot_open
+snapshot_write
+snapshot_release
+snapshot_ioctl
+snapshot_read
+snapshot_compat_ioctl
+is_hibernate_resume_dev
+__wakelocks_gc
+wakelock_lookup_add
+pm_show_wakelocks
+pm_wake_lock
+pm_wake_unlock
+do_poweroff
+handle_poweroff
+em_pd_get
+em_cpu_get
+em_debug_cpus_open
+em_debug_cpus_show
+em_dev_unregister_perf_domain
+em_dev_register_perf_domain
+is_console_locked
+kmsg_dump_reason_str
+__traceiter_console
+__printk_ratelimit
+msg_add_ext_text
+msg_add_dict_text
+msg_print_ext_body
+info_print_prefix
+record_print_text
+printk_timed_ratelimit
+vprintk
+devkmsg_release
+console_lock
+suppress_message_printing
+kmsg_dump_register
+check_syslog_permissions
+try_enable_new_console
+kmsg_dump_unregister
+__control_devkmsg
+__add_preferred_console.constprop.0
+info_print_ext_header.constprop.0
+log_store.constprop.0
+__up_console_sem.isra.0
+console_trylock.part.0
+__down_trylock_console_sem.isra.0
+console_trylock
+kmsg_dump_rewind
+devkmsg_llseek
+devkmsg_poll
+devkmsg_open
+console_unlock
+console_stop
+console_start
+unregister_console
+wake_up_klogd_work_func
+console_cpu_notify
+register_console
+syslog_print_all
+syslog_print
+devkmsg_read
+kmsg_dump_get_buffer
+do_syslog.part.0
+devkmsg_sysctl_set_loglvl
+printk_percpu_data_ready
+log_buf_addr_get
+log_buf_len_get
+log_buf_vmcoreinfo_setup
+do_syslog
+__x64_sys_syslog
+__ia32_sys_syslog
+vprintk_store
+early_printk
+add_preferred_console
+suspend_console
+resume_console
+console_unblank
+console_flush_on_panic
+console_device
+wake_up_klogd
+vprintk_emit
+vprintk_default
+devkmsg_write
+defer_console_output
+vprintk_deferred
+kmsg_dump
+kmsg_dump_get_line_nolock
+kmsg_dump_get_line
+kmsg_dump_rewind_nolock
+printk_safe_log_store
+__printk_safe_flush
+printk_safe_flush
+printk_safe_flush_on_panic
+printk_nmi_direct_enter
+printk_nmi_direct_exit
+__printk_safe_enter
+__printk_safe_exit
+vprintk_func
+to_desc
+desc_make_reusable
+desc_make_final
+_prb_commit
+to_info
+desc_read
+desc_read_finalized_seq
+get_next_lpos
+get_data
+space_used
+_prb_read_valid
+data_push_tail.part.0
+data_alloc
+data_check_size.part.0
+prb_commit
+prb_reserve_in_last
+prb_reserve
+prb_final_commit
+prb_read_valid
+prb_read_valid_info
+prb_first_valid_seq
+prb_next_seq
+prb_init
+prb_record_text_space
+irq_sysfs_add
+irq_to_desc
+generic_handle_irq
+actions_show
+irq_kobj_release
+delayed_free_desc
+free_desc
+irq_free_descs
+alloc_desc
+irq_get_percpu_devid_partition
+type_show
+wakeup_show
+name_show
+hwirq_show
+chip_name_show
+irq_lock_sparse
+irq_unlock_sparse
+irq_get_next_irq
+__irq_get_desc_lock
+__irq_put_desc_unlock
+irq_set_percpu_devid_partition
+irq_set_percpu_devid
+kstat_incr_irq_this_cpu
+kstat_irqs_cpu
+per_cpu_count_show
+kstat_irqs
+kstat_irqs_usr
+no_action
+handle_bad_irq
+__irq_wake_thread
+__handle_irq_event_percpu
+handle_irq_event_percpu
+handle_irq_event
+irq_default_primary_handler
+set_irq_wake_real
+irq_set_vcpu_affinity
+irq_set_parent
+irq_percpu_is_enabled
+irq_set_irqchip_state
+__disable_irq_nosync
+disable_irq_nosync
+irq_set_irq_wake
+irq_nested_primary_handler
+irq_forced_secondary_handler
+irq_wake_thread
+__cleanup_nmi
+disable_percpu_irq
+wake_threads_waitq
+setup_irq_thread
+__free_percpu_irq
+free_percpu_irq
+irq_set_affinity_notifier
+irq_finalize_oneshot.part.0
+irq_thread_fn
+irq_forced_thread_fn
+irq_thread_dtor
+irq_affinity_notify
+irq_thread_check_affinity
+irq_thread
+irq_can_set_affinity
+irq_can_set_affinity_usr
+irq_set_thread_affinity
+irq_do_set_affinity
+irq_set_affinity_locked
+__irq_set_affinity
+irq_set_affinity_hint
+irq_setup_affinity
+__disable_irq
+disable_nmi_nosync
+__enable_irq
+enable_irq
+enable_nmi
+can_request_irq
+__irq_set_trigger
+__setup_irq
+request_threaded_irq
+request_any_context_irq
+__request_percpu_irq
+enable_percpu_irq
+free_nmi
+request_nmi
+enable_percpu_nmi
+disable_percpu_nmi
+remove_percpu_irq
+free_percpu_nmi
+setup_percpu_irq
+request_percpu_nmi
+prepare_percpu_nmi
+teardown_percpu_nmi
+__irq_get_irqchip_state
+__synchronize_hardirq
+synchronize_hardirq
+disable_hardirq
+synchronize_irq
+disable_irq
+free_irq
+irq_get_irqchip_state
+try_one_irq
+poll_spurious_irqs
+__report_bad_irq
+irq_wait_for_poll
+note_interrupt
+resend_irqs
+check_irq_resend
+irq_set_irq_type
+irq_get_irq_data
+irq_chip_set_parent_state
+irq_chip_get_parent_state
+irq_chip_enable_parent
+irq_chip_disable_parent
+irq_chip_ack_parent
+irq_chip_mask_parent
+irq_chip_mask_ack_parent
+irq_chip_unmask_parent
+irq_chip_eoi_parent
+irq_chip_set_affinity_parent
+irq_chip_set_type_parent
+irq_chip_retrigger_hierarchy
+irq_chip_set_vcpu_affinity_parent
+irq_chip_set_wake_parent
+irq_chip_request_resources_parent
+irq_chip_release_resources_parent
+irq_set_chip
+irq_set_handler_data
+irq_set_chip_data
+irq_modify_status
+__irq_disable
+irq_may_run
+bad_chained_irq
+handle_nested_irq
+handle_simple_irq
+handle_fasteoi_nmi
+handle_untracked_irq
+handle_level_irq
+handle_fasteoi_irq
+handle_edge_irq
+irq_set_msi_desc_off
+irq_set_msi_desc
+irq_activate
+irq_shutdown
+irq_shutdown_and_deactivate
+irq_enable
+__irq_startup
+irq_startup
+irq_activate_and_startup
+__irq_do_set_handler
+__irq_set_handler
+irq_set_chip_and_handler_name
+irq_set_chained_handler_and_data
+irq_disable
+irq_percpu_enable
+irq_percpu_disable
+mask_irq
+unmask_irq
+unmask_threaded_irq
+handle_percpu_irq
+handle_percpu_devid_irq
+handle_percpu_devid_fasteoi_ipi
+handle_percpu_devid_fasteoi_nmi
+irq_cpu_online
+irq_cpu_offline
+irq_chip_compose_msi_msg
+irq_chip_pm_get
+irq_chip_pm_put
+noop
+noop_ret
+ack_bad
+devm_free_irq
+devm_irq_alloc_generic_chip
+devm_irq_match
+devm_irq_release
+devm_request_threaded_irq
+devm_request_any_context_irq
+__devm_irq_alloc_descs
+devm_irq_desc_release
+devm_irq_setup_generic_chip
+devm_irq_remove_generic_chip
+irq_writel_be
+irq_readl_be
+irq_gc_init_mask_cache
+irq_setup_alt_chip
+__irq_get_domain_generic_chip
+irq_get_domain_generic_chip
+irq_unmap_generic_chip
+irq_map_generic_chip
+irq_setup_generic_chip
+irq_gc_get_irq_data
+irq_gc_shutdown
+irq_gc_resume
+irq_gc_suspend
+__irq_alloc_domain_generic_chips
+irq_gc_ack_set_bit
+irq_gc_mask_set_bit
+irq_gc_mask_clr_bit
+irq_remove_generic_chip
+irq_alloc_generic_chip
+irq_gc_noop
+irq_gc_mask_disable_reg
+irq_gc_unmask_enable_reg
+irq_gc_ack_clr_bit
+irq_gc_mask_disable_and_ack_set
+irq_gc_eoi
+irq_gc_set_wake
+irq_init_generic_chip
+probe_irq_off
+probe_irq_mask
+probe_irq_on
+irq_set_default_host
+irq_domain_reset_irq_data
+irq_domain_free_irqs_parent
+irq_domain_free_fwnode
+irq_domain_xlate_onecell
+irq_domain_xlate_onetwocell
+irq_domain_translate_onecell
+irq_domain_translate_twocell
+irq_domain_xlate_twocell
+irq_domain_update_bus_token
+irq_find_matching_fwspec
+irq_domain_remove
+irq_domain_get_irq_data
+irq_domain_free_irqs_common
+irq_domain_set_hwirq_and_chip
+irq_domain_set_info
+irq_domain_free_irq_data
+irq_find_mapping
+irq_domain_fix_revmap
+irq_domain_check_msi_remap
+__irq_domain_deactivate_irq
+__irq_domain_activate_irq
+irq_domain_clear_mapping.part.0
+irq_domain_pop_irq
+irq_domain_set_mapping.part.0
+irq_domain_associate
+irq_domain_associate_many
+irq_create_strict_mappings
+irq_create_direct_mapping
+__irq_domain_add
+irq_domain_create_hierarchy
+irq_domain_add_simple
+irq_domain_add_legacy
+__irq_domain_alloc_fwnode
+irq_get_default_host
+irq_domain_disassociate
+irq_domain_alloc_descs
+irq_create_mapping_affinity
+irq_domain_disconnect_hierarchy
+irq_domain_free_irqs_top
+irq_domain_alloc_irqs_hierarchy
+irq_domain_push_irq
+irq_domain_alloc_irqs_parent
+__irq_domain_alloc_irqs
+irq_domain_free_irqs
+irq_dispose_mapping
+irq_create_fwspec_mapping
+irq_create_of_mapping
+irq_domain_activate_irq
+irq_domain_deactivate_irq
+irq_domain_hierarchical_is_msi_remap
+default_affinity_show
+irq_affinity_list_proc_open
+irq_affinity_proc_open
+default_affinity_open
+irq_spurious_proc_show
+irq_node_proc_show
+write_irq_affinity.isra.0
+irq_affinity_list_proc_write
+irq_affinity_proc_write
+irq_effective_aff_list_proc_show
+irq_affinity_proc_show
+irq_effective_aff_proc_show
+irq_affinity_list_proc_show
+default_affinity_write
+irq_affinity_hint_proc_show
+register_handler_proc
+register_irq_proc
+unregister_irq_proc
+unregister_handler_proc
+init_irq_proc
+init_irq_proc
+show_interrupts
+irq_fixup_move_pending
+irq_move_masked_irq
+__irq_move_irq
+irq_migrate_all_off_this_cpu
+irq_affinity_online_cpu
+resume_irqs
+irq_pm_syscore_resume
+resume_device_irqs
+suspend_device_irqs
+irq_pm_check_wakeup
+irq_pm_install_action
+irq_pm_remove_action
+rearm_wake_irq
+msi_domain_ops_check
+msi_domain_ops_get_hwirq
+msi_domain_ops_set_desc
+get_cached_msi_msg
+msi_domain_ops_prepare
+msi_domain_deactivate
+msi_domain_free
+msi_domain_alloc
+msi_domain_ops_init
+__msi_domain_free_irqs
+msi_check_level
+msi_domain_set_affinity
+msi_domain_activate
+alloc_msi_entry
+free_msi_entry
+__get_cached_msi_msg
+msi_create_irq_domain
+msi_domain_prepare_irqs
+__msi_domain_alloc_irqs
+msi_domain_populate_irqs
+msi_domain_alloc_irqs
+msi_domain_free_irqs
+msi_get_domain_info
+ncpus_cmp_func
+default_calc_sets
+__irq_build_affinity_masks
+irq_create_affinity_masks
+irq_calc_affinity_vectors
+__traceiter_irq_matrix_online
+__traceiter_irq_matrix_offline
+__traceiter_irq_matrix_reserve
+__traceiter_irq_matrix_remove_reserved
+__traceiter_irq_matrix_assign_system
+__traceiter_irq_matrix_alloc_reserved
+__traceiter_irq_matrix_reserve_managed
+__traceiter_irq_matrix_remove_managed
+__traceiter_irq_matrix_alloc_managed
+__traceiter_irq_matrix_assign
+__traceiter_irq_matrix_alloc
+__traceiter_irq_matrix_free
+matrix_alloc_area.constprop.0
+irq_matrix_online
+irq_matrix_offline
+irq_matrix_assign_system
+irq_matrix_remove_managed
+irq_matrix_reserve_managed
+irq_matrix_alloc_managed
+irq_matrix_assign
+irq_matrix_reserve
+irq_matrix_remove_reserved
+irq_matrix_alloc
+irq_matrix_free
+irq_matrix_available
+irq_matrix_reserved
+irq_matrix_allocated
+rcu_gp_is_normal
+rcu_gp_is_expedited
+rcu_expedite_gp
+rcu_unexpedite_gp
+do_trace_rcu_torture_read
+rcu_tasks_be_rude
+__traceiter_rcu_utilization
+wakeme_after_rcu
+__wait_rcu_gp
+rcu_barrier_tasks_rude
+synchronize_rcu_tasks_rude
+synchronize_rcu_tasks_trace
+rcu_barrier_tasks_trace
+rcu_read_unlock_iw
+trc_read_check_handler
+rcu_tasks_kthread
+rcu_tasks_wait_gp
+show_rcu_tasks_generic_gp_kthread
+rcu_inkernel_boot_has_ended
+show_stalled_task_trace
+show_stalled_ipi_trace
+rcu_tasks_trace_pregp_step
+call_rcu_tasks_generic
+call_rcu_tasks_rude
+call_rcu_tasks_trace
+rcu_read_unlock_trace_special.part.0
+rcu_read_unlock_trace_special
+rcu_tasks_trace_postgp
+rcu_tasks_rude_wait_gp
+trc_inspect_reader
+trc_wait_for_one_reader
+rcu_tasks_trace_pertask
+rcu_tasks_trace_postscan
+check_all_holdout_tasks_trace
+rcu_end_inkernel_boot
+rcu_test_sync_prims
+rcu_early_boot_tests
+exit_tasks_rcu_start
+exit_tasks_rcu_finish
+show_rcu_tasks_gp_kthreads
+rcu_sync_func
+rcu_sync_init
+rcu_sync_enter_start
+rcu_sync_enter
+rcu_sync_exit
+rcu_sync_dtor
+__srcu_read_lock
+__srcu_read_unlock
+srcu_batches_completed
+srcutorture_get_gp_data
+try_check_zero
+srcu_readers_active
+srcu_delay_timer
+srcu_queue_delayed_work_on
+srcu_torture_stats_print
+cleanup_srcu_struct
+srcu_barrier_cb
+srcu_funnel_exp_start
+init_srcu_struct_fields
+init_srcu_struct
+srcu_module_notify
+check_init_srcu_struct
+srcu_gp_start
+__call_srcu
+call_srcu
+__synchronize_srcu.part.0
+synchronize_srcu_expedited
+synchronize_srcu
+srcu_barrier
+srcu_reschedule
+srcu_invoke_callbacks
+process_srcu
+rcu_get_gp_kthreads_prio
+rcu_get_gp_seq
+rcu_exp_batches_completed
+rcu_gp_set_torture_wait
+strict_work_handler
+rcu_cpu_kthread_should_run
+get_state_synchronize_rcu
+rcu_jiffies_till_stall_check
+rcu_panic
+rcu_read_unlock_strict
+rcu_cpu_kthread_setup
+rcu_pm_notify
+rcu_is_watching
+rcu_is_cpu_rrupt_from_idle
+rcutorture_get_gp_data
+rcu_cpu_kthread_park
+sync_rcu_exp_done_unlocked
+kfree_rcu_shrink_count
+rcu_implicit_dynticks_qs
+kfree_rcu_monitor
+rcu_barrier_callback
+rcu_gp_slow.part.0
+dyntick_save_progress_counter
+rcu_gp_kthread_wake
+rcu_report_qs_rnp
+force_qs_rnp
+param_set_first_fqs_jiffies
+param_set_next_fqs_jiffies
+rcu_barrier_func
+rcu_stall_kick_kthreads
+show_rcu_gp_kthreads
+sysrq_show_rcu
+rcu_idle_enter
+rcu_exp_need_qs
+kfree_rcu_shrink_scan
+rcu_barrier
+kfree_rcu_work
+rcu_report_exp_cpu_mult
+rcu_qs
+rcu_exp_handler
+sync_rcu_exp_select_node_cpus
+sync_rcu_exp_select_cpus
+rcu_exp_wait_wake
+wait_rcu_exp_gp
+rcu_iw_handler
+rcu_note_context_switch
+rcu_idle_exit
+rcu_cleanup_dead_rnp
+rcu_force_quiescent_state
+invoke_rcu_core
+synchronize_rcu_expedited
+synchronize_rcu
+cond_synchronize_rcu
+kvfree_call_rcu
+rcu_accelerate_cbs
+rcu_advance_cbs
+__note_gp_changes
+note_gp_changes
+rcu_gp_kthread
+rcu_accelerate_cbs_unlocked
+call_rcu
+rcu_core
+rcu_core_si
+rcu_cpu_kthread
+rcu_all_qs
+rcu_softirq_qs
+rcu_dynticks_zero_in_eqs
+rcu_eqs_special_set
+rcu_irq_exit_preempt
+rcu_irq_exit_irqson
+rcu_irq_enter_irqson
+rcu_request_urgent_qs_task
+rcutree_dying_cpu
+rcutree_dead_cpu
+rcu_sched_clock_irq
+rcutree_prepare_cpu
+rcutree_online_cpu
+rcutree_offline_cpu
+rcu_cpu_starting
+rcu_report_dead
+rcutree_migrate_callbacks
+rcu_scheduler_starting
+rcu_gp_might_be_stalled
+rcu_sysrq_start
+rcu_sysrq_end
+rcu_cpu_stall_reset
+exit_rcu
+rcu_needs_cpu
+rcu_segcblist_extract_done_cbs.part.0
+rcu_cblist_init
+rcu_cblist_enqueue
+rcu_cblist_flush_enqueue
+rcu_cblist_dequeue
+rcu_segcblist_inc_len
+rcu_segcblist_init
+rcu_segcblist_disable
+rcu_segcblist_offload
+rcu_segcblist_ready_cbs
+rcu_segcblist_pend_cbs
+rcu_segcblist_first_cb
+rcu_segcblist_first_pend_cb
+rcu_segcblist_nextgp
+rcu_segcblist_enqueue
+rcu_segcblist_entrain
+rcu_segcblist_extract_count
+rcu_segcblist_extract_done_cbs
+rcu_segcblist_extract_pend_cbs
+rcu_segcblist_insert_count
+rcu_segcblist_insert_done_cbs
+rcu_segcblist_insert_pend_cbs
+rcu_segcblist_advance
+rcu_segcblist_accelerate
+rcu_segcblist_merge
+transition_show
+klp_kobj_release_patch
+klp_find_callback
+klp_find_object_symbol
+klp_resolve_symbols
+__klp_free_objects
+klp_free_patch_start
+enabled_show
+enabled_store
+klp_kobj_release_object
+klp_kobj_release_func
+klp_free_patch_finish
+klp_free_patch_work_fn
+force_store
+klp_cleanup_module_patches_limited
+klp_apply_section_relocs
+klp_init_object_loaded
+klp_enable_patch
+klp_free_patch_async
+klp_free_replaced_patches_async
+klp_unpatch_replaced_patches
+klp_discard_nops
+klp_module_coming
+klp_module_going
+__klp_unpatch_object
+__klp_unpatch_objects
+klp_find_ops
+klp_unpatch_object
+klp_patch_object
+klp_unpatch_objects
+klp_unpatch_objects_dynamic
+klp_shadow_get
+__klp_shadow_get_or_alloc
+klp_shadow_alloc
+klp_shadow_get_or_alloc
+klp_shadow_free_struct
+klp_shadow_free
+klp_shadow_free_all
+klp_get_state
+klp_get_prev_state
+klp_is_patch_compatible
+klp_sync
+klp_complete_transition
+klp_try_switch_task
+klp_cancel_transition
+klp_update_patch_state
+klp_try_complete_transition
+klp_transition_work_fn
+klp_start_transition
+klp_init_transition
+klp_reverse_transition
+klp_copy_process
+dma_get_merge_boundary
+dmam_match
+dma_map_sg_attrs
+dma_map_resource
+dma_get_sgtable_attrs
+dma_can_mmap
+dma_mmap_attrs
+dma_get_required_mask
+dma_alloc_attrs
+dmam_alloc_attrs
+dma_free_attrs
+dmam_release
+dma_alloc_pages
+dma_free_pages
+dma_supported
+dma_set_mask
+dma_set_coherent_mask
+dma_max_mapping_size
+dma_need_sync
+dma_map_page_attrs
+dma_unmap_resource
+dma_unmap_page_attrs
+dma_sync_single_for_device
+dma_unmap_sg_attrs
+dma_sync_sg_for_cpu
+dma_sync_sg_for_device
+dmam_free_coherent
+dma_alloc_noncoherent
+dma_free_noncoherent
+dma_sync_single_for_cpu
+dma_pgprot
+dma_direct_optimal_gfp_mask
+dma_direct_set_offset
+dma_coherent_ok
+dma_direct_alloc_from_pool
+__dma_direct_alloc_pages
+dma_direct_get_required_mask
+dma_direct_alloc
+dma_direct_free
+dma_direct_alloc_pages
+dma_direct_free_pages
+dma_direct_sync_sg_for_device
+dma_direct_sync_sg_for_cpu
+dma_direct_unmap_sg
+dma_direct_map_sg
+dma_direct_map_resource
+dma_direct_get_sgtable
+dma_direct_can_mmap
+dma_direct_mmap
+dma_direct_supported
+dma_direct_max_mapping_size
+dma_direct_need_sync
+dma_common_get_sgtable
+dma_common_mmap
+dma_common_alloc_pages
+dma_common_free_pages
+dma_dummy_mmap
+dma_dummy_map_page
+dma_dummy_map_sg
+dma_dummy_supported
+dma_virt_map_page
+dma_virt_alloc
+dma_virt_map_sg
+dma_virt_free
+__traceiter_swiotlb_bounced
+swiotlb_bounce
+swiotlb_nr_tbl
+swiotlb_max_segment
+swiotlb_set_max_segment
+swiotlb_size_or_default
+swiotlb_late_init_with_tbl
+swiotlb_late_init_with_default_size
+swiotlb_tbl_map_single
+swiotlb_tbl_unmap_single
+swiotlb_tbl_sync_single
+swiotlb_map
+swiotlb_max_mapping_size
+is_swiotlb_active
+atomic_pool_expand
+atomic_pool_resize
+atomic_pool_work_fn
+dma_alloc_from_pool
+dma_free_from_pool
+__traceiter_sys_enter
+__traceiter_sys_exit
+syscall_trace_enter.isra.0
+syscall_enter_from_user_mode_work
+syscall_enter_from_user_mode_work
+exit_to_user_mode_prepare
+irqentry_exit_cond_resched
+xfer_to_guest_mode_handle_work
+get_file_raw_ptr
+__x64_sys_kcmp
+__ia32_sys_kcmp
+freezing_slow_path
+__refrigerator
+set_freezable
+freeze_task
+__thaw_task
+__profile_flip_buffers
+profile_setup
+profile_online_cpu
+task_handoff_register
+task_handoff_unregister
+prof_cpu_mask_proc_write
+prof_cpu_mask_proc_open
+prof_cpu_mask_proc_show
+write_profile
+read_profile
+profile_dead_cpu
+profile_prepare_cpu
+do_profile_hits.isra.0
+profile_hits
+profile_event_register
+profile_event_unregister
+profile_task_exit
+profile_handoff_task
+profile_munmap
+profile_tick
+create_prof_cpu_mask
+stack_trace_save
+stack_trace_consume_entry
+stack_trace_consume_entry_nosched
+stack_trace_print
+stack_trace_snprint
+stack_trace_save_tsk
+stack_trace_save_regs
+stack_trace_save_tsk_reliable
+stack_trace_save_user
+jiffies_to_msecs
+jiffies_to_usecs
+mktime64
+__msecs_to_jiffies
+__usecs_to_jiffies
+jiffies64_to_nsecs
+jiffies64_to_msecs
+set_normalized_timespec64
+timespec64_to_jiffies
+put_timespec64
+put_itimerspec64
+put_old_itimerspec32
+__x64_sys_time
+__ia32_sys_time
+__x64_sys_time32
+__ia32_sys_time32
+__ia32_sys_stime
+__ia32_sys_stime32
+__ia32_sys_gettimeofday
+__ia32_compat_sys_gettimeofday
+get_timespec64
+get_itimerspec64
+get_old_itimerspec32
+__x64_sys_adjtimex
+__ia32_sys_adjtimex
+get_old_timespec32
+put_old_timespec32
+__x64_sys_stime32
+__x64_sys_stime
+nsecs_to_jiffies64
+nsecs_to_jiffies
+jiffies_64_to_clock_t
+jiffies_to_clock_t
+__x64_sys_gettimeofday
+__x32_compat_sys_gettimeofday
+jiffies_to_timespec64
+clock_t_to_jiffies
+ns_to_timespec64
+ns_to_kernel_old_timeval
+do_sys_settimeofday64
+__ia32_sys_settimeofday
+__ia32_compat_sys_settimeofday
+__x32_compat_sys_settimeofday
+__x64_sys_settimeofday
+get_old_timex32
+put_old_timex32
+__x64_sys_adjtimex_time32
+__ia32_sys_adjtimex_time32
+nsec_to_clock_t
+timespec64_add_safe
+__round_jiffies
+__round_jiffies_relative
+round_jiffies
+round_jiffies_relative
+__round_jiffies_up
+__round_jiffies_up_relative
+round_jiffies_up
+round_jiffies_up_relative
+__traceiter_timer_init
+__traceiter_timer_start
+__traceiter_timer_expire_entry
+__traceiter_timer_expire_exit
+__traceiter_timer_cancel
+__traceiter_hrtimer_init
+__traceiter_hrtimer_start
+__traceiter_hrtimer_expire_entry
+__traceiter_hrtimer_expire_exit
+__traceiter_hrtimer_cancel
+__traceiter_itimer_state
+__traceiter_itimer_expire
+__traceiter_tick_stop
+lock_timer_base
+detach_if_pending
+try_to_del_timer_sync
+timers_update_migration
+timer_update_keys
+init_timer_key
+del_timer_sync
+__next_timer_interrupt
+process_timeout
+enqueue_timer
+call_timer_fn
+del_timer
+run_timer_softirq
+calc_wheel_index
+internal_add_timer
+add_timer_on
+add_timer
+timer_reduce
+mod_timer_pending
+mod_timer
+msleep_interruptible
+msleep
+timers_update_nohz
+timer_migration_handler
+get_next_timer_interrupt
+timer_clear_idle
+run_local_timers
+update_process_times
+timers_prepare_cpu
+timers_dead_cpu
+ktime_add_safe
+clock_was_set_work
+lock_hrtimer_base
+__hrtimer_get_remaining
+hrtimer_active
+__next_base
+hrtimer_reprogram
+__hrtimer_next_event_base
+__hrtimer_get_next_event
+hrtimer_force_reprogram
+retrigger_next_event
+__remove_hrtimer
+hrtimer_update_softirq_timer
+enqueue_hrtimer
+hrtimer_forward
+__hrtimer_init
+hrtimer_init_sleeper
+hrtimer_wakeup
+hrtimer_try_to_cancel
+hrtimer_cancel
+__hrtimer_run_queues
+hrtimer_run_softirq
+hrtimer_init
+hrtimer_start_range_ns
+hrtimer_sleeper_start_expires
+clock_was_set_delayed
+clock_was_set
+hrtimers_resume
+hrtimer_get_next_event
+hrtimer_next_event_without
+hrtimer_interrupt
+hrtimer_run_queues
+nanosleep_copyout
+hrtimer_nanosleep
+__ia32_sys_nanosleep
+__ia32_sys_nanosleep_time32
+__x64_sys_nanosleep
+__x64_sys_nanosleep_time32
+hrtimers_prepare_cpu
+hrtimers_dead_cpu
+ktime_get_real_seconds
+ktime_get_seconds
+pvclock_gtod_register_notifier
+pvclock_gtod_unregister_notifier
+ktime_mono_to_any
+ktime_get_coarse_with_offset
+ktime_get_ts64
+scale64_check_overflow
+tk_set_wall_to_mono
+update_fast_timekeeper
+timekeeping_update
+getboottime64
+dummy_clock_read
+ktime_get_resolution_ns
+tk_setup_internals.constprop.0
+timekeeping_forward_now.constprop.0
+change_clocksource
+ktime_get_real_fast_ns
+ktime_get_mono_fast_ns
+ktime_get_raw_fast_ns
+ktime_get_coarse_real_ts64
+ktime_get_coarse_ts64
+ktime_get_snapshot
+tk_xtime_add.constprop.0
+__timekeeping_inject_sleeptime.constprop.0
+timekeeping_inject_offset
+do_settimeofday64
+get_device_system_crosststamp
+timekeeping_advance
+ktime_get
+ktime_get_raw
+ktime_get_raw_ts64
+ktime_get_with_offset
+ktime_get_real_ts64
+ktime_get_fast_timestamps
+timekeeping_warp_clock
+timekeeping_notify
+timekeeping_valid_for_hres
+timekeeping_max_deferment
+timekeeping_max_deferment
+timekeeping_resume
+timekeeping_suspend
+timekeeping_rtc_skipresume
+timekeeping_rtc_skipsuspend
+timekeeping_inject_sleeptime64
+update_wall_time
+do_timer
+ktime_get_update_offsets_now
+do_adjtimex
+xtime_update
+sched_sync_hw_clock.constprop.0
+ntp_update_frequency
+ntp_clear
+ntp_tick_length
+ntp_get_next_leap
+second_overflow
+second_overflow
+sync_hw_clock
+ntp_notify_cmos_timer
+__do_adjtimex
+clocksource_watchdog_work
+__clocksource_change_rating
+clocks_calc_mult_shift
+__clocksource_select
+clocksource_select_watchdog
+available_clocksource_show
+current_clocksource_show
+__clocksource_suspend_select.part.0
+clocksource_suspend_select
+clocksource_change_rating
+clocksource_unbind
+clocksource_unregister
+__clocksource_unstable
+clocksource_watchdog
+__clocksource_watchdog_kthread
+clocksource_watchdog_kthread
+clocksource_mark_unstable
+clocksource_start_suspend_timing
+clocksource_stop_suspend_timing
+clocksource_suspend
+clocksource_resume
+clocksource_touch_watchdog
+clocks_calc_max_nsecs
+__clocksource_update_freq_scale
+__clocksource_register_scale
+sysfs_get_uname
+unbind_clocksource_store
+current_clocksource_store
+jiffies_read
+register_refined_jiffies
+timer_list_stop
+SEQ_printf
+print_name_offset
+print_cpu
+print_tickdevice
+timer_list_show_tickdevices_header
+move_iter
+timer_list_next
+timer_list_start
+timer_list_show
+sysrq_timer_list_show
+math_div
+time64_to_tm
+timecounter_init
+timecounter_read
+timecounter_cyc2time
+alarmtimer_get_rtcdev
+alarm_timer_wait_running
+__traceiter_alarmtimer_suspend
+__traceiter_alarmtimer_fired
+__traceiter_alarmtimer_start
+__traceiter_alarmtimer_cancel
+alarm_expires_remaining
+alarm_timer_remaining
+alarm_clock_getres
+alarm_clock_get_timespec
+alarm_clock_get_ktime
+alarm_init
+alarmtimer_enqueue
+alarmtimer_fired
+alarm_start
+alarm_restart
+alarm_start_relative
+alarm_timer_arm
+alarm_try_to_cancel
+alarm_cancel
+alarm_timer_try_to_cancel
+alarm_forward
+alarm_forward_now
+alarm_timer_rearm
+alarm_timer_forward
+alarm_timer_create
+alarmtimer_nsleep_wakeup
+alarm_handle_timer
+alarmtimer_resume
+alarmtimer_suspend
+get_boottime_timespec
+alarmtimer_rtc_add_device
+alarmtimer_do_nsleep
+alarm_timer_nsleep
+common_timer_wait_running
+common_hrtimer_remaining
+posix_get_hrtimer_res
+common_timer_del
+__lock_timer
+__x64_sys_timer_getoverrun
+timer_wait_running
+common_timer_create
+common_hrtimer_forward
+posix_timer_fn
+common_hrtimer_arm
+common_hrtimer_rearm
+common_hrtimer_try_to_cancel
+common_nsleep
+posix_get_tai_ktime
+posix_get_boottime_ktime
+posix_get_realtime_ktime
+posix_get_tai_timespec
+posix_get_coarse_res
+common_timer_get
+common_nsleep_timens
+common_timer_set
+posix_get_boottime_timespec
+posix_get_monotonic_coarse
+posix_get_realtime_coarse
+posix_get_monotonic_ktime
+posix_clock_realtime_adj
+posix_get_realtime_timespec
+posix_clock_realtime_set
+k_itimer_rcu_free
+do_timer_gettime
+release_posix_timer
+__x64_sys_timer_delete
+__ia32_sys_timer_gettime
+__ia32_sys_timer_gettime32
+__ia32_sys_clock_settime
+__ia32_sys_clock_nanosleep
+__ia32_sys_clock_gettime
+__ia32_sys_clock_getres
+__ia32_sys_clock_settime32
+__ia32_sys_clock_nanosleep_time32
+__ia32_sys_clock_gettime32
+__ia32_sys_clock_getres_time32
+do_timer_settime.part.0
+__ia32_sys_timer_settime32
+__x64_sys_timer_gettime
+__x64_sys_timer_gettime32
+__ia32_sys_timer_settime
+__ia32_sys_timer_getoverrun
+do_timer_create
+__ia32_sys_timer_create
+__ia32_compat_sys_timer_create
+__x32_compat_sys_timer_create
+__x64_sys_timer_create
+posix_get_monotonic_timespec
+posix_get_monotonic_raw
+__x64_sys_timer_settime
+__x64_sys_timer_settime32
+__x64_sys_clock_gettime32
+__x64_sys_clock_gettime
+__x64_sys_clock_settime
+__x64_sys_clock_settime32
+__x64_sys_clock_getres_time32
+__x64_sys_clock_getres
+__x64_sys_clock_nanosleep
+__x64_sys_clock_nanosleep_time32
+__ia32_sys_timer_delete
+posixtimer_rearm
+posix_timer_event
+exit_itimers
+do_clock_adjtime
+__x64_sys_clock_adjtime
+__ia32_sys_clock_adjtime
+__x64_sys_clock_adjtime32
+__ia32_sys_clock_adjtime32
+cleanup_timers
+collect_posix_cputimers
+check_cpu_itimer
+bump_cpu_timer
+arm_timer
+posix_cpu_timer_del
+pid_for_clock
+check_rlimit
+cpu_clock_sample
+posix_cpu_timer_create
+process_cpu_timer_create
+thread_cpu_timer_create
+thread_cpu_clock_getres
+posix_cpu_clock_set
+posix_cpu_clock_getres
+process_cpu_clock_getres
+cpu_clock_sample_group
+posix_cpu_timer_rearm
+cpu_timer_fire
+posix_cpu_timers_work
+posix_cpu_timer_get
+posix_cpu_timer_set
+posix_cpu_clock_get
+process_cpu_clock_get
+thread_cpu_clock_get
+do_cpu_nanosleep
+posix_cpu_nsleep
+process_cpu_nsleep
+posix_cpu_nsleep_restart
+posix_cputimers_group_init
+thread_group_sample_cputime
+posix_cpu_timers_exit
+posix_cpu_timers_exit_group
+run_posix_cpu_timers
+set_process_cpu_timer
+update_rlimit_cpu
+posix_clock_register
+posix_clock_release
+posix_clock_unregister
+posix_clock_open
+get_posix_clock
+posix_clock_ioctl
+posix_clock_compat_ioctl
+posix_clock_poll
+posix_clock_read
+get_clock_desc
+pc_clock_adjtime
+pc_clock_gettime
+pc_clock_settime
+pc_clock_getres
+itimer_get_remtime
+put_itimerval
+put_old_itimerval32
+get_itimerval
+get_old_itimerval32
+get_cpu_itimer
+set_cpu_itimer
+do_setitimer
+alarm_setitimer
+__x64_sys_alarm
+__ia32_sys_alarm
+__ia32_sys_setitimer
+__ia32_compat_sys_setitimer
+__x64_sys_setitimer
+__x32_compat_sys_setitimer
+do_getitimer
+__ia32_sys_getitimer
+__ia32_compat_sys_getitimer
+__x32_compat_sys_getitimer
+__x64_sys_getitimer
+it_real_fn
+clear_itimer
+clockevents_unbind_device
+cev_delta2ns
+clockevent_delta2ns
+clockevents_program_min_delta
+clockevents_register_device
+__clockevents_try_unbind
+clockevents_config.part.0
+clockevents_config_and_register
+sysfs_unbind_tick_dev
+__clockevents_unbind
+sysfs_show_current_tick_dev
+clockevents_switch_state
+clockevents_shutdown
+clockevents_tick_resume
+clockevents_program_event
+__clockevents_update_freq
+clockevents_update_freq
+clockevents_handle_noop
+clockevents_exchange_device
+clockevents_suspend
+clockevents_resume
+tick_offline_cpu
+tick_cleanup_dead_cpu
+tick_periodic
+tick_handle_periodic
+tick_broadcast_oneshot_control
+tick_check_percpu
+tick_check_preferred
+tick_get_device
+tick_is_oneshot_available
+tick_setup_periodic
+tick_setup_device
+tick_install_replacement
+tick_check_replacement
+tick_check_new_device
+tick_handover_do_timer
+tick_shutdown
+tick_suspend_local
+tick_resume_local
+tick_suspend
+tick_resume
+tick_freeze
+tick_unfreeze
+tick_broadcast_set_event
+tick_device_setup_broadcast_func
+err_broadcast
+tick_broadcast_clear_oneshot
+tick_broadcast_setup_oneshot
+tick_do_broadcast
+tick_handle_periodic_broadcast
+tick_handle_oneshot_broadcast
+tick_broadcast_control
+tick_get_broadcast_device
+tick_get_broadcast_mask
+tick_install_broadcast_device
+tick_is_broadcast_device
+tick_broadcast_update_freq
+tick_device_uses_broadcast
+tick_receive_broadcast
+tick_set_periodic_handler
+tick_broadcast_offline
+tick_suspend_broadcast
+tick_resume_check_broadcast
+tick_resume_broadcast
+tick_get_broadcast_oneshot_mask
+tick_check_broadcast_expired
+tick_check_oneshot_broadcast_this_cpu
+__tick_broadcast_oneshot_control
+tick_broadcast_switch_to_oneshot
+hotplug_cpu__broadcast_tick_pull
+tick_broadcast_oneshot_active
+tick_broadcast_oneshot_available
+bc_handler
+bc_shutdown
+bc_set_next
+tick_setup_hrtimer_broadcast
+tick_program_event
+tick_resume_oneshot
+tick_setup_oneshot
+tick_switch_to_oneshot
+tick_oneshot_mode_active
+tick_init_highres
+tick_nohz_next_event
+tick_sched_handle
+can_stop_idle_tick
+tick_init_jiffy_update
+update_ts_time_stats
+get_cpu_idle_time_us
+get_cpu_iowait_time_us
+tick_do_update_jiffies64.part.0
+tick_sched_do_timer
+tick_sched_timer
+tick_nohz_handler
+__tick_nohz_idle_restart_tick
+tick_get_tick_sched
+tick_nohz_tick_stopped
+tick_nohz_tick_stopped_cpu
+tick_nohz_idle_stop_tick
+tick_nohz_idle_retain_tick
+tick_nohz_idle_enter
+tick_nohz_irq_exit
+tick_nohz_idle_got_tick
+tick_nohz_get_next_hrtimer
+tick_nohz_get_sleep_length
+tick_nohz_get_idle_calls_cpu
+tick_nohz_get_idle_calls
+tick_nohz_idle_restart_tick
+tick_nohz_idle_exit
+tick_irq_enter
+tick_setup_sched_timer
+tick_cancel_sched_timer
+tick_clock_notify
+tick_oneshot_notify
+tick_check_oneshot_change
+update_vsyscall
+update_vsyscall_tz
+vdso_update_begin
+vdso_update_end
+tk_debug_sleep_time_show
+tk_debug_sleep_time_open
+tk_debug_account_sleep_time
+timens_owner
+timens_set_vvar_page.isra.0
+timens_for_children_get
+timens_get
+do_timens_ktime_to_host
+copy_time_ns
+free_time_ns
+timens_put
+timens_install
+timens_commit
+timens_on_fork
+proc_timens_show_offsets
+proc_timens_set_offset
+cmpxchg_futex_value_locked
+__x64_sys_set_robust_list
+__ia32_sys_set_robust_list
+__ia32_compat_sys_set_robust_list
+__x32_compat_sys_set_robust_list
+__ia32_sys_get_robust_list
+__ia32_compat_sys_get_robust_list
+fault_in_user_writeable
+__unqueue_futex
+handle_exit_race.part.0
+refill_pi_state_cache.part.0
+hash_futex
+mark_wake_futex
+get_pi_state
+futex_top_waiter
+__x32_compat_sys_get_robust_list
+__x64_sys_get_robust_list
+wait_for_owner_exiting
+get_futex_key
+futex_wait_queue_me
+futex_wake
+handle_futex_death.part.0
+put_pi_state
+unqueue_me_pi
+fixup_pi_state_owner
+fixup_owner
+attach_to_pi_state
+futex_cleanup
+attach_to_pi_owner
+futex_lock_pi_atomic
+futex_wait_setup
+futex_wait
+futex_wait_restart
+futex_wait_requeue_pi.constprop.0
+futex_requeue
+futex_lock_pi
+futex_exit_recursive
+futex_exec_release
+futex_exit_release
+do_futex
+__ia32_sys_futex
+__ia32_sys_futex_time32
+__x64_sys_futex_time32
+__x64_sys_futex
+request_dma
+free_dma
+proc_dma_show
+do_nothing
+wake_up_all_idle_cpus
+smp_call_on_cpu_callback
+smp_call_on_cpu
+flush_smp_call_function_queue
+smpcfd_prepare_cpu
+smpcfd_dead_cpu
+smpcfd_dying_cpu
+__smp_call_single_queue
+generic_exec_single
+smp_call_function_single
+smp_call_function_any
+smp_call_function_many_cond
+smp_call_function_many
+smp_call_function
+on_each_cpu
+kick_all_cpus_sync
+on_each_cpu_mask
+on_each_cpu_cond_mask
+on_each_cpu_cond
+smp_call_function_single_async
+generic_smp_call_function_single_interrupt
+flush_smp_call_function_from_idle
+flush_smp_call_function_from_idle
+__x64_sys_chown16
+__ia32_sys_chown16
+__x64_sys_lchown16
+__ia32_sys_lchown16
+__x64_sys_fchown16
+__ia32_sys_fchown16
+__x64_sys_setregid16
+__ia32_sys_setregid16
+__x64_sys_setgid16
+__ia32_sys_setgid16
+__x64_sys_setreuid16
+__ia32_sys_setreuid16
+__x64_sys_setuid16
+__ia32_sys_setuid16
+__x64_sys_setresuid16
+__ia32_sys_setresuid16
+__ia32_sys_getresuid16
+__x64_sys_setresgid16
+__ia32_sys_setresgid16
+__ia32_sys_getresgid16
+groups16_to_user
+__ia32_sys_getgroups16
+__x64_sys_setfsuid16
+__ia32_sys_setfsuid16
+__x64_sys_setfsgid16
+__ia32_sys_setfsgid16
+groups16_from_user
+__ia32_sys_setgroups16
+__do_sys_getuid16
+__do_sys_geteuid16
+__do_sys_getgid16
+__do_sys_getegid16
+__x64_sys_getgroups16
+__x64_sys_setgroups16
+__x64_sys_getresuid16
+__x64_sys_getresgid16
+module_layout
+module_refcount
+__traceiter_module_load
+__traceiter_module_free
+__traceiter_module_get
+__traceiter_module_put
+__traceiter_module_request
+modinfo_version_exists
+modinfo_srcversion_exists
+is_core_symbol
+module_notes_read
+register_module_notifier
+unregister_module_notifier
+find_module_all
+find_module
+m_stop
+try_release_module_ref
+frob_rodata
+frob_ro_after_init
+finished_loading
+free_sect_attrs
+free_modinfo_srcversion
+free_modinfo_version
+del_usage_links
+module_remove_modinfo_attrs
+free_notes_attrs
+mod_kobject_put
+mod_sysfs_teardown
+cmp_name
+find_sec
+find_kallsyms_symbol_value
+store_uevent
+get_next_modinfo
+section_objs
+show_refcnt
+show_initsize
+show_coresize
+setup_modinfo_srcversion
+setup_modinfo_version
+show_modinfo_srcversion
+show_modinfo_version
+module_sect_read
+find_kallsyms_symbol
+m_next
+m_start
+is_module_sig_enforced
+module_flags_taint
+show_taint
+module_flags
+m_show
+find_exported_symbol_in_section
+try_module_get
+module_put
+__module_put_and_exit
+module_unload_free
+frob_text
+unknown_module_param_cb
+show_initstate
+modules_open
+check_version.isra.0
+module_enable_ro
+frob_writable_data.constprop.0
+each_symbol_section.constprop.0
+find_symbol
+__symbol_put
+resolve_symbol
+__mod_tree_remove
+__mod_tree_insert
+__symbol_get
+__module_get
+mod_sysfs_setup
+set_module_sig_enforced
+__is_module_percpu_address
+is_module_percpu_address
+module_memfree
+do_free_init
+do_free_init
+module_arch_freeing_init
+free_module
+__ia32_sys_delete_module
+__x64_sys_delete_module
+do_init_module
+arch_mod_section_prepend
+get_offset
+get_offset
+module_init_section
+module_exit_section
+module_frob_arch_sections
+module_frob_arch_sections
+load_module
+__x64_sys_init_module
+__ia32_sys_init_module
+__x64_sys_finit_module
+__ia32_sys_finit_module
+dereference_module_function_descriptor
+lookup_module_symbol_name
+lookup_module_symbol_attrs
+module_get_kallsym
+module_kallsyms_lookup_name
+module_kallsyms_on_each_symbol
+__module_address
+module_address_lookup
+search_module_extables
+is_module_address
+__module_text_address
+symbol_put_addr
+is_module_text_address
+mod_verify_sig
+mod_check_sig
+s_stop
+get_symbol_pos
+s_show
+reset_iter
+kallsyms_expand_symbol.constprop.0
+kallsyms_lookup_name
+kallsyms_on_each_symbol
+kallsyms_lookup_size_offset
+kallsyms_lookup
+__sprint_symbol
+sprint_symbol
+sprint_symbol_no_offset
+lookup_symbol_name
+lookup_symbol_attrs
+sprint_backtrace
+arch_get_kallsym
+update_iter
+s_next
+s_start
+kallsyms_show_value
+kallsyms_open
+kdb_walk_kallsyms
+close_work
+check_free_space
+acct_put
+acct_on
+__ia32_sys_acct
+do_acct_process
+acct_pin_kill
+__x64_sys_acct
+acct_exit_ns
+acct_collect
+acct_process
+acct_process
+append_elf_note
+final_note
+update_vmcoreinfo_note
+crash_update_vmcoreinfo_safecopy
+vmcoreinfo_append_str
+crash_save_vmcoreinfo
+crash_save_vmcoreinfo
+kexec_crash_loaded
+kimage_free_pages
+kimage_alloc_pages
+kimage_alloc_page
+kimage_add_entry
+__crash_kexec
+kexec_should_crash
+sanity_check_segment_list
+do_kimage_alloc_init
+kimage_is_destination_range
+kimage_free_page_list
+kimage_alloc_control_pages
+kimage_crash_copy_vmcoreinfo
+machine_kexec_post_load
+kimage_terminate
+kimage_free
+kimage_load_segment
+crash_kexec
+crash_get_memory_size
+crash_free_reserved_phys_range
+crash_shrink_memory
+crash_save_cpu
+kernel_kexec
+kernel_kexec
+kernel_kexec
+do_kexec_load
+__ia32_compat_sys_kexec_load
+__x64_sys_kexec_load
+__ia32_sys_kexec_load
+__x32_compat_sys_kexec_load
+kexec_purgatory_find_symbol
+locate_mem_hole_callback
+kexec_walk_resources.constprop.0
+kexec_image_probe_default
+arch_kexec_kernel_image_probe
+arch_kexec_kernel_image_probe
+kexec_image_post_load_cleanup_default
+arch_kimage_file_post_load_cleanup
+arch_kexec_kernel_verify_sig
+kimage_file_post_load_cleanup
+kimage_file_alloc_init
+kexec_locate_mem_hole
+arch_kexec_locate_mem_hole
+kexec_add_buffer
+kexec_load_purgatory
+kexec_purgatory_get_symbol_addr
+kexec_purgatory_get_set_symbol
+kexec_calculate_store_digests
+__ia32_sys_kexec_file_load
+__x64_sys_kexec_file_load
+crash_exclude_mem_range
+crash_prepare_elf64_headers
+__ia32_compat_sys_sigprocmask
+get_compat_sigset
+compat_alloc_user_space
+__x32_compat_sys_sigprocmask
+put_compat_rusage
+get_compat_sigevent
+compat_get_bitmap
+compat_get_user_cpu_mask
+__ia32_compat_sys_sched_setaffinity
+__x32_compat_sys_sched_setaffinity
+compat_put_bitmap
+__ia32_compat_sys_sched_getaffinity
+__x32_compat_sys_sched_getaffinity
+__traceiter_cgroup_setup_root
+__traceiter_cgroup_destroy_root
+__traceiter_cgroup_remount
+__traceiter_cgroup_mkdir
+__traceiter_cgroup_rmdir
+__traceiter_cgroup_release
+__traceiter_cgroup_rename
+__traceiter_cgroup_freeze
+__traceiter_cgroup_unfreeze
+__traceiter_cgroup_attach_task
+__traceiter_cgroup_transfer_tasks
+__traceiter_cgroup_notify_populated
+__traceiter_cgroup_notify_frozen
+of_css
+cgroup_file_open
+cgroup_file_release
+cgroup_seqfile_start
+cgroup_seqfile_next
+cgroup_seqfile_stop
+css_set_skip_task_iters
+online_css
+cgroup_control
+free_cgrp_cset_links
+cgroup_exit_cftypes
+css_visible
+css_release
+cgroup_pressure_release
+cgroup_cpu_pressure_show
+cgroup_memory_pressure_show
+cgroup_io_pressure_show
+cgroup_pressure_poll
+cgroup_stat_show
+cgroup_events_show
+cgroup_seqfile_show
+cgroup_max_depth_show
+cgroup_max_descendants_show
+cgroup_show_options
+cgroup_print_ss_mask
+cgroup_subtree_control_show
+cgroup_controllers_show
+cgroup_may_write
+cgroup_procs_show
+features_show
+show_delegatable_files
+delegate_show
+cgroup_file_name
+cgroup_kn_set_ugid
+init_cgroup_housekeeping
+cgroup2_parse_param
+cgroup_file_poll
+cgroup_file_write
+cgroup_init_cftypes
+cgroup_freeze_show
+apply_cgroup_root_flags
+cgroup_reconfigure
+cgroup_migrate_add_task.part.0
+cset_cgroup_from_root
+css_killed_ref_fn
+cgroup_can_be_thread_root
+css_next_descendant_post.part.0
+cgroup_idr_alloc.constprop.0
+allocate_cgrp_cset_links
+cgroup_fs_context_free
+cgroup_get_live
+cgroup_get_from_path
+link_css_set
+css_killed_work_fn
+cgroup_init_fs_context
+cpuset_init_fs_context
+init_and_link_css
+cgroup_show_path
+cgroup_kill_sb
+cpu_stat_show
+cgroup_addrm_files
+css_clear_dir
+kill_css
+css_populate_dir
+css_release_work_fn
+cgroup_ssid_enabled
+cgroup_on_dfl
+cgroup_is_threaded
+cgroup_is_thread_root
+cgroup_is_valid_domain.part.0
+cgroup_migrate_vet_dst.part.0
+cgroup_attach_permissions
+cgroup_type_show
+cgroup_e_css
+cgroup_get_e_css
+__cgroup_task_count
+cgroup_task_count
+put_css_set_locked
+find_css_set
+css_task_iter_advance_css_set
+css_task_iter_advance
+cgroup_css_set_put_fork
+cgroup_root_from_kf
+cgroup_free_root
+task_cgroup_from_root
+cgroup_kn_unlock
+init_cgroup_root
+cgroup_do_get_tree
+cgroup_get_tree
+cgroup_path_ns_locked
+cgroup_path_ns
+task_cgroup_path
+cgroup_taskset_next
+cgroup_taskset_first
+cgroup_migrate_vet_dst
+cgroup_migrate_finish
+cgroup_migrate_add_src
+cgroup_migrate_prepare_dst
+cgroup_procs_write_start
+cgroup_procs_write_finish
+cgroup_file_notify
+cgroup_file_notify_timer
+cgroup_update_populated
+css_set_move_task
+cgroup_migrate_execute
+cgroup_migrate
+cgroup_attach_task
+css_next_child
+css_next_descendant_pre
+cgroup_propagate_control
+cgroup_save_control
+cgroup_apply_control_enable
+cgroup_update_dfl_csses
+cgroup_apply_control
+cgroup_apply_cftypes
+cgroup_rm_cftypes_locked
+cgroup_rm_cftypes
+cgroup_add_cftypes
+cgroup_add_dfl_cftypes
+cgroup_add_legacy_cftypes
+css_rightmost_descendant
+css_next_descendant_post
+cgroup_apply_control_disable
+cgroup_finalize_control
+rebind_subsystems
+cgroup_setup_root
+cgroup_lock_and_drain_offline
+cgroup_kn_lock_live
+cgroup_pressure_write
+cgroup_cpu_pressure_write
+cgroup_memory_pressure_write
+cgroup_io_pressure_write
+cgroup_freeze_write
+cgroup_max_depth_write
+cgroup_max_descendants_write
+cgroup_subtree_control_write
+cgroup_threads_write
+cgroup_procs_write
+cgroup_type_write
+css_free_rwork_fn
+css_has_online_children
+cgroup_destroy_locked
+cgroup_mkdir
+cgroup_rmdir
+css_task_iter_start
+css_task_iter_next
+cgroup_procs_next
+css_task_iter_end
+__cgroup_procs_start
+cgroup_threads_start
+cgroup_procs_start
+cgroup_procs_release
+cgroup_path_from_kernfs_id
+proc_cgroup_show
+cgroup_fork
+cgroup_cancel_fork
+cgroup_post_fork
+cgroup_exit
+cgroup_release
+cgroup_free
+css_tryget_online_from_dir
+cgroup_get_from_file
+cgroup_can_fork
+cgroup_get_from_fd
+css_from_id
+cgroup_parse_float
+cgroup_sk_alloc_disable
+cgroup_sk_alloc
+cgroup_sk_clone
+cgroup_sk_free
+cgroup_bpf_attach
+cgroup_bpf_detach
+cgroup_bpf_query
+root_cgroup_cputime
+cgroup_rstat_flush_locked
+cgroup_rstat_updated
+cgroup_rstat_flush
+cgroup_rstat_flush_irqsafe
+cgroup_rstat_flush_hold
+cgroup_rstat_flush_release
+cgroup_rstat_init
+cgroup_rstat_exit
+__cgroup_account_cputime
+__cgroup_account_cputime_field
+cgroup_base_stat_cputime_show
+cgroupns_owner
+free_cgroup_ns
+cgroupns_put
+cgroupns_get
+cgroupns_install
+copy_cgroup_ns
+cmppid
+cgroup_pidlist_next
+cgroup_read_notify_on_release
+cgroup_clone_children_read
+cgroup_sane_behavior_show
+cgroup_pidlist_stop
+cgroup_pidlist_find
+cgroup_pidlist_destroy_work_fn
+cgroup_pidlist_show
+check_cgroupfs_options
+cgroup_write_notify_on_release
+cgroup_clone_children_write
+__cgroup1_procs_write.constprop.0
+cgroup1_procs_write
+cgroup1_tasks_write
+cgroup1_rename
+pidlist_array_load
+cgroup_pidlist_start
+cgroup_attach_task_all
+cgroup_release_agent_show
+cgroup1_show_options
+cgroup_release_agent_write
+cgroup1_ssid_disabled
+cgroup_transfer_tasks
+cgroup1_pidlist_destroy_all
+proc_cgroupstats_show
+cgroupstats_build
+cgroup1_check_for_release
+cgroup1_release_agent
+cgroup1_parse_param
+cgroup1_reconfigure
+cgroup1_get_tree
+cgroup_freeze_task
+cgroup_dec_frozen_cnt.part.0
+cgroup_update_frozen
+cgroup_do_freeze
+cgroup_enter_frozen
+cgroup_leave_frozen
+cgroup_freezer_migrate_task
+cgroup_freeze
+freeze_cgroup
+unfreeze_cgroup
+freezer_css_free
+freezer_self_freezing_read
+freezer_parent_freezing_read
+freezer_css_offline
+freezer_css_online
+freezer_apply_state
+update_if_frozen
+freezer_attach
+freezer_fork
+freezer_css_alloc
+freezer_read
+freezer_write
+cgroup_freezing
+pids_css_free
+pids_current_read
+pids_max_write
+pids_events_show
+pids_max_show
+pids_cancel.constprop.0
+pids_can_fork
+pids_cancel_fork
+pids_can_attach
+pids_cancel_attach
+pids_release
+pids_css_alloc
+rdmacg_css_free
+rdmacg_register_device
+free_cg_rpool_locked
+rdmacg_css_offline
+rdmacg_unregister_device
+rdmacg_resource_read
+get_cg_rpool_locked
+rdmacg_resource_set_max
+rdmacg_uncharge_hierarchy
+rdmacg_uncharge
+rdmacg_try_charge
+rdmacg_css_alloc
+update_tasks_root_domain
+fmeter_update
+cpuset_read_u64
+cpuset_post_attach
+cpuset_migrate_mm_workfn
+cpuset_track_online_nodes
+update_tasks_cpumask
+sched_partition_show
+cpuset_cancel_attach
+cpuset_mem_spread_node
+cpuset_update_task_spread_flag
+update_tasks_flags
+cpuset_read_s64
+cpuset_fork
+cpuset_migrate_mm
+cpuset_css_free
+cpuset_change_task_nodemask
+is_cpuset_subset
+guarantee_online_mems
+update_tasks_nodemask
+cpuset_css_alloc
+update_domain_attr_tree
+compute_effective_cpumask
+guarantee_online_cpus
+alloc_trial_cpuset
+cpuset_can_attach
+cpuset_common_seq_show
+cpuset_bind
+cpuset_attach
+validate_change
+cpuset_css_online
+update_parent_subparts_cpumask
+rebuild_sched_domains_locked
+cpuset_write_s64
+update_flag
+cpuset_write_u64
+update_cpumasks_hier
+update_sibling_cpumasks
+cpuset_write_resmask
+update_prstate
+sched_partition_write
+cpuset_css_offline
+cpuset_read_lock
+cpuset_read_unlock
+rebuild_sched_domains
+cpuset_hotplug_workfn
+current_cpuset_is_being_rebound
+cpuset_force_rebuild
+cpuset_update_active_cpus
+cpuset_wait_for_hotplug
+cpuset_cpus_allowed
+cpuset_cpus_allowed_fallback
+cpuset_mems_allowed
+cpuset_nodemask_valid_mems_allowed
+__cpuset_node_allowed
+cpuset_slab_spread_node
+cpuset_mems_allowed_intersects
+cpuset_print_current_mems_allowed
+__cpuset_memory_pressure_bump
+proc_cpuset_show
+cpuset_task_status_allowed
+utsns_owner
+utsns_get
+free_uts_ns
+copy_utsname
+utsns_put
+utsns_install
+m_stop
+__put_user_ns
+uid_m_start
+gid_m_start
+projid_m_start
+m_next
+cmp_extents_forward
+cmp_extents_reverse
+ns_get_owner
+userns_owner
+free_user_ns
+map_id_range_down
+make_kuid
+make_kgid
+make_kprojid
+map_id_up
+from_kuid
+from_kuid_munged
+from_kgid
+from_kgid_munged
+from_kprojid
+from_kprojid_munged
+uid_m_show
+gid_m_show
+projid_m_show
+current_in_userns
+userns_get
+cmp_map_id
+userns_install
+map_write
+userns_put
+create_user_ns
+unshare_userns
+proc_uid_map_write
+proc_gid_map_write
+proc_projid_map_write
+proc_setgroups_show
+proc_setgroups_write
+userns_may_setgroups
+in_userns
+pidns_owner
+delayed_free_pidns
+pid_ns_ctl_handler
+put_pid_ns
+pidns_put
+pidns_get
+pidns_install
+pidns_get_parent
+pidns_for_children_get
+copy_pid_ns
+zap_pid_ns_processes
+reboot_pid_ns
+cpu_stop_should_run
+cpu_stop_init_done
+cpu_stop_signal_done
+cpu_stop_create
+cpu_stop_queue_work
+cpu_stop_park
+queue_stop_cpus_work.constprop.0
+cpu_stopper_thread
+stop_one_cpu
+multi_cpu_stop
+stop_two_cpus
+stop_one_cpu_nowait
+stop_machine_park
+stop_machine_unpark
+stop_machine_cpuslocked
+stop_machine
+stop_machine_from_inactive_cpu
+audit_get_sk
+kauditd_send_multicast_skb
+kauditd_retry_skb
+kauditd_rehold_skb
+audit_net_exit
+auditd_pid_vnr
+auditd_conn_free
+audit_free_reply.part.0
+audit_send_reply_thread
+kauditd_send_queue
+auditd_test_task
+audit_ctl_lock
+audit_ctl_unlock
+audit_panic
+audit_net_init
+audit_log_lost
+kauditd_hold_skb
+auditd_reset
+kauditd_thread
+audit_log_end
+audit_log_vformat
+audit_log_format
+audit_log_task_context
+audit_log_start
+audit_log
+audit_send_list_thread
+audit_make_reply
+audit_send_reply.constprop.0
+is_audit_feature_set
+audit_serial
+audit_log_n_hex
+audit_log_n_string
+audit_string_contains_control
+audit_log_n_untrustedstring
+audit_log_untrustedstring
+audit_log_d_path
+audit_log_session_info
+audit_log_config_change
+audit_do_config_change
+audit_set_enabled
+audit_log_common_recv_msg
+audit_log_key
+audit_log_d_path_exe
+audit_get_tty
+audit_log_multicast
+audit_multicast_unbind
+audit_multicast_bind
+audit_log_task_info.part.0
+audit_log_task_info
+audit_log_feature_change.part.0
+audit_receive_msg
+audit_receive
+audit_put_tty
+audit_log_path_denied
+audit_set_loginuid
+audit_signal_info
+audit_compare_rule
+audit_match_signal
+audit_find_rule
+audit_log_rule_change.part.0
+audit_free_rule_rcu
+audit_unpack_string
+audit_data_to_entry
+audit_match_class
+audit_dupe_rule
+audit_del_rule
+audit_rule_change
+audit_list_rules_send
+audit_comparator
+audit_uid_comparator
+audit_gid_comparator
+parent_len
+audit_compare_dname_path
+audit_filter
+audit_update_lsm_rules
+audit_log_pid_context
+audit_compare_uid
+audit_compare_gid
+audit_log_execve_info
+unroll_tree_refs
+audit_copy_inode
+audit_log_ntp_val
+__audit_log_nfcfg
+audit_log_task
+audit_in_mask.part.0
+audit_log_cap
+audit_log_exit
+audit_filter_rules.constprop.0
+audit_filter_syscall.constprop.0
+grow_tree_refs
+audit_alloc_name
+__audit_inode_child
+audit_filter_inodes
+audit_alloc
+__audit_free
+__audit_syscall_entry
+__audit_syscall_exit
+__audit_reusename
+__audit_getcwd
+__audit_getname
+__audit_inode
+__audit_file
+auditsc_get_stamp
+__audit_mq_open
+__audit_mq_sendrecv
+__audit_mq_notify
+__audit_mq_getsetattr
+__audit_ipc_obj
+__audit_ipc_set_perm
+__audit_bprm
+__audit_socketcall
+__audit_fd_pair
+__audit_sockaddr
+__audit_ptrace
+audit_signal_info_syscall
+__audit_log_bprm_fcaps
+__audit_log_capset
+__audit_mmap_fd
+__audit_log_kern_module
+__audit_fanotify
+__audit_tk_injoffset
+__audit_ntp_log
+audit_core_dumps
+audit_seccomp
+audit_seccomp_actions_logged
+audit_killed_trees
+audit_free_parent
+audit_watch_free_mark
+audit_init_watch
+audit_get_watch
+audit_put_watch
+audit_remove_watch
+audit_update_watch
+audit_watch_handle_event
+audit_watch_path
+audit_watch_compare
+audit_to_watch
+audit_add_watch
+audit_remove_watch_rule
+audit_dupe_exe
+audit_exe_compare
+audit_fsnotify_free_mark
+audit_mark_handle_event
+audit_mark_path
+audit_mark_compare
+audit_alloc_mark
+audit_remove_mark
+audit_remove_mark_rule
+audit_tree_handle_event
+compare_root
+kill_rules
+audit_tree_destroy_watch
+replace_mark_chunk.part.0
+replace_mark_chunk
+replace_chunk
+audit_tree_freeing_mark
+alloc_chunk
+prune_tree_chunks
+trim_marked
+prune_tree_thread
+tag_mount
+audit_tree_path
+audit_put_chunk
+__put_chunk
+audit_tree_lookup
+audit_tree_match
+audit_remove_tree_rule
+audit_trim_trees
+audit_make_tree
+audit_put_tree
+audit_add_tree_rule
+audit_tag_tree
+audit_kill_trees
+kprobe_exceptions_notify
+kprobe_seq_stop
+kprobe_seq_stop
+kprobe_seq_stop
+kprobe_blacklist_seq_stop
+get_kprobe
+aggr_fault_handler
+kretprobe_hash_lock
+kretprobe_table_lock
+kretprobe_hash_unlock
+kretprobe_table_unlock
+kprobe_seq_start
+kprobe_seq_next
+opt_pre_handler
+aggr_pre_handler
+aggr_post_handler
+__get_valid_kprobe
+kprobe_remove_area_blacklist
+__unregister_kprobe_bottom
+get_optimized_kprobe
+pre_handler_kretprobe
+report_probe
+kprobe_blacklist_seq_next
+kprobe_blacklist_seq_start
+show_kprobe_addr
+__disarm_kprobe_ftrace
+read_enabled_file_bool
+kprobes_inc_nmissed_count
+collect_one_slot.part.0
+collect_garbage_slots
+recycle_rp_inst
+__kretprobe_trampoline_handler
+kprobe_flush_task
+kprobe_blacklist_open
+kprobe_blacklist_seq_show
+optimize_kprobe
+__within_kprobe_blacklist.part.0
+alloc_aggr_kprobe
+kprobes_open
+unoptimize_kprobe
+arm_kprobe
+enable_kprobe
+disarm_kprobe
+__disable_kprobe
+disable_kprobe
+__unregister_kprobe_top
+unregister_kprobes.part.0
+unregister_kprobes
+unregister_kprobe
+kprobe_optimizer
+kill_kprobe
+init_aggr_kprobe
+cleanup_rp_inst
+unregister_kretprobes.part.0
+unregister_kretprobes
+unregister_kretprobe
+kprobe_lookup_name
+kprobe_addr
+__get_insn_slot
+__free_insn_slot
+__is_insn_slot_addr
+kprobe_cache_get_kallsym
+wait_for_kprobe_optimizer
+write_enabled_file_bool
+proc_kprobes_optimization_handler
+kprobe_busy_begin
+kprobe_busy_end
+arch_within_kprobe_blacklist
+within_kprobe_blacklist.part.0
+within_kprobe_blacklist
+arch_check_ftrace_location
+register_kprobe
+register_kprobes
+arch_deref_entry_point
+arch_kprobe_on_func_entry
+kprobe_on_func_entry
+register_kretprobe
+register_kretprobes
+kprobe_add_ksym_blacklist
+kprobes_module_callback
+kprobe_add_area_blacklist
+arch_kprobe_get_kallsym
+kprobe_get_kallsym
+kprobe_free_init_mem
+kprobe_free_init_mem
+module_event
+kgdb_breakpoint
+kgdb_tasklet_bpt
+sysrq_handle_dbg
+dbg_touch_watchdogs
+dbg_touch_watchdogs
+dbg_touch_watchdogs
+dbg_touch_watchdogs
+dbg_touch_watchdogs
+kgdb_io_ready
+kgdb_flush_swbreak_addr.part.0
+kgdb_flush_swbreak_addr
+dbg_activate_sw_breakpoints
+dbg_deactivate_sw_breakpoints
+dbg_notify_reboot
+kgdb_schedule_breakpoint
+kgdb_console_write
+kgdb_unregister_io_module
+kgdb_cpu_enter
+kgdb_nmicallback
+kgdb_call_nmi_hook
+kgdb_nmicallin
+kgdb_validate_break_address
+kgdb_validate_break_address
+dbg_set_sw_break
+dbg_remove_sw_break
+kgdb_isremovedbreak
+kgdb_has_hit_break
+dbg_remove_all_break
+kgdb_reenter_check.part.0
+kgdb_reenter_check
+kgdb_handle_exception
+kdb_dump_stack_on_cpu
+kgdb_panic
+kgdb_panic
+kgdb_register_io_module
+dbg_io_get_char
+pack_threadid
+gdbstub_read_wait
+put_packet
+gdb_get_regs_helper
+gdb_cmd_detachkill.isra.0
+getthread.isra.0
+gdbstub_msg_write
+kgdb_mem2hex
+kgdb_hex2mem
+kgdb_hex2long
+write_mem_msg
+pt_regs_to_gdb_regs
+gdb_regs_to_pt_regs
+gdb_serial_stub
+gdbstub_state
+gdbstub_exit
+kdb_input_flush
+kdb_msg_write.part.0
+kdb_getchar
+vkdb_printf
+kdb_printf
+kdb_getstr
+kdb_kgdb
+kdb_unregister
+kdb_grep_help
+kdb_help
+kdb_env
+kdb_set
+kdb_param_enable_nmi
+kdb_register_flags
+kdb_register
+kdb_md_line
+kdb_kill
+kdb_sr
+kdb_lsmod
+kdb_reboot
+kdb_defcmd2
+kdb_defcmd
+kdb_disable_nmi
+kdb_rd
+kdb_summary
+kdb_curr_task
+kdbgetenv
+kdbgetulenv
+kdb_dmesg
+kdbgetintenv
+kdbgetularg
+kdb_pid
+kdb_cpu
+kdbgetu64arg
+kdb_rm
+kdbgetaddrarg
+kdb_per_cpu
+kdb_ef
+kdb_go
+kdb_mm
+kdb_md
+kdb_parse
+kdb_exec_defcmd
+kdb_print_state
+kdb_main_loop
+kdb_ps_suppressed
+kdb_ps1
+kdb_ps
+kdb_getphys
+get_dap_lock
+kdbgetsymval
+kallsyms_symbol_complete
+kallsyms_symbol_next
+kdb_strdup
+kdb_getarea_size
+kdb_putarea_size
+kdb_getphysword
+kdb_getword
+kdb_putword
+kdb_task_state_string
+kdb_task_state_char
+kdb_task_state
+debug_kmalloc
+debug_kfree
+kdbnearsym
+kdb_symbol_print
+kdb_print_nameval
+kdbnearsym_cleanup
+debug_kusage
+kdb_save_flags
+kdb_restore_flags
+kdb_show_stack
+kdb_bt1
+kdb_bt_cpu
+kdb_bt
+kdb_bc
+kdb_printbp
+kdb_bp
+kdb_ss
+kdb_bp_install
+kdb_bp_remove
+kdb_common_init_state
+kdb_common_deinit_state
+kdb_stub
+kdb_gdb_state_pass
+kdb_get_kbd_char
+kdb_kbd_cleanup_state
+hung_task_panic
+reset_hung_task_detector
+hungtask_pm_notify
+watchdog
+proc_dohung_task_timeout_secs
+softlockup_fn
+watchdog_timer_fn
+lockup_detector_update_enable
+watchdog_nmi_enable
+watchdog_enable
+softlockup_start_fn
+watchdog_nmi_disable
+watchdog_disable
+softlockup_stop_fn
+watchdog_nmi_stop
+watchdog_nmi_start
+lockup_detector_reconfigure
+proc_watchdog_update
+proc_watchdog_common
+touch_all_softlockup_watchdogs
+touch_softlockup_watchdog_sync
+is_hardlockup
+lockup_detector_online_cpu
+lockup_detector_offline_cpu
+lockup_detector_cleanup
+lockup_detector_soft_poweroff
+proc_watchdog
+proc_nmi_watchdog
+proc_soft_watchdog
+proc_watchdog_thresh
+proc_watchdog_cpumask
+hardlockup_detector_event_create
+watchdog_overflow_callback
+watchdog_update_hrtimer_threshold
+hardlockup_detector_perf_enable
+hardlockup_detector_perf_disable
+hardlockup_detector_perf_cleanup
+seccomp_check_filter
+seccomp_init_siginfo
+seccomp_notify_poll
+seccomp_notify_ioctl
+seccomp_notify_detach.part.0
+seccomp_do_user_notification.isra.0
+write_actions_logged.constprop.0
+seccomp_names_from_actions_logged.constprop.0
+read_actions_logged
+audit_actions_logged
+seccomp_actions_logged_handler
+__seccomp_filter_orphan
+__put_seccomp_filter
+seccomp_notify_release
+get_nth_filter
+__seccomp_filter
+__seccomp_filter
+seccomp_filter_release
+get_seccomp_filter
+do_seccomp
+__x64_sys_seccomp
+__ia32_sys_seccomp
+__secure_computing
+prctl_get_seccomp
+prctl_set_seccomp
+seccomp_get_filter
+seccomp_get_metadata
+buf_mapped_default_callback
+create_buf_file_default_callback
+remove_buf_file_default_callback
+relay_page_release
+wakeup_readers
+relay_file_mmap_close
+relay_buf_full
+subbuf_start_default_callback
+__relay_set_buf_dentry
+relay_file_mmap
+relay_file_poll
+__relay_reset
+relay_destroy_channel
+relay_switch_subbuf
+relay_buf_fault
+relay_subbufs_consumed.part.0
+relay_subbufs_consumed
+relay_pipe_buf_release
+relay_file_read_consume
+relay_file_read
+relay_reset
+relay_flush
+subbuf_splice_actor.isra.0
+relay_file_splice_read
+buf_unmapped_default_callback
+relay_create_buf_file
+relay_late_setup_files
+relay_file_open
+relay_destroy_buf
+relay_file_release
+relay_open_buf
+relay_close_buf
+relay_close
+relay_open
+relay_prepare_cpu
+proc_do_uts_string
+uts_proc_notify
+delayacct_end
+delayacct_init
+__delayacct_tsk_init
+__delayacct_blkio_start
+__delayacct_blkio_end
+__delayacct_add_tsk
+__delayacct_blkio_ticks
+__delayacct_freepages_start
+__delayacct_freepages_end
+__delayacct_thrashing_start
+__delayacct_thrashing_end
+send_reply
+parse
+fill_stats
+prepare_reply
+cgroupstats_user_cmd
+add_del_listener
+mk_reply
+taskstats_user_cmd
+taskstats_exit
+__acct_update_integrals
+bacct_add_tsk
+xacct_add_tsk
+acct_update_integrals
+acct_account_cputime
+acct_clear_integrals
+rcu_free_old_probes
+srcu_free_old_probes
+tracepoint_update_call
+register_tracepoint_module_notifier
+unregister_tracepoint_module_notifier
+tracepoint_probe_register_prio
+tracepoint_probe_register
+tracepoint_module_notify
+for_each_kernel_tracepoint
+tracepoint_probe_unregister
+trace_module_has_bad_taint
+syscall_regfunc
+syscall_unregfunc
+__bpf_call_base
+__bpf_prog_ret0_warn
+__bpf_prog_ret1
+__bpf_prog_ret1
+bpf_adj_branches
+__traceiter_xdp_exception
+__traceiter_xdp_bulk_tx
+__traceiter_xdp_redirect
+__traceiter_xdp_redirect_err
+__traceiter_xdp_redirect_map
+__traceiter_xdp_redirect_map_err
+__traceiter_xdp_cpumap_kthread
+__traceiter_xdp_cpumap_enqueue
+__traceiter_xdp_devmap_xmit
+__traceiter_mem_disconnect
+__traceiter_mem_connect
+__traceiter_mem_return_failed
+bpf_prog_free
+bpf_ksym_find
+bpf_internal_load_pointer_neg_helper
+bpf_prog_alloc_no_stats
+bpf_prog_alloc
+bpf_prog_alloc_jited_linfo
+bpf_prog_free_jited_linfo
+bpf_prog_free_unused_jited_linfo
+bpf_prog_fill_jited_linfo
+bpf_prog_free_linfo
+bpf_prog_realloc
+__bpf_prog_free
+bpf_prog_calc_tag
+bpf_patch_insn_single
+bpf_remove_insns
+bpf_ksym_add
+bpf_ksym_del
+bpf_prog_kallsyms_add
+bpf_prog_kallsyms_del
+bpf_prog_kallsyms_del_all
+__bpf_address_lookup
+is_bpf_text_address
+search_bpf_extables
+bpf_get_kallsym
+bpf_jit_add_poke_descriptor
+bpf_jit_alloc_exec_limit
+bpf_jit_alloc_exec
+bpf_jit_free_exec
+bpf_jit_binary_alloc
+bpf_jit_binary_free
+bpf_jit_free
+bpf_jit_get_func_addr
+bpf_jit_prog_release_other
+bpf_jit_blind_constants
+bpf_opcode_in_insntable
+bpf_prog_array_compatible
+bpf_prog_array_alloc
+bpf_prog_array_free
+bpf_prog_array_length
+bpf_prog_array_is_empty
+bpf_prog_array_copy_to_user
+bpf_prog_array_delete_safe
+bpf_prog_array_delete_safe_at
+bpf_prog_array_update_at
+bpf_prog_array_copy
+bpf_prog_array_copy_info
+__bpf_free_used_maps
+bpf_prog_free_deferred
+bpf_user_rnd_init_once
+bpf_user_rnd_u32
+bpf_get_raw_cpu_id
+bpf_get_raw_cpu_id
+bpf_get_raw_cpu_id
+bpf_prog_select_runtime
+bpf_jit_compile
+bpf_jit_compile
+bpf_jit_needs_zext
+bpf_jit_needs_zext
+bpf_jit_needs_zext
+bpf_dummy_read
+map_check_no_btf
+bpf_map_inc
+bpf_map_inc_with_uref
+__bpf_map_area_alloc
+bpf_charge_memlock
+bpf_map_put_uref
+bpf_map_poll
+bpf_prog_add
+bpf_prog_inc
+bpf_prog_inc_not_zero
+bpf_tracing_link_fill_link_info
+bpf_prog_uncharge_memlock
+bpf_raw_tp_link_show_fdinfo
+bpf_tracing_link_show_fdinfo
+bpf_map_mmap_close
+bpf_map_mmap_open
+bpf_tracing_link_dealloc
+__bpf_prog_put_rcu
+bpf_link_show_fdinfo
+bpf_prog_get_stats
+bpf_prog_show_fdinfo
+bpf_obj_get_next_id
+bpf_task_fd_query_copy
+bpf_raw_tp_link_release
+bpf_stats_release
+bpf_map_show_fdinfo
+bpf_map_mmap
+bpf_map_do_batch
+__bpf_prog_put_noref
+__bpf_map_inc_not_zero
+bpf_map_inc_not_zero
+bpf_prog_sub
+bpf_link_free_id.part.0
+bpf_map_update_value.isra.0
+bpf_audit_prog.part.0
+bpf_prog_attach_check_attach_type
+__bpf_prog_get
+bpf_prog_get_type_dev
+bpf_prog_by_id.part.0
+bpf_dummy_write
+bpf_link_by_id.part.0
+bpf_raw_tp_link_dealloc
+bpf_raw_tp_link_fill_link_info
+bpf_map_value_size
+bpf_check_uarg_tail_zero
+bpf_prog_get_info_by_fd
+bpf_obj_get_info_by_fd
+bpf_map_area_alloc
+bpf_map_area_mmapable_alloc
+bpf_map_area_free
+bpf_map_init_from_attr
+bpf_map_charge_init
+bpf_map_charge_finish
+bpf_map_charge_move
+bpf_map_free_deferred
+bpf_map_charge_memlock
+bpf_map_uncharge_memlock
+bpf_map_free_id
+__bpf_map_put.constprop.0
+bpf_map_release
+bpf_map_put
+bpf_map_put_with_uref
+bpf_map_new_fd
+bpf_get_file_flag
+bpf_obj_name_cpy
+__bpf_map_get
+bpf_map_get
+bpf_map_get_with_uref
+bpf_map_get_with_uref
+bpf_map_copy_value
+generic_map_delete_batch
+generic_map_update_batch
+generic_map_lookup_batch
+__bpf_prog_charge
+__bpf_prog_uncharge
+bpf_prog_free_id
+__bpf_prog_put.constprop.0
+bpf_tracing_link_release
+bpf_link_free
+bpf_link_put_deferred
+bpf_prog_release
+bpf_prog_put
+bpf_prog_new_fd
+bpf_prog_load
+bpf_prog_get_ok
+bpf_prog_get
+bpf_link_init
+bpf_link_cleanup
+bpf_link_inc
+bpf_link_put
+bpf_link_release
+bpf_link_prime
+bpf_link_settle
+bpf_tracing_prog_attach
+tracing_bpf_link_attach
+bpf_raw_tracepoint_open
+bpf_link_new_fd
+bpf_link_get_from_fd
+__x64_sys_bpf
+__ia32_sys_bpf
+bpf_map_get_curr_or_next
+bpf_prog_get_curr_or_next
+bpf_prog_by_id
+bpf_link_by_id
+reg_type_may_be_null
+__reg32_deduce_bounds
+__reg64_deduce_bounds
+cmp_subprogs
+save_register_state
+find_good_pkt_pointers
+find_equal_scalars
+is_preallocated_map
+find_subprog
+__mark_reg_known
+release_reference_state
+__scalar32_min_max_lsh
+push_jmp_history
+explored_state
+zext_32_to_64
+__update_reg32_bounds
+__update_reg_bounds
+__reg_bound_offset
+__reg_combine_64_into_32
+__reg_combine_min_max
+__reg_combine_32_into_64
+reg_set_min_max
+verifier_remove_insns
+__mark_reg_unknown
+is_pointer_value
+sanitize_val_alu
+mark_all_scalars_precise.isra.0
+check_ids
+copy_reference_state
+bpf_vlog_reset
+free_func_state.part.0
+free_verifier_state
+is_branch_taken
+may_access_direct_pkt_data
+regsafe.part.0
+mark_ptr_or_null_reg.constprop.0
+mark_ptr_or_null_regs
+is_reg64.isra.0.constprop.0
+insn_has_def32.isra.0
+states_equal.isra.0
+realloc_reference_state
+transfer_reference_state
+realloc_stack_state
+copy_verifier_state
+pop_stack
+bpf_verifier_vlog
+bpf_verifier_log_write
+verbose
+add_subprog
+check_abnormal_return
+check_btf_func
+resolve_pseudo_ldimm64
+mark_reg_not_init
+mark_reg_unknown
+mark_reg_known_zero
+init_reg_state
+mark_btf_ld_reg
+mark_reg_read
+propagate_liveness_reg
+print_liveness
+push_stack
+sanitize_ptr_alu
+check_reg_sane_offset
+__check_mem_access
+check_stack_access
+check_reg_arg
+clear_caller_saved_regs
+check_ptr_alignment
+check_map_access_type
+check_packet_access
+__check_buffer_access
+process_spin_lock
+__check_stack_boundary
+may_update_sockmap
+check_reference_leak
+bpf_patch_insn_data
+convert_ctx_accesses
+fixup_bpf_calls
+verbose_linfo
+push_insn
+bpf_log
+kernel_type_name
+print_verifier_state
+__mark_chain_precision
+check_mem_region_access
+check_map_access
+adjust_ptr_min_max_vals
+check_helper_mem_access
+adjust_reg_min_max_vals
+check_alu_op
+check_ctx_reg
+check_mem_access
+check_helper_call
+do_check_common
+bpf_check_attach_target
+bpf_get_btf_vmlinux
+bpf_check
+map_seq_stop
+bpffs_obj_open
+bpf_get_tree
+bpf_get_inode
+bpf_dentry_finalize
+bpf_mkobj_ops
+bpf_mklink
+bpf_mkprog
+bpf_mkmap
+bpf_free_fc
+bpf_mkdir
+bpf_symlink
+bpf_lookup
+bpf_prog_get_type_path
+bpf_show_options
+bpf_fill_super
+bpf_parse_param
+map_seq_start
+map_seq_next
+bpf_any_put
+bpf_free_inode
+map_iter_free.part.0
+bpffs_map_release
+map_seq_show
+bpf_init_fs_context
+bpffs_map_open
+bpf_obj_pin_user
+bpf_obj_get_user
+bpf_get_smp_processor_id
+bpf_get_numa_node_id
+bpf_spin_unlock
+bpf_jiffies64
+bpf_per_cpu_ptr
+bpf_this_cpu_ptr
+bpf_ktime_get_ns
+bpf_ktime_get_boot_ns
+bpf_map_lookup_elem
+bpf_map_update_elem
+bpf_map_delete_elem
+bpf_map_push_elem
+bpf_map_pop_elem
+bpf_get_current_pid_tgid
+bpf_get_current_uid_gid
+bpf_get_local_storage
+bpf_get_current_comm
+bpf_get_ns_current_pid_tgid
+bpf_event_output_data
+bpf_copy_from_user
+__bpf_strtoull
+bpf_strtoul
+bpf_strtol
+bpf_get_current_ancestor_cgroup_id
+bpf_get_current_cgroup_id
+bpf_spin_lock
+bpf_map_peek_elem
+copy_map_value_locked
+bpf_base_func_proto
+tnum_strn
+tnum_const
+tnum_range
+tnum_lshift
+tnum_rshift
+tnum_arshift
+tnum_add
+tnum_sub
+tnum_and
+tnum_or
+tnum_xor
+tnum_mul
+tnum_intersect
+tnum_cast
+tnum_is_aligned
+tnum_in
+tnum_sbin
+tnum_subreg
+tnum_clear_subreg
+tnum_const_subreg
+bpf_iter_link_release
+iter_release
+bpf_iter_link_replace
+prepare_seq_file
+iter_open
+bpf_iter_link_dealloc
+bpf_iter_link_fill_link_info
+bpf_iter_link_show_fdinfo
+bpf_seq_read
+bpf_iter_reg_target
+bpf_iter_unreg_target
+bpf_iter_prog_supported
+bpf_link_is_iter
+bpf_iter_link_attach
+bpf_iter_new_fd
+bpf_iter_get_info
+bpf_iter_run_prog
+__bpf_map_seq_show
+bpf_map_seq_show
+bpf_iter_map_fill_link_info
+bpf_iter_map_show_fdinfo
+bpf_iter_detach_map
+bpf_map_seq_next
+bpf_map_seq_start
+bpf_map_seq_stop
+bpf_iter_attach_map
+__task_seq_show
+task_seq_show
+fini_seq_pidns
+__task_file_seq_show
+task_file_seq_show
+init_seq_pidns
+task_seq_get_next
+task_seq_start
+task_seq_next
+task_seq_stop
+task_file_seq_stop
+task_file_seq_get_next
+task_file_seq_next
+task_file_seq_start
+__bpf_prog_seq_show
+bpf_prog_seq_show
+bpf_prog_seq_next
+bpf_prog_seq_start
+bpf_prog_seq_stop
+htab_map_gen_lookup
+htab_lru_map_gen_lookup
+htab_lru_map_delete_node
+htab_of_map_gen_lookup
+bpf_iter_fini_hash_map
+__bpf_hash_map_seq_show
+bpf_hash_map_seq_show
+bpf_hash_map_seq_stop
+bpf_hash_map_seq_find_next
+bpf_hash_map_seq_next
+bpf_hash_map_seq_start
+lookup_elem_raw
+lookup_nulls_elem_raw
+htab_elem_free_rcu
+htab_map_get_next_key
+htab_free_elems
+prealloc_destroy
+htab_map_alloc_check
+fd_htab_map_alloc_check
+prealloc_lru_pop
+pcpu_copy_value
+pcpu_init_value
+alloc_htab_elem
+free_htab_elem
+htab_map_alloc
+htab_of_map_alloc
+bpf_iter_init_hash_map
+htab_map_free
+htab_of_map_free
+__htab_map_lookup_and_delete_batch
+htab_map_lookup_and_delete_batch
+htab_map_lookup_batch
+htab_lru_map_lookup_and_delete_batch
+htab_lru_map_lookup_batch
+htab_percpu_map_lookup_and_delete_batch
+htab_percpu_map_lookup_batch
+htab_lru_percpu_map_lookup_and_delete_batch
+htab_lru_percpu_map_lookup_batch
+__htab_map_lookup_elem
+htab_lru_map_lookup_elem
+htab_lru_map_lookup_elem_sys
+htab_map_lookup_elem
+htab_of_map_lookup_elem
+htab_percpu_map_lookup_elem
+htab_lru_percpu_map_lookup_elem
+htab_map_seq_show_elem
+htab_percpu_map_seq_show_elem
+htab_map_delete_elem
+htab_lru_map_delete_elem
+__htab_percpu_map_update_elem
+htab_percpu_map_update_elem
+__htab_lru_percpu_map_update_elem
+htab_lru_percpu_map_update_elem
+htab_lru_map_update_elem
+htab_map_update_elem
+bpf_percpu_hash_copy
+bpf_percpu_hash_update
+bpf_fd_htab_map_lookup_elem
+bpf_fd_htab_map_update_elem
+array_map_delete_elem
+fd_array_map_lookup_elem
+array_map_alloc_check
+array_map_direct_value_addr
+array_map_direct_value_meta
+array_map_get_next_key
+bpf_array_map_seq_start
+bpf_array_map_seq_next
+fd_array_map_alloc_check
+prog_fd_array_sys_lookup_elem
+array_map_lookup_elem
+array_of_map_lookup_elem
+percpu_array_map_lookup_elem
+bpf_iter_fini_array_map
+__bpf_array_map_seq_show
+bpf_array_map_seq_show
+bpf_array_map_seq_stop
+array_map_mmap
+array_map_seq_show_elem
+percpu_array_map_seq_show_elem
+prog_array_map_seq_show_elem
+array_map_update_elem
+bpf_array_free_percpu
+array_map_free
+prog_array_map_poke_untrack
+prog_array_map_poke_track
+fd_array_map_delete_elem
+bpf_fd_array_map_clear
+prog_fd_array_put_ptr
+prog_fd_array_get_ptr
+prog_array_map_clear
+prog_array_map_clear_deferred
+perf_event_fd_array_put_ptr
+__bpf_event_entry_free
+perf_event_fd_array_get_ptr
+cgroup_fd_array_get_ptr
+array_map_gen_lookup
+array_of_map_gen_lookup
+prog_array_map_poke_run
+array_map_meta_equal
+array_map_check_btf
+fd_array_map_free
+prog_array_map_free
+perf_event_fd_array_map_free
+cgroup_fd_array_free
+array_of_map_free
+perf_event_fd_array_release
+cgroup_fd_array_put_ptr
+array_map_alloc
+array_of_map_alloc
+bpf_iter_init_array_map
+prog_array_map_alloc
+bpf_percpu_array_copy
+bpf_percpu_array_update
+bpf_fd_array_map_lookup_elem
+bpf_fd_array_map_update_elem
+pcpu_freelist_init
+pcpu_freelist_destroy
+__pcpu_freelist_push
+pcpu_freelist_push
+pcpu_freelist_populate
+__pcpu_freelist_pop
+pcpu_freelist_pop
+__bpf_lru_node_move
+__bpf_lru_list_rotate_active
+__bpf_lru_list_rotate_inactive
+__bpf_lru_node_move_to_free
+__bpf_lru_list_shrink
+__bpf_lru_node_move_in
+bpf_lru_pop_free
+bpf_lru_push_free
+bpf_lru_populate
+bpf_lru_init
+bpf_lru_destroy
+trie_check_btf
+longest_prefix_match
+trie_delete_elem
+trie_lookup_elem
+trie_free
+lpm_trie_node_alloc
+trie_update_elem
+trie_alloc
+trie_get_next_key
+bpf_map_meta_alloc
+bpf_map_meta_free
+bpf_map_meta_equal
+bpf_map_fd_get_ptr
+bpf_map_fd_put_ptr
+bpf_map_fd_sys_lookup_elem
+cgroup_storage_delete_elem
+free_shared_cgroup_storage_rcu
+cgroup_storage_map_alloc
+free_percpu_cgroup_storage_rcu
+bpf_cgroup_storage_key_cmp.part.0
+cgroup_storage_check_btf
+bpf_cgroup_storage_unlink.part.0
+bpf_cgroup_storage_calculate_size
+bpf_cgroup_storage_free.part.0
+cgroup_storage_map_free
+cgroup_storage_lookup
+cgroup_storage_seq_show_elem
+cgroup_storage_update_elem
+cgroup_storage_lookup_elem
+cgroup_storage_get_next_key
+bpf_percpu_cgroup_storage_copy
+bpf_percpu_cgroup_storage_update
+bpf_cgroup_storage_assign
+bpf_cgroup_storage_alloc
+bpf_cgroup_storage_free
+bpf_cgroup_storage_link
+bpf_cgroup_storage_unlink
+queue_stack_map_lookup_elem
+queue_stack_map_update_elem
+queue_stack_map_delete_elem
+queue_stack_map_get_next_key
+__queue_map_get
+queue_map_peek_elem
+queue_map_pop_elem
+queue_stack_map_push_elem
+__stack_map_get
+stack_map_peek_elem
+stack_map_pop_elem
+queue_stack_map_free
+queue_stack_map_alloc
+queue_stack_map_alloc_check
+ringbuf_map_lookup_elem
+ringbuf_map_update_elem
+ringbuf_map_delete_elem
+ringbuf_map_get_next_key
+bpf_ringbuf_notify
+bpf_ringbuf_query
+ringbuf_map_poll
+ringbuf_map_mmap
+ringbuf_map_free
+__bpf_ringbuf_reserve
+bpf_ringbuf_reserve
+bpf_ringbuf_commit
+bpf_ringbuf_submit
+bpf_ringbuf_discard
+bpf_ringbuf_output
+ringbuf_map_alloc
+notsupp_get_next_key
+inode_storage_ptr
+inode_storage_lookup
+bpf_inode_storage_get
+bpf_fd_inode_storage_delete_elem
+bpf_fd_inode_storage_update_elem
+bpf_fd_inode_storage_lookup_elem
+inode_storage_map_free
+inode_storage_map_alloc
+bpf_inode_storage_delete
+bpf_inode_storage_free
+__func_get_name.constprop.0
+func_id_name
+print_bpf_insn
+bpf_attach_type_to_tramp
+bpf_jit_alloc_exec_page
+bpf_image_ksym_add
+bpf_image_ksym_del
+bpf_trampoline_get
+bpf_trampoline_put
+__bpf_prog_exit_sleepable
+bpf_trampoline_update
+bpf_trampoline_link_prog
+bpf_trampoline_unlink_prog
+btf_type_needs_resolve
+btf_type_int_is_regular
+env_stack_push
+btf_sec_info_cmp
+btf_id_cmp_func
+btf_free
+btf_free_rcu
+__btf_resolve_size
+btf_var_show
+__btf_verifier_log
+btf_verifier_log
+btf_parse_str_sec
+btf_var_log
+btf_ref_type_log
+btf_fwd_type_log
+btf_struct_log
+btf_enum_log
+btf_datasec_log
+btf_array_log
+btf_int_log
+btf_show
+btf_df_show
+btf_parse_hdr
+btf_show_obj_safe
+btf_show_name
+btf_check_all_metas
+btf_get_prog_ctx_type
+btf_seq_show
+btf_type_show
+btf_snprintf_show
+bpf_btf_show_fdinfo
+btf_show_indent.part.0
+btf_show_start_aggr_type
+btf_show_delim.part.0
+btf_show_end_aggr_type
+btf_int128_print
+btf_bitfield_show
+btf_ptr_show
+env_type_is_resolve_sink
+__get_type_size.part.0
+__btf_struct_show.constprop.0
+btf_struct_show
+__btf_verifier_log_type
+btf_df_check_kflag_member
+btf_df_check_member
+btf_df_resolve
+btf_func_proto_check_meta
+btf_array_check_meta
+btf_int_check_meta
+btf_verifier_log_vsi
+btf_verifier_log_member
+btf_enum_check_kflag_member
+btf_generic_check_kflag_member
+btf_struct_check_member
+btf_enum_check_member
+btf_ptr_check_member
+btf_int_check_kflag_member
+btf_int_check_member
+btf_struct_resolve
+btf_enum_show
+btf_func_proto_log
+btf_datasec_show
+__btf_name_valid
+btf_var_check_meta
+btf_func_check_meta
+btf_ref_type_check_meta
+btf_fwd_check_meta
+btf_enum_check_meta
+btf_datasec_check_meta
+btf_struct_check_meta
+btf_int_show
+btf_type_is_void
+btf_find_by_name_kind
+btf_type_skip_modifiers
+btf_modifier_show
+btf_struct_walk
+__btf_array_show
+btf_array_show
+btf_type_resolve_ptr
+btf_type_resolve_func_ptr
+btf_name_by_offset
+btf_type_by_id
+btf_put
+btf_release
+btf_resolve_size
+btf_type_id_size
+btf_member_is_reg_int
+btf_datasec_resolve
+btf_var_resolve
+btf_modifier_check_kflag_member
+btf_modifier_check_member
+btf_modifier_resolve
+btf_array_check_member
+btf_array_resolve
+btf_ptr_resolve
+btf_resolve
+btf_find_spin_lock
+btf_parse_vmlinux
+bpf_prog_get_target_btf
+btf_ctx_access
+btf_struct_access
+btf_struct_ids_match
+btf_distill_func_proto
+btf_check_type_match
+btf_check_func_arg_match
+btf_prepare_func_args
+btf_type_seq_show_flags
+btf_type_seq_show
+btf_type_snprintf_show
+btf_new_fd
+btf_get_by_fd
+btf_get_info_by_fd
+btf_get_fd_by_id
+btf_id
+btf_id_set_contains
+btf_id_set_contains
+bpf_dispatcher_prepare
+bpf_dispatcher_change_prog
+dev_map_get_next_key
+bq_xmit_all
+bq_enqueue
+dev_map_delete_elem
+__dev_map_entry_free
+dev_map_hash_delete_elem
+dev_map_hash_lookup_elem
+dev_map_hash_get_next_key
+dev_map_lookup_elem
+__dev_map_alloc_node
+dev_map_update_elem
+dev_map_hash_update_elem
+dev_map_notification
+dev_map_alloc
+dev_map_free
+__dev_map_hash_lookup_elem
+dev_map_can_have_prog
+__dev_flush
+__dev_map_lookup_elem
+dev_xdp_enqueue
+dev_map_enqueue
+dev_map_generic_redirect
+cpu_map_get_next_key
+cpu_map_kthread_stop
+__cpu_map_entry_replace
+cpu_map_delete_elem
+cpu_map_lookup_elem
+cpu_map_free
+bq_flush_to_queue
+cpu_map_bpf_prog_run_xdp
+cpu_map_alloc
+cpu_map_update_elem
+put_cpu_map_entry
+__cpu_map_entry_free
+cpu_map_kthread_run
+cpu_map_prog_allowed
+__cpu_map_lookup_elem
+cpu_map_enqueue
+__cpu_map_flush
+select_bucket
+bpf_selem_alloc
+bpf_selem_unlink_storage_nolock
+__bpf_selem_unlink_storage
+bpf_selem_link_storage_nolock
+bpf_selem_unlink_map
+bpf_selem_link_map
+bpf_selem_unlink
+bpf_local_storage_lookup
+bpf_local_storage_alloc
+bpf_local_storage_update
+bpf_local_storage_cache_idx_get
+bpf_local_storage_cache_idx_free
+bpf_local_storage_map_free
+bpf_local_storage_map_alloc_check
+bpf_local_storage_map_alloc
+bpf_local_storage_map_check_btf
+bpf_offload_dev_destroy
+bpf_offload_dev_priv
+bpf_prog_warn_on_exec
+__bpf_prog_offload_destroy
+bpf_map_offload_ndo
+__bpf_map_offload_destroy
+bpf_prog_offload_info_fill_ns
+bpf_offload_dev_create
+bpf_map_offload_info_fill_ns
+bpf_offload_find_netdev
+__bpf_offload_dev_match
+bpf_offload_dev_match
+bpf_offload_dev_netdev_unregister
+bpf_offload_dev_netdev_register
+bpf_prog_offload_init
+bpf_prog_offload_verifier_prep
+bpf_prog_offload_verify_insn
+bpf_prog_offload_finalize
+bpf_prog_offload_replace_insn
+bpf_prog_offload_remove_insns
+bpf_prog_offload_destroy
+bpf_prog_offload_compile
+bpf_prog_offload_info_fill
+bpf_map_offload_map_alloc
+bpf_map_offload_map_free
+bpf_map_offload_lookup_elem
+bpf_map_offload_update_elem
+bpf_map_offload_delete_elem
+bpf_map_offload_get_next_key
+bpf_map_offload_info_fill
+bpf_offload_prog_map_match
+netns_bpf_pernet_init
+bpf_netns_link_fill_info
+bpf_netns_link_dealloc
+bpf_netns_link_show_fdinfo
+bpf_netns_link_update_prog
+bpf_netns_link_release
+bpf_netns_link_detach
+netns_bpf_pernet_pre_exit
+netns_bpf_prog_query
+netns_bpf_prog_attach
+netns_bpf_prog_detach
+netns_bpf_link_create
+stack_map_lookup_elem
+stack_map_update_elem
+stack_map_get_next_key
+stack_map_delete_elem
+do_up_read
+stack_map_free
+stack_map_alloc
+stack_map_get_build_id_offset
+__bpf_get_stackid
+bpf_get_stackid
+bpf_get_stackid_pe
+__bpf_get_stack
+bpf_get_stack
+bpf_get_task_stack
+bpf_get_stack_pe
+bpf_stackmap_copy
+cg_sockopt_get_prologue
+bpf_cgroup_link_dealloc
+bpf_cgroup_link_fill_link_info
+cgroup_bpf_release_fn
+sysctl_convert_ctx_access
+cg_sockopt_convert_ctx_access
+bpf_cgroup_link_show_fdinfo
+__cgroup_bpf_run_filter_sk
+__cgroup_bpf_run_filter_sock_ops
+__cgroup_bpf_run_filter_sock_addr
+bpf_sysctl_set_new_value
+copy_sysctl_value
+bpf_sysctl_get_current_value
+bpf_sysctl_get_new_value
+sysctl_cpy_dir
+bpf_sysctl_get_name
+cgroup_dev_is_valid_access
+sysctl_is_valid_access
+cg_sockopt_is_valid_access
+cgroup_base_func_proto.isra.0
+cgroup_dev_func_proto
+sysctl_func_proto
+cg_sockopt_func_proto
+sockopt_alloc_buf
+cgroup_bpf_replace
+prog_list_length
+compute_effective_progs
+update_effective_progs
+__cgroup_bpf_run_filter_skb
+cgroup_bpf_release
+cgroup_bpf_offline
+cgroup_bpf_inherit
+__cgroup_bpf_attach
+__cgroup_bpf_detach
+bpf_cgroup_link_release
+bpf_cgroup_link_detach
+__cgroup_bpf_query
+cgroup_bpf_prog_attach
+cgroup_bpf_prog_detach
+cgroup_bpf_link_attach
+cgroup_bpf_prog_query
+__cgroup_bpf_check_dev_permission
+__cgroup_bpf_run_filter_sysctl
+__cgroup_bpf_run_filter_setsockopt
+__cgroup_bpf_run_filter_getsockopt
+reuseport_array_delete_elem
+reuseport_array_get_next_key
+reuseport_array_lookup_elem
+reuseport_array_free
+reuseport_array_alloc
+reuseport_array_alloc_check
+reuseport_array_update_check.isra.0
+bpf_sk_reuseport_detach
+bpf_fd_reuseport_array_lookup_elem
+bpf_fd_reuseport_array_update_elem
+btf_vmlinux_read
+bpf_struct_ops_map_lookup_elem
+bpf_struct_ops_map_get_next_key
+bpf_struct_ops_map_alloc_check
+check_zero_holes
+bpf_struct_ops_map_put_progs
+bpf_struct_ops_map_free
+bpf_struct_ops_map_alloc
+bpf_struct_ops_map_update_elem
+bpf_struct_ops_map_delete_elem
+bpf_struct_ops_init
+bpf_struct_ops_find
+bpf_struct_ops_map_sys_lookup_elem
+bpf_struct_ops_map_seq_show_elem
+bpf_struct_ops_get
+bpf_struct_ops_put
+bpf_lsm_func_proto
+bpf_lsm_binder_set_context_mgr
+bpf_lsm_binder_transaction
+bpf_lsm_binder_transfer_binder
+bpf_lsm_binder_transfer_file
+bpf_lsm_ptrace_access_check
+bpf_lsm_ptrace_traceme
+bpf_lsm_capget
+bpf_lsm_capset
+bpf_lsm_capable
+bpf_lsm_quotactl
+bpf_lsm_quota_on
+bpf_lsm_syslog
+bpf_lsm_settime
+bpf_lsm_vm_enough_memory
+bpf_lsm_bprm_creds_for_exec
+bpf_lsm_bprm_creds_from_file
+bpf_lsm_bprm_check_security
+bpf_lsm_bprm_committing_creds
+bpf_lsm_bprm_committed_creds
+bpf_lsm_fs_context_dup
+bpf_lsm_fs_context_parse_param
+bpf_lsm_sb_alloc_security
+bpf_lsm_sb_free_security
+bpf_lsm_sb_free_mnt_opts
+bpf_lsm_sb_eat_lsm_opts
+bpf_lsm_sb_remount
+bpf_lsm_sb_kern_mount
+bpf_lsm_sb_show_options
+bpf_lsm_sb_statfs
+bpf_lsm_sb_mount
+bpf_lsm_sb_umount
+bpf_lsm_sb_pivotroot
+bpf_lsm_sb_set_mnt_opts
+bpf_lsm_sb_clone_mnt_opts
+bpf_lsm_sb_add_mnt_opt
+bpf_lsm_move_mount
+bpf_lsm_dentry_init_security
+bpf_lsm_dentry_create_files_as
+bpf_lsm_path_unlink
+bpf_lsm_path_mkdir
+bpf_lsm_path_rmdir
+bpf_lsm_path_mknod
+bpf_lsm_path_truncate
+bpf_lsm_path_symlink
+bpf_lsm_path_link
+bpf_lsm_path_rename
+bpf_lsm_path_chmod
+bpf_lsm_path_chown
+bpf_lsm_path_chroot
+bpf_lsm_path_notify
+bpf_lsm_inode_alloc_security
+bpf_lsm_inode_free_security
+bpf_lsm_inode_init_security
+bpf_lsm_inode_create
+bpf_lsm_inode_link
+bpf_lsm_inode_unlink
+bpf_lsm_inode_symlink
+bpf_lsm_inode_mkdir
+bpf_lsm_inode_rmdir
+bpf_lsm_inode_mknod
+bpf_lsm_inode_rename
+bpf_lsm_inode_readlink
+bpf_lsm_inode_follow_link
+bpf_lsm_inode_permission
+bpf_lsm_inode_setattr
+bpf_lsm_inode_getattr
+bpf_lsm_inode_setxattr
+bpf_lsm_inode_post_setxattr
+bpf_lsm_inode_getxattr
+bpf_lsm_inode_listxattr
+bpf_lsm_inode_removexattr
+bpf_lsm_inode_need_killpriv
+bpf_lsm_inode_killpriv
+bpf_lsm_inode_getsecurity
+bpf_lsm_inode_setsecurity
+bpf_lsm_inode_listsecurity
+bpf_lsm_inode_getsecid
+bpf_lsm_inode_copy_up
+bpf_lsm_inode_copy_up_xattr
+bpf_lsm_kernfs_init_security
+bpf_lsm_file_permission
+bpf_lsm_file_alloc_security
+bpf_lsm_file_free_security
+bpf_lsm_file_ioctl
+bpf_lsm_mmap_addr
+bpf_lsm_mmap_file
+bpf_lsm_file_mprotect
+bpf_lsm_file_lock
+bpf_lsm_file_fcntl
+bpf_lsm_file_set_fowner
+bpf_lsm_file_send_sigiotask
+bpf_lsm_file_receive
+bpf_lsm_file_open
+bpf_lsm_task_alloc
+bpf_lsm_task_free
+bpf_lsm_cred_alloc_blank
+bpf_lsm_cred_free
+bpf_lsm_cred_prepare
+bpf_lsm_cred_transfer
+bpf_lsm_cred_getsecid
+bpf_lsm_kernel_act_as
+bpf_lsm_kernel_create_files_as
+bpf_lsm_kernel_module_request
+bpf_lsm_kernel_load_data
+bpf_lsm_kernel_post_load_data
+bpf_lsm_kernel_read_file
+bpf_lsm_kernel_post_read_file
+bpf_lsm_task_fix_setuid
+bpf_lsm_task_fix_setgid
+bpf_lsm_task_setpgid
+bpf_lsm_task_getpgid
+bpf_lsm_task_getsid
+bpf_lsm_task_getsecid
+bpf_lsm_task_setnice
+bpf_lsm_task_setioprio
+bpf_lsm_task_getioprio
+bpf_lsm_task_prlimit
+bpf_lsm_task_setrlimit
+bpf_lsm_task_setscheduler
+bpf_lsm_task_getscheduler
+bpf_lsm_task_movememory
+bpf_lsm_task_kill
+bpf_lsm_task_prctl
+bpf_lsm_task_to_inode
+bpf_lsm_ipc_permission
+bpf_lsm_ipc_getsecid
+bpf_lsm_msg_msg_alloc_security
+bpf_lsm_msg_msg_free_security
+bpf_lsm_msg_queue_alloc_security
+bpf_lsm_msg_queue_free_security
+bpf_lsm_msg_queue_associate
+bpf_lsm_msg_queue_msgctl
+bpf_lsm_msg_queue_msgsnd
+bpf_lsm_msg_queue_msgrcv
+bpf_lsm_shm_alloc_security
+bpf_lsm_shm_free_security
+bpf_lsm_shm_associate
+bpf_lsm_shm_shmctl
+bpf_lsm_shm_shmat
+bpf_lsm_sem_alloc_security
+bpf_lsm_sem_free_security
+bpf_lsm_sem_associate
+bpf_lsm_sem_semctl
+bpf_lsm_sem_semop
+bpf_lsm_netlink_send
+bpf_lsm_d_instantiate
+bpf_lsm_getprocattr
+bpf_lsm_setprocattr
+bpf_lsm_ismaclabel
+bpf_lsm_secid_to_secctx
+bpf_lsm_secctx_to_secid
+bpf_lsm_release_secctx
+bpf_lsm_inode_invalidate_secctx
+bpf_lsm_inode_notifysecctx
+bpf_lsm_inode_setsecctx
+bpf_lsm_inode_getsecctx
+bpf_lsm_post_notification
+bpf_lsm_watch_key
+bpf_lsm_unix_stream_connect
+bpf_lsm_unix_may_send
+bpf_lsm_socket_create
+bpf_lsm_socket_post_create
+bpf_lsm_socket_socketpair
+bpf_lsm_socket_bind
+bpf_lsm_socket_connect
+bpf_lsm_socket_listen
+bpf_lsm_socket_accept
+bpf_lsm_socket_sendmsg
+bpf_lsm_socket_recvmsg
+bpf_lsm_socket_getsockname
+bpf_lsm_socket_getpeername
+bpf_lsm_socket_getsockopt
+bpf_lsm_socket_setsockopt
+bpf_lsm_socket_shutdown
+bpf_lsm_socket_sock_rcv_skb
+bpf_lsm_socket_getpeersec_stream
+bpf_lsm_socket_getpeersec_dgram
+bpf_lsm_sk_alloc_security
+bpf_lsm_sk_free_security
+bpf_lsm_sk_clone_security
+bpf_lsm_sk_getsecid
+bpf_lsm_sock_graft
+bpf_lsm_inet_conn_request
+bpf_lsm_inet_csk_clone
+bpf_lsm_inet_conn_established
+bpf_lsm_secmark_relabel_packet
+bpf_lsm_secmark_refcount_inc
+bpf_lsm_secmark_refcount_dec
+bpf_lsm_req_classify_flow
+bpf_lsm_tun_dev_alloc_security
+bpf_lsm_tun_dev_free_security
+bpf_lsm_tun_dev_create
+bpf_lsm_tun_dev_attach_queue
+bpf_lsm_tun_dev_attach
+bpf_lsm_tun_dev_open
+bpf_lsm_sctp_assoc_request
+bpf_lsm_sctp_bind_connect
+bpf_lsm_sctp_sk_clone
+bpf_lsm_ib_pkey_access
+bpf_lsm_ib_endport_manage_subnet
+bpf_lsm_ib_alloc_security
+bpf_lsm_ib_free_security
+bpf_lsm_xfrm_policy_alloc_security
+bpf_lsm_xfrm_policy_clone_security
+bpf_lsm_xfrm_policy_free_security
+bpf_lsm_xfrm_policy_delete_security
+bpf_lsm_xfrm_state_alloc
+bpf_lsm_xfrm_state_alloc_acquire
+bpf_lsm_xfrm_state_free_security
+bpf_lsm_xfrm_state_delete_security
+bpf_lsm_xfrm_policy_lookup
+bpf_lsm_xfrm_state_pol_flow_match
+bpf_lsm_xfrm_decode_session
+bpf_lsm_key_alloc
+bpf_lsm_key_free
+bpf_lsm_key_permission
+bpf_lsm_key_getsecurity
+bpf_lsm_audit_rule_init
+bpf_lsm_audit_rule_known
+bpf_lsm_audit_rule_match
+bpf_lsm_audit_rule_free
+bpf_lsm_bpf
+bpf_lsm_bpf_map
+bpf_lsm_bpf_prog
+bpf_lsm_bpf_map_alloc_security
+bpf_lsm_bpf_map_free_security
+bpf_lsm_bpf_prog_alloc_security
+bpf_lsm_bpf_prog_free_security
+bpf_lsm_locked_down
+bpf_lsm_perf_event_open
+bpf_lsm_perf_event_alloc
+bpf_lsm_perf_event_free
+bpf_lsm_perf_event_read
+bpf_lsm_perf_event_write
+bpf_lsm_verify_prog
+static_call_site_cmp
+static_call_site_swap
+static_call_del_module
+__static_call_update
+__static_call_init.part.0
+static_call_module_notify
+static_call_text_reserved
+perf_get_aux
+perf_aux_output_flag
+perf_output_put_handle
+perf_aux_output_skip
+perf_mmap_alloc_page
+__rb_free_aux
+perf_mmap_free_page
+perf_output_copy
+perf_output_begin_forward
+perf_output_begin_backward
+perf_output_begin
+perf_output_skip
+perf_output_end
+perf_output_copy_aux
+rb_alloc_aux
+rb_free_aux
+perf_aux_output_begin
+perf_aux_output_end
+rb_alloc
+rb_free
+perf_mmap_to_page
+release_callchain_buffers_rcu
+release_callchain_buffers_rcu
+release_callchain_buffers_rcu
+get_callchain_buffers
+put_callchain_buffers
+get_callchain_entry
+put_callchain_entry
+get_perf_callchain
+perf_event_max_stack_handler
+hw_breakpoint_del
+register_user_hw_breakpoint
+hw_breakpoint_start
+hw_breakpoint_stop
+hw_breakpoint_add
+unregister_hw_breakpoint
+unregister_wide_hw_breakpoint
+register_wide_hw_breakpoint
+hw_breakpoint_parse
+hw_breakpoint_weight
+task_bp_pinned.constprop.0
+toggle_bp_slot.constprop.0
+arch_reserve_bp_slot
+__reserve_bp_slot
+arch_release_bp_slot
+__release_bp_slot.isra.0
+arch_unregister_hw_breakpoint
+reserve_bp_slot
+release_bp_slot
+bp_perf_event_destroy
+dbg_reserve_bp_slot
+dbg_release_bp_slot
+register_perf_hw_breakpoint
+hw_breakpoint_event_init
+modify_user_hw_breakpoint_check
+modify_user_hw_breakpoint
+valid_ref_ctr_vma
+find_node_in_range
+copy_from_page
+copy_to_page
+delayed_uprobe_delete
+filter_chain
+delayed_uprobe_remove.part.0
+put_uprobe
+get_utask
+xol_free_insn_slot
+vma_has_uprobes
+__find_uprobe
+find_uprobe
+__update_ref_ctr
+update_ref_ctr
+__replace_page
+is_swbp_insn
+is_trap_insn
+prepare_uprobe
+uprobe_write_opcode
+set_swbp
+install_breakpoint.part.0
+set_orig_insn
+register_for_each_vma
+__uprobe_unregister
+uprobe_unregister
+__uprobe_register
+uprobe_register
+uprobe_register_refctr
+uprobe_apply
+uprobe_mmap
+uprobe_munmap
+uprobe_clear_state
+uprobe_start_dup_mmap
+uprobe_end_dup_mmap
+uprobe_dup_mmap
+arch_uprobe_copy_ixol
+__create_xol_area
+dup_xol_work
+uprobe_get_swbp_addr
+uprobe_get_trap_addr
+uprobe_free_utask
+uprobe_copy_process
+uprobe_deny_signal
+arch_uprobe_ignore
+arch_uprobe_ignore
+uprobe_notify_resume
+uprobe_pre_sstep_notifier
+uprobe_post_sstep_notifier
+user_return_notifier_unregister
+user_return_notifier_register
+fire_user_return_notifiers
+padata_sysfs_show
+padata_sysfs_store
+padata_free_pd
+show_cpumask
+padata_sysfs_release
+padata_free
+padata_free_shell
+padata_validate_cpumask
+padata_alloc_pd
+padata_replace
+padata_cpu_dead
+padata_alloc_shell
+padata_cpu_online
+padata_setup_cpumasks
+padata_set_cpumask
+store_cpumask
+padata_alloc
+padata_parallel_worker
+padata_serial_worker
+padata_do_parallel
+padata_find_next
+padata_reorder
+invoke_padata_reorder
+padata_do_serial
+static_key_count
+jump_label_swap
+jump_label_del_module
+__jump_label_update
+jump_label_update
+__static_key_deferred_flush
+jump_label_rate_limit
+static_key_enable_cpuslocked
+static_key_enable
+static_key_disable_cpuslocked
+static_key_disable
+static_key_slow_try_dec
+jump_label_cmp
+__static_key_slow_dec_deferred
+__static_key_slow_dec_cpuslocked
+jump_label_update_timeout
+static_key_slow_dec
+jump_label_module_notify
+jump_label_lock
+jump_label_unlock
+static_key_slow_inc_cpuslocked
+static_key_slow_inc
+static_key_slow_dec_cpuslocked
+static_key_slow_dec_cpuslocked
+jump_label_apply_nops
+jump_label_text_reserved
+memunmap
+devm_memremap_match
+devm_memremap_release
+memremap
+devm_memremap
+devm_memunmap
+__traceiter_rseq_update
+__traceiter_rseq_ip_fixup
+__ia32_sys_rseq
+__x64_sys_rseq
+__rseq_handle_notify_resume
+watch_queue_pipe_buf_release
+__put_watch_queue
+get_watch_queue
+put_watch_queue
+free_watch
+post_one_notification
+__post_watch_notification
+add_watch_to_object
+remove_watch_from_object
+watch_queue_set_size
+watch_queue_set_filter
+init_watch
+watch_queue_clear
+watch_queue_init
+restrict_link_by_builtin_and_secondary_trusted
+restrict_link_by_builtin_trusted
+verify_pkcs7_message_sig
+verify_pkcs7_signature
+blacklist_free_preparse
+blacklist_preparse
+blacklist_describe
+is_hash_blacklisted
+is_binary_blacklisted
+blacklist_vet_description
+mark_hash_blacklisted
+filemap_check_errors
+add_page_wait_queue
+__traceiter_mm_filemap_delete_from_page_cache
+__traceiter_mm_filemap_add_to_page_cache
+__traceiter_filemap_set_wb_err
+__traceiter_file_check_and_advance_wb_err
+pagecache_write_begin
+pagecache_write_end
+filemap_range_has_page
+__filemap_fdatawait_range
+filemap_fdatawait_range
+filemap_fdatawait_range_keep_errors
+filemap_fdatawait_keep_errors
+file_check_and_advance_wb_err
+file_fdatawait_range
+wake_page_function
+wake_up_page_bit
+page_cache_prev_miss
+generic_file_mmap
+generic_file_readonly_mmap
+__page_cache_alloc
+try_to_release_page
+dio_warn_stale_pagecache.part.0
+unlock_page
+generic_perform_write
+page_cache_next_miss
+__filemap_set_wb_err
+__wait_on_page_locked_async
+unaccount_page_cache_page
+page_cache_free_page
+end_page_writeback
+page_endio
+wait_on_page_bit_killable
+wait_on_page_bit
+replace_page_cache_page
+__lock_page_killable
+__lock_page
+filemap_page_mkwrite
+filemap_map_pages
+find_get_pages_contig
+find_get_pages_range_tag
+__add_to_page_cache_locked
+add_to_page_cache_locked
+add_to_page_cache_lru
+__delete_from_page_cache
+delete_from_page_cache
+delete_from_page_cache_batch
+__filemap_fdatawrite_range
+filemap_fdatawrite
+filemap_flush
+filemap_fdatawrite_range
+filemap_write_and_wait_range
+file_write_and_wait_range
+put_and_wait_on_page_locked
+__lock_page_async
+__lock_page_or_retry
+find_get_entry
+pagecache_get_page
+generic_file_buffered_read
+generic_file_read_iter
+do_read_cache_page
+read_cache_page
+read_cache_page_gfp
+filemap_fault
+grab_cache_page_write_begin
+find_lock_entry
+find_get_entries
+find_get_pages_range
+dio_warn_stale_pagecache
+generic_file_direct_write
+__generic_file_write_iter
+generic_file_write_iter
+mempool_kfree
+mempool_free
+mempool_alloc_slab
+mempool_free_slab
+mempool_alloc_pages
+mempool_free_pages
+remove_element
+mempool_exit
+mempool_destroy
+mempool_alloc
+mempool_init_node
+mempool_init
+mempool_create_node
+mempool_create
+mempool_resize
+mempool_kmalloc
+__traceiter_oom_score_adj_update
+__traceiter_reclaim_retry_zone
+__traceiter_mark_victim
+__traceiter_wake_reaper
+__traceiter_start_task_reaping
+__traceiter_finish_task_reaping
+__traceiter_skip_task_reaping
+__traceiter_compact_retry
+register_oom_notifier
+unregister_oom_notifier
+oom_cpuset_eligible
+mark_oom_victim
+task_will_free_mem
+wake_oom_reaper
+find_lock_task_mm
+dump_task
+dump_header
+oom_badness.part.0
+oom_evaluate_task
+__oom_kill_process
+oom_kill_process
+oom_kill_memcg_member
+oom_badness
+process_shares_mm
+__oom_reap_task_mm
+oom_reaper
+exit_oom_victim
+oom_killer_disable
+out_of_memory
+pagefault_out_of_memory
+generic_fadvise
+vfs_fadvise
+ksys_fadvise64_64
+__x64_sys_fadvise64_64
+__ia32_sys_fadvise64_64
+__x64_sys_fadvise64
+__ia32_sys_fadvise64
+copy_from_user_nofault
+copy_to_user_nofault
+copy_from_kernel_nofault
+strncpy_from_kernel_nofault
+strncpy_from_user_nofault
+strnlen_user_nofault
+pos_ratio_polynom
+bdi_set_max_ratio
+domain_dirty_limits
+wb_domain_writeout_inc
+writeout_period
+__wb_calc_thresh
+__writepage
+set_page_dirty
+set_page_dirty_lock
+dirty_poll_interval.part.0
+wait_on_page_writeback
+wait_for_stable_page
+global_dirtyable_memory
+tag_pages_for_writeback
+domain_update_bandwidth
+wb_update_dirty_ratelimit
+__wb_update_bandwidth
+wb_position_ratio
+__test_set_page_writeback
+balance_dirty_pages
+balance_dirty_pages_ratelimited
+account_page_cleaned.part.0
+__cancel_dirty_page
+wb_writeout_inc
+account_page_redirty
+clear_page_dirty_for_io
+write_cache_pages
+generic_writepages
+write_one_page
+global_dirty_limits
+node_dirty_ok
+dirty_background_ratio_handler
+dirty_background_bytes_handler
+wb_domain_init
+wb_domain_exit
+bdi_set_min_ratio
+wb_calc_thresh
+wb_update_bandwidth
+wb_over_bg_thresh
+dirty_writeback_centisecs_handler
+laptop_mode_timer_fn
+laptop_io_completion
+laptop_sync_completion
+writeback_set_ratelimit
+dirty_ratio_handler
+dirty_bytes_handler
+page_writeback_cpu_online
+do_writepages
+__set_page_dirty_no_writeback
+account_page_dirtied
+__set_page_dirty_nobuffers
+redirty_page_for_writepage
+account_page_cleaned
+test_clear_page_writeback
+file_ra_state_init
+read_cache_pages_invalidate_page
+read_cache_pages
+read_pages
+page_cache_ra_unbounded
+do_page_cache_ra
+ondemand_readahead
+page_cache_async_ra
+force_page_cache_ra
+page_cache_sync_ra
+ksys_readahead
+__x64_sys_readahead
+__ia32_sys_readahead
+__traceiter_mm_lru_insertion
+__traceiter_mm_lru_activate
+get_kernel_pages
+get_kernel_page
+pagevec_lookup_range
+pagevec_lookup_range_tag
+pagevec_lookup_range_nr_tag
+lru_lazyfree_fn
+__page_cache_release
+__put_compound_page
+__put_page
+put_devmap_managed_page
+release_pages
+pagevec_lru_move_fn
+pagevec_move_tail
+mark_page_accessed
+lru_cache_add
+put_pages_list
+pagevec_move_tail_fn
+__pagevec_lru_add_fn
+lru_deactivate_file_fn
+__activate_page
+lru_deactivate_fn
+rotate_reclaimable_page
+lru_note_cost
+lru_note_cost_page
+lru_cache_add_inactive_or_unevictable
+lru_add_drain_cpu
+lru_add_drain_per_cpu
+__pagevec_release
+deactivate_file_page
+deactivate_page
+mark_page_lazyfree
+lru_add_drain
+lru_add_drain_cpu_zone
+lru_add_drain_all
+lru_add_page_tail
+__pagevec_lru_add
+pagevec_lookup_entries
+pagevec_remove_exceptionals
+truncate_cleanup_page
+generic_error_remove_page
+truncate_exceptional_pvec_entries.part.0
+invalidate_inode_pages2_range
+invalidate_inode_pages2
+pagecache_isize_extended
+do_invalidatepage
+truncate_inode_page
+truncate_inode_pages_range
+truncate_inode_pages
+truncate_inode_pages_final
+truncate_pagecache
+truncate_setsize
+truncate_pagecache_range
+invalidate_inode_page
+__invalidate_mapping_pages
+invalidate_mapping_pages
+invalidate_mapping_pagevec
+__traceiter_mm_vmscan_kswapd_sleep
+__traceiter_mm_vmscan_kswapd_wake
+__traceiter_mm_vmscan_wakeup_kswapd
+__traceiter_mm_vmscan_direct_reclaim_begin
+__traceiter_mm_vmscan_memcg_reclaim_begin
+__traceiter_mm_vmscan_memcg_softlimit_reclaim_begin
+__traceiter_mm_vmscan_direct_reclaim_end
+__traceiter_mm_vmscan_memcg_reclaim_end
+__traceiter_mm_vmscan_memcg_softlimit_reclaim_end
+__traceiter_mm_shrink_slab_start
+__traceiter_mm_shrink_slab_end
+__traceiter_mm_vmscan_lru_isolate
+__traceiter_mm_vmscan_writepage
+__traceiter_mm_vmscan_lru_shrink_inactive
+__traceiter_mm_vmscan_lru_shrink_active
+__traceiter_mm_vmscan_inactive_list_is_low
+__traceiter_mm_vmscan_node_reclaim_begin
+__traceiter_mm_vmscan_node_reclaim_end
+set_task_reclaim_state
+do_shrink_slab
+node_pagecache_reclaimable
+unregister_memcg_shrinker
+unregister_shrinker
+pgdat_balanced
+pageout
+shrink_slab
+inactive_is_low
+snapshot_refaults
+__remove_mapping
+shrink_page_list
+prepare_kswapd_sleep
+check_move_unevictable_pages
+move_pages_to_lru
+zone_reclaimable_pages
+allow_direct_reclaim.part.0
+throttle_direct_reclaim
+lruvec_lru_size
+prealloc_shrinker
+free_prealloced_shrinker
+register_shrinker_prepared
+register_shrinker
+drop_slab_node
+drop_slab
+remove_mapping
+putback_lru_page
+reclaim_clean_pages_from_list
+__isolate_lru_page
+isolate_lru_pages
+shrink_inactive_list
+shrink_active_list
+shrink_lruvec
+shrink_node
+do_try_to_free_pages
+__node_reclaim
+balance_pgdat
+kswapd
+isolate_lru_page
+reclaim_pages
+try_to_free_pages
+mem_cgroup_shrink_node
+try_to_free_mem_cgroup_pages
+wakeup_kswapd
+shrink_all_memory
+kswapd_run
+kswapd_stop
+node_reclaim
+shmem_get_parent
+shmem_unused_huge_count
+shmem_match
+shmem_get_unmapped_area
+shmem_replace_entry
+shmem_get_policy
+shmem_confirm_swap
+shmem_punch_compound
+shmem_set_policy
+synchronous_wake_function
+shmem_seek_hole_data
+shmem_get_tree
+shmem_xattr_handler_set
+shmem_xattr_handler_get
+shmem_statfs
+shmem_free_fc
+shmem_free_in_core_inode
+shmem_destroy_inode
+shmem_alloc_inode
+shmem_fh_to_dentry
+shmem_listxattr
+shmem_file_llseek
+shmem_put_super
+shmem_parse_options
+shmem_init_inode
+shmem_enabled_store
+shmem_enabled_show
+shmem_initxattrs
+shmem_pseudo_vma_init
+shmem_swapin
+shmem_alloc_page
+shmem_alloc_hugepage
+shmem_parse_one
+shmem_show_options
+shmem_init_fs_context
+shmem_mmap
+shmem_recalc_inode
+shmem_alloc_and_acct_page
+shmem_add_to_page_cache
+shmem_free_swap
+shmem_free_inode
+shmem_unlink
+shmem_rmdir
+shmem_put_link
+shmem_getattr
+shmem_write_end
+shmem_encode_fh
+shmem_mfill_atomic_pte
+shmem_unused_huge_shrink
+shmem_unused_huge_scan
+shmem_reserve_inode
+shmem_get_inode
+shmem_tmpfile
+shmem_mknod
+shmem_rename2
+shmem_mkdir
+shmem_create
+__shmem_file_setup.part.0
+shmem_file_setup
+shmem_file_setup_with_mnt
+shmem_fill_super
+shmem_link
+shmem_reconfigure
+shmem_writepage
+shmem_swapin_page
+shmem_getpage_gfp
+shmem_read_mapping_page_gfp
+shmem_fault
+shmem_write_begin
+shmem_undo_range
+shmem_truncate_range
+shmem_evict_inode
+shmem_setattr
+shmem_symlink
+shmem_get_link
+shmem_fallocate
+shmem_file_read_iter
+shmem_unuse_inode
+shmem_getpage
+vma_is_shmem
+shmem_charge
+shmem_uncharge
+shmem_partial_swap_usage
+shmem_swap_usage
+shmem_unlock_mapping
+shmem_unuse
+shmem_lock
+shmem_mapping
+shmem_mcopy_atomic_pte
+shmem_mfill_zeropage_pte
+shmem_huge_enabled
+shmem_kernel_file_setup
+shmem_zero_setup
+kmemdup_nul
+kfree_const
+kstrdup
+kstrdup_const
+kstrndup
+page_mapping
+memdup_user_nul
+__account_locked_vm
+kvmalloc_node
+kvfree
+vmemdup_user
+kvfree_sensitive
+__page_mapcount
+sync_overcommit_as
+vm_memory_committed
+account_locked_vm
+page_mapped
+memdup_user
+strndup_user
+__vma_link_list
+__vma_unlink_list
+vma_is_stack_for_current
+randomize_stack_top
+vm_mmap_pgoff
+vm_mmap
+page_rmapping
+page_anon_vma
+page_mapping_file
+overcommit_ratio_handler
+overcommit_policy_handler
+overcommit_kbytes_handler
+vm_commit_limit
+__vm_enough_memory
+get_cmdline
+memcmp_pages
+first_online_pgdat
+next_online_pgdat
+next_zone
+__next_zones_zonelist
+lruvec_init
+page_cpupid_xchg_last
+frag_stop
+dec_zone_page_state
+dec_node_page_state
+fold_diff
+vmstat_next
+sum_vm_events
+all_vm_events
+frag_next
+frag_start
+__mod_zone_page_state
+__mod_node_page_state
+fill_contig_page_info
+refresh_cpu_vm_stats
+refresh_vm_stats
+need_update
+pagetypeinfo_showfree_print
+frag_show_print
+vmstat_show
+vmstat_stop
+pagetypeinfo_showblockcount_print
+vmstat_cpu_down_prep
+vmstat_shepherd
+vmstat_update
+extfrag_open
+walk_zones_in_node.constprop.0
+pagetypeinfo_show
+unusable_show
+extfrag_show
+zoneinfo_show
+frag_show
+zoneinfo_show_print
+vmstat_start
+unusable_open
+unusable_show_print
+__fragmentation_index
+extfrag_show_print
+mod_zone_page_state
+inc_zone_page_state
+mod_node_page_state
+inc_node_page_state
+sysctl_vm_numa_stat_handler
+vm_events_fold_cpu
+calculate_pressure_threshold
+calculate_normal_threshold
+refresh_zone_stat_thresholds
+vmstat_cpu_online
+vmstat_cpu_dead
+set_pgdat_percpu_threshold
+__inc_zone_state
+__inc_zone_page_state
+__inc_node_state
+__inc_node_page_state
+__dec_zone_state
+__dec_zone_page_state
+__dec_node_state
+__dec_node_page_state
+inc_node_state
+cpu_vm_stats_fold
+drain_zonestat
+__inc_numa_state
+sum_zone_node_page_state
+sum_zone_numa_state
+node_page_state_pages
+node_page_state
+extfrag_for_order
+fragmentation_index
+vmstat_refresh
+quiet_vmstat
+max_ratio_store
+min_ratio_store
+bdi_dev_name
+max_ratio_show
+min_ratio_show
+read_ahead_kb_show
+read_ahead_kb_store
+cgwb_release
+cgwb_kill
+bdi_debug_stats_open
+bdi_debug_stats_show
+clear_bdi_congested
+congestion_wait
+wait_iff_congested
+stable_pages_required_show
+set_bdi_congested
+wb_get_lookup.part.0
+wb_shutdown
+wb_wakeup_delayed
+wb_get_lookup
+wb_memcg_offline
+wb_blkcg_offline
+bdi_get_by_id
+bdi_register_va
+bdi_register
+bdi_set_owner
+bdi_unregister
+release_bdi
+wb_init
+cgwb_bdi_init
+bdi_alloc
+bdi_put
+wb_exit
+cgwb_release_workfn
+wb_get_create
+mm_compute_batch
+__traceiter_percpu_alloc_percpu
+__traceiter_percpu_free_percpu
+__traceiter_percpu_alloc_percpu_fail
+__traceiter_percpu_create_chunk
+__traceiter_percpu_destroy_chunk
+__pcpu_chunk_move
+pcpu_chunk_relocate
+pcpu_next_md_free_region
+pcpu_block_update
+pcpu_chunk_refresh_hint
+pcpu_init_md_blocks
+pcpu_chunk_populated
+pcpu_free_area
+pcpu_mem_zalloc
+pcpu_get_pages
+pcpu_free_chunk.part.0
+pcpu_free_pages.isra.0
+pcpu_populate_chunk
+pcpu_schedule_balance_work
+pcpu_next_fit_region.constprop.0
+pcpu_find_block_fit
+pcpu_block_refresh_hint
+pcpu_block_update_hint_alloc
+pcpu_create_chunk
+pcpu_balance_workfn
+free_percpu
+pcpu_alloc_area
+pcpu_memcg_post_alloc_hook.part.0
+pcpu_alloc
+__alloc_percpu_gfp
+__alloc_percpu
+__alloc_reserved_percpu
+__is_kernel_percpu_address
+is_kernel_percpu_address
+per_cpu_ptr_to_phys
+pcpu_nr_pages
+should_failslab
+__traceiter_kmalloc
+__traceiter_kmem_cache_alloc
+__traceiter_kmalloc_node
+__traceiter_kmem_cache_alloc_node
+__traceiter_kfree
+__traceiter_kmem_cache_free
+__traceiter_mm_page_free
+__traceiter_mm_page_free_batched
+__traceiter_mm_page_alloc
+__traceiter_mm_page_alloc_zone_locked
+__traceiter_mm_page_pcpu_drain
+__traceiter_mm_page_alloc_extfrag
+__traceiter_rss_stat
+kmem_cache_size
+slab_stop
+slab_caches_to_rcu_destroy_workfn
+kmem_cache_destroy
+kmem_cache_shrink
+slab_start
+slab_next
+slabinfo_open
+slab_show
+ksize
+krealloc
+kfree_sensitive
+kmem_cache_create_usercopy
+kmem_cache_create
+__kmem_cache_free_bulk
+__kmem_cache_alloc_bulk
+slab_unmergeable
+find_mergeable
+slab_kmem_cache_release
+slab_is_available
+kmalloc_slab
+kmalloc_order
+kmalloc_order_trace
+cache_random_seq_create
+cache_random_seq_destroy
+dump_unreclaimable_slab
+memcg_slab_show
+move_freelist_tail
+__traceiter_mm_compaction_isolate_migratepages
+__traceiter_mm_compaction_isolate_freepages
+__traceiter_mm_compaction_migratepages
+__traceiter_mm_compaction_begin
+__traceiter_mm_compaction_end
+__traceiter_mm_compaction_try_to_compact_pages
+__traceiter_mm_compaction_finished
+__traceiter_mm_compaction_suitable
+__traceiter_mm_compaction_deferred
+__traceiter_mm_compaction_defer_compaction
+__traceiter_mm_compaction_defer_reset
+__traceiter_mm_compaction_kcompactd_sleep
+__traceiter_mm_compaction_wakeup_kcompactd
+__traceiter_mm_compaction_kcompactd_wake
+__SetPageMovable
+__ClearPageMovable
+compaction_free
+pageblock_skip_persistent
+split_map_pages
+release_freepages
+__compaction_suitable
+fragmentation_score_zone
+kcompactd_cpu_online
+update_cached_migrate
+compact_lock_irqsave
+PageMovable
+compact_unlock_should_abort
+isolate_freepages_block
+isolate_migratepages_block
+compaction_alloc
+__reset_isolation_pfn
+__reset_isolation_suitable
+defer_compaction
+compaction_deferred
+compaction_defer_reset
+compaction_restarting
+reset_isolation_suitable
+isolate_freepages_range
+isolate_migratepages_range
+compaction_suitable
+compact_zone
+compact_zone_order
+compact_node
+sysfs_compact_node
+proactive_compact_node
+kcompactd_do_work
+kcompactd
+compaction_zonelist_suitable
+try_to_compact_pages
+sysctl_compaction_handler
+compaction_register_node
+compaction_unregister_node
+wakeup_kcompactd
+kcompactd_run
+kcompactd_stop
+vmacache_update
+vmacache_find
+vma_interval_tree_augment_rotate
+vma_interval_tree_subtree_search
+__anon_vma_interval_tree_augment_rotate
+__anon_vma_interval_tree_subtree_search
+vma_interval_tree_insert
+vma_interval_tree_remove
+vma_interval_tree_iter_first
+vma_interval_tree_iter_next
+vma_interval_tree_insert_after
+anon_vma_interval_tree_insert
+anon_vma_interval_tree_remove
+anon_vma_interval_tree_iter_first
+anon_vma_interval_tree_iter_next
+kvfree_rcu_local
+list_lru_isolate
+list_lru_isolate_move
+list_lru_count_node
+list_lru_count_one
+__list_lru_walk_one
+__memcg_init_list_lru_node
+memcg_destroy_list_lru_node
+list_lru_destroy
+__list_lru_init
+list_lru_walk_one
+list_lru_walk_node
+list_lru_add
+list_lru_del
+list_lru_walk_one_irq
+memcg_update_all_list_lrus
+memcg_drain_all_list_lrus
+scan_shadow_nodes
+workingset_update_node
+shadow_lru_isolate
+count_shadow_nodes
+workingset_age_nonresident
+workingset_eviction
+workingset_refault
+workingset_activation
+__dump_page
+dump_page
+is_valid_gup_flags
+fixup_user_fault
+try_grab_compound_head
+unpin_user_page
+unpin_user_pages
+unpin_user_pages_dirty_lock
+undo_dev_pagemap
+put_compound_head
+try_grab_page
+follow_page_pte
+follow_page_mask
+__get_user_pages
+get_user_pages_locked
+pin_user_pages_locked
+get_user_pages_unlocked
+pin_user_pages_unlocked
+__gup_longterm_locked
+get_user_pages
+pin_user_pages
+__get_user_pages_remote
+get_user_pages_remote
+pin_user_pages_remote
+__gup_device_huge
+internal_get_user_pages_fast
+get_user_pages_fast_only
+get_user_pages_fast
+pin_user_pages_fast
+pin_user_pages_fast_only
+follow_page
+populate_vma_page_range
+__mm_populate
+get_dump_page
+fault_around_bytes_get
+fault_around_bytes_fops_open
+clear_subpage
+fault_around_bytes_set
+fault_dirty_shared_page
+add_mm_counter_fast
+pmd_devmap_trans_unstable
+do_page_mkwrite
+copy_subpage
+__do_fault
+print_bad_pte
+__follow_pte_pmd
+follow_pte_pmd
+follow_pfn
+wp_page_copy
+mm_trace_rss_stat
+sync_mm_rss
+free_pgd_range
+free_pgtables
+__pte_alloc
+__pte_alloc_kernel
+vm_normal_page
+vm_normal_page_pmd
+unmap_page_range
+unmap_single_vma
+zap_page_range
+zap_page_range_single
+zap_vma_ptes
+unmap_vmas
+finish_mkwrite_fault
+do_wp_page
+unmap_mapping_pages
+unmap_mapping_range
+do_swap_page
+alloc_set_pte
+finish_fault
+__p4d_alloc
+__pud_alloc
+__pmd_alloc
+__get_locked_pte
+vm_insert_page
+vm_insert_pages
+__vm_map_pages
+vm_map_pages
+vm_map_pages_zero
+insert_pfn
+vmf_insert_pfn_prot
+vmf_insert_pfn
+__vm_insert_mixed
+vmf_insert_mixed_prot
+vmf_insert_mixed
+vmf_insert_mixed_mkwrite
+__apply_to_page_range
+apply_to_page_range
+apply_to_existing_page_range
+remap_pfn_range
+vm_iomap_memory
+copy_page_range
+handle_mm_fault
+follow_phys
+generic_access_phys
+__access_remote_vm
+access_process_vm
+access_remote_vm
+print_vma_addr
+clear_huge_page
+copy_user_huge_page
+copy_huge_page_from_user
+mincore_hugetlb
+mincore_page
+__mincore_unmapped_range
+mincore_unmapped_range
+__x64_sys_mincore
+__ia32_sys_mincore
+mincore_pte_range
+can_do_mlock.part.0
+can_do_mlock
+__munlock_isolate_lru_page
+__munlock_isolation_failed
+__munlock_isolated_page
+__munlock_pagevec
+clear_page_mlock
+mlock_vma_page
+munlock_vma_page
+munlock_vma_pages_range
+mlock_fixup
+apply_vma_lock_flags
+do_mlock
+__x64_sys_mlock
+__ia32_sys_mlock
+__x64_sys_mlock2
+__ia32_sys_mlock2
+__ia32_sys_munlock
+__x64_sys_munlock
+apply_mlockall_flags
+__ia32_sys_mlockall
+__do_sys_munlockall
+__x64_sys_mlockall
+user_shm_lock
+user_shm_unlock
+vm_get_page_prot
+vm_pgprot_modify
+special_mapping_close
+__traceiter_vm_unmapped_area
+vma_gap_callbacks_rotate
+special_mapping_name
+special_mapping_fault
+special_mapping_mremap
+__remove_shared_vm_struct
+__vma_link_file
+anon_vma_compatible
+get_unmapped_area
+find_vma
+remove_vma
+can_vma_merge_before.part.0
+vm_lock_mapping.isra.0
+unmap_region
+init_user_reserve
+init_admin_reserve
+reserve_mem_notifier
+__vma_rb_erase
+unlink_file_vma
+__vma_link_rb
+vma_link
+__vma_adjust
+vma_merge
+find_mergeable_anon_vma
+ksys_mmap_pgoff
+__x64_sys_mmap_pgoff
+__ia32_sys_mmap_pgoff
+vma_wants_writenotify
+vma_set_page_prot
+vm_unmapped_area
+find_vma_prev
+__split_vma
+split_vma
+__do_munmap
+__vm_munmap
+vm_munmap
+__x64_sys_munmap
+__ia32_sys_munmap
+do_munmap
+exit_mmap
+insert_vm_struct
+__install_special_mapping
+copy_vma
+may_expand_vm
+expand_downwards
+expand_stack
+find_extend_vma
+do_brk_flags
+vm_brk_flags
+vm_brk
+__ia32_sys_brk
+__x64_sys_brk
+mmap_region
+do_mmap
+__ia32_sys_remap_file_pages
+__x64_sys_remap_file_pages
+vm_stat_account
+vma_is_special_mapping
+_install_special_mapping
+install_special_mapping
+mm_drop_all_locks
+mm_take_all_locks
+tlb_remove_table_smp_sync
+tlb_remove_table_rcu
+tlb_table_flush
+__tlb_remove_page_size
+tlb_remove_table
+tlb_flush_mmu
+tlb_gather_mmu
+tlb_finish_mmu
+prot_none_test
+prot_none_hugetlb_entry
+__ia32_sys_pkey_alloc
+__ia32_sys_pkey_free
+__x64_sys_pkey_free
+prot_none_pte_entry
+__x64_sys_pkey_alloc
+change_protection
+mprotect_fixup
+do_mprotect_pkey
+__x64_sys_mprotect
+__ia32_sys_mprotect
+__x64_sys_pkey_mprotect
+__ia32_sys_pkey_mprotect
+take_rmap_locks
+drop_rmap_locks
+vma_to_resize
+move_page_tables
+move_vma
+__x64_sys_mremap
+__ia32_sys_mremap
+__ia32_sys_msync
+__x64_sys_msync
+check_pte
+page_vma_mapped_walk
+page_mapped_in_vma
+walk_page_test
+__walk_page_range
+walk_page_range
+walk_page_range_novma
+walk_page_vma
+walk_page_mapping
+pgd_clear_bad
+p4d_clear_bad
+pud_clear_bad
+pmd_clear_bad
+ptep_clear_flush
+pmdp_huge_clear_flush
+pudp_huge_clear_flush
+pgtable_trans_huge_deposit
+pgtable_trans_huge_withdraw
+pmdp_invalidate
+pmdp_collapse_flush
+page_not_mapped
+page_mapcount_is_zero
+invalid_migration_vma
+invalid_mkclean_vma
+anon_vma_ctor
+invalid_page_referenced_vma
+__page_set_anon_rmap
+rmap_walk_anon
+page_mkclean_one
+rmap_walk_file
+page_referenced_one
+page_unlock_anon_vma_read
+try_to_unmap_flush
+try_to_unmap_flush_dirty
+flush_tlb_batched_pending
+page_address_in_vma
+mm_find_pmd
+page_move_anon_rmap
+do_page_add_anon_rmap
+page_add_anon_rmap
+page_add_new_anon_rmap
+page_add_file_rmap
+page_remove_rmap
+try_to_unmap_one
+__put_anon_vma
+unlink_anon_vmas
+anon_vma_clone
+anon_vma_fork
+__anon_vma_prepare
+page_get_anon_vma
+page_lock_anon_vma_read
+rmap_walk
+page_referenced
+page_mkclean
+try_to_munlock
+rmap_walk_locked
+try_to_unmap
+hugepage_add_anon_rmap
+hugepage_add_new_anon_rmap
+is_vmalloc_addr
+register_vmap_purge_notifier
+unregister_vmap_purge_notifier
+free_vmap_area_rb_augment_cb_rotate
+pvm_determine_end_from_reverse
+vmap_pfn_apply
+s_show
+s_next
+s_start
+vmalloc_to_page
+vmalloc_to_pfn
+insert_vmap_area.constprop.0
+s_stop
+find_vmap_area
+remap_vmalloc_range_partial
+remap_vmalloc_range
+insert_vmap_area_augment.constprop.0
+__purge_vmap_area_lazy
+free_vmap_area_noflush
+free_vmap_block
+purge_fragmented_blocks_allcpus
+_vm_unmap_aliases
+vm_unmap_aliases
+purge_vmap_area_lazy
+alloc_vmap_area
+__get_vm_area_node
+pcpu_get_vm_areas
+unmap_kernel_range_noflush
+vm_unmap_ram
+map_kernel_range_noflush
+vm_map_ram
+map_kernel_range
+is_vmalloc_or_module_addr
+vmalloc_nr_pages
+set_iounmap_nonlazy
+unmap_kernel_range
+__get_vm_area_caller
+get_vm_area
+get_vm_area_caller
+find_vm_area
+remove_vm_area
+__vunmap
+free_work
+__vfree
+vfree
+vunmap
+vmap
+free_vm_area
+vmap_pfn
+vfree_atomic
+__vmalloc_node
+__vmalloc_node_range
+vmalloc_user
+vmalloc_32_user
+__vmalloc
+vmalloc
+vzalloc
+vmalloc_node
+vzalloc_node
+vmalloc_32
+vread
+vwrite
+pcpu_free_vm_areas
+ioremap_page_range
+process_vm_rw_core.isra.0
+process_vm_rw
+__x64_sys_process_vm_readv
+__ia32_sys_process_vm_readv
+__x64_sys_process_vm_writev
+__ia32_sys_process_vm_writev
+should_fail_alloc_page
+__get_free_pages
+get_zeroed_page
+kernel_init_free_pages
+bad_page
+adjust_managed_page_count
+check_free_page_bad
+check_new_page_bad
+split_page
+show_mem_node_skip.part.0
+free_unref_page_prepare.part.0
+build_zonerefs_node
+zone_batchsize
+pageset_set_high_and_batch
+__zone_pcp_update
+calculate_totalreserve_pages
+setup_per_zone_lowmem_reserve
+setup_min_unmapped_ratio
+setup_min_slab_ratio
+si_mem_available
+si_meminfo
+nr_free_zone_pages
+nr_free_buffer_pages
+wake_all_kswapds
+free_pcp_prepare
+build_zonelists
+__build_all_zonelists
+pm_restore_gfp_mask
+pm_restrict_gfp_mask
+pm_suspended_storage
+get_pfnblock_flags_mask
+free_one_page
+__free_pages_ok
+free_compound_page
+free_pcppages_bulk
+drain_pages_zone
+drain_pages
+page_alloc_cpu_dead
+free_unref_page_commit
+set_pfnblock_flags_mask
+set_pageblock_migratetype
+prep_compound_page
+prep_new_page
+__free_pages_core
+__pageblock_pfn_to_page
+set_zone_contiguous
+clear_zone_contiguous
+move_freepages_block
+steal_suitable_fallback
+unreserve_highatomic_pageblock
+find_suitable_fallback
+drain_zone_pages
+drain_local_pages
+drain_local_pages_wq
+drain_all_pages
+mark_free_pages
+free_unref_page
+__page_frag_cache_drain
+__free_pages
+free_pages.part.0
+free_pages
+make_alloc_exact
+alloc_pages_exact
+free_pages_exact
+free_contig_range
+alloc_contig_range
+page_frag_free
+free_unref_page_list
+__putback_isolated_page
+__zone_watermark_ok
+zone_watermark_ok
+__isolate_free_page
+get_page_from_freelist
+__alloc_pages_direct_compact
+zone_watermark_ok_safe
+warn_alloc
+__alloc_pages_nodemask
+page_frag_alloc
+gfp_pfmemalloc_allowed
+si_meminfo_node
+show_free_areas
+numa_zonelist_order_handler
+arch_has_descending_max_zone_pfns
+free_reserved_area
+setup_per_zone_wmarks
+min_free_kbytes_sysctl_handler
+watermark_scale_factor_sysctl_handler
+sysctl_min_unmapped_ratio_sysctl_handler
+sysctl_min_slab_ratio_sysctl_handler
+lowmem_reserve_ratio_sysctl_handler
+percpu_pagelist_fraction_sysctl_handler
+has_unmovable_pages
+alloc_contig_pages
+zone_pcp_reset
+__offline_isolated_pages
+is_free_buddy_page
+take_page_off_buddy
+shuffle_show
+shuffle_pick_tail
+should_skip_region
+__next_mem_range
+reset_node_managed_pages
+madvise_cold
+madvise_pageout
+madvise_free_single_vma
+swapin_walk_pmd_entry
+madvise_free_pte_range
+madvise_cold_or_pageout_pte_range
+do_madvise
+__x64_sys_madvise
+__ia32_sys_madvise
+__x64_sys_process_madvise
+__ia32_sys_process_madvise
+end_swap_bio_write
+swap_slot_free_notify
+end_swap_bio_read
+get_swap_bio
+generic_swapfile_activate
+__swap_writepage
+swap_writepage
+swap_readpage
+swap_set_page_dirty
+vma_ra_enabled_store
+vma_ra_enabled_show
+total_swapcache_pages
+show_swap_cache_info
+get_shadow_from_swap_cache
+add_to_swap_cache
+__delete_from_swap_cache
+add_to_swap
+delete_from_swap_cache
+clear_shadow_from_swap_cache
+free_page_and_swap_cache
+free_pages_and_swap_cache
+lookup_swap_cache
+find_get_incore_page
+__read_swap_cache_async
+read_swap_cache_async
+swap_cluster_readahead
+init_swap_address_space
+exit_swap_address_space
+swapin_readahead
+__del_from_avail_list
+inc_cluster_info_page
+swp_entry_cmp
+swaps_poll
+swap_next
+__page_file_index
+setup_swap_info
+__page_file_mapping
+_swap_info_get
+add_swap_extent
+swap_start
+swap_stop
+destroy_swap_extents
+swaps_open
+swap_show
+offset_to_swap_extent
+map_swap_entry
+cluster_list_add_tail.part.0
+__free_cluster
+swap_do_scheduled_discard
+swap_discard_work
+free_cluster
+scan_swap_map_try_ssd_cluster
+add_to_avail_list
+_enable_swap_info
+swap_range_free
+swap_page_trans_huge_swapped
+swap_range_alloc
+swap_count_continued
+__swap_entry_free_locked
+__swap_entry_free
+get_swap_device
+__swap_duplicate
+swap_free
+put_swap_page
+split_swap_cluster
+swapcache_free_entries
+page_swapcount
+__swap_count
+__swp_swapcount
+swp_swapcount
+reuse_swap_page
+try_to_free_swap
+__try_to_reclaim_swap
+scan_swap_map_slots
+get_swap_pages
+get_swap_page_of_type
+free_swap_and_cache
+swap_type_of
+find_first_swap
+swapdev_block
+count_swap_pages
+try_to_unuse
+__x64_sys_swapoff
+__ia32_sys_swapoff
+map_swap_page
+has_usable_swap
+generic_max_swapfile_size
+generic_max_swapfile_size
+__x64_sys_swapon
+__ia32_sys_swapon
+si_swapinfo
+swap_shmem_alloc
+swapcache_prepare
+swp_swap_info
+page_swap_info
+add_swap_count_continuation
+swap_duplicate
+cgroup_throttle_swaprate
+alloc_swap_slot_cache
+drain_slots_cache_cpu.constprop.0
+__drain_swap_slots_cache.constprop.0
+free_slot_cache
+disable_swap_slots_cache_lock
+reenable_swap_slots_cache_unlock
+enable_swap_slots_cache
+free_swap_slot
+get_swap_page
+frontswap_writethrough
+frontswap_tmem_exclusive_gets
+__frontswap_init
+__frontswap_test
+__frontswap_load
+__frontswap_curr_pages
+__frontswap_invalidate_area
+__frontswap_invalidate_page
+frontswap_curr_pages
+frontswap_shrink
+__frontswap_store
+frontswap_register_ops
+zswap_dstmem_dead
+zswap_update_total_size
+zswap_pool_destroy
+zswap_cpu_comp_dead
+zswap_cpu_comp_prepare
+zswap_dstmem_prepare
+zswap_enabled_param_set
+__zswap_pool_current
+zswap_pool_current.part.0
+zswap_pool_create
+zswap_frontswap_init
+__zswap_pool_release
+__zswap_pool_empty
+shrink_worker
+zswap_free_entry
+zswap_entry_put
+zswap_frontswap_invalidate_area
+zswap_frontswap_load
+__zswap_param_set
+zswap_compressor_param_set
+zswap_zpool_param_set
+zswap_frontswap_invalidate_page
+zswap_writeback_entry
+zswap_frontswap_store
+dmam_pool_match
+show_pools
+dma_pool_create
+dma_pool_destroy
+dmam_pool_release
+dma_pool_alloc
+dma_pool_free
+dmam_pool_create
+dmam_pool_destroy
+hugetlb_vm_op_fault
+get_valid_node_allowed
+hugetlb_vm_op_split
+hugetlb_vm_op_pagesize
+vma_kernel_pagesize
+PageHuge
+dequeue_huge_page_nodemask
+kobj_to_node_hstate
+kobj_to_hstate
+vma_hugecache_offset
+linear_hugepage_index
+hstate_next_node_to_alloc
+coalesce_file_region
+surplus_hugepages_show
+resv_hugepages_show
+free_hugepages_show
+nr_overcommit_hugepages_show
+hugetlb_sysfs_add_hstate
+hugetlb_unregister_node
+hugetlb_register_node
+vma_has_reserves
+nr_hugepages_show_common.isra.0
+nr_hugepages_show
+adjust_range_if_pmd_sharing_possible.part.0
+record_hugetlb_cgroup_uncharge_info.constprop.0
+add_reservation_in_range
+nr_hugepages_mempolicy_show
+hugetlb_vm_op_open
+prep_compound_gigantic_page
+make_huge_pte
+allocate_file_region_entries
+is_hugetlb_entry_hwpoisoned
+hugepage_subpool_get_pages.part.0
+region_chg
+prep_new_huge_page
+alloc_fresh_huge_page
+region_add
+nr_overcommit_hugepages_store
+update_and_free_page
+free_pool_huge_page
+return_unused_surplus_pages
+alloc_pool_huge_page
+__nr_hugepages_store_common
+nr_hugepages_store_common
+nr_hugepages_mempolicy_store
+nr_hugepages_store
+hugetlb_sysctl_handler_common
+region_del
+__vma_reservation_common
+restore_reserve_on_error
+alloc_surplus_huge_page
+hugetlb_acct_memory
+hugepage_subpool_put_pages.part.0
+hugepage_new_subpool
+hugepage_put_subpool
+hugetlb_fix_reserve_counts
+vma_mmu_pagesize
+resv_map_alloc
+resv_map_release
+hugetlb_vm_op_close
+reset_vma_resv_huge_pages
+size_to_hstate
+__free_huge_page
+free_hpage_workfn
+page_huge_active
+free_huge_page
+PageHeadHuge
+hugetlb_page_mapping_lock_write
+__basepage_index
+dissolve_free_huge_page
+dissolve_free_huge_pages
+alloc_huge_page_nodemask
+alloc_huge_page_vma
+alloc_huge_page
+hugetlb_sysctl_handler
+hugetlb_mempolicy_sysctl_handler
+hugetlb_overcommit_handler
+hugetlb_report_meminfo
+hugetlb_report_node_meminfo
+hugetlb_show_meminfo
+hugetlb_report_usage
+hugetlb_total_pages
+is_hugetlb_entry_migration
+huge_add_to_page_cache
+hugetlb_fault_mutex_hash
+hugetlb_mcopy_atomic_pte
+hugetlb_reserve_pages
+hugetlb_unreserve_pages
+adjust_range_if_pmd_sharing_possible
+huge_pmd_unshare
+huge_pte_offset
+__unmap_hugepage_range
+__unmap_hugepage_range_final
+unmap_hugepage_range
+hugetlb_cow
+hugetlb_no_page
+hugetlb_change_protection
+huge_pmd_share
+huge_pte_alloc
+copy_hugetlb_page_range
+hugetlb_fault
+follow_hugetlb_page
+follow_huge_addr
+follow_huge_pd
+follow_huge_pmd
+follow_huge_pud
+follow_huge_pgd
+isolate_huge_page
+putback_active_hugepage
+move_hugetlb_state
+mpol_rebind_default
+alloc_page_interleave
+sp_lookup
+sp_insert
+numa_map_to_online_node
+policy_node
+get_task_policy.part.0
+get_vma_policy.part.0
+offset_il_node
+migrate_page_add
+mpol_new_interleave
+mpol_new_bind
+mpol_new_preferred
+get_nodes
+mpol_new
+migrate_to_node
+mpol_rebind_policy
+__mpol_equal.part.0
+do_migrate_pages.part.0
+kernel_migrate_pages
+__x64_sys_migrate_pages
+__ia32_sys_migrate_pages
+__ia32_compat_sys_migrate_pages
+__x32_compat_sys_migrate_pages
+mpol_relative_nodemask
+mpol_set_nodemask.part.0
+mpol_rebind_nodemask
+mpol_rebind_preferred
+get_task_policy
+__mpol_put
+do_set_mempolicy
+kernel_set_mempolicy
+__x64_sys_set_mempolicy
+__ia32_sys_set_mempolicy
+__ia32_compat_sys_set_mempolicy
+__x32_compat_sys_set_mempolicy
+sp_free
+sp_delete
+kernel_get_mempolicy
+__x64_sys_get_mempolicy
+__ia32_sys_get_mempolicy
+__ia32_compat_sys_get_mempolicy
+__x32_compat_sys_get_mempolicy
+mpol_rebind_task
+mpol_rebind_mm
+change_prot_numa
+do_migrate_pages
+vma_migratable
+queue_pages_test_walk
+queue_pages_hugetlb
+queue_pages_pte_range
+__get_vma_policy
+vma_policy_mof
+policy_nodemask
+alloc_pages_vma
+new_page
+alloc_pages_current
+mempolicy_slab_node
+huge_node
+init_nodemask_of_mempolicy
+mempolicy_nodemask_intersects
+__mpol_dup
+do_mbind
+kernel_mbind
+__x64_sys_mbind
+__ia32_sys_mbind
+__ia32_compat_sys_mbind
+__x32_compat_sys_mbind
+vma_dup_policy
+__mpol_equal
+mpol_shared_policy_lookup
+mpol_misplaced
+mpol_put_task_policy
+mpol_set_shared_policy
+mpol_shared_policy_init
+mpol_free_shared_policy
+numa_default_policy
+mpol_parse_str
+mpol_to_str
+subsection_mask_set
+section_deactivate
+__section_nr
+sparse_decode_mem_map
+mem_section_usage_size
+online_mem_sections
+offline_mem_sections
+sparse_remove_section
+mmu_notifier_synchronize
+mmu_notifier_range_update_to_read_only
+mmu_notifier_free_rcu
+mn_itree_inv_start_range
+mmu_interval_read_begin
+mmu_interval_notifier_remove
+__mmu_interval_notifier_insert
+mn_itree_inv_end
+mmu_notifier_put
+mmu_notifier_unregister
+__mmu_notifier_register
+mmu_notifier_register
+mmu_interval_notifier_insert
+mmu_notifier_get_locked
+mmu_interval_notifier_insert_locked
+__mmu_notifier_release
+__mmu_notifier_clear_flush_young
+__mmu_notifier_clear_young
+__mmu_notifier_test_young
+__mmu_notifier_change_pte
+__mmu_notifier_invalidate_range_start
+__mmu_notifier_invalidate_range_end
+__mmu_notifier_invalidate_range
+__mmu_notifier_subscriptions_destroy
+stable_node_chains_prune_millisecs_show
+stable_node_dups_show
+stable_node_chains_show
+max_page_sharing_show
+merge_across_nodes_show
+full_scans_show
+pages_volatile_show
+pages_unshared_show
+pages_sharing_show
+pages_shared_show
+run_show
+pages_to_scan_show
+sleep_millisecs_show
+stable_node_chains_prune_millisecs_store
+pages_to_scan_store
+sleep_millisecs_store
+calc_checksum
+stable_tree_append
+find_mergeable_vma
+alloc_stable_node_chain
+use_zero_pages_store
+use_zero_pages_show
+wait_while_offlining
+write_protect_page
+remove_node_from_stable_tree
+ksm_memory_callback
+break_ksm
+unmerge_ksm_pages
+break_cow
+try_to_merge_one_page
+get_ksm_page
+remove_stable_node
+remove_all_stable_nodes
+max_page_sharing_store
+merge_across_nodes_store
+remove_rmap_item_from_tree
+remove_trailing_rmap_items.isra.0
+run_store
+try_to_merge_with_ksm_page
+__stable_node_chain
+ksm_scan_thread
+__ksm_enter
+ksm_madvise
+__ksm_exit
+ksm_might_need_to_copy
+rmap_walk_ksm
+ksm_migrate_page
+page_poisoning_enabled
+kernel_poison_pages
+count_free
+count_inuse
+count_total
+validate_show
+has_cpu_slab
+count_partial
+slab_attr_show
+slab_attr_store
+parse_slub_debug_flags
+slab_fix
+init_object
+init_cache_random_seq
+set_track
+usersize_show
+remote_node_defrag_ratio_show
+cache_dma_show
+store_user_show
+poison_show
+red_zone_show
+trace_show
+sanity_checks_show
+slabs_cpu_partial_show
+destroy_by_rcu_show
+reclaim_account_show
+hwcache_align_show
+align_show
+aliases_show
+ctor_show
+cpu_partial_show
+min_partial_show
+order_show
+objs_per_slab_show
+object_size_show
+slab_size_show
+remote_node_defrag_ratio_store
+cpu_partial_store
+shrink_store
+min_partial_store
+kmem_cache_release
+free_loc_track
+print_track
+init_tracking.part.0
+setup_object_debug.isra.0
+slab_out_of_memory
+shrink_show
+slab_pad_check.part.0
+get_map
+check_slab
+__ksize
+calculate_sizes.constprop.0
+alloc_loc_track
+kmalloc_large_node
+fixup_red_left
+allocate_slab
+process_slab
+list_locations
+free_calls_show
+alloc_calls_show
+print_tracking
+check_bytes_and_report
+check_object
+alloc_debug_processing
+on_freelist
+validate_slab
+validate_store
+free_debug_processing
+__slab_free
+kfree
+__free_slab
+discard_slab
+deactivate_slab
+unfreeze_partials
+put_cpu_partial
+get_partial_node.part.0
+___slab_alloc
+__slab_alloc
+kmem_cache_alloc
+kmem_cache_alloc_trace
+sysfs_slab_alias
+sysfs_slab_add
+kmem_cache_alloc_node
+kmem_cache_alloc_node_trace
+__kmalloc
+show_slab_objects
+slabs_show
+total_objects_show
+cpu_slabs_show
+partial_show
+objects_partial_show
+objects_show
+__kmalloc_node
+__kmalloc_track_caller
+__kmalloc_node_track_caller
+kmem_cache_alloc_bulk
+slub_cpu_dead
+flush_cpu_slab
+rcu_free_slab
+kmem_cache_free
+free_kmem_cache_nodes
+kmem_cache_free_bulk
+kmem_cache_flags
+__kmem_cache_release
+__kmem_cache_empty
+__kmem_cache_shutdown
+__check_heap_object
+__kmem_cache_shrink
+slab_memory_callback
+__kmem_cache_alias
+__kmem_cache_create
+sysfs_slab_unlink
+sysfs_slab_release
+get_slabinfo
+slabinfo_show_stats
+slabinfo_write
+generic_online_page
+count_system_ram_pages_cb
+check_no_memblock_for_node_cb
+online_memory_block
+register_memory_resource
+check_hotplug_memory_range
+check_memblock_offlined_cb
+restore_online_page_callback
+set_online_page_callback
+try_offline_node
+remove_memory
+offline_and_remove_memory
+do_migrate_range
+__try_online_node
+get_online_mems
+put_online_mems
+mem_hotplug_begin
+mem_hotplug_done
+get_page_bootmem
+put_page_bootmem
+__remove_pages
+zone_for_pfn_range
+try_online_node
+add_memory_driver_managed
+add_memory
+test_pages_in_a_zone
+__remove_memory
+__traceiter_mm_migrate_pages
+migrate_vma_collect_hole
+alloc_misplaced_dst_page
+migrate_vma_check_page
+expected_page_refs
+migrate_page_states
+alloc_migration_target
+do_pages_stat
+migrate_page_copy
+remove_migration_pte
+migrate_page_move_mapping
+migrate_page
+numamigrate_isolate_page
+migrate_vma_collect_pmd
+__buffer_migrate_page
+buffer_migrate_page
+migrate_vma_pages
+migrate_prep
+migrate_prep_local
+isolate_movable_page
+putback_movable_page
+putback_movable_pages
+remove_migration_ptes
+move_to_new_page
+migrate_vma_setup
+migrate_vma_finalize
+__migration_entry_wait
+migration_entry_wait
+migration_entry_wait_huge
+pmd_migration_entry_wait
+migrate_huge_page_move_mapping
+buffer_migrate_page_norefs
+migrate_pages
+move_pages_and_store_status.isra.0
+kernel_move_pages
+__x64_sys_move_pages
+__ia32_sys_move_pages
+__ia32_compat_sys_move_pages
+__x32_compat_sys_move_pages
+pmd_trans_migrating
+migrate_misplaced_page
+migrate_misplaced_transhuge_page
+shrink_huge_zero_page_count
+hpage_pmd_size_show
+use_zero_page_show
+defrag_store
+enabled_store
+split_huge_pages_fops_open
+deferred_split_count
+is_transparent_hugepage
+touch_pmd
+put_huge_zero_page
+defrag_show
+enabled_show
+shrink_huge_zero_page_scan
+thp_get_unmapped_area
+remap_page
+set_huge_zero_page.isra.0.part.0
+vmf_insert_pfn_pud_prot
+vmf_insert_pfn_pmd_prot
+transparent_hugepage_enabled
+mm_get_huge_zero_page
+mm_put_huge_zero_page
+single_hugepage_flag_show
+single_hugepage_flag_store
+use_zero_page_store
+maybe_pmd_mkwrite
+prep_transhuge_page
+do_huge_pmd_anonymous_page
+follow_devmap_pmd
+follow_devmap_pud
+huge_pud_set_accessed
+huge_pmd_set_accessed
+follow_trans_huge_pmd
+do_huge_pmd_numa_page
+__pmd_trans_huge_lock
+zap_huge_pmd
+move_huge_pmd
+change_huge_pmd
+__pud_trans_huge_lock
+zap_huge_pud
+__split_huge_pud
+copy_huge_pud
+__split_huge_pmd
+copy_huge_pmd
+do_huge_pmd_wp_page
+split_huge_pmd_address
+vma_adjust_trans_huge
+total_mapcount
+page_trans_huge_mapcount
+can_split_huge_page
+split_huge_page_to_list
+deferred_split_scan
+madvise_free_huge_pmd
+split_huge_pages_set
+free_transhuge_page
+deferred_split_huge_page
+set_pmd_migration_entry
+remove_migration_pmd
+__traceiter_mm_khugepaged_scan_pmd
+__traceiter_mm_collapse_huge_page
+__traceiter_mm_collapse_huge_page_isolate
+__traceiter_mm_collapse_huge_page_swapin
+promotion_metric_store
+min_sleep_store
+max_cpu_store
+max_thp_collapse_alloc_store
+pages_to_scan_store
+khugepaged_max_ptes_shared_store
+khugepaged_max_ptes_swap_store
+khugepaged_max_ptes_none_store
+promotion_metric_show
+min_sleep_show
+max_cpu_show
+max_thp_collapse_alloc_show
+alloc_sleep_millisecs_show
+scan_sleep_millisecs_show
+full_scans_show
+pages_collapsed_show
+pages_to_scan_show
+khugepaged_max_ptes_shared_show
+khugepaged_max_ptes_swap_show
+khugepaged_max_ptes_none_show
+alloc_sleep_millisecs_store
+scan_sleep_millisecs_store
+khugepaged_defrag_store
+khugepaged_defrag_show
+is_refcount_suitable
+set_recommended_min_free_kbytes
+follow_page_custom
+hugepage_vma_check
+hugepage_vma_revalidate
+release_pte_page
+ohp_sleep_iteration.isra.0
+__collapse_huge_page_swapin
+collapse_huge_page
+khugepaged
+__khugepaged_enter
+khugepaged_enter_vma_merge
+hugepage_madvise
+__khugepaged_exit
+collapse_pte_mapped_thp
+start_stop_khugepaged
+khugepaged_min_free_kbytes_update
+ohp_mm_pending_promotions
+count_ohp_bins
+ohp_adjust_mm_bins
+ohp_get_target_mm
+get_time_difference
+ohp_has_work
+ohp_exit_mm
+init_mm_ohp_bins
+get_ohp_mm_addr
+get_ohp_global_kaddr
+ohp_putback_kaddr
+remove_ohp_bins
+add_ohp_bin
+start_kbinmanager
+__ia32_sys_update_mm_ohp_stats
+__x64_sys_update_mm_ohp_stats
+stop_kbinmanager
+ohp_follow_pte
+ohp_clear_pte_accessed_range
+ohp_clear_pte_accessed_mm
+kbinmanager
+propagate_protected_usage
+page_counter_cancel
+page_counter_charge
+page_counter_try_charge
+page_counter_uncharge
+page_counter_set_max
+page_counter_set_min
+page_counter_set_low
+page_counter_memparse
+mem_cgroup_from_task
+__invalidate_reclaim_iterators
+mem_cgroup_css_released
+mem_cgroup_move_charge_read
+mem_cgroup_move_charge_write
+mem_cgroup_swappiness_write
+compare_thresholds
+swap_events_show
+mem_cgroup_oom_control_read
+memcg_flush_percpu_vmevents
+memcg_exact_page_state
+mem_cgroup_bind
+lock_page_memcg
+memcg_flush_percpu_vmstats
+memcg_event_ptable_queue_proc
+swap_max_write
+swap_high_write
+memory_oom_group_write
+memory_low_write
+memory_min_write
+memcg_free_shrinker_map_rcu
+__mem_cgroup_free
+mem_cgroup_free
+effective_protection
+mem_cgroup_hierarchy_read
+memory_oom_group_show
+do_memsw_account
+mem_cgroup_hierarchy_write
+__mem_cgroup_insert_exceeded
+memcg_oom_recover.part.0
+mem_cgroup_oom_control_write
+seq_puts_memcg_tunable.part.0
+memory_max_show
+memory_high_show
+memory_low_show
+memory_min_show
+swap_max_show
+swap_high_show
+memcg_free_shrinker_maps.part.0
+cancel_charge.part.0
+__mem_cgroup_remove_exceeded
+mem_cgroup_id_get_online
+mem_cgroup_margin
+memory_stat_format
+memory_stat_show
+mem_cgroup_reset
+memory_current_read
+__memory_events_show
+memory_events_local_show
+memory_events_show
+swap_current_read
+mem_cgroup_usage
+mem_cgroup_read_u64
+__mem_cgroup_threshold
+memcg_check_events
+__mem_cgroup_usage_unregister_event
+memsw_cgroup_usage_unregister_event
+mem_cgroup_usage_unregister_event
+__mem_cgroup_usage_register_event
+memsw_cgroup_usage_register_event
+mem_cgroup_usage_register_event
+mem_cgroup_out_of_memory
+memcg_stat_show
+memory_numa_stat_show
+mem_cgroup_swappiness_read
+get_mem_cgroup_from_mm
+__mem_cgroup_largest_soft_limit_node
+mem_cgroup_node_nr_lru_pages
+memcg_numa_stat_show
+get_mem_cgroup_from_page
+memcg_oom_wake_function
+get_mctgt_type_thp.isra.0
+reclaim_high.constprop.0
+high_work_func
+mem_cgroup_oom_unregister_event
+mem_cgroup_oom_register_event
+mem_cgroup_css_reset
+mem_cgroup_css_online
+get_mctgt_type
+memcg_event_wake
+mem_cgroup_id_put_many.part.0
+mem_cgroup_id_put_many
+__mem_cgroup_clear_mc
+mem_cgroup_clear_mc
+mem_cgroup_move_task
+mem_cgroup_cancel_attach
+memcg_offline_kmem
+mem_cgroup_css_free
+memcg_event_remove
+drain_stock
+refill_stock
+mem_cgroup_count_precharge_pte_range
+memcg_write_event_control
+memcg_to_vmpressure
+vmpressure_to_css
+memcg_get_cache_ids
+memcg_put_cache_ids
+memcg_set_shrinker_bit
+mem_cgroup_css_from_page
+page_cgroup_ino
+__mod_memcg_state
+__mod_memcg_lruvec_state
+__mod_lruvec_state
+__count_memcg_events
+mem_cgroup_charge_statistics.isra.0
+uncharge_batch
+uncharge_page
+mem_cgroup_iter
+mem_cgroup_mark_under_oom
+mem_cgroup_oom_notify
+mem_cgroup_unmark_under_oom
+mem_cgroup_oom_unlock
+memcg_hotplug_cpu_dead
+mem_cgroup_oom_trylock
+memcg_expand_shrinker_maps
+mem_cgroup_iter_break
+mem_cgroup_scan_tasks
+mem_cgroup_page_lruvec
+mem_cgroup_update_lru_size
+mem_cgroup_print_oom_context
+mem_cgroup_print_oom_meminfo
+mem_cgroup_get_max
+mem_cgroup_size
+mem_cgroup_oom_synchronize
+mem_cgroup_get_oom_group
+__unlock_page_memcg
+mem_cgroup_move_account
+unlock_page_memcg
+mem_cgroup_handle_over_high
+memcg_alloc_page_obj_cgroups
+mem_cgroup_from_obj
+__mod_lruvec_slab_state
+mod_memcg_obj_state
+__memcg_kmem_uncharge
+drain_obj_stock
+drain_local_stock
+drain_all_stock
+mem_cgroup_force_empty_write
+mem_cgroup_resize_max
+mem_cgroup_write
+memory_max_write
+memory_high_write
+try_charge
+mem_cgroup_do_precharge
+mem_cgroup_move_charge_pte_range
+mem_cgroup_can_attach
+__memcg_kmem_charge
+mem_cgroup_css_offline
+refill_obj_stock
+obj_cgroup_release
+__memcg_kmem_charge_page
+__memcg_kmem_uncharge_page
+obj_cgroup_charge
+obj_cgroup_uncharge
+mem_cgroup_split_huge_fixup
+mem_cgroup_soft_limit_reclaim
+mem_cgroup_wb_domain
+mem_cgroup_wb_stats
+mem_cgroup_track_foreign_dirty_slowpath
+mem_cgroup_flush_foreign
+mem_cgroup_from_id
+mem_cgroup_calculate_protection
+mem_cgroup_uncharge
+mem_cgroup_uncharge_list
+mem_cgroup_migrate
+mem_cgroup_sk_alloc
+mem_cgroup_sk_free
+mem_cgroup_charge_skmem
+mem_cgroup_uncharge_skmem
+mem_cgroup_swapout
+mem_cgroup_try_charge_swap
+mem_cgroup_uncharge_swap
+mem_cgroup_charge
+mem_cgroup_get_nr_swap_pages
+mem_cgroup_swap_full
+vmpressure_calc_level
+vmpressure_work_fn
+vmpressure
+vmpressure_prio
+vmpressure_register_event
+vmpressure_unregister_event
+vmpressure_init
+vmpressure_cleanup
+swap_cgroup_cmpxchg
+swap_cgroup_record
+lookup_swap_cgroup_id
+swap_cgroup_swapon
+swap_cgroup_swapoff
+__hugetlb_events_show
+hugetlb_events_local_show
+hugetlb_events_show
+hugetlb_cgroup_css_free
+hugetlb_cgroup_write.isra.0
+hugetlb_cgroup_write_dfl
+hugetlb_cgroup_write_legacy
+hugetlb_cgroup_css_alloc
+hugetlb_cgroup_reset
+hugetlb_cgroup_read_u64
+hugetlb_cgroup_read_u64_max
+hugetlb_cgroup_css_offline
+__hugetlb_cgroup_commit_charge.constprop.0
+__hugetlb_cgroup_uncharge_page
+__hugetlb_cgroup_uncharge_cgroup
+__hugetlb_cgroup_charge_cgroup
+hugetlb_cgroup_charge_cgroup
+hugetlb_cgroup_charge_cgroup_rsvd
+hugetlb_cgroup_commit_charge
+hugetlb_cgroup_commit_charge_rsvd
+hugetlb_cgroup_uncharge_page
+hugetlb_cgroup_uncharge_page_rsvd
+hugetlb_cgroup_uncharge_cgroup
+hugetlb_cgroup_uncharge_cgroup_rsvd
+hugetlb_cgroup_uncharge_counter
+hugetlb_cgroup_uncharge_file_region
+hugetlb_cgroup_migrate
+me_kernel
+action_result
+identify_page_state
+memory_failure_queue
+task_early_kill
+truncate_error_page
+kill_procs
+get_hwpoison_page
+__get_any_page
+hwpoison_filter
+shake_page
+add_to_kill
+collect_procs
+hwpoison_user_mappings
+try_to_split_thp_page
+delete_from_lru_cache
+me_swapcache_dirty
+me_swapcache_clean
+me_pagecache_clean
+me_pagecache_dirty
+page_handle_poison
+me_huge_page
+memory_failure
+unpoison_memory
+soft_offline_page
+memory_failure_work_func
+memory_failure_queue_kick
+cleancache_register_ops
+__cleancache_init_fs
+__cleancache_init_shared_fs
+cleancache_register_ops_sb
+cleancache_get_key
+__cleancache_get_page
+__cleancache_invalidate_page
+__cleancache_invalidate_inode
+__cleancache_invalidate_fs
+__cleancache_put_page
+__traceiter_test_pages_isolated
+unset_migratetype_isolate
+start_isolate_page_range
+undo_isolate_page_range
+test_pages_isolated
+zpool_put_driver
+zpool_register_driver
+zpool_unregister_driver
+zpool_get_driver
+zpool_has_pool
+zpool_create_pool
+zpool_destroy_pool
+zpool_get_type
+zpool_malloc_support_movable
+zpool_malloc
+zpool_free
+zpool_shrink
+zpool_map_handle
+zpool_unmap_handle
+zpool_get_total_size
+zpool_evictable
+zbud_zpool_map
+zbud_zpool_destroy
+free_zbud_page
+zbud_zpool_evict
+zbud_zpool_total_size
+zbud_zpool_unmap
+zbud_create_pool
+zbud_zpool_create
+zbud_destroy_pool
+zbud_alloc
+zbud_zpool_malloc
+zbud_free
+zbud_zpool_free
+zbud_reclaim_page
+zbud_zpool_shrink
+zbud_map
+zbud_unmap
+zbud_get_pool_size
+zs_huge_class_size
+insert_zspage
+isolate_zspage
+putback_zspage
+create_page_chain
+zs_pool_stats
+reset_page
+zs_can_compact
+zs_shrinker_count
+zs_cpu_prepare
+zs_cpu_dead
+zs_init_fs_context
+get_zspage.part.0
+obj_free
+get_zspage_mapping.part.0
+fix_fullness_group
+zs_destroy_pool
+zs_zpool_destroy
+zs_zpool_total_size
+zs_get_total_pages
+zs_map_object
+zs_zpool_map
+obj_malloc
+zs_create_pool
+zs_zpool_create
+__free_zspage
+free_zspage
+zs_unmap_object
+zs_zpool_unmap
+async_free_zspage
+zs_page_putback
+zs_compact
+zs_shrinker_scan
+zs_free
+zs_zpool_free
+zs_page_migrate
+zs_page_isolate
+zs_malloc
+zs_zpool_malloc
+balloon_page_alloc
+balloon_page_isolate
+balloon_page_putback
+balloon_page_migrate
+balloon_page_list_dequeue
+balloon_page_enqueue_one
+balloon_page_enqueue
+balloon_page_list_enqueue
+balloon_page_dequeue
+mm_alloc_pmd
+mcopy_atomic
+mfill_zeropage
+mwriteprotect_range
+page_idle_get_page
+page_idle_clear_pte_refs_one
+page_idle_clear_pte_refs
+page_idle_bitmap_read
+page_idle_bitmap_write
+frame_vector_destroy
+frame_vector_create
+frame_vector_to_pfns
+get_vaddr_frames
+frame_vector_to_pages
+put_vaddr_frames
+check_stack_object
+usercopy_warn
+__check_object_size
+memremap_compat_align
+dev_pagemap_percpu_release
+devm_memunmap_pages
+pgmap_array_delete
+memunmap_pages
+devm_memremap_pages_release
+get_dev_pagemap
+memremap_pages
+devm_memremap_pages
+vmem_altmap_offset
+vmem_altmap_free
+free_devmap_managed_page
+hmm_range_need_fault
+hmm_vma_walk_test
+hmm_range_fault
+hmm_vma_fault
+hmm_vma_walk_hole
+hmm_vma_walk_hugetlb_entry
+hmm_vma_walk_pmd
+hmm_vma_walk_pud
+memfd_file_seals_ptr
+__ia32_sys_memfd_create
+__x64_sys_memfd_create
+memfd_fcntl
+wp_shared_mapping_range
+wp_pte
+clean_record_pte
+wp_clean_test_walk
+wp_clean_post_vma
+wp_clean_pre_vma
+clean_record_shared_mapping_range
+wp_clean_pmd_entry
+wp_clean_pud_entry
+ptdump_pgd_entry
+ptdump_p4d_entry
+ptdump_pud_entry
+ptdump_pmd_entry
+ptdump_pte_entry
+ptdump_hole
+ptdump_walk_pgd
+page_reporting_unregister
+page_reporting_register
+page_reporting_drain.constprop.0
+page_reporting_process
+__page_reporting_notify
+file_path
+finish_no_open
+generic_file_open
+nonseekable_open
+stream_open
+do_faccessat
+__x64_sys_faccessat
+__ia32_sys_faccessat
+__x64_sys_faccessat2
+__ia32_sys_faccessat2
+__x64_sys_access
+__ia32_sys_access
+__ia32_sys_chdir
+__ia32_sys_fchdir
+__ia32_sys_chroot
+filp_close
+__ia32_sys_close
+__x64_sys_close_range
+__ia32_sys_close_range
+__do_sys_vhangup
+__x64_sys_close
+vfs_fallocate
+do_dentry_open
+finish_open
+open_with_fake_path
+dentry_open
+__x64_sys_fchdir
+__x64_sys_chdir
+__x64_sys_chroot
+file_open_root
+do_sys_openat2
+__ia32_sys_openat2
+__x64_sys_openat2
+do_truncate
+vfs_truncate
+do_sys_truncate.part.0
+__x64_sys_truncate
+__ia32_sys_truncate
+__ia32_compat_sys_truncate
+__x32_compat_sys_truncate
+do_sys_truncate
+do_sys_ftruncate
+__x64_sys_ftruncate
+__ia32_sys_ftruncate
+__ia32_compat_sys_ftruncate
+__x32_compat_sys_ftruncate
+ksys_fallocate
+__x64_sys_fallocate
+__ia32_sys_fallocate
+chmod_common
+do_fchmodat
+__x64_sys_fchmodat
+__ia32_sys_fchmodat
+__x64_sys_chmod
+__ia32_sys_chmod
+__ia32_sys_fchmod
+__x64_sys_fchmod
+vfs_fchmod
+chown_common
+do_fchownat
+__x64_sys_fchownat
+__ia32_sys_fchownat
+__x64_sys_chown
+__ia32_sys_chown
+__x64_sys_lchown
+__ia32_sys_lchown
+vfs_fchown
+ksys_fchown
+__x64_sys_fchown
+__ia32_sys_fchown
+vfs_open
+file_open_name
+filp_open
+do_sys_open
+__x64_sys_open
+__ia32_sys_open
+__x64_sys_openat
+__ia32_sys_openat
+__ia32_compat_sys_open
+__x32_compat_sys_open
+__ia32_compat_sys_openat
+__x32_compat_sys_openat
+__x64_sys_creat
+__ia32_sys_creat
+no_llseek
+vfs_setpos
+noop_llseek
+vfs_llseek
+default_llseek
+generic_copy_file_range
+generic_file_llseek_size
+fixed_size_llseek
+no_seek_end_llseek
+no_seek_end_llseek_size
+generic_file_llseek
+ksys_lseek
+__x64_sys_lseek
+__ia32_sys_lseek
+__ia32_compat_sys_lseek
+__x32_compat_sys_lseek
+__ia32_sys_llseek
+__x64_sys_llseek
+new_sync_read
+new_sync_write
+do_iter_readv_writev
+__kernel_write
+rw_verify_area
+kernel_write
+vfs_iocb_iter_read
+do_iter_read
+vfs_iter_read
+vfs_readv
+do_readv
+__x64_sys_readv
+__ia32_sys_readv
+do_preadv
+__x64_sys_preadv
+__ia32_sys_preadv
+__ia32_sys_preadv2
+__ia32_compat_sys_preadv64
+__x32_compat_sys_preadv64
+__ia32_compat_sys_preadv
+__x32_compat_sys_preadv
+__ia32_compat_sys_preadv64v2
+__ia32_compat_sys_preadv2
+__x64_sys_preadv2
+__x32_compat_sys_preadv64v2
+__x32_compat_sys_preadv2
+vfs_iocb_iter_write
+do_iter_write
+vfs_iter_write
+vfs_writev
+do_writev
+__x64_sys_writev
+__ia32_sys_writev
+do_pwritev
+__x64_sys_pwritev
+__ia32_sys_pwritev
+__ia32_sys_pwritev2
+__ia32_compat_sys_pwritev64
+__x32_compat_sys_pwritev64
+__ia32_compat_sys_pwritev
+__x32_compat_sys_pwritev
+__ia32_compat_sys_pwritev64v2
+__ia32_compat_sys_pwritev2
+__x64_sys_pwritev2
+__x32_compat_sys_pwritev64v2
+__x32_compat_sys_pwritev2
+do_sendfile
+__ia32_sys_sendfile
+__ia32_sys_sendfile64
+__ia32_compat_sys_sendfile
+__ia32_compat_sys_sendfile64
+__x64_sys_sendfile
+__x32_compat_sys_sendfile
+__x64_sys_sendfile64
+__x32_compat_sys_sendfile64
+__kernel_read
+kernel_read
+vfs_read
+vfs_write
+ksys_read
+__x64_sys_read
+__ia32_sys_read
+ksys_write
+__x64_sys_write
+__ia32_sys_write
+ksys_pread64
+__x64_sys_pread64
+__ia32_sys_pread64
+ksys_pwrite64
+__x64_sys_pwrite64
+__ia32_sys_pwrite64
+generic_write_check_limits
+generic_write_checks
+generic_file_rw_checks
+vfs_copy_file_range
+__ia32_sys_copy_file_range
+__x64_sys_copy_file_range
+get_max_files
+file_free_rcu
+__alloc_file
+__fput
+delayed_fput
+flush_delayed_fput
+____fput
+proc_nr_files
+alloc_empty_file
+alloc_file
+alloc_file_pseudo
+alloc_empty_file_noaccount
+alloc_file_clone
+fput_many
+fput
+__fput_sync
+test_single_super
+destroy_super_work
+test_keyed_super
+test_bdev_super_fc
+test_bdev_super
+destroy_super_rcu
+super_cache_count
+get_anon_bdev
+set_anon_super
+free_anon_bdev
+vfs_get_tree
+super_setup_bdi_name
+super_setup_bdi
+__put_super
+set_bdev_super
+set_bdev_super_fc
+compare_single
+set_anon_super_fc
+destroy_unused_super.part.0
+alloc_super
+put_super
+drop_super_exclusive
+drop_super
+deactivate_locked_super
+deactivate_super
+thaw_super_locked
+do_thaw_all_callback
+thaw_super
+freeze_super
+__iterate_supers
+do_emergency_remount
+do_thaw_all
+grab_super
+iterate_supers_type
+generic_shutdown_super
+kill_anon_super
+kill_litter_super
+kill_block_super
+__get_super.part.0
+get_super
+__get_super_thawed
+get_super_thawed
+get_super_exclusive_thawed
+sget
+mount_nodev
+mount_bdev
+sget_fc
+get_tree_bdev
+trylock_super
+super_cache_scan
+mount_capable
+iterate_supers
+get_active_super
+user_get_super
+reconfigure_super
+do_emergency_remount_callback
+vfs_get_super
+get_tree_nodev
+get_tree_single
+get_tree_single_reconf
+get_tree_keyed
+mount_single
+emergency_remount
+emergency_thaw_all
+exact_match
+base_probe
+__unregister_chrdev_region
+unregister_chrdev_region
+cdev_set_parent
+cdev_get
+exact_lock
+cdev_add
+cdev_del
+__unregister_chrdev
+cdev_device_add
+cdev_device_del
+cdev_init
+cdev_put.part.0
+cdev_alloc
+__register_chrdev_region
+register_chrdev_region
+alloc_chrdev_region
+__register_chrdev
+cdev_purge
+cdev_dynamic_release
+cdev_default_release
+chrdev_open
+chrdev_show
+cdev_put
+cd_forget
+__inode_add_bytes
+__inode_sub_bytes
+inode_sub_bytes
+inode_set_bytes
+generic_fillattr
+vfs_getattr_nosec
+vfs_getattr
+vfs_statx
+cp_old_stat
+__x64_sys_stat
+__ia32_sys_stat
+__x64_sys_lstat
+__ia32_sys_lstat
+cp_new_stat
+__x64_sys_newstat
+__ia32_sys_newstat
+__x64_sys_newlstat
+__ia32_sys_newlstat
+__x64_sys_newfstatat
+__ia32_sys_newfstatat
+cp_statx
+cp_compat_stat
+__ia32_compat_sys_newstat
+__x32_compat_sys_newstat
+__ia32_compat_sys_newlstat
+__x32_compat_sys_newlstat
+__ia32_compat_sys_newfstatat
+__x32_compat_sys_newfstatat
+do_readlinkat
+__x64_sys_readlinkat
+__ia32_sys_readlinkat
+__x64_sys_readlink
+__ia32_sys_readlink
+inode_get_bytes
+inode_add_bytes
+vfs_fstat
+__x64_sys_fstat
+__ia32_sys_fstat
+__x64_sys_newfstat
+__ia32_sys_newfstat
+__ia32_compat_sys_newfstat
+__x32_compat_sys_newfstat
+vfs_fstatat
+do_statx
+__x64_sys_statx
+__ia32_sys_statx
+unregister_binfmt
+shift_arg_pages
+would_dump
+setup_new_exec
+bprm_change_interp
+set_binfmt
+setup_arg_pages
+__register_binfmt
+get_user_arg_ptr.isra.0
+do_open_execat
+open_exec
+acct_arg_size
+get_arg_page
+free_bprm
+count_strings_kernel.part.0
+count.isra.0.constprop.0
+__ia32_sys_uselib
+copy_string_kernel
+copy_strings_kernel
+remove_arg_zero
+finalize_exec
+__get_task_comm
+copy_strings.isra.0
+alloc_bprm
+bprm_execve
+do_execveat_common.isra.0
+__ia32_sys_execve
+__ia32_sys_execveat
+__ia32_compat_sys_execve
+__ia32_compat_sys_execveat
+__x32_compat_sys_execve
+__x64_sys_execve
+__x64_sys_execveat
+__x32_compat_sys_execveat
+__x64_sys_uselib
+path_noexec
+__set_task_comm
+kernel_execve
+set_dumpable
+begin_new_exec
+pipe_poll
+pipe_lock
+pipe_unlock
+generic_pipe_buf_get
+generic_pipe_buf_try_steal
+anon_pipe_buf_release
+pipe_fasync
+wait_for_partner
+pipe_ioctl
+pipefs_init_fs_context
+pipefs_dname
+round_pipe_size.part.0
+anon_pipe_buf_try_steal
+generic_pipe_buf_release
+pipe_read
+pipe_write
+pipe_double_lock
+account_pipe_buffers
+too_many_pipe_buffers_soft
+too_many_pipe_buffers_hard
+pipe_is_unprivileged_user
+alloc_pipe_info
+free_pipe_info
+put_pipe_info
+pipe_release
+fifo_open
+create_pipe_files
+__do_pipe_flags
+do_pipe2
+__x64_sys_pipe2
+__ia32_sys_pipe2
+__x64_sys_pipe
+__ia32_sys_pipe
+do_pipe_flags
+pipe_wait_readable
+pipe_wait_writable
+round_pipe_size
+pipe_resize_ring
+get_pipe_info
+pipe_fcntl
+choose_mountpoint_rcu
+restore_nameidata
+path_get
+path_put
+follow_down_one
+__traverse_mounts
+__legitimize_path
+legitimize_links
+legitimize_root
+unlazy_walk
+terminate_walk
+unlazy_child
+complete_walk
+done_path_create
+vfs_get_link
+page_get_link
+__page_symlink
+page_symlink
+lock_rename
+unlock_rename
+generic_permission
+nd_alloc_stack
+follow_down
+__check_sticky
+full_name_hash
+hashlen_string
+lookup_dcache
+__lookup_hash
+page_put_link
+lookup_fast
+set_root
+nd_jump_root
+step_into
+handle_lookup_down
+handle_dots.part.0
+follow_up
+__lookup_slow
+walk_component
+path_init
+inode_permission
+lookup_one_len_common
+try_lookup_one_len
+lookup_one_len
+lookup_one_len_unlocked
+lookup_positive_unlocked
+link_path_walk
+path_parentat
+path_lookupat
+may_delete
+vfs_rmdir
+vfs_unlink
+vfs_tmpfile
+vfs_rename
+may_open
+path_openat
+vfs_symlink
+vfs_create
+vfs_mkobj
+vfs_mkdir
+vfs_mknod
+vfs_link
+getname_kernel
+putname
+getname_flags
+getname
+filename_parentat
+filename_create
+kern_path_create
+do_mkdirat
+__x64_sys_mkdirat
+__ia32_sys_mkdirat
+__x64_sys_mkdir
+__ia32_sys_mkdir
+do_mknodat
+__x64_sys_mknodat
+__ia32_sys_mknodat
+__x64_sys_mknod
+__ia32_sys_mknod
+do_symlinkat
+__x64_sys_symlinkat
+__ia32_sys_symlinkat
+__x64_sys_symlink
+__ia32_sys_symlink
+do_renameat2
+__x64_sys_renameat2
+__ia32_sys_renameat2
+__x64_sys_renameat
+__ia32_sys_renameat
+__x64_sys_rename
+__ia32_sys_rename
+nd_jump_link
+may_linkat
+filename_lookup
+kern_path
+vfs_path_lookup
+user_path_at_empty
+do_linkat
+__x64_sys_linkat
+__ia32_sys_linkat
+__x64_sys_link
+__ia32_sys_link
+kern_path_locked
+path_pts
+may_open_dev
+do_filp_open
+do_file_open_root
+do_rmdir
+__ia32_sys_rmdir
+__x64_sys_rmdir
+do_unlinkat
+__ia32_sys_unlinkat
+__ia32_sys_unlink
+__x64_sys_unlink
+__x64_sys_unlinkat
+readlink_copy
+vfs_readlink
+page_readlink
+get_compat_flock
+get_compat_flock64
+send_sigio_to_task
+fasync_free_rcu
+send_sigurg_to_task
+f_modown
+__f_setown
+f_setown
+f_delown
+f_getown
+do_fcntl
+__ia32_sys_fcntl
+do_compat_fcntl64
+__ia32_compat_sys_fcntl64
+__x32_compat_sys_fcntl64
+__ia32_compat_sys_fcntl
+__x32_compat_sys_fcntl
+__x64_sys_fcntl
+send_sigio
+kill_fasync
+send_sigurg
+fasync_remove_entry
+fasync_alloc
+fasync_free
+fasync_insert_entry
+fasync_helper
+vfs_ioctl
+compat_ptr_ioctl
+fiemap_fill_next_extent
+ioctl_preallocate
+compat_ioctl_preallocate
+ioctl_file_clone
+do_vfs_ioctl
+__ia32_sys_ioctl
+__x32_compat_sys_ioctl
+fiemap_prep
+__generic_block_fiemap
+generic_block_fiemap
+__x64_sys_ioctl
+__ia32_compat_sys_ioctl
+fillonedir
+compat_fillonedir
+verify_dirent_name
+filldir
+filldir64
+compat_filldir
+iterate_dir
+__ia32_sys_getdents
+__x64_sys_old_readdir
+__x32_compat_sys_old_readdir
+__ia32_compat_sys_old_readdir
+__ia32_sys_old_readdir
+__ia32_sys_getdents64
+__ia32_compat_sys_getdents
+__x64_sys_getdents64
+__x64_sys_getdents
+__x32_compat_sys_getdents
+poll_initwait
+pollwake
+__pollwait
+poll_freewait
+poll_select_finish
+poll_schedule_timeout.constprop.0
+compat_get_fd_set
+select_estimate_accuracy
+do_select
+compat_core_sys_select
+do_sys_poll
+do_restart_poll
+poll_select_set_timeout
+__ia32_sys_poll
+__ia32_sys_ppoll
+do_compat_select
+__ia32_compat_sys_select
+__x32_compat_sys_select
+__ia32_compat_sys_old_select
+__x32_compat_sys_old_select
+do_compat_pselect
+__ia32_compat_sys_pselect6_time64
+__ia32_compat_sys_pselect6_time32
+__x32_compat_sys_pselect6_time64
+__x32_compat_sys_pselect6_time32
+__ia32_compat_sys_ppoll_time32
+__ia32_compat_sys_ppoll_time64
+__x64_sys_poll
+__x64_sys_ppoll
+__x32_compat_sys_ppoll_time32
+__x32_compat_sys_ppoll_time64
+core_sys_select
+kern_select
+__x64_sys_select
+__ia32_sys_select
+do_pselect.constprop.0
+__ia32_sys_pselect6
+__x64_sys_pselect6
+find_submount
+d_shrink_del
+d_set_d_op
+d_flags_for_inode
+release_dentry_name_snapshot
+d_lru_add
+__d_free_external
+__d_free
+d_lru_shrink_move
+path_check_mount
+__d_alloc
+d_alloc_anon
+d_genocide_kill
+d_lru_del
+__dput_to_list
+select_collect2
+select_collect
+dentry_free
+umount_check
+is_subdir
+__d_rehash
+___d_drop
+__d_drop
+__d_lookup_done
+d_rehash
+d_set_fallthru
+d_find_any_alias
+d_drop
+d_mark_dontcache
+d_alloc
+d_alloc_name
+dentry_lru_isolate_shrink
+d_add
+take_dentry_name_snapshot
+__d_instantiate
+d_instantiate
+d_make_root
+dentry_unlink_inode
+d_delete
+d_instantiate_new
+d_tmpfile
+d_find_alias
+__dentry_kill
+__lock_parent
+dentry_lru_isolate
+d_exact_alias
+__d_move
+d_move
+dput
+d_prune_aliases
+__d_instantiate_anon
+d_instantiate_anon
+__d_obtain_alias
+d_obtain_alias
+d_obtain_root
+dget_parent
+d_walk
+path_has_submounts
+d_genocide
+shrink_lock_dentry
+d_splice_alias
+proc_nr_dentry
+dput_to_list
+shrink_dentry_list
+shrink_dcache_sb
+shrink_dcache_parent
+do_one_tree
+d_invalidate
+prune_dcache_sb
+d_set_mounted
+shrink_dcache_for_umount
+d_alloc_cursor
+d_alloc_pseudo
+__d_lookup_rcu
+d_alloc_parallel
+__d_lookup
+d_lookup
+d_hash_and_lookup
+d_add_ci
+d_exchange
+d_ancestor
+no_open
+generic_delete_inode
+free_inode_nonrcu
+bmap
+inode_needs_sync
+inode_nohighmem
+get_nr_inodes
+inode_init_always
+i_callback
+inc_nlink
+get_next_ino
+inode_set_flags
+clear_inode
+address_space_init_once
+inode_init_once
+init_once
+inode_lru_list_add
+hash
+find_inode_rcu
+find_inode_by_ino_rcu
+alloc_inode
+lock_two_nondirectories
+unlock_two_nondirectories
+inode_dio_wait
+should_remove_suid
+vfs_ioc_fssetxattr_check
+init_special_inode
+inode_init_owner
+inode_owner_or_capable
+timestamp_truncate
+current_time
+vfs_ioc_setflags_prepare
+ihold
+set_nlink
+drop_nlink
+dentry_needs_remove_privs.part.0
+file_remove_privs
+generic_update_time
+update_time
+file_update_time
+file_modified
+clear_nlink
+__destroy_inode
+destroy_inode
+inode_sb_list_add
+__remove_inode_hash
+iunique
+unlock_new_inode
+__insert_inode_hash
+__wait_on_freeing_inode
+find_inode_nowait
+igrab
+evict
+dispose_list
+evict_inodes
+iput
+discard_new_inode
+inode_lru_isolate
+find_inode
+ilookup5_nowait
+ilookup5
+inode_insert5
+iget5_locked
+insert_inode_locked4
+find_inode_fast
+ilookup
+insert_inode_locked
+iget_locked
+get_nr_dirty_inodes
+proc_nr_inodes
+__iget
+inode_add_lru
+invalidate_inodes
+prune_icache_sb
+new_inode_pseudo
+new_inode
+atime_needs_update
+touch_atime
+dentry_needs_remove_privs
+setattr_copy
+inode_newsize_ok
+setattr_prepare
+notify_change
+bad_file_open
+bad_inode_create
+bad_inode_lookup
+bad_inode_link
+bad_inode_mkdir
+bad_inode_mknod
+bad_inode_rename2
+bad_inode_readlink
+bad_inode_permission
+bad_inode_getattr
+bad_inode_listxattr
+bad_inode_get_link
+bad_inode_get_acl
+bad_inode_fiemap
+bad_inode_atomic_open
+is_bad_inode
+make_bad_inode
+iget_failed
+bad_inode_update_time
+bad_inode_tmpfile
+bad_inode_symlink
+bad_inode_setattr
+bad_inode_set_acl
+bad_inode_unlink
+bad_inode_rmdir
+__free_fdtable
+free_fdtable_rcu
+alloc_fdtable
+copy_fd_bitmaps
+__fget_files
+fget
+fget_raw
+__fget_light
+__fdget
+put_unused_fd
+iterate_fd
+pick_file
+__close_fd
+do_dup2
+expand_files
+ksys_dup3
+__x64_sys_dup3
+__ia32_sys_dup3
+__ia32_sys_dup2
+__x64_sys_dup2
+dup_fd
+get_files_struct
+put_files_struct
+reset_files_struct
+exit_files
+__alloc_fd
+get_unused_fd_flags
+__get_unused_fd_flags
+__fd_install
+fd_install
+__ia32_sys_dup
+__x64_sys_dup
+__close_range
+__close_fd_get_file
+do_close_on_exec
+fget_many
+fget_task
+__fdget_raw
+__fdget_pos
+__f_unlock_pos
+set_close_on_exec
+get_close_on_exec
+replace_fd
+__receive_fd
+f_dupfd
+fs_maxindex
+find_filesystem
+register_filesystem
+fs_index
+__get_fs_type
+fs_name
+__ia32_sys_sysfs
+filesystems_proc_show
+get_fs_type
+unregister_filesystem
+__x64_sys_sysfs
+get_filesystem
+put_filesystem
+__mnt_is_readonly
+mnt_clone_write
+unhash_mnt
+m_show
+lock_mnt_tree
+can_change_locked_flags
+mntns_owner
+mntget
+mnt_get_writers
+alloc_vfsmnt
+cleanup_group_ids
+invent_group_ids
+free_vfsmnt
+delayed_free_vfsmnt
+free_mnt_ns
+mnt_warn_timestamp_expiry
+copy_mount_options
+touch_mnt_namespace.part.0
+alloc_mnt_ns
+lookup_mountpoint
+__attach_mnt
+commit_tree
+attach_mnt
+mnt_drop_write
+mnt_drop_write_file
+mnt_list_next
+m_next
+m_start
+mntns_get
+set_mount_attributes
+may_umount
+m_stop
+__put_mountpoint
+umount_tree
+vfs_create_mount
+fc_mount
+vfs_kern_mount.part.0
+vfs_kern_mount
+vfs_submount
+kern_mount
+clone_mnt
+clone_private_mount
+mount_too_revealing
+get_mountpoint
+mnt_release_group_id
+mnt_get_count
+mntput_no_expire
+mntput
+cleanup_mnt
+delayed_mntput
+__cleanup_mnt
+namespace_unlock
+unlock_mount
+mnt_set_expiry
+mark_mounts_for_expiry
+kern_unmount
+kern_unmount_array
+may_umount_tree
+__mnt_want_write
+mnt_want_write
+__mnt_want_write_file
+mnt_want_write_file
+__mnt_drop_write
+__mnt_drop_write_file
+sb_prepare_remount_readonly
+__legitimize_mnt
+legitimize_mnt
+__lookup_mnt
+path_is_mountpoint
+lookup_mnt
+lock_mount
+__is_local_mountpoint
+mnt_set_mountpoint
+mnt_change_mountpoint
+mnt_clone_internal
+mnt_cursor_del
+__detach_mounts
+path_umount
+ksys_umount
+__x64_sys_umount
+__ia32_sys_umount
+__x64_sys_oldumount
+__ia32_sys_oldumount
+from_mnt_ns
+copy_tree
+__do_loopback
+collect_mounts
+dissolve_on_fput
+open_detached_copy
+__ia32_sys_open_tree
+__x64_sys_open_tree
+__ia32_sys_fsmount
+__x64_sys_fsmount
+drop_collected_mounts
+iterate_mounts
+count_mounts
+attach_recursive_mnt
+graft_tree
+do_add_mount
+do_move_mount
+__ia32_sys_move_mount
+__x64_sys_move_mount
+finish_automount
+path_mount
+do_mount
+__ia32_sys_mount
+__x64_sys_mount
+copy_mnt_ns
+is_path_reachable
+path_is_under
+__ia32_sys_pivot_root
+__x64_sys_pivot_root
+put_mnt_ns
+mount_subtree
+mntns_install
+mntns_put
+our_mnt
+current_chrooted
+mnt_may_suid
+single_stop
+single_start
+single_next
+seq_putc
+seq_list_start
+seq_list_next
+seq_hlist_start
+seq_hlist_next
+seq_hlist_start_rcu
+seq_hlist_next_rcu
+seq_open
+traverse
+seq_lseek
+seq_read_iter
+seq_read
+seq_release
+seq_vprintf
+seq_printf
+mangle_path
+single_release
+seq_release_private
+single_open
+single_open_size
+seq_puts
+seq_write
+seq_put_decimal_ll
+seq_pad
+seq_hlist_start_percpu
+seq_list_start_head
+seq_hlist_start_head
+seq_hlist_start_head_rcu
+seq_hlist_next_percpu
+__seq_open_private
+seq_open_private
+seq_hex_dump
+seq_escape_mem_ascii
+seq_escape
+seq_path
+seq_file_path
+seq_dentry
+seq_path_root
+seq_put_decimal_ull_width
+seq_put_decimal_ull
+seq_put_hex_ll
+xattr_resolve_name
+__vfs_setxattr
+__vfs_getxattr
+__vfs_removexattr
+xattr_full_name
+xattr_supported_namespace
+xattr_permission
+generic_listxattr
+xattr_list_one
+vfs_getxattr
+vfs_listxattr
+listxattr
+path_listxattr
+__x64_sys_listxattr
+__ia32_sys_listxattr
+__x64_sys_llistxattr
+__ia32_sys_llistxattr
+getxattr
+path_getxattr
+__x64_sys_getxattr
+__ia32_sys_getxattr
+__x64_sys_lgetxattr
+__ia32_sys_lgetxattr
+__vfs_removexattr_locked
+vfs_removexattr
+removexattr
+path_removexattr
+__x64_sys_removexattr
+__ia32_sys_removexattr
+__x64_sys_lremovexattr
+__ia32_sys_lremovexattr
+__x64_sys_flistxattr
+__x64_sys_fremovexattr
+__ia32_sys_fremovexattr
+__ia32_sys_flistxattr
+__x64_sys_fgetxattr
+__ia32_sys_fgetxattr
+__vfs_setxattr_noperm
+__vfs_setxattr_locked
+vfs_setxattr
+setxattr
+path_setxattr
+__x64_sys_setxattr
+__ia32_sys_setxattr
+__x64_sys_lsetxattr
+__ia32_sys_lsetxattr
+__ia32_sys_fsetxattr
+__x64_sys_fsetxattr
+vfs_getxattr_alloc
+simple_xattr_alloc
+simple_xattr_get
+simple_xattr_set
+simple_xattr_list
+simple_xattr_list_add
+always_delete_dentry
+generic_read_dir
+noop_fsync
+noop_set_page_dirty
+noop_invalidatepage
+noop_direct_IO
+simple_nosetlease
+empty_dir_lookup
+empty_dir_setattr
+empty_dir_listxattr
+generic_check_addressable
+pseudo_fs_get_tree
+kfree_link
+simple_readpage
+simple_statfs
+simple_open
+simple_get_link
+simple_getattr
+empty_dir_getattr
+dcache_dir_open
+dcache_dir_close
+simple_unlink
+pseudo_fs_fill_super
+pseudo_fs_free
+simple_attr_release
+simple_link
+simple_setattr
+simple_fill_super
+simple_read_from_buffer
+simple_transaction_read
+memory_read_from_buffer
+simple_transaction_release
+simple_attr_read
+simple_attr_write
+generic_fh_to_dentry
+generic_fh_to_parent
+__generic_file_fsync
+generic_file_fsync
+alloc_anon_inode
+empty_dir_llseek
+generic_ci_d_compare
+generic_ci_d_hash
+simple_write_end
+simple_lookup
+simple_transaction_set
+simple_attr_open
+anon_set_page_dirty
+init_pseudo
+simple_write_to_buffer
+simple_recursive_removal
+simple_write_begin
+simple_release_fs
+simple_empty
+simple_rmdir
+simple_rename
+empty_dir_readdir
+scan_positives
+dcache_readdir
+dcache_dir_lseek
+simple_transaction_get
+simple_pin_fs
+make_empty_dir_inode
+is_empty_dir_inode
+__traceiter_writeback_dirty_page
+__traceiter_wait_on_page_writeback
+__traceiter_writeback_mark_inode_dirty
+__traceiter_writeback_dirty_inode_start
+__traceiter_writeback_dirty_inode
+__traceiter_inode_foreign_history
+__traceiter_inode_switch_wbs
+__traceiter_track_foreign_dirty
+__traceiter_flush_foreign
+__traceiter_writeback_write_inode_start
+__traceiter_writeback_write_inode
+__traceiter_writeback_queue
+__traceiter_writeback_exec
+__traceiter_writeback_start
+__traceiter_writeback_written
+__traceiter_writeback_wait
+__traceiter_writeback_pages_written
+__traceiter_writeback_wake_background
+__traceiter_writeback_bdi_register
+__traceiter_wbc_writepage
+__traceiter_writeback_queue_io
+__traceiter_global_dirty_state
+__traceiter_bdi_dirty_ratelimit
+__traceiter_balance_dirty_pages
+__traceiter_writeback_sb_inodes_requeue
+__traceiter_writeback_congestion_wait
+__traceiter_writeback_wait_iff_congested
+__traceiter_writeback_single_inode_start
+__traceiter_writeback_single_inode
+__traceiter_writeback_lazytime
+__traceiter_writeback_lazytime_iput
+__traceiter_writeback_dirty_inode_enqueue
+__traceiter_sb_mark_inode_writeback
+__traceiter_sb_clear_inode_writeback
+wb_split_bdi_pages
+wb_io_lists_populated
+wb_wakeup
+wb_start_writeback
+inode_switch_wbs_rcu_fn
+inode_sync_complete
+wakeup_dirtytime_writeback
+block_dump___mark_inode_dirty
+wbc_account_cgroup_owner
+wb_io_lists_depopulated
+inode_io_list_del_locked
+inode_io_list_move_locked
+redirty_tail_locked
+finish_writeback_work.isra.0
+wb_queue_work
+get_nr_dirty_pages
+inode_congested
+__inode_wait_for_writeback
+move_expired_inodes
+queue_io
+inode_sleep_on_writeback
+locked_inode_to_wb_and_lock_list
+inode_io_list_del
+inode_switch_wbs_work_fn
+__inode_attach_wb
+inode_switch_wbs
+wbc_attach_and_unlock_inode
+wbc_detach_inode
+__mark_inode_dirty
+__writeback_single_inode
+writeback_single_inode
+write_inode_now
+sync_inode
+sync_inode_metadata
+writeback_sb_inodes
+__writeback_inodes_wb
+wb_writeback
+wb_wait_for_completion
+bdi_split_work_to_wbs
+__writeback_inodes_sb_nr
+writeback_inodes_sb_nr
+writeback_inodes_sb
+try_to_writeback_inodes_sb
+sync_inodes_sb
+cgroup_writeback_by_id
+cgroup_writeback_umount
+wb_start_background_writeback
+sb_mark_inode_writeback
+sb_clear_inode_writeback
+inode_wait_for_writeback
+wb_workfn
+wakeup_flusher_threads_bdi
+wakeup_flusher_threads
+dirtytime_interval_handler
+next_group
+umount_one
+propagation_next.part.0
+propagate_one
+get_dominating_id
+change_mnt_propagation
+propagate_mnt
+propagate_mount_busy
+propagate_mount_unlock
+propagate_umount
+wakeup_pipe_writers
+wakeup_pipe_readers
+pipe_to_sendpage
+page_cache_pipe_buf_confirm
+page_cache_pipe_buf_release
+splice_to_pipe
+add_to_pipe
+generic_file_splice_read
+user_page_pipe_buf_try_steal
+ipipe_prep
+opipe_prep
+pipe_to_user
+splice_from_pipe_end
+warn_unsupported
+do_splice_to
+splice_direct_to_actor
+do_splice_direct
+wait_for_space
+splice_from_pipe_next.part.0
+__splice_from_pipe
+iter_file_splice_write
+direct_splice_actor
+iter_to_pipe
+__x64_sys_vmsplice
+__ia32_sys_vmsplice
+page_cache_pipe_buf_try_steal
+splice_grow_spd
+splice_shrink_spd
+splice_from_pipe
+generic_splice_sendpage
+do_splice
+__do_splice
+__ia32_sys_splice
+__x64_sys_splice
+do_tee
+__ia32_sys_tee
+__x64_sys_tee
+do_sync_work
+sync_inodes_one_sb
+fdatawait_one_bdev
+fdatawrite_one_bdev
+vfs_fsync_range
+vfs_fsync
+do_fsync
+__x64_sys_fsync
+__ia32_sys_fsync
+__x64_sys_fdatasync
+__ia32_sys_fdatasync
+sync_fs_one_sb
+sync_filesystem
+__x64_sys_syncfs
+__ia32_sys_syncfs
+ksys_sync
+__do_sys_sync
+emergency_sync
+sync_file_range
+ksys_sync_file_range
+__x64_sys_sync_file_range
+__ia32_sys_sync_file_range
+__x64_sys_sync_file_range2
+__ia32_sys_sync_file_range2
+vfs_utimes
+do_utimes
+__ia32_sys_utimensat
+do_futimesat
+__x64_sys_futimesat
+__ia32_sys_futimesat
+__x64_sys_utimes
+__ia32_sys_utimes
+__ia32_sys_utime
+__ia32_sys_utime32
+__ia32_sys_utimensat_time32
+do_compat_futimesat
+__x64_sys_futimesat_time32
+__ia32_sys_futimesat_time32
+__x64_sys_utimes_time32
+__ia32_sys_utimes_time32
+__x64_sys_utime
+__x64_sys_utime32
+__x64_sys_utimensat_time32
+__x64_sys_utimensat
+prepend_name
+prepend
+prepend_path
+d_path
+__ia32_sys_getcwd
+__dentry_path
+dentry_path_raw
+__x64_sys_getcwd
+__d_path
+d_absolute_path
+dynamic_dname
+simple_dname
+dentry_path
+fsstack_copy_inode_size
+fsstack_copy_attr_all
+current_umask
+set_fs_root
+set_fs_pwd
+chroot_fs_refs
+free_fs_struct
+exit_fs
+copy_fs_struct
+unshare_fs_struct
+statfs_by_dentry
+vfs_get_fsid
+do_statfs_native
+do_statfs64
+put_compat_statfs
+put_compat_statfs64
+vfs_ustat
+__x64_sys_ustat
+__ia32_sys_ustat
+__ia32_compat_sys_ustat
+__x32_compat_sys_ustat
+vfs_statfs
+user_statfs
+__x64_sys_statfs
+__ia32_sys_statfs
+__x64_sys_statfs64
+__ia32_sys_statfs64
+__ia32_compat_sys_statfs
+__x32_compat_sys_statfs
+fd_statfs
+__x64_sys_fstatfs
+__ia32_sys_fstatfs
+__x64_sys_fstatfs64
+__ia32_sys_fstatfs64
+__ia32_compat_sys_fstatfs
+__x32_compat_sys_fstatfs
+kcompat_sys_statfs64
+__ia32_compat_sys_statfs64
+__x32_compat_sys_statfs64
+kcompat_sys_fstatfs64
+__ia32_compat_sys_fstatfs64
+__x32_compat_sys_fstatfs64
+pin_remove
+pin_insert
+pin_kill
+mnt_pin_kill
+group_pin_kill
+ns_prune_dentry
+ns_get_path_task
+ns_dname
+__ns_get_path
+open_related_ns
+ns_ioctl
+nsfs_init_fs_context
+nsfs_show_path
+nsfs_evict
+ns_get_path_cb
+ns_get_path
+ns_get_name
+proc_ns_file
+proc_ns_fget
+ns_match
+fs_ftype_to_dtype
+fs_umode_to_ftype
+fs_umode_to_dtype
+legacy_reconfigure
+legacy_fs_context_free
+legacy_fs_context_dup
+legacy_parse_monolithic
+logfc
+vfs_parse_fs_param
+vfs_parse_fs_string
+generic_parse_monolithic
+legacy_parse_param
+legacy_get_tree
+legacy_init_fs_context
+put_fs_context
+vfs_dup_fs_context
+alloc_fs_context
+fs_context_for_mount
+fs_context_for_reconfigure
+fs_context_for_submount
+fc_drop_locked
+parse_monolithic_mount_data
+vfs_clean_context
+finish_clean_context
+fs_param_is_blockdev
+lookup_constant
+fs_lookup_param
+__fs_parse
+fs_param_is_blob.part.0
+fs_param_is_bool
+fs_param_is_enum
+fs_param_is_string
+fs_param_is_blob
+fs_param_is_u32
+fs_param_is_fd
+fs_param_is_s32
+fs_param_is_u64
+fs_param_is_path
+validate_constant_table
+fs_validate_description
+fscontext_release
+fscontext_read
+__ia32_sys_fsconfig
+fscontext_alloc_log
+__ia32_sys_fspick
+__ia32_sys_fsopen
+__x64_sys_fsopen
+__x64_sys_fspick
+__x64_sys_fsconfig
+kernel_read_file
+kernel_read_file_from_fd
+kernel_read_file_from_path
+kernel_read_file_from_path_initns
+remap_verify_area
+vfs_dedupe_file_range_one
+vfs_dedupe_file_range
+do_clone_file_range
+vfs_clone_file_range
+vfs_dedupe_get_page
+generic_remap_file_range_prep
+unlock_buffer
+invalidate_bh_lrus
+__end_buffer_read_notouch
+end_buffer_read_sync
+end_buffer_read_nobh
+mark_buffer_async_write
+has_bh_in_lru
+generic_block_bmap
+buffer_check_dirty_writeback
+__set_page_dirty
+init_page_buffers
+end_bio_bh_io_sync
+submit_bh_wbc
+submit_bh
+ll_rw_block
+__brelse
+invalidate_bh_lru
+buffer_exit_cpu_dead
+set_bh_page.part.0
+set_bh_page
+block_is_partially_uptodate
+buffer_io_error
+end_buffer_async_read
+decrypt_bh
+end_buffer_async_read_io
+mark_buffer_dirty
+mark_buffer_dirty_inode
+__block_commit_write.isra.0
+block_commit_write
+generic_cont_expand_simple
+__x64_sys_bdflush
+recalc_bh_state.part.0
+alloc_buffer_head
+free_buffer_head
+alloc_page_buffers
+__wait_on_buffer
+__lock_buffer
+__ia32_sys_bdflush
+clean_bdev_aliases
+mark_buffer_write_io_error
+end_buffer_write_sync
+end_buffer_async_write
+bh_submit_read
+write_dirty_buffer
+block_invalidatepage
+__sync_dirty_buffer
+sync_dirty_buffer
+sync_mapping_buffers
+bh_uptodate_or_lock
+attach_nobh_buffers
+__bforget
+invalidate_inode_buffers
+create_empty_buffers
+create_page_buffers
+__set_page_dirty_buffers
+__find_get_block
+drop_buffers
+try_to_free_buffers
+__getblk_gfp
+__breadahead
+__breadahead_gfp
+__bread_gfp
+page_zero_new_buffers
+block_write_end
+generic_write_end
+nobh_write_end
+block_read_full_page
+__block_write_full_page
+nobh_writepage
+block_write_full_page
+block_truncate_page
+nobh_truncate_page
+inode_has_buffers
+emergency_thaw_bdev
+write_boundary_block
+remove_inode_buffers
+__block_write_begin_int
+__block_write_begin
+block_write_begin
+cont_write_begin
+block_page_mkwrite
+nobh_write_begin
+I_BDEV
+bdev_free_inode
+bdev_alloc_inode
+blkdev_get_block
+bdev_test
+bdev_set
+bd_init_fs_context
+init_once
+invalidate_bdev
+kill_bdev
+thaw_bdev
+blkdev_fsync
+bdgrab
+bdget
+blkdev_iopoll
+blkdev_bio_end_io_simple
+blkdev_bio_end_io
+blkdev_releasepage
+blkdev_write_end
+blkdev_write_begin
+blkdev_readahead
+blkdev_writepages
+blkdev_readpage
+blkdev_writepage
+bdput
+bd_unlink_disk_holder
+blkdev_read_iter
+block_ioctl
+block_llseek
+__invalidate_device
+bd_clear_claiming.part.0
+blkdev_write_iter
+bd_link_disk_holder
+__blkdev_direct_IO_simple
+blkdev_direct_IO
+bdev_evict_inode
+bd_may_claim
+bd_set_nr_sectors
+bd_abort_claiming
+check_disk_size_change
+revalidate_disk_size
+bdev_disk_changed
+bd_prepare_to_claim
+truncate_bdev_range
+blkdev_fallocate
+__sync_blockdev
+sync_blockdev
+set_blocksize
+sb_set_blocksize
+sb_min_blocksize
+fsync_bdev
+freeze_bdev
+__blkdev_put
+__blkdev_get
+blkdev_get
+blkdev_get_by_dev
+blkdev_put
+blkdev_close
+bdev_read_page
+bdev_write_page
+bdget_part
+nr_blockdev_pages
+bd_forget
+bd_acquire
+blkdev_open
+lookup_bdev.part.0
+lookup_bdev
+blkdev_get_by_path
+iterate_bdevs
+dio_bio_end_io
+dio_complete
+dio_aio_complete_work
+dio_bio_complete
+dio_bio_end_aio
+sb_init_dio_done_wq
+dio_set_defer_completion
+__blockdev_direct_IO
+mpage_alloc
+mpage_end_io
+mpage_writepages
+clean_buffers
+__mpage_writepage
+mpage_writepage
+do_mpage_readpage
+mpage_readahead
+mpage_readpage
+clean_page_buffers
+mounts_poll
+mounts_release
+show_mnt_opts
+show_type
+show_vfsstat
+show_sb_opts
+show_vfsmnt
+show_mountinfo
+mounts_open_common
+mounts_open
+mountinfo_open
+mountstats_open
+__fsnotify_inode_delete
+fsnotify
+__fsnotify_update_child_dentry_flags.part.0
+__fsnotify_parent
+__fsnotify_vfsmount_delete
+fsnotify_sb_delete
+__fsnotify_update_child_dentry_flags
+fsnotify_get_cookie
+fsnotify_notify_queue_is_empty.part.0
+fsnotify_remove_queued_event.part.0
+fsnotify_destroy_event.part.0
+fsnotify_notify_queue_is_empty
+fsnotify_destroy_event
+fsnotify_add_event
+fsnotify_remove_queued_event
+fsnotify_remove_first_event
+fsnotify_peek_first_event
+fsnotify_flush_notify
+fsnotify_alloc_group
+fsnotify_put_group
+fsnotify_group_stop_queueing
+fsnotify_destroy_group
+fsnotify_get_group
+fsnotify_fasync
+fsnotify_detach_connector_from_object
+fsnotify_final_mark_destroy
+fsnotify_drop_object
+fsnotify_init_mark
+fsnotify_wait_marks_destroyed
+__fsnotify_recalc_mask
+fsnotify_grab_connector
+fsnotify_connector_destroy_workfn
+fsnotify_mark_destroy_workfn
+fsnotify_put_mark
+fsnotify_put_mark_wake.part.0
+fsnotify_get_mark
+fsnotify_find_mark
+fsnotify_conn_mask
+fsnotify_recalc_mask
+fsnotify_prepare_user_wait
+fsnotify_finish_user_wait
+fsnotify_detach_mark
+fsnotify_free_mark
+fsnotify_destroy_mark
+fsnotify_compare_groups
+fsnotify_add_mark_locked
+fsnotify_add_mark
+fsnotify_clear_marks_by_group
+fsnotify_destroy_marks
+show_fdinfo
+show_mark_fhandle
+inotify_fdinfo
+fanotify_fdinfo
+inotify_show_fdinfo
+fanotify_show_fdinfo
+dnotify_free_mark
+dnotify_recalc_inode_mask
+dnotify_handle_event
+dnotify_flush
+fcntl_dirnotify
+inotify_merge
+inotify_free_mark
+inotify_free_event
+inotify_freeing_mark
+inotify_free_group_priv
+idr_callback
+inotify_one_event
+inotify_handle_event
+inotify_release
+do_inotify_init
+__x64_sys_inotify_init1
+__ia32_sys_inotify_init1
+__do_sys_inotify_init
+inotify_find_inode
+inotify_idr_find_locked
+__x64_sys_inotify_rm_watch
+__ia32_sys_inotify_rm_watch
+inotify_poll
+inotify_read
+inotify_remove_from_idr
+inotify_update_watch
+__ia32_sys_inotify_add_watch
+__x64_sys_inotify_add_watch
+inotify_ioctl
+inotify_ignored_and_remove_idr
+fanotify_free_mark
+fanotify_free_group_priv
+fanotify_fh_equal.part.0
+fanotify_merge
+fanotify_free_event
+fanotify_encode_fh
+fanotify_handle_event
+copy_info_to_user
+__x64_sys_fanotify_init
+fanotify_event_info_len
+finish_permission_event
+fanotify_write
+fanotify_poll
+fanotify_add_mark
+fanotify_remove_mark
+do_fanotify_mark
+__x64_sys_fanotify_mark
+__ia32_sys_fanotify_mark
+__ia32_compat_sys_fanotify_mark
+__x32_compat_sys_fanotify_mark
+fanotify_release
+fanotify_ioctl
+fanotify_read
+__ia32_sys_fanotify_init
+epi_rcu_free
+ep_show_fdinfo
+ep_ptable_queue_proc
+ep_create_wakeup_source
+ep_destroy_wakeup_source
+ep_busy_loop_end
+ep_unregister_pollwait.isra.0
+ep_call_nested.constprop.0
+reverse_path_check_proc
+ep_loop_check_proc
+ep_poll_callback
+ep_remove
+ep_free
+ep_eventpoll_release
+do_epoll_create
+__x64_sys_epoll_create1
+__ia32_sys_epoll_create1
+__x64_sys_epoll_create
+__ia32_sys_epoll_create
+ep_scan_ready_list.constprop.0
+ep_item_poll
+ep_read_events_proc
+ep_send_events_proc
+ep_eventpoll_poll
+ep_poll
+do_epoll_wait
+__x64_sys_epoll_wait
+__ia32_sys_epoll_wait
+__ia32_sys_epoll_pwait
+__ia32_compat_sys_epoll_pwait
+__x64_sys_epoll_pwait
+__x32_compat_sys_epoll_pwait
+eventpoll_release_file
+get_epoll_tfile_raw_ptr
+do_epoll_ctl
+__ia32_sys_epoll_ctl
+__x64_sys_epoll_ctl
+anon_inode_getfile
+anon_inode_getfd
+anon_inodefs_init_fs_context
+anon_inodefs_dname
+signalfd_release
+signalfd_show_fdinfo
+signalfd_copyinfo
+do_signalfd4
+__ia32_sys_signalfd4
+__ia32_sys_signalfd
+do_compat_signalfd4
+__ia32_compat_sys_signalfd4
+__x32_compat_sys_signalfd4
+__ia32_compat_sys_signalfd
+__x32_compat_sys_signalfd
+__x64_sys_signalfd4
+__x64_sys_signalfd
+signalfd_read
+signalfd_poll
+signalfd_cleanup
+timerfd_get_remaining
+timerfd_poll
+timerfd_triggered
+timerfd_alarmproc
+timerfd_tmrproc
+timerfd_fget
+timerfd_canceled
+timerfd_ioctl
+__x64_sys_timerfd_create
+__timerfd_remove_cancel
+timerfd_release
+__ia32_sys_timerfd_create
+timerfd_show
+timerfd_read
+do_timerfd_settime
+__ia32_sys_timerfd_settime
+__ia32_sys_timerfd_settime32
+__x64_sys_timerfd_settime32
+__x64_sys_timerfd_settime
+do_timerfd_gettime
+__ia32_sys_timerfd_gettime
+__ia32_sys_timerfd_gettime32
+__x64_sys_timerfd_gettime
+__x64_sys_timerfd_gettime32
+timerfd_clock_was_set
+eventfd_poll
+eventfd_signal
+eventfd_ctx_remove_wait_queue
+eventfd_free_ctx
+eventfd_fget
+do_eventfd
+__x64_sys_eventfd2
+__ia32_sys_eventfd2
+__x64_sys_eventfd
+__ia32_sys_eventfd
+eventfd_ctx_fileget.part.0
+eventfd_ctx_fileget
+eventfd_ctx_fdget
+eventfd_release
+eventfd_ctx_put
+eventfd_show_fdinfo
+eventfd_write
+eventfd_read
+__ia32_sys_userfaultfd
+init_once_userfaultfd_ctx
+userfaultfd_poll
+userfaultfd_wake_function
+userfaultfd_ctx_put
+__x64_sys_userfaultfd
+__wake_userfault
+userfaultfd_show_fdinfo
+userfaultfd_read
+userfaultfd_event_wait_completion
+userfaultfd_release
+userfaultfd_ioctl
+handle_userfault
+dup_userfaultfd
+dup_userfaultfd_complete
+mremap_userfaultfd_prep
+mremap_userfaultfd_complete
+userfaultfd_remove
+userfaultfd_unmap_prep
+userfaultfd_unmap_complete
+aio_ring_mmap
+kiocb_set_cancel_fn
+aio_init_fs_context
+free_ioctx_reqs
+lookup_ioctx
+aio_prep_rw
+aio_write
+aio_poll_queue_proc
+aio_read_events
+read_events
+aio_fsync
+aio_read
+put_reqs_available
+refill_reqs_available
+__get_reqs_available
+aio_nr_sub
+aio_poll_cancel
+aio_ring_mremap
+put_aio_ring_file
+aio_free_ring
+free_ioctx
+__x64_sys_io_cancel
+__ia32_sys_io_cancel
+free_ioctx_users
+do_io_getevents
+__ia32_sys_io_getevents
+__ia32_sys_io_pgetevents
+__ia32_sys_io_getevents_time32
+__ia32_compat_sys_io_pgetevents
+__ia32_compat_sys_io_pgetevents_time64
+__x64_sys_io_getevents
+__x64_sys_io_getevents_time32
+__x32_compat_sys_io_pgetevents
+__x32_compat_sys_io_pgetevents_time64
+__x64_sys_io_pgetevents
+aio_poll_put_work
+aio_poll_wake
+aio_migratepage
+aio_fsync_work
+aio_complete_rw
+aio_poll_complete_work
+io_submit_one
+__ia32_sys_io_submit
+__ia32_compat_sys_io_submit
+__x32_compat_sys_io_submit
+__x64_sys_io_submit
+kill_ioctx
+__ia32_sys_io_destroy
+__x64_sys_io_destroy
+ioctx_alloc
+__ia32_sys_io_setup
+__ia32_compat_sys_io_setup
+__x32_compat_sys_io_setup
+__x64_sys_io_setup
+exit_aio
+__traceiter_io_uring_create
+__traceiter_io_uring_register
+__traceiter_io_uring_file_get
+__traceiter_io_uring_queue_async_work
+__traceiter_io_uring_defer
+__traceiter_io_uring_link
+__traceiter_io_uring_cqring_wait
+__traceiter_io_uring_fail_link
+__traceiter_io_uring_complete
+__traceiter_io_uring_submit_sqe
+__traceiter_io_uring_poll_arm
+__traceiter_io_uring_poll_wake
+__traceiter_io_uring_task_add
+__traceiter_io_uring_task_run
+io_uring_get_socket
+io_cancel_task_cb
+io_cancel_cb
+io_prep_linked_timeout
+io_wq_files_match
+io_file_supports_async
+io_uring_show_cred
+io_uring_fasync
+io_sq_thread_park
+io_sq_thread_unpark
+io_mem_free
+io_req_task_work_add
+io_free_req_deferred
+__io_queue_async_work
+__io_queue_linked_timeout
+loop_rw_iter
+kiocb_end_write
+io_complete_rw_iopoll
+io_recvmsg_copy_hdr
+io_uring_del_task_file
+io_uring_flush
+io_uring_mmap
+io_sqpoll_wait_sq
+io_prep_rw
+__io_openat_prep
+io_ring_ctx_ref_free
+io_file_ref_kill
+io_sq_thread_drop_mm
+io_poll_rewait
+tctx_inflight
+io_match_files
+io_match_link.part.0
+io_cancel_link_cb
+__io_remove_buffers.part.0
+__io_destroy_buffers
+io_cqring_ev_posted
+io_iter_do_read
+io_buffer_select.part.0
+io_rw_buffer_select
+__io_import_iovec
+io_recv_buffer_select
+io_grab_identity
+io_sq_wake_function
+io_sqe_buffer_unregister
+io_init_identity
+io_uring_alloc_task_context
+io_uring_add_task_file
+alloc_fixed_file_ref_node
+io_req_task_queue
+io_file_put_work
+__io_async_wake
+io_poll_wake
+io_async_wake
+io_file_get
+__io_poll_remove_one
+io_remove_personalities
+io_sq_thread_stop
+io_sqe_files_unregister
+__io_sq_thread_acquire_mm
+io_file_data_ref_zero
+__io_arm_poll_handler
+io_poll_remove_double
+io_poll_double_wake
+__io_sqe_files_scm
+io_async_buf_func
+io_prep_async_work
+io_prep_async_link
+io_uring_show_fdinfo
+__io_sqe_files_update
+__io_splice_prep
+__io_queue_proc
+io_poll_queue_proc
+io_async_queue_proc
+io_run_task_work_sig
+__io_clean_op
+io_dismantle_req
+__io_free_req
+__io_cqring_fill_event
+io_kill_timeout
+io_kill_timeouts
+io_commit_cqring
+__io_timeout_cancel
+io_timeout_cancel
+__io_req_find_next
+io_queue_next
+io_put_req_deferred_cb
+io_double_put_req
+io_put_req
+io_poll_remove_one
+io_poll_cancel
+io_poll_remove_all
+io_async_find_and_cancel
+io_submit_flush_completions
+__io_req_complete.part.0
+__io_req_complete
+io_send
+io_recv
+io_openat2
+io_link_timeout_fn
+io_timeout_fn
+io_queue_linked_timeout
+io_queue_async_work
+io_cqring_overflow_flush
+io_cqring_events
+io_uring_poll
+io_wake_function
+io_cqring_wait
+io_cancel_defer_files
+io_free_work
+io_put_req_find_next
+__io_req_task_cancel
+io_req_task_cancel
+io_poll_complete.constprop.0
+ring_pages
+io_setup_async_rw.part.0
+io_resubmit_prep
+__io_complete_rw.isra.0
+kiocb_done
+io_complete_rw
+io_iopoll_complete
+io_do_iopoll
+io_iopoll_try_reap_events.part.0
+io_ring_exit_work
+io_ring_ctx_wait_and_kill
+io_uring_release
+io_iopoll_check
+io_read
+io_write
+io_uring_setup
+__x64_sys_io_uring_setup
+__ia32_sys_io_uring_setup
+io_setup_async_msg
+io_sendmsg
+io_recvmsg
+io_timeout_prep
+io_req_prep
+io_req_defer_prep
+__io_uring_register
+__ia32_sys_io_uring_register
+__x64_sys_io_uring_register
+io_connect
+io_issue_sqe
+io_wq_submit_work
+__io_queue_sqe
+__io_req_task_submit
+io_req_task_submit
+io_poll_task_func
+io_async_task_func
+io_queue_sqe
+io_submit_sqes
+__ia32_sys_io_uring_enter
+io_sq_thread
+__x64_sys_io_uring_enter
+__io_uring_free
+__io_uring_files_cancel
+__io_uring_task_cancel
+io_wq_io_cb_cancel_data
+io_wq_worker_wake
+io_wqe_worker_send_sig
+io_wq_worker_cancel
+io_wq_worker_affinity
+io_worker_release
+io_wq_for_each_worker
+io_wq_cpu_online
+io_wqe_wake_worker
+io_wqe_dec_running
+io_wqe_enqueue
+io_assign_current_work
+io_worker_handle_work
+create_io_worker
+io_wq_manager
+__io_worker_unuse
+io_wqe_worker
+io_wq_worker_running
+io_wq_worker_sleeping
+io_wq_enqueue
+io_wq_hash_work
+io_wq_cancel_all
+io_wq_cancel_cb
+io_wq_cancel_work
+io_wq_create
+io_wq_get
+io_wq_destroy
+io_wq_get_task
+__traceiter_dax_pmd_fault
+__traceiter_dax_pmd_fault_done
+__traceiter_dax_pmd_load_hole
+__traceiter_dax_pmd_load_hole_fallback
+__traceiter_dax_pmd_insert_mapping
+__traceiter_dax_pte_fault
+__traceiter_dax_pte_fault_done
+__traceiter_dax_load_hole
+__traceiter_dax_insert_pfn_mkwrite_no_entry
+__traceiter_dax_insert_pfn_mkwrite
+__traceiter_dax_insert_mapping
+__traceiter_dax_writeback_range
+__traceiter_dax_writeback_range_done
+__traceiter_dax_writeback_one
+dax_disassociate_entry
+dax_wake_entry
+dax_iomap_pfn
+dax_iomap_rw
+dax_iomap_actor
+wake_exceptional_entry_func
+dax_entry_mkclean
+get_unlocked_entry
+wait_entry_unlocked
+dax_unlock_entry
+__dax_invalidate_entry
+dax_insert_entry
+dax_writeback_mapping_range
+dax_layout_busy_page_range
+dax_layout_busy_page
+dax_finish_sync_fault
+grab_mapping_entry
+dax_iomap_pte_fault
+dax_iomap_pmd_fault
+dax_iomap_fault
+dax_lock_page
+dax_unlock_page
+dax_delete_mapping_entry
+dax_invalidate_mapping_entry_sync
+dax_iomap_zero
+fscrypt_enqueue_decrypt_work
+fscrypt_free_bounce_page.part.0
+fscrypt_free_bounce_page
+fscrypt_alloc_bounce_page
+fscrypt_generate_iv
+fscrypt_initialize
+fscrypt_crypt_block
+fscrypt_encrypt_pagecache_blocks
+fscrypt_encrypt_block_inplace
+fscrypt_decrypt_pagecache_blocks
+fscrypt_decrypt_block_inplace
+fscrypt_match_name
+fscrypt_fname_siphash
+fscrypt_fname_free_buffer
+fscrypt_d_revalidate
+fscrypt_fname_alloc_buffer
+fname_decrypt
+fscrypt_fname_disk_to_usr
+fscrypt_fname_encrypt
+fscrypt_fname_encrypted_size
+fscrypt_setup_filename
+fscrypt_init_hkdf
+fscrypt_hkdf_expand
+fscrypt_destroy_hkdf
+fscrypt_prepare_symlink
+__fscrypt_encrypt_symlink
+fscrypt_get_symlink
+__fscrypt_prepare_lookup
+fscrypt_file_open
+__fscrypt_prepare_link
+__fscrypt_prepare_rename
+fscrypt_prepare_setflags
+fscrypt_key_instantiate
+fscrypt_user_key_describe
+fscrypt_provisioning_key_destroy
+fscrypt_provisioning_key_free_preparse
+fscrypt_provisioning_key_preparse
+fscrypt_user_key_instantiate
+format_mk_description
+search_fscrypt_keyring
+find_master_key_user
+add_master_key_user
+fscrypt_key_describe
+fscrypt_provisioning_key_describe
+move_master_key_secret
+free_master_key
+fscrypt_key_destroy
+try_to_lock_encrypted_files
+fscrypt_sb_free
+fscrypt_find_master_key
+add_master_key
+fscrypt_ioctl_add_key
+do_remove_key
+fscrypt_ioctl_remove_key
+fscrypt_ioctl_remove_key_all_users
+fscrypt_ioctl_get_key_status
+fscrypt_add_test_dummy_key
+fscrypt_verify_key_added
+fscrypt_drop_inode
+fscrypt_free_inode
+put_crypt_info
+fscrypt_put_encryption_info
+fscrypt_prepare_key
+setup_per_mode_enc_key
+fscrypt_destroy_prepared_key
+fscrypt_set_per_file_enc_key
+fscrypt_derive_dirhash_key
+fscrypt_hash_inode_number
+fscrypt_setup_v2_file_key
+fscrypt_setup_encryption_info
+fscrypt_get_encryption_info
+fscrypt_prepare_new_inode
+find_and_lock_process_key
+find_or_insert_direct_key
+derive_key_aes
+fscrypt_put_direct_key
+fscrypt_setup_v1_file_key
+fscrypt_setup_v1_file_key_via_subscribed_keyrings
+fscrypt_new_context
+fscrypt_ioctl_get_nonce
+fscrypt_set_context
+fscrypt_show_test_dummy_encryption
+fscrypt_valid_enc_modes
+supported_direct_key_modes
+supported_iv_ino_lblk_policy.constprop.0
+fscrypt_policies_equal
+fscrypt_set_test_dummy_encryption
+fscrypt_supported_policy
+set_encryption_policy
+fscrypt_policy_from_context
+fscrypt_get_policy
+fscrypt_ioctl_set_policy
+fscrypt_ioctl_get_policy
+fscrypt_ioctl_get_policy_ex
+fscrypt_has_permitted_context
+fscrypt_policy_to_inherit
+fscrypt_decrypt_bio
+fscrypt_zeroout_range
+fscrypt_generate_dun
+bh_get_inode_and_lblk_num
+__fscrypt_inode_uses_inline_crypto
+fscrypt_mergeable_bio
+fscrypt_mergeable_bio_bh
+fscrypt_get_dun_bytes
+fscrypt_set_bio_crypt_ctx
+fscrypt_set_bio_crypt_ctx_bh
+fscrypt_select_encryption_impl
+fscrypt_prepare_inline_crypt_key
+fscrypt_destroy_inline_crypt_key
+build_merkle_tree
+enable_verity
+fsverity_ioctl_enable
+fsverity_free_hash_request.part.0
+fsverity_get_hash_alg
+fsverity_alloc_hash_request
+fsverity_free_hash_request
+fsverity_prepare_hash_state
+fsverity_hash_page
+fsverity_hash_buffer
+fsverity_ioctl_measure
+fsverity_prepare_setattr
+fsverity_free_info.part.0
+fsverity_cleanup_inode
+fsverity_init_merkle_tree_params
+fsverity_create_info
+fsverity_set_info
+fsverity_file_open
+fsverity_free_info
+extract_hash
+fsverity_enqueue_verify_work
+verify_page
+fsverity_verify_page
+fsverity_verify_bio
+fsverity_verify_signature
+__traceiter_locks_get_lock_context
+__traceiter_posix_lock_inode
+__traceiter_fcntl_setlk
+__traceiter_locks_remove_posix
+__traceiter_flock_lock_inode
+__traceiter_break_lease_noblock
+__traceiter_break_lease_block
+__traceiter_break_lease_unblock
+__traceiter_generic_delete_lease
+__traceiter_time_out_leases
+__traceiter_generic_add_lease
+__traceiter_leases_conflict
+locks_copy_conflock
+flock64_to_posix_lock
+flock_locks_conflict
+check_conflicting_open
+vfs_cancel_lock
+leases_conflict
+any_leases_conflict
+locks_copy_lock
+locks_dump_ctx_list
+locks_check_ctx_file_list
+locks_get_lock_context
+locks_alloc_lock
+locks_release_private
+locks_free_lock
+locks_dispose_list
+lease_alloc
+locks_init_lock
+flock_make_lock
+__locks_wake_up_blocks
+__locks_insert_block
+lease_setup
+lease_break_callback
+lease_register_notifier
+lease_unregister_notifier
+locks_translate_pid
+locks_next
+locks_start
+lock_get_status
+__show_fd_locks
+locks_show
+posix_locks_conflict
+locks_stop
+locks_wake_up_blocks.part.0
+locks_insert_global_locks
+locks_unlink_lock_ctx
+lease_modify
+time_out_leases
+locks_delete_block
+locks_move_blocks
+posix_test_lock
+vfs_test_lock
+lease_get_mtime
+generic_setlease
+vfs_setlease
+__break_lease
+flock_lock_inode
+locks_remove_flock
+posix_lock_inode
+posix_lock_file
+vfs_lock_file
+locks_remove_posix
+do_lock_file_wait
+locks_mandatory_area
+locks_lock_inode_wait
+__ia32_sys_flock
+__x64_sys_flock
+locks_free_lock_context
+locks_mandatory_locked
+fcntl_getlease
+fcntl_setlease
+fcntl_getlk
+fcntl_setlk
+locks_remove_file
+show_fd_locks
+load_script
+total_mapping_size
+notesize
+writenote
+load_elf_phdrs
+load_elf_library
+elf_map
+set_brk
+load_elf_binary
+elf_core_dump
+total_mapping_size
+notesize
+writenote
+load_elf_phdrs
+load_elf_library
+elf_map
+set_brk
+load_elf_binary
+elf_core_dump
+__mb_cache_entry_free
+mb_cache_entry_touch
+mb_cache_count
+mb_cache_entry_delete
+mb_cache_create
+mb_cache_destroy
+mb_cache_shrink
+mb_cache_shrink_worker
+mb_cache_scan
+mb_cache_entry_get
+__entry_find
+mb_cache_entry_find_first
+mb_cache_entry_find_next
+mb_cache_entry_create
+posix_acl_init
+posix_acl_alloc
+posix_acl_equiv_mode
+posix_acl_from_mode
+posix_acl_create_masq
+posix_acl_xattr_list
+posix_acl_valid
+posix_acl_to_xattr
+posix_acl_clone
+posix_acl_update_mode
+posix_acl_fix_xattr_userns
+set_posix_acl
+acl_by_type.part.0
+get_cached_acl_rcu
+get_cached_acl
+__posix_acl_chmod
+forget_cached_acl
+forget_all_cached_acls
+set_cached_acl
+get_acl
+posix_acl_xattr_get
+__posix_acl_create
+posix_acl_chmod
+posix_acl_from_xattr
+posix_acl_xattr_set
+posix_acl_create
+posix_acl_permission
+posix_acl_fix_xattr_from_user
+posix_acl_fix_xattr_to_user
+simple_set_acl
+simple_acl_create
+dump_truncate
+umh_pipe_setup
+zap_process
+expand_corename
+cn_vprintf
+cn_printf
+cn_esc_printf
+cn_print_exe_file
+dump_emit
+dump_skip
+dump_align
+do_coredump
+dump_user_range
+dump_vma_snapshot
+drop_pagecache_sb
+drop_caches_sysctl_handler
+vfs_dentry_acceptable
+do_sys_name_to_handle
+__ia32_sys_name_to_handle_at
+do_handle_open
+__x64_sys_open_by_handle_at
+__ia32_sys_open_by_handle_at
+__ia32_compat_sys_open_by_handle_at
+__x32_compat_sys_open_by_handle_at
+__x64_sys_name_to_handle_at
+__traceiter_iomap_readpage
+__traceiter_iomap_readahead
+__traceiter_iomap_writepage
+__traceiter_iomap_releasepage
+__traceiter_iomap_invalidatepage
+__traceiter_iomap_dio_invalidate_fail
+__traceiter_iomap_apply_dstmap
+__traceiter_iomap_apply_srcmap
+__traceiter_iomap_apply
+iomap_apply
+iomap_file_unshare
+iomap_zero_range
+iomap_ioend_try_merge
+iomap_ioend_compare
+iomap_file_buffered_write
+iomap_adjust_read_range
+iomap_is_partially_uptodate
+iomap_truncate_page
+iomap_read_inline_data
+iomap_set_page_dirty
+iomap_read_page_sync
+iomap_page_mkwrite
+iomap_sort_ioends
+iomap_submit_ioend
+iomap_writepages
+iomap_readpage
+iomap_finish_ioend
+iomap_finish_ioends
+iomap_writepage_end_bio
+iomap_page_create
+iomap_page_mkwrite_actor
+iomap_set_range_uptodate
+iomap_read_end_io
+iomap_readpage_actor
+iomap_readahead_actor
+iomap_write_end
+iomap_page_release
+iomap_releasepage
+iomap_invalidatepage
+iomap_readahead
+iomap_migrate_page
+iomap_write_begin
+iomap_write_actor
+iomap_unshare_actor
+iomap_zero_range_actor
+iomap_do_writepage
+iomap_writepage
+iomap_dio_iopoll
+iomap_dio_complete
+iomap_dio_complete_work
+iomap_dio_submit_bio
+iomap_dio_zero
+iomap_dio_bio_actor
+iomap_dio_actor
+__iomap_dio_rw
+iomap_dio_rw
+iomap_dio_bio_end_io
+iomap_to_fiemap
+iomap_fiemap
+iomap_bmap
+iomap_fiemap_actor
+iomap_bmap_actor
+iomap_seek_hole
+iomap_seek_data
+page_cache_seek_hole_data
+iomap_seek_hole_actor
+iomap_seek_data_actor
+iomap_swapfile_add_extent
+iomap_swapfile_activate
+iomap_swapfile_activate_actor
+dqcache_shrink_count
+__quota_error
+dquot_destroy
+dquot_alloc
+dquot_decr_inodes
+dquot_decr_space
+prepare_warning
+dquot_commit_info
+info_idq_free
+dquot_acquire
+dquot_release
+ignore_hardlimit
+flush_warnings
+vfs_cleanup_quota_inode
+do_proc_dqstats
+inode_reserved_space
+dquot_get_next_id
+register_quota_format
+mark_info_dirty
+unregister_quota_format
+do_get_dqblk
+dqcache_shrink_scan
+dquot_get_state
+dquot_set_dqinfo
+dquot_add_inodes
+dquot_initialize_needed
+dquot_add_space
+dquot_free_inode
+dquot_reclaim_space_nodirty
+dquot_claim_space_nodirty
+dquot_commit
+dquot_mark_dquot_dirty
+__dquot_free_space
+dqput.part.0
+dqput
+dquot_scan_active
+dquot_writeback_dquots
+dquot_quota_sync
+dqget
+dquot_get_dqblk
+dquot_get_next_dqblk
+dquot_set_dqblk
+__dquot_drop
+dquot_drop
+dquot_alloc_inode
+__dquot_alloc_space
+dquot_disable
+dquot_quota_off
+dquot_quota_disable
+dquot_quota_enable
+__dquot_transfer
+dquot_transfer
+__dquot_initialize
+dquot_initialize
+dquot_file_open
+dquot_load_quota_sb
+dquot_resume
+dquot_load_quota_inode
+dquot_quota_on
+dquot_quota_on_mount
+quota_sync_all
+quota_state_to_flags
+quota_sync_one
+quotactl_block
+compat_copy_fs_qfilestat
+quota_getinfo
+copy_to_if_dqblk
+quota_getstate
+quota_getstatev
+copy_to_xfs_dqblk
+quota_getxstatev
+quota_setxquota
+quota_getxquota
+quota_getnextquota
+quota_getnextxquota
+quota_getquota
+quota_setquota
+do_quotactl
+__ia32_sys_quotactl
+__x64_sys_quotactl
+qtype_enforce_flag
+qid_eq
+qid_lt
+qid_valid
+from_kqid
+from_kqid_munged
+quota_send_warning
+show_vma_header_prefix
+m_next
+clear_refs_test_walk
+__show_smap
+show_map_vma
+show_map
+pagemap_pte_hole
+proc_maps_open
+pid_maps_open
+pid_smaps_open
+pid_numa_maps_open
+pagemap_open
+smap_gather_stats
+show_smap
+smaps_pte_hole
+smaps_rollup_release
+show_numa_map
+smaps_rollup_open
+pagemap_read
+smaps_page_accumulate
+pagemap_release
+proc_map_release
+smaps_account
+m_stop
+gather_stats
+clear_refs_write
+hold_task_mempolicy
+m_start
+show_smaps_rollup
+gather_hugetlb_stats
+pagemap_hugetlb_range
+smaps_hugetlb_range
+gather_pte_stats
+smaps_pte_range
+clear_refs_pte_range
+pagemap_pmd_range
+task_mem
+task_vsize
+task_statm
+init_once
+proc_free_inode
+proc_evict_inode
+proc_alloc_inode
+unuse_pde
+proc_put_link
+proc_reg_get_unmapped_area
+proc_show_options
+proc_get_link
+close_pdeo
+proc_reg_read_iter
+proc_reg_mmap
+proc_reg_poll
+proc_reg_release
+proc_reg_unlocked_ioctl
+proc_reg_llseek
+proc_reg_compat_ioctl
+proc_reg_read
+proc_reg_write
+proc_reg_open
+proc_invalidate_siblings_dcache
+proc_entry_rundown
+proc_get_inode
+proc_get_tree
+proc_root_lookup
+proc_kill_sb
+proc_fs_context_free
+proc_apply_options
+proc_reconfigure
+proc_parse_param
+proc_root_readdir
+proc_root_getattr
+proc_fill_super
+proc_init_fs_context
+mem_lseek
+pid_delete_dentry
+proc_setattr
+proc_pid_patch_state
+proc_pid_schedstat
+timerslack_ns_open
+comm_open
+timens_offsets_open
+sched_autogroup_open
+sched_open
+proc_single_open
+proc_timers_open
+show_timer
+timers_next
+timers_start
+lock_trace
+auxv_read
+proc_loginuid_write
+proc_pid_wchan
+proc_pid_attr_write
+proc_pid_limits
+dname_to_vma_addr
+has_pid_permissions
+proc_pid_personality
+proc_pid_syscall
+proc_pid_stack
+proc_oom_score
+do_io_accounting
+proc_tgid_io_accounting
+proc_tid_io_accounting
+mem_release
+mem_rw
+mem_write
+mem_read
+proc_id_map_release
+proc_setgroups_release
+sched_write
+sched_autogroup_show
+timens_offsets_show
+proc_root_link
+sched_show
+comm_show
+proc_cwd_link
+proc_single_show
+proc_tid_comm_permission
+proc_exe_link
+proc_sessionid_read
+oom_score_adj_read
+proc_pid_permission
+oom_adj_read
+proc_loginuid_read
+proc_pid_attr_read
+proc_coredump_filter_read
+comm_write
+proc_id_map_open
+proc_projid_map_open
+proc_gid_map_open
+proc_uid_map_open
+proc_pid_cmdline_read
+timerslack_ns_show
+proc_fd_access_allowed
+proc_pid_readlink
+proc_pid_get_link.part.0
+proc_pid_get_link
+proc_map_files_get_link
+proc_setgroups_open
+timers_stop
+map_files_get_link
+proc_task_getattr
+next_tgid
+timerslack_ns_write
+proc_coredump_filter_write
+sched_autogroup_write
+timens_offsets_write
+environ_read
+__set_oom_adj
+oom_score_adj_write
+oom_adj_write
+proc_mem_open
+mem_open
+auxv_open
+environ_open
+task_dump_owner
+pid_getattr
+map_files_d_revalidate
+proc_pid_evict_inode
+proc_pid_make_inode
+proc_map_files_instantiate
+proc_map_files_lookup
+pid_update_inode
+pid_revalidate
+proc_pident_instantiate
+proc_pident_lookup
+proc_apparmor_attr_dir_lookup
+proc_smack_attr_dir_lookup
+proc_attr_dir_lookup
+proc_tid_base_lookup
+proc_tgid_base_lookup
+proc_task_instantiate
+proc_task_lookup
+proc_pid_instantiate
+proc_fill_cache
+proc_map_files_readdir
+proc_task_readdir
+proc_pident_readdir
+proc_tgid_base_readdir
+proc_attr_dir_readdir
+proc_apparmor_attr_dir_iterate
+proc_smack_attr_dir_iterate
+proc_tid_base_readdir
+tgid_pidfd_to_pid
+proc_flush_pid
+proc_pid_lookup
+proc_pid_readdir
+proc_misc_d_revalidate
+proc_misc_d_delete
+PDE_DATA
+proc_set_size
+proc_set_user
+proc_get_parent_data
+proc_getattr
+proc_notify_change
+proc_seq_release
+proc_seq_open
+proc_single_open
+proc_match.part.0
+pde_subdir_find
+__xlate_proc_name
+pde_free
+__proc_create
+proc_alloc_inum
+proc_free_inum
+proc_lookup_de
+proc_lookup
+proc_register
+proc_symlink
+proc_mkdir_data
+proc_mkdir_mode
+proc_mkdir
+proc_create_mount_point
+proc_create_reg
+proc_create_data
+proc_create
+proc_create_seq_private
+proc_create_single_data
+pde_put
+proc_readdir_de
+proc_readdir
+remove_proc_entry
+remove_proc_subtree
+proc_remove
+proc_simple_write
+children_seq_show
+render_cap_t
+children_seq_stop
+children_seq_open
+get_children_pid
+children_seq_next
+children_seq_start
+proc_task_name
+do_task_stat
+render_sigset_t
+proc_pid_status
+proc_tid_stat
+proc_tgid_stat
+proc_pid_statm
+seq_fdinfo_open
+proc_fd_permission
+tid_fd_mode
+tid_fd_update_inode
+proc_fd_instantiate
+proc_fdinfo_instantiate
+proc_lookupfd_common
+proc_lookupfd
+proc_lookupfdinfo
+proc_fd_link
+proc_readfd_common
+proc_readfd
+proc_readfdinfo
+seq_show
+tid_fd_revalidate
+t_next
+t_stop
+show_tty_range
+show_tty_driver
+t_start
+proc_tty_register_driver
+proc_tty_unregister_driver
+cmdline_proc_show
+c_stop
+c_next
+show_console_dev
+c_start
+c_start
+cpuinfo_open
+devinfo_stop
+devinfo_start
+devinfo_next
+devinfo_show
+int_seq_stop
+int_seq_start
+int_seq_next
+loadavg_proc_show
+show_val_kb
+show_val_kb
+meminfo_proc_show
+stat_open
+get_idle_time
+get_iowait_time
+show_stat
+uptime_proc_show
+name_to_int
+version_proc_show
+show_softirqs
+proc_ns_instantiate
+proc_ns_dir_lookup
+proc_ns_readlink
+proc_ns_dir_readdir
+proc_ns_get_link
+proc_self_get_link
+proc_setup_self
+proc_thread_self_get_link
+proc_setup_thread_self
+proc_sys_revalidate
+proc_sys_delete
+sysctl_print_dir
+sysctl_err
+append_path
+namecmp
+find_entry
+find_subdir
+xlate_dir
+get_links
+erase_header
+first_usable_entry
+sysctl_perm
+proc_sys_setattr
+process_sysctl_arg
+count_subheaders.part.0
+unuse_table.part.0
+sysctl_head_finish.part.0
+sysctl_head_grab
+proc_sys_open
+proc_sys_poll
+proc_sys_permission
+proc_sys_getattr
+sysctl_follow_link
+proc_sys_compare
+drop_sysctl_table
+put_links
+unregister_sysctl_table
+proc_sys_make_inode
+proc_sys_lookup
+proc_sys_fill_cache
+proc_sys_readdir
+insert_header
+proc_sys_call_handler
+proc_sys_write
+proc_sys_read
+proc_sys_poll_notify
+proc_sys_evict_inode
+__register_sysctl_table
+register_sysctl
+register_leaf_sysctl_tables
+__register_sysctl_paths
+register_sysctl_paths
+register_sysctl_table
+setup_sysctl_set
+retire_sysctl_set
+do_sysctl_args
+proc_net_d_revalidate
+proc_create_net_data
+proc_create_net_data_write
+proc_create_net_single
+proc_create_net_single_write
+proc_net_ns_exit
+proc_net_ns_init
+get_proc_task_net
+get_proc_net
+seq_open_net
+seq_release_net
+single_release_net
+proc_tgid_net_readdir
+proc_tgid_net_lookup
+proc_tgid_net_getattr
+single_open_net
+bpf_iter_init_seq_net
+bpf_iter_fini_seq_net
+release_kcore
+get_kcore_size
+append_kcore_note
+kcore_update_ram
+kclist_add_private
+open_kcore
+read_kcore
+register_oldmem_pfn_is_ram
+unregister_oldmem_pfn_is_ram
+mmap_vmcore_fault
+vmcore_add_device_dump
+copy_to.part.0
+free_elfcorebuf
+elfcorehdr_alloc
+elfcorehdr_free
+remap_oldmem_pfn_range
+mmap_vmcore
+mmap_vmcore
+read_from_oldmem.part.0
+read_from_oldmem
+read_from_oldmem
+elfcorehdr_read_notes
+read_vmcore
+vmcore_cleanup
+kmsg_release
+kmsg_open
+kmsg_poll
+kmsg_read
+kpagecount_read
+kpagecgroup_read
+stable_page_flags
+kpageflags_read
+boot_config_proc_show
+kernfs_sop_show_options
+kernfs_encode_fh
+kernfs_test_super
+kernfs_sop_show_path
+kernfs_set_super
+kernfs_get_parent_dentry
+__kernfs_fh_to_dentry
+kernfs_fh_to_parent
+kernfs_fh_to_dentry
+kernfs_root_from_sb
+kernfs_node_dentry
+kernfs_super_ns
+kernfs_get_tree
+kernfs_free_fs_context
+kernfs_kill_sb
+__kernfs_iattrs
+kernfs_iop_listxattr
+kernfs_refresh_inode
+kernfs_iop_getattr
+kernfs_iop_permission
+kernfs_vfs_user_xattr_set
+__kernfs_setattr
+kernfs_iop_setattr
+kernfs_setattr
+kernfs_get_inode
+kernfs_evict_inode
+kernfs_xattr_get
+kernfs_vfs_xattr_get
+kernfs_xattr_set
+kernfs_vfs_xattr_set
+kernfs_name_locked
+kernfs_name_hash
+kernfs_path_from_node_locked
+kernfs_path_from_node
+kernfs_get
+kernfs_dop_revalidate
+kernfs_unlink_sibling
+kernfs_link_sibling
+kernfs_next_descendant_post
+kernfs_find_ns
+kernfs_find_and_get_ns
+kernfs_iop_lookup
+kernfs_put
+kernfs_dir_fop_release
+kernfs_dir_pos
+kernfs_fop_readdir
+__kernfs_remove.part.0
+__kernfs_new_node
+kernfs_name
+pr_cont_kernfs_name
+pr_cont_kernfs_path
+kernfs_get_parent
+kernfs_get_active
+kernfs_put_active
+kernfs_iop_rename
+kernfs_iop_rmdir
+kernfs_iop_mkdir
+kernfs_node_from_dentry
+kernfs_new_node
+kernfs_find_and_get_node_by_id
+kernfs_walk_and_get_ns
+kernfs_activate
+kernfs_add_one
+kernfs_create_dir_ns
+kernfs_create_empty_dir
+kernfs_create_root
+kernfs_remove
+kernfs_destroy_root
+kernfs_break_active_protection
+kernfs_unbreak_active_protection
+kernfs_remove_self
+kernfs_remove_by_name_ns
+kernfs_rename_ns
+kernfs_seq_show
+kernfs_put_open_node
+kernfs_notify
+kernfs_fop_release
+kernfs_seq_stop_active
+kernfs_seq_next
+kernfs_seq_stop
+kernfs_seq_start
+kernfs_fop_mmap
+kernfs_vma_get_policy
+kernfs_vma_set_policy
+kernfs_vma_access
+kernfs_vma_fault
+kernfs_vma_open
+kernfs_vma_page_mkwrite
+kernfs_fop_read
+kernfs_fop_open
+kernfs_notify_workfn
+kernfs_fop_write
+kernfs_drain_open_files
+kernfs_generic_poll
+kernfs_fop_poll
+__kernfs_create_file
+kernfs_iop_get_link
+kernfs_create_link
+sysfs_kf_bin_read
+sysfs_kf_write
+sysfs_kf_bin_write
+sysfs_kf_bin_mmap
+sysfs_notify
+sysfs_kf_read
+sysfs_chmod_file
+internal_change_owner
+sysfs_file_change_owner
+sysfs_break_active_protection
+sysfs_unbreak_active_protection
+sysfs_remove_file_ns
+sysfs_remove_files
+sysfs_remove_file_from_group
+sysfs_remove_bin_file
+sysfs_remove_file_self
+sysfs_change_owner
+sysfs_emit
+sysfs_emit_at
+sysfs_kf_seq_show
+sysfs_add_file_mode_ns
+sysfs_create_file_ns
+sysfs_create_files
+sysfs_add_file_to_group
+sysfs_create_bin_file
+sysfs_link_change_owner
+sysfs_remove_mount_point
+sysfs_warn_dup
+sysfs_create_mount_point
+sysfs_create_dir_ns
+sysfs_remove_dir
+sysfs_rename_dir_ns
+sysfs_move_dir_ns
+sysfs_remove_link
+sysfs_rename_link_ns
+sysfs_do_create_link_sd
+sysfs_create_link
+sysfs_create_link_nowarn
+sysfs_create_link_sd
+sysfs_delete_link
+sysfs_kill_sb
+sysfs_fs_context_free
+sysfs_get_tree
+sysfs_init_fs_context
+remove_files
+internal_create_group
+sysfs_create_group
+sysfs_update_group
+sysfs_remove_group
+sysfs_merge_group
+sysfs_unmerge_group
+sysfs_remove_link_from_group
+sysfs_add_link_to_group
+sysfs_group_change_owner
+sysfs_groups_change_owner
+internal_create_groups.part.0
+sysfs_create_groups
+sysfs_update_groups
+sysfs_remove_groups
+compat_only_sysfs_link_entry_to_kobj
+configfs_setattr
+configfs_new_inode
+configfs_create
+configfs_get_name
+configfs_drop_dentry
+configfs_hash_and_remove
+configfs_release
+configfs_write_file
+configfs_read_file
+configfs_release_bin_file
+configfs_read_bin_file
+configfs_write_bin_file
+__configfs_open_file
+configfs_open_file
+configfs_open_bin_file
+configfs_create_file
+configfs_create_bin_file
+configfs_dir_set_ready
+configfs_detach_rollback
+configfs_detach_prep
+configfs_remove_default_groups
+unlink_obj
+unlink_group
+configfs_depend_prep
+link_obj
+new_fragment
+client_disconnect_notify
+client_drop_item
+link_group
+configfs_do_depend_item
+configfs_depend_item
+configfs_depend_item_unlocked
+configfs_undepend_item
+configfs_new_dirent
+configfs_dir_open
+configfs_dir_lseek
+configfs_readdir
+put_fragment
+configfs_dir_close
+configfs_lookup
+detach_attrs
+configfs_remove_dirent
+configfs_remove_dir
+configfs_detach_group
+detach_groups
+configfs_unregister_group
+configfs_unregister_default_group
+configfs_unregister_subsystem
+configfs_rmdir
+configfs_attach_item.isra.0.part.0
+configfs_d_iput
+get_fragment
+configfs_make_dirent
+configfs_create_dir
+configfs_attach_group.isra.0
+create_default_group
+configfs_register_group
+configfs_register_default_group
+configfs_register_subsystem
+configfs_mkdir
+configfs_dirent_is_ready
+configfs_create_link
+configfs_symlink
+configfs_unlink
+configfs_get_tree
+configfs_init_fs_context
+configfs_fill_super
+configfs_free_inode
+configfs_is_root
+configfs_pin_fs
+configfs_release_fs
+config_group_init
+config_item_set_name
+config_item_init_type_name
+config_group_init_type_name
+config_item_get_unless_zero
+config_item_get
+config_group_find_item
+config_item_release
+config_item_put
+devpts_mount
+devpts_kill_sb
+devpts_show_options
+parse_mount_options
+devpts_remount
+devpts_ptmx_path
+devpts_fill_super
+devpts_mntget
+devpts_acquire
+devpts_release
+devpts_new_index
+devpts_kill_index
+devpts_pty_new
+devpts_get_priv
+devpts_pty_kill
+get_dcookie
+do_lookup_dcookie
+__x64_sys_lookup_dcookie
+__ia32_sys_lookup_dcookie
+__ia32_compat_sys_lookup_dcookie
+__x32_compat_sys_lookup_dcookie
+dcookie_register
+dcookie_unregister
+num_clusters_in_group
+ext4_has_free_clusters
+ext4_validate_block_bitmap
+ext4_get_group_no_and_offset
+ext4_get_group_number
+ext4_get_group_desc
+ext4_wait_block_bitmap
+ext4_claim_free_clusters
+ext4_should_retry_alloc
+ext4_new_meta_blocks
+ext4_count_free_clusters
+ext4_bg_has_super
+ext4_bg_num_gdb
+ext4_num_base_meta_clusters
+ext4_free_clusters_after_init
+ext4_read_block_bitmap_nowait
+ext4_read_block_bitmap
+ext4_inode_to_goal_block
+ext4_count_free
+ext4_inode_bitmap_csum_verify
+ext4_inode_bitmap_csum_set
+ext4_block_bitmap_csum_verify
+ext4_block_bitmap_csum_set
+release_system_zone
+ext4_destroy_system_zone
+add_system_zone
+ext4_exit_system_zone
+ext4_setup_system_zone
+ext4_release_system_zone
+ext4_inode_block_valid
+ext4_check_blockref
+free_rb_tree_fname
+ext4_release_dir
+ext4_dir_open
+is_dx_dir
+call_filldir
+ext4_dir_llseek
+__ext4_check_dir_entry
+ext4_readdir
+ext4_htree_free_dir_info
+ext4_htree_store_dirent
+ext4_check_all_de
+ext4_journal_check_start
+ext4_get_nojournal.part.0
+ext4_journal_abort_handle.isra.0
+ext4_inode_journal_mode
+__ext4_journal_start_sb
+__ext4_journal_stop
+__ext4_journal_start_reserved
+__ext4_journal_ensure_credits
+__ext4_journal_get_write_access
+__ext4_forget
+__ext4_journal_get_create_access
+__ext4_handle_dirty_metadata
+__ext4_handle_dirty_super
+ext4_extent_block_csum
+__ext4_ext_check
+ext4_cache_extents
+__read_extent_tree_block
+ext4_ext_search_right
+ext4_ext_find_goal
+ext4_ext_zeroout
+ext4_zeroout_es
+ext4_rereserve_cluster
+skip_hole
+ext4_iomap_xattr_begin
+ext4_can_extents_be_merged.isra.0
+ext4_extent_block_csum_set
+__ext4_ext_dirty
+ext4_ext_correct_indexes
+ext4_ext_rm_idx
+ext4_alloc_file_blocks
+ext4_ext_try_to_merge_right
+ext4_ext_try_to_merge
+ext4_datasem_ensure_credits
+ext4_access_path
+ext4_ext_check_inode
+ext4_ext_drop_refs
+ext4_ext_precache
+ext4_ext_tree_init
+ext4_find_extent
+ext4_ext_next_allocated_block
+get_implied_cluster_alloc
+ext4_ext_shift_extents
+ext4_ext_insert_extent
+ext4_split_extent_at
+ext4_split_extent
+ext4_split_convert_extents
+ext4_ext_convert_to_initialized
+ext4_ext_calc_credits_for_single_extent
+ext4_ext_index_trans_blocks
+ext4_ext_remove_space
+ext4_ext_init
+ext4_ext_release
+ext4_ext_map_blocks
+ext4_ext_truncate
+ext4_fallocate
+ext4_convert_unwritten_extents
+ext4_convert_unwritten_io_end_vec
+ext4_fiemap
+ext4_get_es_cache
+ext4_swap_extents
+ext4_clu_mapped
+ext4_ext_replay_update_ex
+ext4_ext_replay_shrink_inode
+ext4_ext_replay_set_iblocks
+ext4_ext_clear_bb
+ext4_es_count
+__remove_pending
+ext4_es_can_be_merged
+__insert_pending
+ext4_es_free_extent
+__es_insert_extent
+__es_tree_search
+__es_find_extent_range
+__es_scan_range
+es_do_reclaim_extents
+es_reclaim_extents
+__es_shrink
+ext4_es_scan
+count_rsvd
+__es_remove_extent
+ext4_exit_es
+ext4_es_init_tree
+ext4_es_find_extent_range
+ext4_es_scan_range
+ext4_es_scan_clu
+ext4_es_insert_extent
+ext4_es_cache_extent
+ext4_es_lookup_extent
+ext4_es_remove_extent
+ext4_seq_es_shrinker_info_show
+ext4_es_register_shrinker
+ext4_es_unregister_shrinker
+ext4_clear_inode_es
+ext4_exit_pending
+ext4_init_pending_tree
+ext4_remove_pending
+ext4_is_pending
+ext4_es_insert_delayed_block
+ext4_es_delayed_clu
+ext4_llseek
+ext4_generic_write_checks
+ext4_write_checks
+ext4_handle_inode_extension
+ext4_dio_write_end_io
+ext4_file_mmap
+ext4_dio_supported
+ext4_file_read_iter
+ext4_release_file
+ext4_buffered_write_iter
+ext4_file_write_iter
+ext4_dax_huge_fault
+ext4_dax_fault
+ext4_file_open
+ext4_getfsmap_dev_compare
+ext4_getfsmap_compare
+ext4_getfsmap_is_valid_device
+ext4_getfsmap_free_fixed_metadata
+ext4_getfsmap_helper
+ext4_getfsmap_logdev
+ext4_getfsmap_datadev_helper
+ext4_getfsmap_datadev
+ext4_fsmap_from_internal
+ext4_fsmap_to_internal
+ext4_getfsmap
+ext4_sync_file
+str2hashbuf_signed
+str2hashbuf_unsigned
+__ext4fs_dirhash
+ext4fs_dirhash
+ext4_end_bitmap_read
+find_inode_bit
+get_orlov_stats
+find_group_orlov
+ext4_mark_bitmap_end.part.0
+ext4_read_inode_bitmap
+ext4_mark_bitmap_end
+ext4_free_inode
+ext4_mark_inode_used
+__ext4_new_inode
+ext4_orphan_get
+ext4_count_free_inodes
+ext4_count_dirs
+ext4_init_inode_table
+ext4_block_to_path
+ext4_get_branch
+ext4_find_shared
+ext4_ind_truncate_ensure_credits
+ext4_clear_blocks
+ext4_free_data
+ext4_free_branches
+ext4_ind_map_blocks
+ext4_ind_trans_blocks
+ext4_ind_truncate
+ext4_ind_remove_space
+get_max_inline_xattr_value_size
+ext4_write_inline_data
+ext4_read_inline_data.part.0
+ext4_update_final_de
+ext4_get_inline_xattr_pos
+ext4_get_max_inline_size.part.0
+ext4_add_dirent_to_inline
+ext4_create_inline_data
+ext4_destroy_inline_data_nolock
+ext4_read_inline_page
+ext4_convert_inline_data_nolock
+ext4_update_inline_data
+ext4_prepare_inline_data
+ext4_get_max_inline_size
+ext4_find_inline_data_nolock
+ext4_readpage_inline
+ext4_try_to_write_inline_data
+ext4_write_inline_data_end
+ext4_journalled_write_inline_data
+ext4_da_write_inline_data_begin
+ext4_da_write_inline_data_end
+ext4_try_add_inline_entry
+ext4_inlinedir_to_tree
+ext4_read_inline_dir
+ext4_get_first_inline_block
+ext4_try_create_inline_dir
+ext4_find_inline_entry
+ext4_delete_inline_entry
+empty_inline_dir
+ext4_destroy_inline_data
+ext4_inline_data_iomap
+ext4_inline_data_truncate
+ext4_convert_inline_data
+ext4_iomap_end
+ext4_update_bh_state
+ext4_set_iomap
+ext4_iomap_swap_activate
+ext4_releasepage
+ext4_set_page_dirty
+ext4_meta_trans_blocks
+mpage_release_unused_pages
+ext4_nonda_switch
+__ext4_journalled_invalidatepage
+ext4_journalled_set_page_dirty
+__ext4_expand_extra_isize
+write_end_fn
+ext4_invalidatepage
+mpage_submit_page
+mpage_process_page_bufs
+mpage_map_and_submit_buffers
+ext4_journalled_invalidatepage
+__check_block_validity.constprop.0
+ext4_readahead
+ext4_readpage
+ext4_block_write_begin
+ext4_bmap
+ext4_dax_writepages
+mpage_prepare_extent_to_map
+ext4_journalled_zero_new_buffers
+ext4_inode_csum
+__ext4_get_inode_loc
+__ext4_get_inode_loc_noinmem
+ext4_da_reserve_space
+ext4_da_get_block_prep
+ext4_inode_csum_set
+ext4_inode_is_fast_symlink
+ext4_get_reserved_space
+ext4_da_update_reserve_space
+ext4_issue_zeroout
+ext4_map_blocks
+_ext4_get_block
+ext4_get_block
+ext4_block_zero_page_range
+ext4_get_block_unwritten
+ext4_iomap_begin_report
+ext4_iomap_begin
+ext4_iomap_overwrite_begin
+ext4_getblk
+ext4_bread
+ext4_bread_batch
+ext4_walk_page_buffers
+do_journal_get_write_access
+ext4_da_release_space
+ext4_alloc_da_blocks
+ext4_set_aops
+ext4_zero_partial_blocks
+ext4_can_truncate
+ext4_break_layouts
+ext4_inode_attach_jinode
+ext4_get_inode_loc
+ext4_get_fc_inode_loc
+ext4_set_inode_flags
+ext4_get_projid
+__ext4_iget
+ext4_write_inode
+ext4_getattr
+ext4_file_getattr
+ext4_writepage_trans_blocks
+ext4_chunk_trans_blocks
+ext4_mark_iloc_dirty
+ext4_reserve_inode_write
+ext4_expand_extra_isize
+__ext4_mark_inode_dirty
+ext4_writepages
+ext4_writepage
+ext4_update_disksize_before_punch
+ext4_punch_hole
+ext4_truncate
+ext4_write_begin
+ext4_da_write_begin
+ext4_evict_inode
+ext4_write_end
+ext4_da_write_end
+ext4_journalled_write_end
+ext4_setattr
+ext4_dirty_inode
+ext4_change_inode_journal_flag
+ext4_page_mkwrite
+ext4_filemap_fault
+ext4_ioctl_check_immutable
+ext4_fill_fsxattr
+swap_inode_data
+ext4_getfsmap_format
+ext4_ioc_getfsmap
+ext4_ioctl_setflags
+ext4_ioctl_group_add
+ext4_reset_inode_seed
+__ext4_ioctl
+ext4_ioctl
+ext4_compat_ioctl
+ext4_mb_seq_groups_stop
+mb_clear_bits
+mb_find_buddy
+mb_find_order_for_block
+mb_test_and_clear_bits
+ext4_mb_use_inode_pa
+ext4_mb_seq_groups_next
+ext4_mb_seq_groups_start
+ext4_mb_initialize_context
+mb_find_extent
+get_groupinfo_cache.part.0
+ext4_mb_pa_callback
+ext4_mb_pa_free
+ext4_mb_mark_pa_deleted
+ext4_mb_good_group
+ext4_mb_generate_buddy
+ext4_mb_unload_buddy
+ext4_try_merge_freed_extent
+ext4_mb_free_metadata
+ext4_mb_new_group_pa
+ext4_mb_new_inode_pa
+ext4_mb_normalize_request.constprop.0
+ext4_mb_use_preallocated
+ext4_set_bits
+ext4_mb_generate_from_pa
+ext4_mb_init_cache
+ext4_mb_init_group
+ext4_mb_load_buddy_gfp
+ext4_mb_seq_groups_show
+mb_free_blocks
+ext4_mb_release_inode_pa
+ext4_discard_allocated_blocks
+ext4_mb_release_group_pa
+ext4_mb_discard_group_preallocations
+ext4_mb_discard_lg_preallocations
+mb_mark_used
+ext4_mb_use_best_found
+ext4_mb_find_by_goal
+ext4_mb_simple_scan_group
+ext4_mb_scan_aligned
+ext4_mb_check_limits
+ext4_mb_try_best_found
+ext4_mb_complex_scan_group
+ext4_mb_mark_diskspace_used
+ext4_mb_prefetch
+ext4_mb_prefetch_fini
+ext4_mb_regular_allocator
+ext4_mb_alloc_groupinfo
+ext4_mb_add_groupinfo
+ext4_mb_init
+ext4_mb_release
+ext4_process_freed_data
+ext4_exit_mballoc
+ext4_mb_mark_bb
+ext4_discard_preallocations
+ext4_mb_new_blocks
+ext4_free_blocks
+ext4_group_add_blocks
+ext4_trim_fs
+ext4_mballoc_query_range
+finish_range
+update_extent_range
+update_ind_extent_range
+update_dind_extent_range
+free_dind_blocks
+free_ext_idx
+free_ext_block
+ext4_ext_migrate
+ext4_ind_migrate
+read_mmp_block
+write_mmp_block
+__dump_mmp_msg
+kmmpd
+ext4_multi_mount_protect
+mext_check_coverage.constprop.0
+ext4_double_down_write_data_sem
+ext4_double_up_write_data_sem
+ext4_move_extents
+get_dx_countlimit
+dx_release
+ext4_append
+dx_insert_block
+ext4_inc_count
+ext4_update_dir_count
+ext4_dx_csum
+ext4_initialize_dirent_tail
+ext4_dirblock_csum_verify
+__ext4_read_dirblock
+dx_probe
+htree_dirblock_to_tree
+ext4_htree_next_block
+ext4_rename_dir_prepare
+ext4_handle_dirty_dirblock
+do_split
+ext4_setent
+ext4_rename_dir_finish
+ext4_htree_fill_tree
+ext4_ci_compare
+ext4_fname_setup_ci_filename
+ext4_search_dir
+ext4_dx_find_entry
+__ext4_find_entry
+ext4_find_entry
+ext4_cross_rename
+ext4_lookup
+ext4_get_parent
+ext4_find_dest_de
+ext4_insert_dentry
+add_dirent_to_buf
+ext4_dx_add_entry
+make_indexed_dir
+ext4_add_entry
+ext4_generic_delete_entry
+ext4_delete_entry
+ext4_find_delete_entry
+ext4_init_dot_dotdot
+ext4_init_new_dir
+ext4_empty_dir
+ext4_orphan_add
+ext4_tmpfile
+ext4_rename
+ext4_rename2
+ext4_add_nondir
+ext4_mknod
+ext4_create
+ext4_rmdir
+ext4_mkdir
+ext4_orphan_del
+ext4_symlink
+__ext4_unlink
+ext4_unlink
+__ext4_link
+ext4_link
+ext4_finish_bio
+ext4_release_io_end
+ext4_exit_pageio
+ext4_alloc_io_end_vec
+ext4_last_io_end_vec
+ext4_end_io_rsv_work
+ext4_init_io_end
+ext4_put_io_end_defer
+ext4_end_bio
+ext4_put_io_end
+ext4_get_io_end
+ext4_io_submit
+ext4_io_submit_init
+ext4_bio_write_page
+__read_end_io
+bio_post_read_processing
+decrypt_work
+mpage_end_io
+verity_work
+ext4_mpage_readpages
+ext4_exit_post_read_processing
+ext4_rcu_ptr_callback
+ext4_meta_bg_first_group
+ext4_group_overhead_blocks
+bclean
+ext4_get_bitmap
+ext4_list_backups.part.0
+verify_reserved_gdb
+ext4_resize_ensure_credits_batch.constprop.0
+update_backups
+ext4_group_extend_no_check
+set_flexbg_block_bitmap
+ext4_kvfree_array_rcu
+ext4_flex_group_add
+ext4_resize_begin
+ext4_resize_end
+ext4_group_add
+ext4_group_extend
+ext4_resize_fs
+ext4_get_dquots
+ext4_has_stable_inodes
+__traceiter_ext4_other_inode_update_time
+__traceiter_ext4_free_inode
+__traceiter_ext4_request_inode
+__traceiter_ext4_allocate_inode
+__traceiter_ext4_evict_inode
+__traceiter_ext4_drop_inode
+__traceiter_ext4_nfs_commit_metadata
+__traceiter_ext4_mark_inode_dirty
+__traceiter_ext4_begin_ordered_truncate
+__traceiter_ext4_write_begin
+__traceiter_ext4_da_write_begin
+__traceiter_ext4_write_end
+__traceiter_ext4_journalled_write_end
+__traceiter_ext4_da_write_end
+__traceiter_ext4_writepages
+__traceiter_ext4_da_write_pages
+__traceiter_ext4_da_write_pages_extent
+__traceiter_ext4_writepages_result
+__traceiter_ext4_writepage
+__traceiter_ext4_readpage
+__traceiter_ext4_releasepage
+__traceiter_ext4_invalidatepage
+__traceiter_ext4_journalled_invalidatepage
+__traceiter_ext4_discard_blocks
+__traceiter_ext4_mb_new_inode_pa
+__traceiter_ext4_mb_new_group_pa
+__traceiter_ext4_mb_release_inode_pa
+__traceiter_ext4_mb_release_group_pa
+__traceiter_ext4_discard_preallocations
+__traceiter_ext4_mb_discard_preallocations
+__traceiter_ext4_request_blocks
+__traceiter_ext4_allocate_blocks
+__traceiter_ext4_free_blocks
+__traceiter_ext4_sync_file_enter
+__traceiter_ext4_sync_file_exit
+__traceiter_ext4_sync_fs
+__traceiter_ext4_alloc_da_blocks
+__traceiter_ext4_mballoc_alloc
+__traceiter_ext4_mballoc_prealloc
+__traceiter_ext4_mballoc_discard
+__traceiter_ext4_mballoc_free
+__traceiter_ext4_forget
+__traceiter_ext4_da_update_reserve_space
+__traceiter_ext4_da_reserve_space
+__traceiter_ext4_da_release_space
+__traceiter_ext4_mb_bitmap_load
+__traceiter_ext4_mb_buddy_bitmap_load
+__traceiter_ext4_load_inode_bitmap
+__traceiter_ext4_read_block_bitmap_load
+__traceiter_ext4_direct_IO_enter
+__traceiter_ext4_direct_IO_exit
+__traceiter_ext4_fallocate_enter
+__traceiter_ext4_punch_hole
+__traceiter_ext4_zero_range
+__traceiter_ext4_fallocate_exit
+__traceiter_ext4_unlink_enter
+__traceiter_ext4_unlink_exit
+__traceiter_ext4_truncate_enter
+__traceiter_ext4_truncate_exit
+__traceiter_ext4_ext_convert_to_initialized_enter
+__traceiter_ext4_ext_convert_to_initialized_fastpath
+__traceiter_ext4_ext_map_blocks_enter
+__traceiter_ext4_ind_map_blocks_enter
+__traceiter_ext4_ext_map_blocks_exit
+__traceiter_ext4_ind_map_blocks_exit
+__traceiter_ext4_ext_load_extent
+__traceiter_ext4_load_inode
+__traceiter_ext4_journal_start
+__traceiter_ext4_journal_start_reserved
+__traceiter_ext4_trim_extent
+__traceiter_ext4_trim_all_free
+__traceiter_ext4_ext_handle_unwritten_extents
+__traceiter_ext4_get_implied_cluster_alloc_exit
+__traceiter_ext4_ext_put_in_cache
+__traceiter_ext4_ext_in_cache
+__traceiter_ext4_find_delalloc_range
+__traceiter_ext4_get_reserved_cluster_alloc
+__traceiter_ext4_ext_show_extent
+__traceiter_ext4_remove_blocks
+__traceiter_ext4_ext_rm_leaf
+__traceiter_ext4_ext_rm_idx
+__traceiter_ext4_ext_remove_space
+__traceiter_ext4_ext_remove_space_done
+__traceiter_ext4_es_insert_extent
+__traceiter_ext4_es_cache_extent
+__traceiter_ext4_es_remove_extent
+__traceiter_ext4_es_find_extent_range_enter
+__traceiter_ext4_es_find_extent_range_exit
+__traceiter_ext4_es_lookup_extent_enter
+__traceiter_ext4_es_lookup_extent_exit
+__traceiter_ext4_es_shrink_count
+__traceiter_ext4_es_shrink_scan_enter
+__traceiter_ext4_es_shrink_scan_exit
+__traceiter_ext4_collapse_range
+__traceiter_ext4_insert_range
+__traceiter_ext4_es_shrink
+__traceiter_ext4_es_insert_delayed_block
+__traceiter_ext4_fsmap_low_key
+__traceiter_ext4_fsmap_high_key
+__traceiter_ext4_fsmap_mapping
+__traceiter_ext4_getfsmap_low_key
+__traceiter_ext4_getfsmap_high_key
+__traceiter_ext4_getfsmap_mapping
+__traceiter_ext4_shutdown
+__traceiter_ext4_error
+__traceiter_ext4_prefetch_bitmaps
+__traceiter_ext4_lazy_itable_init
+__traceiter_ext4_fc_replay_scan
+__traceiter_ext4_fc_replay
+__traceiter_ext4_fc_commit_start
+__traceiter_ext4_fc_commit_stop
+__traceiter_ext4_fc_stats
+__traceiter_ext4_fc_track_create
+__traceiter_ext4_fc_track_link
+__traceiter_ext4_fc_track_unlink
+__traceiter_ext4_fc_track_inode
+__traceiter_ext4_fc_track_range
+ext4_get_dummy_policy
+ext4_get_ino_and_lblk_bits
+ext4_warning_ratelimit
+__save_error_info
+ext4_mount
+ext4_nfs_get_inode
+ext4_journal_finish_inode_data_buffers
+ext4_journal_submit_inode_data_buffers
+ext4_quota_off
+ext4_write_info
+ext4_release_dquot
+ext4_acquire_dquot
+ext4_write_dquot
+ext4_mark_dquot_dirty
+ext4_get_context
+ext4_nfs_commit_metadata
+ext4_fh_to_parent
+ext4_fh_to_dentry
+bdev_try_to_free_page
+ext4_init_journal_params
+ext4_sync_fs
+ext4_drop_inode
+ext4_free_in_core_inode
+descriptor_loc
+ext4_quota_read
+init_once
+ext4_remove_li_request.part.0
+ext4_unregister_li_request
+ext4_clear_request_list
+ext4_journalled_writepage_callback
+ext4_lazyinit_thread
+ext4_alloc_inode
+_ext4_show_options
+ext4_show_options
+ext4_journal_commit_callback
+ext4_statfs
+ext4_group_desc_csum
+ext4_read_bh_nowait
+ext4_read_bh
+ext4_read_bh_lock
+__ext4_sb_bread_gfp
+ext4_sb_bread
+ext4_sb_bread_unmovable
+ext4_sb_breadahead_unmovable
+ext4_superblock_csum_set
+ext4_block_bitmap
+ext4_inode_bitmap
+ext4_inode_table
+ext4_free_group_clusters
+ext4_free_inodes_count
+ext4_used_dirs_count
+ext4_itable_unused_count
+ext4_block_bitmap_set
+ext4_inode_bitmap_set
+ext4_inode_table_set
+ext4_free_group_clusters_set
+ext4_free_inodes_set
+ext4_used_dirs_set
+ext4_itable_unused_set
+ext4_decode_error
+__ext4_msg
+ext4_commit_super
+save_error_info
+ext4_freeze
+ext4_handle_error
+__ext4_error
+ext4_mark_recovery_complete.isra.0
+__ext4_error_inode
+ext4_set_context
+__ext4_error_file
+__ext4_std_error
+__ext4_abort
+ext4_quota_on
+ext4_quota_write
+ext4_put_super
+ext4_destroy_inode
+print_daily_error_info
+set_qf_name
+clear_qf_name
+parse_options
+ext4_feature_set_ok
+ext4_get_journal_inode
+__ext4_warning
+ext4_clear_journal_err
+ext4_enable_quotas
+__ext4_warning_inode
+__ext4_grp_locked_error
+ext4_mark_group_bitmap_corrupted
+ext4_update_dynamic_rev
+ext4_unfreeze
+ext4_setup_super
+ext4_clear_inode
+ext4_seq_options_show
+ext4_alloc_flex_bg_array
+ext4_group_desc_csum_verify
+ext4_group_desc_csum_set
+ext4_register_li_request
+ext4_remount
+ext4_calculate_overhead
+ext4_fill_super
+ext4_force_commit
+ext4_encrypted_get_link
+ext4_sb_release
+ext4_attr_store
+ext4_attr_show
+ext4_register_sysfs
+ext4_unregister_sysfs
+ext4_exit_sysfs
+ext4_xattr_free_space
+ext4_xattr_check_entries
+__xattr_check_inode
+ext4_xattr_value_same
+xattr_find_entry
+ext4_xattr_block_cache_insert
+ext4_xattr_list_entries
+ext4_xattr_inode_update_ref
+ext4_xattr_inode_array_free.part.0
+ext4_xattr_inode_iget
+ext4_xattr_inode_free_quota
+ext4_xattr_block_csum
+ext4_xattr_block_csum_set
+ext4_xattr_block_csum_verify
+ext4_xattr_get_block
+ext4_xattr_block_find
+ext4_xattr_inode_dec_ref_all
+ext4_xattr_release_block
+ext4_xattr_inode_read
+ext4_xattr_inode_get
+ext4_xattr_set_entry
+ext4_xattr_block_set
+ext4_xattr_ibody_get
+ext4_xattr_get
+ext4_listxattr
+ext4_get_inode_usage
+__ext4_xattr_set_credits
+ext4_xattr_ibody_find
+ext4_xattr_ibody_inline_set
+ext4_xattr_set_handle
+ext4_xattr_set_credits
+ext4_xattr_set
+ext4_expand_extra_isize_ea
+ext4_xattr_delete_inode
+ext4_xattr_inode_array_free
+ext4_xattr_create_cache
+ext4_xattr_destroy_cache
+ext4_xattr_hurd_list
+ext4_xattr_hurd_set
+ext4_xattr_hurd_get
+ext4_xattr_trusted_set
+ext4_xattr_trusted_get
+ext4_xattr_trusted_list
+ext4_xattr_user_list
+ext4_xattr_user_set
+ext4_xattr_user_get
+__track_inode
+__track_range
+ext4_end_buffer_io_sync
+ext4_fc_submit_bh
+ext4_fc_record_modified_inode
+ext4_fc_set_bitmaps_and_counters
+ext4_fc_replay_link_internal
+ext4_fc_memcpy
+ext4_fc_wait_committing_inode
+ext4_fc_reserve_space
+ext4_fc_add_tlv
+ext4_fc_write_inode_data
+ext4_fc_add_dentry_tlv
+ext4_fc_write_inode
+ext4_fc_cleanup
+ext4_fc_replay
+ext4_fc_track_template
+ext4_fc_init_inode
+ext4_fc_start_update
+ext4_fc_stop_update
+ext4_fc_del
+ext4_fc_mark_ineligible
+__track_dentry_update
+ext4_fc_start_ineligible
+ext4_fc_stop_ineligible
+__ext4_fc_track_unlink
+ext4_fc_track_unlink
+__ext4_fc_track_link
+ext4_fc_track_link
+ext4_fc_track_create
+ext4_fc_track_inode
+ext4_fc_track_range
+ext4_fc_commit
+ext4_fc_replay_check_excluded
+ext4_fc_replay_cleanup
+ext4_fc_init
+ext4_fc_info_show
+__ext4_set_acl
+ext4_get_acl
+ext4_set_acl
+ext4_init_acl
+ext4_xattr_security_set
+ext4_xattr_security_get
+ext4_initxattrs
+ext4_init_security
+ext4_read_merkle_tree_page
+ext4_begin_enable_verity
+pagecache_write.part.0
+ext4_write_merkle_tree_block
+ext4_end_enable_verity
+pagecache_read
+ext4_get_verity_descriptor
+sub_reserved_credits
+wait_transaction_locked
+add_transaction_credits
+__jbd2_journal_unreserve_handle
+jbd2_journal_free_reserved
+stop_this_handle
+jbd2_write_access_granted
+start_this_handle
+jbd2__journal_restart
+jbd2_journal_restart
+__jbd2_journal_temp_unlink_buffer
+__jbd2_journal_unfile_buffer
+jbd2__journal_start
+jbd2_journal_start
+jbd2_journal_file_inode
+jbd2_journal_destroy_transaction_cache
+jbd2_journal_free_transaction
+jbd2_journal_extend
+jbd2_journal_lock_updates
+jbd2_journal_unlock_updates
+jbd2_journal_set_triggers
+jbd2_buffer_frozen_trigger
+jbd2_buffer_abort_trigger
+jbd2_journal_stop
+jbd2_journal_start_reserved
+jbd2_journal_unfile_buffer
+jbd2_journal_try_to_free_buffers
+__jbd2_journal_file_buffer
+do_get_write_access
+jbd2_journal_get_write_access
+jbd2_journal_get_undo_access
+jbd2_journal_get_create_access
+jbd2_journal_dirty_metadata
+jbd2_journal_forget
+__dispose_buffer
+jbd2_journal_invalidatepage
+jbd2_journal_file_buffer
+__jbd2_journal_refile_buffer
+jbd2_journal_refile_buffer
+jbd2_journal_inode_ranged_write
+jbd2_journal_inode_ranged_wait
+jbd2_journal_begin_ordered_truncate
+jbd2_wait_inode_data
+journal_end_buffer_io_sync
+journal_submit_commit_record
+jbd2_journal_submit_inode_data_buffers
+jbd2_submit_inode_data
+jbd2_journal_finish_inode_data_buffers
+jbd2_journal_commit_transaction
+journal_brelse_array
+jread
+jbd2_descriptor_block_csum_verify
+count_tags
+do_one_pass
+jbd2_journal_recover
+jbd2_journal_skip_recovery
+__flush_batch
+jbd2_cleanup_journal_tail
+__jbd2_journal_insert_checkpoint
+__jbd2_journal_drop_transaction
+__jbd2_journal_remove_checkpoint
+jbd2_log_do_checkpoint
+__jbd2_log_wait_for_space
+journal_clean_one_cp_list
+__jbd2_journal_clean_checkpoint_list
+jbd2_journal_destroy_checkpoint
+jbd2_journal_destroy_revoke_table
+flush_descriptor.part.0
+jbd2_journal_init_revoke_table
+insert_revoke_hash
+find_revoke_record
+jbd2_journal_destroy_revoke_record_cache
+jbd2_journal_destroy_revoke_table_cache
+jbd2_journal_init_revoke
+jbd2_journal_destroy_revoke
+jbd2_journal_revoke
+jbd2_journal_cancel_revoke
+jbd2_clear_buffer_revoked_flags
+jbd2_journal_switch_revoke_table
+jbd2_journal_write_revoke_records
+jbd2_journal_set_revoke
+jbd2_journal_test_revoke
+jbd2_journal_clear_revoke
+jbd2_seq_info_stop
+__traceiter_jbd2_checkpoint
+__traceiter_jbd2_start_commit
+__traceiter_jbd2_commit_locking
+__traceiter_jbd2_commit_flushing
+__traceiter_jbd2_commit_logging
+__traceiter_jbd2_drop_transaction
+__traceiter_jbd2_end_commit
+__traceiter_jbd2_submit_inode_data
+__traceiter_jbd2_handle_start
+__traceiter_jbd2_handle_restart
+__traceiter_jbd2_handle_extend
+__traceiter_jbd2_handle_stats
+__traceiter_jbd2_run_stats
+__traceiter_jbd2_checkpoint_stats
+__traceiter_jbd2_update_log_tail
+__traceiter_jbd2_write_superblock
+__traceiter_jbd2_lock_buffer_stall
+jbd2_transaction_committed
+jbd2_fc_release_bufs
+jbd2_seq_info_start
+jbd2_seq_info_next
+jbd2_journal_errno
+jbd2_journal_clear_err
+jbd2_journal_ack_err
+jbd2_journal_init_jbd_inode
+jbd2_journal_blocks_per_page
+jbd2_log_wait_commit
+jbd2_stats_proc_init
+jbd2_seq_info_release
+commit_timeout
+kjournald2
+jbd2_trans_will_send_data_barrier
+jbd2_journal_check_available_features
+jbd2_fc_begin_commit
+load_superblock.part.0
+jbd2_seq_info_show
+jbd2_fc_wait_bufs
+journal_revoke_records_per_block
+jbd2_journal_clear_features
+jbd2_journal_release_jbd_inode
+jbd2_seq_info_open
+journal_get_superblock
+jbd2_journal_check_used_features
+jbd2_journal_set_features
+get_slab
+journal_init_common
+jbd2_journal_init_dev
+jbd2_journal_init_inode
+__jbd2_log_start_commit
+jbd2_log_start_commit
+__jbd2_journal_force_commit
+jbd2_journal_force_commit_nested
+jbd2_journal_force_commit
+jbd2_complete_transaction
+__jbd2_fc_end_commit
+jbd2_fc_end_commit
+jbd2_fc_end_commit_fallback
+jbd2_journal_start_commit
+jbd2_journal_abort
+jbd2_write_superblock
+jbd2_journal_update_sb_errno
+jbd2_mark_journal_empty
+jbd2_journal_destroy
+jbd2_journal_wipe
+jbd2_journal_flush
+jbd2_journal_bmap
+jbd2_journal_next_log_block
+jbd2_fc_get_buf
+jbd2_journal_get_descriptor_buffer
+jbd2_descriptor_block_csum_set
+jbd2_journal_get_log_tail
+jbd2_journal_update_sb_log_tail
+__jbd2_update_log_tail
+jbd2_update_log_tail
+jbd2_journal_load
+journal_tag_bytes
+jbd2_alloc
+jbd2_free
+jbd2_journal_write_metadata_buffer
+jbd2_journal_add_journal_head
+jbd2_journal_grab_journal_head
+jbd2_journal_put_journal_head
+squashfs_bio_read
+squashfs_read_data
+squashfs_cache_delete.part.0
+squashfs_copy_data.part.0
+squashfs_cache_get
+squashfs_cache_put
+squashfs_cache_delete
+squashfs_cache_init
+squashfs_copy_data
+squashfs_read_metadata
+squashfs_get_fragment
+squashfs_get_datablock
+squashfs_read_table
+squashfs_readdir
+squashfs_export_iget
+squashfs_get_parent
+squashfs_fh_to_parent
+squashfs_fh_to_dentry
+squashfs_read_inode_lookup_table
+read_indexes
+squashfs_fill_page
+squashfs_copy_cache
+squashfs_readpage
+squashfs_frag_lookup
+squashfs_read_fragment_index_table
+squashfs_get_id
+squashfs_read_id_index_table
+squashfs_read_inode
+squashfs_iget
+squashfs_lookup
+squashfs_get_tree
+squashfs_free_inode
+squashfs_alloc_inode
+init_once
+squashfs_init_fs_context
+squashfs_reconfigure
+squashfs_statfs
+squashfs_put_super
+squashfs_fill_super
+squashfs_symlink_readpage
+squashfs_lookup_decompressor
+squashfs_decompressor_setup
+squashfs_readpage_block
+cache_finish_page
+cache_first_page
+cache_next_page
+direct_first_page
+direct_next_page
+direct_finish_page
+squashfs_page_actor_init
+squashfs_page_actor_init_special
+squashfs_decompressor_create
+squashfs_decompressor_destroy
+squashfs_decompress
+squashfs_max_decompressors
+squashfs_trusted_xattr_handler_list
+squashfs_xattr_handler_get
+squashfs_listxattr
+squashfs_xattr_lookup
+squashfs_read_xattr_id_table
+lz4_uncompress
+lz4_free
+lz4_comp_opts
+lz4_init
+lzo_uncompress
+lzo_free
+lzo_init
+squashfs_xz_uncompress
+squashfs_xz_comp_opts
+squashfs_xz_init
+squashfs_xz_free
+zlib_uncompress
+zlib_free
+zlib_init
+zstd_uncompress
+zstd_free
+zstd_init
+ramfs_get_tree
+ramfs_show_options
+ramfs_parse_param
+ramfs_free_fc
+ramfs_kill_sb
+ramfs_init_fs_context
+ramfs_get_inode
+ramfs_mknod
+ramfs_mkdir
+ramfs_create
+ramfs_symlink
+ramfs_fill_super
+ramfs_mmu_get_unmapped_area
+hugetlbfs_write_begin
+hugetlbfs_write_end
+hugetlbfs_set_page_dirty
+hugetlb_vmdelete_list
+hugetlbfs_size_to_hpages
+hugetlbfs_file_mmap
+hugetlbfs_fs_context_free
+hugetlbfs_show_options
+hugetlbfs_put_super
+hugetlbfs_free_inode
+hugetlbfs_fill_super
+hugetlbfs_parse_param
+init_once
+hugetlbfs_migrate_page
+hugetlbfs_get_tree
+hugetlbfs_init_fs_context
+hugetlbfs_get_inode
+do_hugetlbfs_mknod
+hugetlbfs_tmpfile
+hugetlbfs_mknod
+hugetlbfs_mkdir
+hugetlbfs_create
+hugetlbfs_symlink
+remove_huge_page
+hugetlbfs_error_remove_page
+remove_inode_hugepages
+hugetlbfs_setattr
+hugetlbfs_evict_inode
+hugetlbfs_read_iter
+hugetlbfs_inc_free_inodes
+hugetlbfs_destroy_inode
+hugetlbfs_statfs
+hugetlbfs_alloc_inode
+hugetlbfs_fallocate
+hugetlb_file_setup
+init_once
+fat_cache_merge
+fat_cache_add
+fat_cache_destroy
+fat_cache_inval_inode
+fat_get_cluster
+fat_get_mapped_cluster
+fat_bmap
+fat__get_entry
+__fat_remove_entries
+fat_remove_entries
+fat_zeroed_cluster.constprop.0
+fat_alloc_new_dir
+fat_parse_long
+fat_get_short_entry
+fat_get_dotdot_entry
+fat_dir_empty
+fat_scan
+fat_parse_short
+fat_search_long
+__fat_readdir
+fat_readdir
+fat_ioctl_readdir
+fat_compat_dir_ioctl
+fat_dir_ioctl
+fat_add_new_entries
+fat_add_entries
+fat_ioctl_filldir
+fat_compat_ioctl_filldir
+fat_subdirs
+fat_scan_logstart
+fat16_ent_next
+fat32_ent_next
+fat_collect_bhs
+fat12_ent_set_ptr
+fat16_ent_get
+fat16_ent_set_ptr
+fat32_ent_get
+fat32_ent_set_ptr
+fat12_ent_next
+fat16_ent_put
+fat32_ent_put
+fat12_ent_bread
+fat12_ent_blocknr
+fat_ent_blocknr
+mark_fsinfo_dirty
+fat_ent_reada
+fat_ent_bread
+fat_ra_init.constprop.0
+fat12_ent_put
+fat_mirror_bhs
+fat_trim_clusters
+fat12_ent_get
+fat_ent_access_init
+fat_ent_read
+fat_free_clusters
+fat_ent_write
+fat_alloc_clusters
+fat_count_free_clusters
+fat_trim_fs
+fat_file_fsync
+fat_cont_expand
+fat_fallocate
+fat_getattr
+fat_file_release
+fat_truncate_blocks
+fat_setattr
+fat_generic_ioctl
+fat_readahead
+fat_writepages
+fat_readpage
+fat_writepage
+fat_free_inode
+fat_get_block_bmap
+fat_write_failed
+fat_direct_IO
+_fat_bmap
+fat_write_end
+fat_write_begin
+fat_calc_dir_size
+fat_set_state
+delayed_free
+fat_show_options
+fat_statfs
+fat_put_super
+fat_alloc_inode
+parse_options
+init_once
+fat_remount
+writeback_inode
+fat_flush_inodes
+fat_attach
+fat_fill_super
+__fat_write_inode
+fat_sync_inode
+fat_write_inode
+fat_detach
+fat_evict_inode
+fat_add_cluster
+fat_get_block
+fat_block_truncate_page
+fat_iget
+fat_fill_inode
+fat_build_inode
+fat_time_unix2fat
+fat_truncate_time
+fat_update_time
+fat_clusters_flush
+fat_chain_add
+fat_time_fat2unix
+fat_sync_bhs
+fat_fh_to_parent
+fat_fh_to_dentry
+__fat_nfs_get_inode
+fat_nfs_get_inode
+fat_fh_to_parent_nostale
+fat_encode_fh_nostale
+fat_dget
+fat_get_parent
+fat_fh_to_dentry_nostale
+vfat_mount
+vfat_fill_super
+vfat_revalidate_shortname
+vfat_revalidate
+vfat_hashi
+vfat_cmpi
+setup
+vfat_cmp
+vfat_hash
+vfat_find
+vfat_find_form
+vfat_revalidate_ci
+vfat_lookup
+vfat_add_entry
+vfat_unlink
+vfat_rmdir
+vfat_create
+vfat_mkdir
+vfat_rename
+ecryptfs_dentry_free_rcu
+ecryptfs_d_release
+ecryptfs_d_revalidate
+ecryptfs_release
+ecryptfs_dir_release
+ecryptfs_dir_llseek
+ecryptfs_fasync
+ecryptfs_compat_ioctl
+ecryptfs_unlocked_ioctl
+ecryptfs_readdir
+ecryptfs_filldir
+ecryptfs_flush
+ecryptfs_open
+ecryptfs_mmap
+ecryptfs_read_update_atime
+ecryptfs_fsync
+ecryptfs_dir_open
+ecryptfs_inode_test
+ecryptfs_inode_set
+upper_size_to_lower_size
+ecryptfs_inode_newsize_ok
+ecryptfs_listxattr
+ecryptfs_readlink_lower
+ecryptfs_getattr_link
+ecryptfs_permission
+ecryptfs_rename
+ecryptfs_rmdir
+ecryptfs_do_unlink
+ecryptfs_unlink
+ecryptfs_getattr
+__ecryptfs_get_inode
+ecryptfs_lookup
+ecryptfs_get_link
+truncate_upper
+ecryptfs_setattr
+ecryptfs_get_inode
+ecryptfs_interpose
+ecryptfs_mknod
+ecryptfs_mkdir
+ecryptfs_symlink
+ecryptfs_link
+ecryptfs_initialize_file
+ecryptfs_create
+ecryptfs_truncate
+ecryptfs_setxattr
+ecryptfs_xattr_set
+ecryptfs_getxattr_lower
+ecryptfs_xattr_get
+ecryptfs_kill_block_super
+version_show
+inode_info_init_once
+__ecryptfs_printk
+ecryptfs_mount
+ecryptfs_get_lower_file
+ecryptfs_put_lower_file
+ecryptfs_free_inode
+ecryptfs_evict_inode
+ecryptfs_show_options
+ecryptfs_alloc_inode
+ecryptfs_statfs
+ecryptfs_destroy_inode
+ecryptfs_bmap
+ecryptfs_writepage
+ecryptfs_copy_up_encrypted_with_header
+ecryptfs_readpage
+ecryptfs_write_begin
+ecryptfs_get_locked_page
+ecryptfs_write_inode_size_to_metadata
+ecryptfs_write_end
+ecryptfs_write_lower
+ecryptfs_write_lower_page_segment
+ecryptfs_write
+ecryptfs_read_lower
+ecryptfs_read_lower_page_segment
+ecryptfs_copy_mount_wide_flags_to_inode_flags
+extent_crypt_complete
+ecryptfs_validate_marker
+ecryptfs_read_headers_virt
+ecryptfs_encode_for_filename.part.0
+ecryptfs_copy_filename
+crypt_scatterlist
+ecryptfs_crypto_api_algify_cipher_name
+ecryptfs_from_hex
+ecryptfs_derive_iv
+crypt_extent
+ecryptfs_init_crypt_stat
+ecryptfs_destroy_crypt_stat
+ecryptfs_destroy_mount_crypt_stat
+virt_to_scatterlist
+ecryptfs_encrypt_page
+ecryptfs_decrypt_page
+ecryptfs_init_crypt_ctx
+ecryptfs_set_default_sizes
+ecryptfs_compute_root_iv
+ecryptfs_new_file_context
+ecryptfs_write_crypt_stat_flags
+ecryptfs_code_for_cipher_string
+ecryptfs_cipher_code_to_string
+ecryptfs_read_and_validate_header_region
+ecryptfs_write_header_metadata
+ecryptfs_write_metadata
+ecryptfs_i_size_init
+ecryptfs_read_xattr_region
+ecryptfs_read_and_validate_xattr_region
+ecryptfs_read_metadata
+ecryptfs_destroy_crypto
+ecryptfs_add_new_key_tfm
+ecryptfs_tfm_exists
+ecryptfs_get_tfm_and_mutex_for_cipher_name
+ecryptfs_encrypt_and_encode_filename
+ecryptfs_decode_and_decrypt_filename
+ecryptfs_set_f_namelen
+ecryptfs_verify_auth_tok_from_key
+ecryptfs_find_global_auth_tok_for_sig
+decrypt_passphrase_encrypted_session_key
+ecryptfs_parse_packet_length
+ecryptfs_write_packet_length
+decrypt_pki_encrypted_session_key
+write_tag_3_packet
+ecryptfs_keyring_auth_tok_for_sig
+ecryptfs_find_auth_tok_for_sig
+ecryptfs_write_tag_70_packet
+ecryptfs_parse_tag_70_packet
+ecryptfs_parse_packet_set
+ecryptfs_generate_key_packet_set
+ecryptfs_add_keysig
+ecryptfs_add_global_auth_tok
+ecryptfs_threadfn
+ecryptfs_destroy_kthread
+ecryptfs_privileged_open
+ecryptfs_dump_hex.part.0
+ecryptfs_dump_auth_tok
+ecryptfs_dump_hex
+ecryptfs_msg_ctx_alloc_to_free
+ecryptfs_find_daemon_by_euid
+ecryptfs_spawn_daemon
+ecryptfs_exorcise_daemon
+ecryptfs_process_response
+ecryptfs_send_message
+ecryptfs_wait_for_response
+ecryptfs_release_messaging
+ecryptfs_miscdev_poll
+ecryptfs_miscdev_release
+ecryptfs_miscdev_open
+ecryptfs_miscdev_read
+ecryptfs_miscdev_write
+ecryptfs_send_miscdev
+ecryptfs_destroy_ecryptfs_miscdev
+get_name
+exportfs_get_name
+filldir_one
+exportfs_encode_inode_fh
+exportfs_encode_fh
+find_acceptable_alias
+reconnect_path
+exportfs_decode_fh
+utf8_to_utf32
+uni2char
+char2uni
+utf32_to_utf8
+utf8s_to_utf16s
+utf16s_to_utf8s
+unload_nls
+find_nls
+load_nls
+load_nls_default
+unregister_nls
+__register_nls
+uni2char
+char2uni
+utf8version_is_supported
+utf8version_latest
+utf8nfdi
+utf8nfdicf
+utf8nlookup
+utf8agemin
+utf8nagemin
+utf8byte
+utf8ncursor
+utf8agemax
+utf8len
+utf8nagemax
+utf8nlen
+utf8cursor
+utf8_validate
+utf8_strncmp
+utf8_normalize
+utf8_strncasecmp
+utf8_strncasecmp_folded
+utf8_casefold
+utf8_casefold_hash
+utf8_unload
+utf8_load
+fuse_len_args
+fuse_get_unique
+queue_request_and_unlock
+flush_bg_queue
+fuse_dequeue_forget
+fuse_dev_open
+fuse_request_alloc
+fuse_copy_init
+fuse_copy_do
+fuse_retrieve_end
+fuse_dev_fasync
+fuse_dev_ioctl
+fuse_drop_waiting
+fuse_dev_wake_and_unlock
+lock_request.part.0
+unlock_request.part.0
+fuse_dev_poll
+fuse_copy_finish
+fuse_copy_fill
+fuse_copy_one
+fuse_put_request
+fuse_get_req
+fuse_simple_background
+fuse_request_end
+end_requests
+fuse_abort_conn
+fuse_dev_release
+queue_interrupt
+request_wait_answer
+fuse_copy_page
+fuse_copy_args
+fuse_dev_do_read
+fuse_dev_splice_read
+fuse_dev_read
+fuse_dev_do_write
+fuse_dev_splice_write
+fuse_dev_write
+fuse_set_initialized
+fuse_queue_forget
+fuse_simple_request
+fuse_wait_aborted
+fuse_dev_cleanup
+fuse_dentry_delete
+fuse_access
+fuse_dir_fsync
+fuse_dir_release
+fuse_dir_open
+fuse_dir_compat_ioctl
+fuse_dir_ioctl
+time_to_jiffies.part.0
+__fuse_release_nowrite.part.0
+fuse_invalidate_atime.part.0
+fuse_readlink_page
+fuse_symlink_readpage
+fuse_get_link
+fuse_update_ctime.part.0
+fuse_dentry_automount
+fuse_dir_changed
+fuse_dentry_settime
+fuse_rmdir.part.0
+fuse_rmdir
+fuse_rename_common
+fuse_rename2
+fuse_unlink
+fuse_change_entry_timeout
+entry_attr_timeout
+fuse_invalidate_attr
+fuse_invalidate_atime
+fuse_invalidate_entry_cache
+fuse_valid_type
+fuse_invalid_attr
+fuse_dentry_revalidate
+fuse_do_getattr
+fuse_perm_getattr
+fuse_create_open
+create_new_entry.constprop.0
+fuse_link
+fuse_symlink
+fuse_mkdir
+fuse_mknod
+fuse_create
+fuse_lookup_name
+fuse_lookup
+fuse_atomic_open
+fuse_update_ctime
+fuse_update_attributes
+fuse_reverse_inval_entry
+fuse_allow_current_process
+fuse_getattr
+fuse_permission
+fuse_set_nowrite
+fuse_release_nowrite
+fuse_flush_times
+fuse_do_setattr
+fuse_setattr
+fuse_init_common
+fuse_init_dir
+fuse_init_symlink
+fuse_send_open
+fuse_bmap
+fuse_release_end
+fuse_insert_writeback
+fuse_do_truncate
+fuse_vma_close
+fuse_lseek
+fuse_file_llseek
+fuse_write_file_get.isra.0.part.0
+tree_insert.part.0
+fuse_writeback_range
+fuse_get_res_by_io.part.0
+fuse_file_put
+fuse_writepage_free
+fuse_writepage_args_alloc
+fuse_release_user_pages
+fuse_range_is_writeback
+fuse_wait_on_page_writeback
+fuse_page_mkwrite
+__fuse_write_file_get.isra.0
+fuse_link_write_file
+fuse_file_mmap
+fuse_prepare_release
+fuse_sync_release
+fuse_writepage_finish.isra.0
+fuse_short_read
+fuse_readpages_end
+fuse_do_readpage
+fuse_write_begin
+fuse_readpage
+fuse_file_poll
+fuse_send_writepage
+fuse_writepage_end
+fuse_aio_complete
+fuse_aio_complete_req
+fuse_async_req_send
+fuse_io_alloc
+fuse_readahead
+fuse_do_ioctl
+fuse_file_alloc
+fuse_do_open
+fuse_file_free
+fuse_finish_open
+fuse_open_common
+fuse_open
+fuse_lock_owner_id
+fuse_release_common
+fuse_release
+fuse_lk_fill
+fuse_setlk
+fuse_file_flock
+fuse_getlk
+fuse_file_lock
+fuse_flush
+fuse_direct_io
+fuse_fsync_common
+fuse_fsync
+fuse_read_args_fill
+fuse_write_update_size
+fuse_direct_IO
+fuse_file_read_iter
+fuse_write_end
+__fuse_copy_file_range
+fuse_copy_file_range
+fuse_file_fallocate
+fuse_perform_write
+fuse_file_write_iter
+fuse_flush_writepages
+fuse_writepage_locked
+fuse_launder_page
+fuse_writepage
+fuse_writepages_send
+fuse_writepages
+fuse_writepages_fill
+fuse_write_inode
+fuse_ioctl_common
+fuse_file_compat_ioctl
+fuse_file_ioctl
+fuse_notify_poll_wakeup
+fuse_init_file_inode
+fuse_inode_eq
+fuse_inode_set
+fuse_encode_fh
+fuse_init_inode
+fuse_free_fc
+fuse_free_conn
+fuse_get_parent
+fuse_get_dentry
+fuse_fh_to_parent
+fuse_show_options
+fuse_umount_begin
+fuse_statfs
+fuse_send_destroy
+fuse_free_inode
+fuse_mount_remove
+fuse_conn_destroy
+fuse_kill_sb_anon
+fuse_reconfigure
+fuse_parse_param
+fuse_kill_sb_blk
+fuse_inode_init_once
+fuse_fh_to_dentry
+fuse_evict_inode
+fuse_get_tree
+fuse_conn_put
+fuse_conn_init
+sanitize_global_limit
+set_global_limit
+process_init_reply
+fuse_init_fs_context
+fuse_dev_alloc
+fuse_alloc_inode
+fuse_send_init
+fuse_mount_put
+fuse_put_super
+fuse_mount_get
+fuse_conn_get
+fuse_dev_install
+fuse_dev_alloc_install
+fuse_dev_free
+fuse_alloc_forget
+fuse_change_attributes_common
+fuse_change_attributes
+fuse_iget
+fuse_fill_super_common
+fuse_fill_super
+fuse_ilookup
+fuse_reverse_inval_inode
+fuse_lock_inode
+fuse_unlock_inode
+fuse_fill_super_submount
+fuse_ctl_get_tree
+fuse_ctl_init_fs_context
+fuse_ctl_kill_sb
+fuse_ctl_file_conn_get
+fuse_conn_waiting_read
+fuse_conn_abort_write
+fuse_ctl_add_dentry
+fuse_conn_max_background_read
+fuse_conn_limit_write.isra.0
+fuse_conn_max_background_write
+fuse_conn_congestion_threshold_read
+fuse_conn_congestion_threshold_write
+fuse_ctl_remove_conn
+fuse_ctl_add_conn
+fuse_ctl_fill_super
+no_xattr_list
+no_xattr_get
+no_xattr_set
+fuse_setxattr
+fuse_getxattr
+fuse_xattr_get
+fuse_listxattr
+fuse_removexattr
+fuse_xattr_set
+fuse_get_acl
+fuse_set_acl
+fuse_force_forget
+fuse_emit
+fuse_readdir_uncached
+fuse_readdir
+fuse_free_dax_mem_ranges
+fuse_send_removemapping
+dmap_reinit_add_to_free_pool
+fuse_setup_one_mapping
+dmap_writeback_invalidate
+__fuse_dax_fault
+fuse_dax_page_mkwrite
+fuse_dax_pfn_mkwrite
+fuse_dax_huge_fault
+fuse_dax_fault
+fuse_dax_writepages
+fuse_dax_cancel_work
+reclaim_one_dmap_locked.part.0
+fuse_iomap_end
+fuse_fill_iomap
+dmap_add_to_free_pool
+alloc_dax_mapping
+fuse_dax_inode_cleanup
+fuse_dax_break_layouts
+fuse_iomap_begin
+fuse_dax_free_mem_worker
+fuse_dax_read_iter
+fuse_dax_write_iter
+fuse_dax_mmap
+fuse_dax_conn_free
+fuse_dax_conn_alloc
+fuse_dax_inode_alloc
+fuse_dax_inode_init
+fuse_dax_check_alignment
+debugfs_automount
+debugfs_lookup
+debugfs_setattr
+debugfs_release_dentry
+debugfs_show_options
+debugfs_free_inode
+debugfs_parse_options
+debugfs_remount
+failed_creating
+debugfs_get_inode
+debugfs_initialized
+debug_mount
+start_creating
+debugfs_create_symlink
+debugfs_remove
+debug_fill_super
+debugfs_rename
+remove_one
+debugfs_create_dir
+debugfs_create_automount
+__debugfs_create_file
+debugfs_create_file
+debugfs_create_file_size
+debugfs_create_file_unsafe
+default_read_file
+default_write_file
+fops_u8_wo_open
+fops_u8_ro_open
+fops_u8_open
+fops_u16_wo_open
+fops_u16_ro_open
+fops_u16_open
+fops_u32_wo_open
+fops_u32_ro_open
+fops_u32_open
+fops_u64_wo_open
+fops_u64_ro_open
+fops_u64_open
+fops_ulong_wo_open
+fops_ulong_ro_open
+fops_ulong_open
+fops_x8_wo_open
+fops_x8_ro_open
+fops_x8_open
+fops_x16_wo_open
+fops_x16_ro_open
+fops_x16_open
+fops_x32_wo_open
+fops_x32_ro_open
+fops_x32_open
+fops_x64_wo_open
+fops_x64_ro_open
+fops_x64_open
+fops_size_t_wo_open
+fops_size_t_ro_open
+fops_size_t_open
+fops_atomic_t_wo_open
+fops_atomic_t_ro_open
+fops_atomic_t_open
+debugfs_create_mode_unsafe
+debugfs_create_u8
+debugfs_create_u16
+debugfs_create_u32
+debugfs_create_u64
+debugfs_create_ulong
+debugfs_create_x8
+debugfs_create_x16
+debugfs_create_x32
+debugfs_create_x64
+debugfs_create_size_t
+debugfs_create_atomic_t
+debugfs_create_bool
+debugfs_create_blob
+debugfs_create_u32_array
+debugfs_atomic_t_set
+debugfs_u8_set
+debugfs_u8_get
+debugfs_u16_set
+debugfs_u16_get
+debugfs_u32_set
+debugfs_u32_get
+debugfs_u64_set
+debugfs_u64_get
+debugfs_ulong_set
+debugfs_ulong_get
+debugfs_atomic_t_get
+u32_array_release
+debugfs_locked_down
+u32_array_read
+debugfs_print_regs32
+debugfs_create_regset32
+debugfs_open_regset32
+debugfs_devm_entry_open
+debugfs_show_regset32
+debugfs_create_devm_seqfile
+u32_array_open
+debugfs_real_fops.part.0
+debugfs_real_fops
+full_proxy_release
+debugfs_file_put
+debugfs_file_get
+full_proxy_unlocked_ioctl
+full_proxy_poll
+full_proxy_write
+full_proxy_read
+full_proxy_llseek
+open_proxy_open
+full_proxy_open
+debugfs_attr_read
+debugfs_attr_write
+read_file_blob
+debugfs_read_file_bool
+debugfs_write_file_bool
+debugfs_size_t_get
+debugfs_size_t_set
+default_read_file
+default_write_file
+remove_one
+trace_mount
+tracefs_show_options
+tracefs_parse_options
+tracefs_remount
+tracefs_get_inode
+get_dname
+tracefs_syscall_rmdir
+tracefs_syscall_mkdir
+start_creating
+trace_fill_super
+__create_dir
+tracefs_create_file
+tracefs_create_dir
+tracefs_remove
+tracefs_initialized
+pstore_kill_sb
+pstore_mount
+pstore_show_options
+pstore_ftrace_seq_stop
+pstore_ftrace_seq_next
+pstore_unlink
+pstore_ftrace_seq_show
+free_pstore_private
+pstore_evict_inode
+parse_options
+pstore_remount
+pstore_get_inode
+psinfo_lock_root
+pstore_file_open
+pstore_file_read
+pstore_file_llseek
+pstore_ftrace_seq_start
+pstore_put_backend_records
+pstore_mkfile
+pstore_get_records
+pstore_fill_super
+zbufsize_deflate
+pstore_type_to_name
+pstore_name_to_type
+pstore_dowork
+pstore_write_user_compat
+pstore_timer_kick
+pstore_timefunc
+free_buf_for_compression
+allocate_buf_for_compression
+pstore_register
+pstore_unregister
+pstore_set_kmsg_bytes
+pstore_record_init
+pstore_dump
+pstore_get_backend_records
+efivarfs_unlink
+efivarfs_get_inode
+efivarfs_valid_name
+efivarfs_create
+efivarfs_file_ioctl
+efivarfs_file_read
+efivarfs_file_write
+efivarfs_kill_sb
+efivarfs_destroy
+efivarfs_get_tree
+efivarfs_init_fs_context
+efivarfs_fill_super
+efivarfs_d_hash
+efivarfs_d_compare
+efivarfs_evict_inode
+efivarfs_callback
+get_compat_ipc64_perm
+get_compat_ipc_perm
+to_compat_ipc64_perm
+to_compat_ipc_perm
+sysvipc_proc_release
+sysvipc_proc_show
+sysvipc_find_ipc
+sysvipc_proc_start
+sysvipc_proc_open
+sysvipc_proc_stop
+sysvipc_proc_next
+ipc_kht_remove.part.0
+ipc_init_ids
+ipc_addid
+ipc_rmid
+ipc_set_key_private
+ipc_rcu_getref
+ipc_rcu_putref
+ipcperms
+kernel_to_ipc64_perm
+ipc64_perm_to_ipc_perm
+ipc_obtain_object_idr
+ipc_obtain_object_check
+ipcget
+ipc_update_perm
+ipcctl_obtain_check
+ipc_seq_pid_ns
+copy_msg
+store_msg
+free_msg
+load_msg
+msg_rcu_free
+testmsg
+__x64_sys_msgget
+__ia32_sys_msgget
+ss_wakeup
+copy_compat_msqid_to_user
+do_msg_fill
+compat_do_msg_fill
+sysvipc_msg_proc_show
+msgctl_info.isra.0
+expunge_all
+freeque
+newque
+do_msgsnd
+__x64_sys_msgsnd
+__ia32_sys_msgsnd
+__ia32_compat_sys_msgsnd
+__x32_compat_sys_msgsnd
+msgctl_stat
+msgctl_down
+compat_ksys_msgctl
+__ia32_compat_sys_msgctl
+__x32_compat_sys_msgctl
+__ia32_compat_sys_old_msgctl
+__x32_compat_sys_old_msgctl
+ksys_msgctl.constprop.0
+__ia32_sys_msgctl
+__x64_sys_msgctl
+do_msgrcv
+__x64_sys_msgrcv
+__ia32_sys_msgrcv
+__ia32_compat_sys_msgrcv
+__x32_compat_sys_msgrcv
+ksys_msgget
+compat_ksys_old_msgctl
+ksys_msgsnd
+compat_ksys_msgsnd
+ksys_msgrcv
+compat_ksys_msgrcv
+msg_init_ns
+msg_exit_ns
+sem_rcu_free
+sem_more_checks
+copy_compat_semid_to_user
+lookup_undo
+semctl_info.isra.0
+copy_semid_to_user.constprop.0
+check_qop.constprop.0
+count_semcnt
+complexmode_enter.part.0
+sysvipc_sem_proc_show
+perform_atomic_semop
+wake_const_ops
+do_smart_wakeup_zero
+update_queue
+do_smart_update
+newary
+freeary
+semctl_down
+semctl_stat
+do_semtimedop
+__x64_sys_semop
+__ia32_sys_semop
+semctl_main
+semctl_setval
+compat_ksys_semctl
+__ia32_compat_sys_semctl
+__x32_compat_sys_semctl
+__ia32_compat_sys_old_semctl
+__x32_compat_sys_old_semctl
+ksys_semctl.constprop.0
+__ia32_sys_semctl
+__x64_sys_semctl
+sem_init_ns
+sem_exit_ns
+ksys_semget
+__x64_sys_semget
+__ia32_sys_semget
+compat_ksys_old_semctl
+ksys_semtimedop
+__x64_sys_semtimedop
+__ia32_sys_semtimedop
+compat_ksys_semtimedop
+__x64_sys_semtimedop_time32
+__ia32_sys_semtimedop_time32
+copy_semundo
+exit_sem
+shm_rcu_free
+shm_fault
+shm_split
+shm_pagesize
+shm_set_policy
+shm_get_policy
+shm_fsync
+shm_fallocate
+shm_get_unmapped_area
+shm_more_checks
+shm_release
+shm_add_rss_swap
+sysvipc_shm_proc_show
+__x64_sys_shmget
+__ia32_sys_shmget
+copy_compat_shmid_to_user
+shmctl_ipc_info
+shmctl_shm_info
+shm_destroy
+shm_try_destroy_orphaned
+do_shm_rmid
+shm_close
+shmctl_stat
+shmctl_down
+newseg
+__shm_open
+shm_open
+shm_mmap
+shmctl_do_lock
+compat_ksys_shmctl
+__ia32_compat_sys_shmctl
+__x32_compat_sys_shmctl
+__ia32_compat_sys_old_shmctl
+__x32_compat_sys_old_shmctl
+ksys_shmctl.constprop.0
+__ia32_sys_shmctl
+__x64_sys_shmctl
+shm_init_ns
+shm_exit_ns
+shm_destroy_orphaned
+exit_shm
+is_file_shm_hugepages
+ksys_shmget
+compat_ksys_old_shmctl
+do_shmat
+__x64_sys_shmat
+__ia32_sys_shmat
+__ia32_compat_sys_shmat
+__x32_compat_sys_shmat
+ksys_shmdt
+__x64_sys_shmdt
+__ia32_sys_shmdt
+compat_ksys_ipc
+__ia32_compat_sys_ipc
+__x32_compat_sys_ipc
+proc_ipc_sem_dointvec
+proc_ipc_dointvec_minmax
+proc_ipc_dointvec_minmax_orphans
+proc_ipc_doulongvec_minmax
+proc_ipc_auto_msgmni
+mqueue_unlink
+mqueue_fs_context_free
+msg_insert
+__do_notify
+mqueue_get_tree
+mqueue_free_inode
+mqueue_alloc_inode
+init_once
+do_mq_open
+__ia32_sys_mq_open
+__ia32_compat_sys_mq_open
+__x64_sys_mq_open
+__ia32_sys_mq_unlink
+__x32_compat_sys_mq_open
+remove_notification
+mqueue_init_fs_context
+mq_create_mount
+mqueue_flush_file
+mqueue_poll_file
+__x64_sys_mq_unlink
+wq_sleep.constprop.0
+mqueue_read_file
+do_mq_getsetattr
+__x64_sys_mq_getsetattr
+__ia32_sys_mq_getsetattr
+__ia32_compat_sys_mq_getsetattr
+__x32_compat_sys_mq_getsetattr
+mqueue_evict_inode
+do_mq_timedsend
+__ia32_sys_mq_timedsend
+__ia32_sys_mq_timedsend_time32
+__x64_sys_mq_timedsend_time32
+__x64_sys_mq_timedsend
+do_mq_notify
+__ia32_sys_mq_notify
+__ia32_compat_sys_mq_notify
+__x64_sys_mq_notify
+__x32_compat_sys_mq_notify
+do_mq_timedreceive
+__ia32_sys_mq_timedreceive
+__ia32_sys_mq_timedreceive_time32
+__x64_sys_mq_timedreceive_time32
+__x64_sys_mq_timedreceive
+mqueue_get_inode
+mqueue_create_attr
+mqueue_create
+mqueue_fill_super
+mq_init_ns
+mq_clear_sbinfo
+mq_put_mnt
+ipcns_owner
+free_ipc
+ipcns_get
+copy_ipcs
+free_ipcs
+put_ipc_ns
+ipcns_install
+ipcns_put
+proc_mq_dointvec_minmax
+proc_mq_dointvec
+mq_register_sysctl_table
+key_gc_unused_keys.constprop.0
+key_schedule_gc
+key_garbage_collector
+key_schedule_gc_links
+key_gc_timer_func
+key_gc_keytype
+key_set_timeout
+register_key_type
+unregister_key_type
+key_put
+key_revoke
+key_invalidate
+__key_instantiate_and_link
+key_instantiate_and_link
+key_reject_and_link
+key_update
+key_payload_reserve
+generic_key_instantiate
+key_user_lookup
+key_user_put
+key_alloc
+key_lookup
+key_type_lookup
+key_create_or_update
+key_type_put
+keyring_free_preparse
+restrict_link_reject
+keyring_free_object
+keyring_instantiate
+keyring_preparse
+keyring_get_key_chunk
+keyring_get_object_key_chunk
+keyring_diff_objects
+keyring_read_iterator
+keyring_detect_cycle_iterator
+keyring_read
+keyring_destroy
+keyring_compare_object
+keyring_revoke
+keyring_alloc
+key_default_cmp
+keyring_search_iterator
+keyring_describe
+__key_unlink_begin.part.0
+keyring_restrict
+keyring_gc_check_iterator
+__key_unlink
+key_unlink
+keyring_clear
+keyring_gc_select_iterator
+key_free_user_ns
+key_set_index_key
+search_nested_keyrings
+keyring_detect_cycle
+key_put_tag
+key_remove_domain
+keyring_search_rcu
+keyring_search
+find_key_to_update
+find_keyring_by_name
+__key_link_lock
+__key_move_lock
+__key_link_begin
+__key_link_check_live_key
+__key_link
+__key_link_end
+key_link
+key_move
+keyring_gc
+keyring_restriction_gc
+__keyctl_read_key
+keyctl_capabilities.part.0
+key_get_type_from_user.constprop.0
+__ia32_sys_request_key
+__ia32_sys_add_key
+get_instantiation_keyring
+keyctl_change_reqkey_auth
+keyctl_instantiate_key_common
+__x64_sys_request_key
+__x64_sys_add_key
+keyctl_get_keyring_ID
+keyctl_join_session_keyring
+keyctl_update_key
+keyctl_revoke_key
+keyctl_invalidate_key
+keyctl_keyring_clear
+keyctl_keyring_link
+keyctl_keyring_unlink
+keyctl_keyring_move
+keyctl_describe_key
+keyctl_keyring_search
+keyctl_read_key
+keyctl_chown_key
+keyctl_setperm_key
+keyctl_instantiate_key
+keyctl_instantiate_key_iov
+keyctl_reject_key
+keyctl_negate_key
+keyctl_set_reqkey_keyring
+keyctl_set_timeout
+keyctl_assume_authority
+keyctl_get_security
+keyctl_session_to_parent
+keyctl_restrict_keyring
+keyctl_watch_key
+__ia32_sys_keyctl
+__x64_sys_keyctl
+keyctl_capabilities
+key_task_permission
+key_validate
+lookup_user_key_possessed
+look_up_user_keyrings
+get_user_session_keyring_rcu
+install_thread_keyring_to_cred
+install_process_keyring_to_cred
+install_session_keyring_to_cred
+key_fsuid_changed
+key_fsgid_changed
+search_cred_keyrings_rcu
+search_process_keyrings_rcu
+join_session_keyring
+lookup_user_key
+key_change_session_keyring
+complete_request_key
+umh_keys_cleanup
+umh_keys_init
+wait_for_key_construction
+cache_requested_key
+check_cached_key
+request_key_rcu
+call_sbin_request_key
+request_key_and_link
+request_key_tag
+request_key_with_auxdata
+request_key_auth_preparse
+request_key_auth_free_preparse
+request_key_auth_instantiate
+request_key_auth_read
+request_key_auth_describe
+request_key_auth_destroy
+request_key_auth_revoke
+free_request_key_auth.part.0
+request_key_auth_rcu_disposal
+request_key_auth_new
+key_get_instantiation_authkey
+logon_vet_description
+user_preparse
+user_read
+user_free_preparse
+user_free_payload_rcu
+user_destroy
+user_update
+user_revoke
+user_describe
+__ia32_compat_sys_keyctl
+__x32_compat_sys_keyctl
+compat_keyctl_dh_compute
+proc_key_users_stop
+proc_key_users_show
+__key_user_next
+proc_key_users_next
+proc_keys_next
+proc_keys_start
+proc_key_users_start
+proc_keys_stop
+proc_keys_show
+keyctl_get_persistent
+dh_crypto_done
+dh_data_from_key
+__keyctl_dh_compute
+keyctl_dh_compute
+keyctl_pkey_params_get
+keyctl_pkey_params_get_2
+keyctl_pkey_query
+keyctl_pkey_e_d_s
+keyctl_pkey_verify
+trusted_rcu_free
+trusted_read
+trusted_destroy
+trusted_tpm_send
+oiap
+getoptions
+datablob_parse
+pcrlock
+trusted_options_alloc
+trusted_payload_alloc
+init_sdesc
+TSS_rawhmac
+osap
+TSS_authhmac
+TSS_checkhmac1
+TSS_checkhmac2.constprop.0
+tpm_unseal
+key_seal
+trusted_update
+trusted_instantiate
+tpm2_buf_append_auth.constprop.0
+tpm2_seal_trusted
+tpm2_unseal_trusted
+encrypted_rcu_free
+encrypted_destroy
+valid_master_desc
+request_master_key
+datablob_parse
+__ekey_init
+calc_hmac.constprop.0
+init_skcipher_req.constprop.0
+derived_key_encrypt.constprop.0
+derived_key_decrypt.constprop.0
+get_derived_key
+encrypted_read
+datablob_hmac_verify
+encrypted_key_alloc
+encrypted_update
+encrypted_instantiate
+ecryptfs_get_auth_tok_key
+ecryptfs_get_versions
+ecryptfs_fill_auth_tok
+request_trusted_key
+cap_mmap_file
+cap_settime
+cap_inode_killpriv
+cap_inode_need_killpriv
+cap_capget
+rootid_owns_currentns
+cap_inode_getsecurity
+cap_capable
+cap_vm_enough_memory
+cap_task_prctl
+cap_mmap_addr
+cap_task_fix_setuid
+cap_safe_nice
+cap_task_setscheduler
+cap_task_setioprio
+cap_task_setnice
+cap_ptrace_access_check
+cap_ptrace_traceme
+cap_capset
+cap_convert_nscap
+get_vfs_caps_from_disk
+cap_bprm_creds_from_file
+cap_inode_setxattr
+cap_inode_removexattr
+mmap_min_addr_handler
+call_blocking_lsm_notifier
+register_blocking_lsm_notifier
+unregister_blocking_lsm_notifier
+inode_free_by_rcu
+security_free_mnt_opts
+security_sb_eat_lsm_opts
+security_sb_remount
+security_sb_set_mnt_opts
+security_sb_clone_mnt_opts
+security_add_mnt_opt
+security_dentry_init_security
+security_dentry_create_files_as
+security_inode_copy_up
+security_inode_copy_up_xattr
+security_file_ioctl
+security_cred_getsecid
+security_task_getsecid
+security_ismaclabel
+security_secid_to_secctx
+security_secctx_to_secid
+security_release_secctx
+security_inode_invalidate_secctx
+security_inode_notifysecctx
+security_inode_setsecctx
+security_inode_getsecctx
+security_unix_stream_connect
+security_unix_may_send
+security_socket_socketpair
+security_sock_rcv_skb
+security_socket_getpeersec_dgram
+security_sk_clone
+security_sk_classify_flow
+security_req_classify_flow
+security_sock_graft
+security_inet_conn_request
+security_inet_conn_established
+security_secmark_relabel_packet
+security_secmark_refcount_inc
+security_secmark_refcount_dec
+security_tun_dev_alloc_security
+security_tun_dev_free_security
+security_tun_dev_create
+security_tun_dev_attach_queue
+security_tun_dev_attach
+security_tun_dev_open
+security_sctp_assoc_request
+security_sctp_bind_connect
+security_sctp_sk_clone
+security_ib_pkey_access
+security_ib_endport_manage_subnet
+security_ib_alloc_security
+security_ib_free_security
+security_xfrm_policy_alloc
+security_xfrm_policy_free
+security_xfrm_state_alloc
+security_xfrm_state_delete
+security_locked_down
+security_old_inode_init_security
+security_path_mknod
+security_path_mkdir
+security_path_unlink
+security_path_rename
+security_inode_create
+security_inode_mkdir
+security_inode_listsecurity
+security_d_instantiate
+security_inode_setattr
+security_kernel_read_file
+security_kernel_post_read_file
+security_kernel_load_data
+security_kernel_post_load_data
+security_skb_classify_flow
+security_inode_init_security
+lsm_inode_alloc
+security_binder_set_context_mgr
+security_binder_transaction
+security_binder_transfer_binder
+security_binder_transfer_file
+security_ptrace_access_check
+security_ptrace_traceme
+security_capget
+security_capset
+security_capable
+security_quotactl
+security_quota_on
+security_syslog
+security_settime64
+security_vm_enough_memory_mm
+security_bprm_creds_for_exec
+security_bprm_creds_from_file
+security_bprm_check
+security_bprm_committing_creds
+security_bprm_committed_creds
+security_fs_context_dup
+security_fs_context_parse_param
+security_sb_alloc
+security_sb_free
+security_sb_kern_mount
+security_sb_show_options
+security_sb_statfs
+security_sb_mount
+security_sb_umount
+security_sb_pivotroot
+security_move_mount
+security_path_notify
+security_inode_free
+security_inode_alloc
+security_path_rmdir
+security_path_symlink
+security_path_link
+security_path_truncate
+security_path_chmod
+security_path_chown
+security_path_chroot
+security_inode_link
+security_inode_unlink
+security_inode_symlink
+security_inode_rmdir
+security_inode_mknod
+security_inode_rename
+security_inode_readlink
+security_inode_follow_link
+security_inode_permission
+security_inode_getattr
+security_inode_setxattr
+security_inode_post_setxattr
+security_inode_getxattr
+security_inode_listxattr
+security_inode_removexattr
+security_inode_need_killpriv
+security_inode_killpriv
+security_inode_getsecurity
+security_inode_setsecurity
+security_inode_getsecid
+security_kernfs_init_security
+security_file_permission
+security_file_free
+security_file_alloc
+security_mmap_file
+security_mmap_addr
+security_file_mprotect
+security_file_lock
+security_file_fcntl
+security_file_set_fowner
+security_file_send_sigiotask
+security_file_receive
+security_file_open
+security_task_free
+security_task_alloc
+security_cred_free
+security_cred_alloc_blank
+security_prepare_creds
+security_transfer_creds
+security_kernel_act_as
+security_kernel_create_files_as
+security_kernel_module_request
+security_task_fix_setuid
+security_task_fix_setgid
+security_task_setpgid
+security_task_getpgid
+security_task_getsid
+security_task_setnice
+security_task_setioprio
+security_task_getioprio
+security_task_prlimit
+security_task_setrlimit
+security_task_setscheduler
+security_task_getscheduler
+security_task_movememory
+security_task_kill
+security_task_prctl
+security_task_to_inode
+security_ipc_permission
+security_ipc_getsecid
+security_msg_msg_free
+security_msg_msg_alloc
+security_msg_queue_free
+security_msg_queue_alloc
+security_msg_queue_associate
+security_msg_queue_msgctl
+security_msg_queue_msgsnd
+security_msg_queue_msgrcv
+security_shm_free
+security_shm_alloc
+security_shm_associate
+security_shm_shmctl
+security_shm_shmat
+security_sem_free
+security_sem_alloc
+security_sem_associate
+security_sem_semctl
+security_sem_semop
+security_getprocattr
+security_setprocattr
+security_netlink_send
+security_post_notification
+security_watch_key
+security_socket_create
+security_socket_post_create
+security_socket_bind
+security_socket_connect
+security_socket_listen
+security_socket_accept
+security_socket_sendmsg
+security_socket_recvmsg
+security_socket_getsockname
+security_socket_getpeername
+security_socket_getsockopt
+security_socket_setsockopt
+security_socket_shutdown
+security_socket_getpeersec_stream
+security_sk_alloc
+security_sk_free
+security_inet_csk_clone
+security_xfrm_policy_clone
+security_xfrm_policy_delete
+security_xfrm_state_alloc_acquire
+security_xfrm_state_free
+security_xfrm_policy_lookup
+security_xfrm_state_pol_flow_match
+security_xfrm_decode_session
+security_key_alloc
+security_key_free
+security_key_permission
+security_key_getsecurity
+security_audit_rule_init
+security_audit_rule_known
+security_audit_rule_free
+security_audit_rule_match
+security_bpf
+security_bpf_map
+security_bpf_prog
+security_bpf_map_alloc
+security_bpf_prog_alloc
+security_bpf_map_free
+security_bpf_prog_free
+security_perf_event_open
+security_perf_event_alloc
+security_perf_event_free
+security_perf_event_read
+security_perf_event_write
+securityfs_get_tree
+securityfs_init_fs_context
+securityfs_fill_super
+securityfs_free_inode
+securityfs_create_dentry
+securityfs_create_file
+securityfs_create_dir
+securityfs_create_symlink
+securityfs_remove
+lsm_read
+__traceiter_selinux_audited
+avc_copy_xperms_decision
+avc_node_populate
+avc_audit_pre_callback
+avc_audit_post_callback
+avc_node_delete
+avc_flush
+avc_node_replace
+avc_xperms_decision_free
+avc_xperms_free
+avc_node_free
+avc_node_kill
+avc_alloc_node
+avc_xperms_decision_alloc
+avc_xperms_populate
+avc_update_node.part.0
+avc_denied
+avc_compute_av
+selinux_avc_init
+avc_get_cache_threshold
+avc_set_cache_threshold
+avc_get_hash_stats
+slow_avc_audit
+avc_ss_reset
+avc_has_extended_perms
+avc_has_perm
+avc_has_perm_flags
+avc_policy_seqno
+avc_disable
+selinux_mmap_addr
+selinux_secmark_refcount_inc
+selinux_secmark_refcount_dec
+selinux_ismaclabel
+selinux_inode_copy_up_xattr
+selinux_tun_dev_free_security
+selinux_release_secctx
+selinux_secid_to_secctx
+selinux_perf_event_open
+selinux_bpf
+selinux_tun_dev_create
+selinux_kernel_module_request
+selinux_task_alloc
+selinux_capset
+selinux_file_alloc_security
+selinux_file_set_fowner
+selinux_cred_prepare
+selinux_cred_transfer
+selinux_cred_getsecid
+selinux_socket_socketpair
+selinux_sk_getsecid
+selinux_req_classify_flow
+selinux_tun_dev_attach
+selinux_msg_msg_alloc_security
+selinux_ipc_getsecid
+selinux_add_opt
+selinux_inode_alloc_security
+selinux_sock_graft
+selinux_inode_getsecid
+parse_sid
+may_context_mount_sb_relabel
+may_context_mount_inode_relabel
+selinux_sem_alloc_security
+selinux_shm_alloc_security
+selinux_msg_queue_alloc_security
+selinux_perf_event_write
+selinux_perf_event_read
+selinux_bpf_prog
+selinux_bpf_map
+selinux_watch_key
+selinux_tun_dev_open
+selinux_tun_dev_attach_queue
+selinux_secmark_relabel_packet
+sock_has_perm
+selinux_socket_shutdown
+selinux_socket_getsockopt
+selinux_socket_getsockname
+selinux_socket_getpeername
+selinux_socket_recvmsg
+selinux_socket_sendmsg
+selinux_socket_listen
+selinux_socket_unix_may_send
+ipc_has_perm
+selinux_sem_semop
+selinux_shm_shmat
+selinux_ipc_permission
+selinux_sem_associate
+selinux_shm_associate
+selinux_msg_queue_msgsnd
+selinux_msg_queue_associate
+selinux_kernel_act_as
+inode_has_perm
+selinux_umount
+selinux_sb_statfs
+selinux_sb_kern_mount
+selinux_quotactl
+selinux_perf_event_free
+selinux_bpf_prog_free
+selinux_bpf_map_free
+selinux_key_free
+selinux_free_mnt_opts
+selinux_sb_free_security
+selinux_sk_clone_security
+selinux_key_getsecurity
+selinux_add_mnt_opt
+selinux_fs_context_parse_param
+selinux_lockdown
+selinux_ib_endport_manage_subnet
+selinux_ib_pkey_access
+selinux_skb_peerlbl_sid
+selinux_inet_conn_established
+selinux_socket_getpeersec_dgram
+selinux_inet_csk_clone
+selinux_socket_unix_stream_connect
+selinux_socket_connect_helper
+selinux_sk_free_security
+selinux_socket_getpeersec_stream
+selinux_socket_setsockopt
+selinux_socket_connect
+selinux_socket_bind
+selinux_inode_setsecctx
+selinux_secctx_to_secid
+selinux_inode_copy_up
+audit_inode_permission
+selinux_msg_queue_msgrcv
+selinux_task_kill
+selinux_task_setscheduler
+selinux_task_movememory
+selinux_task_getioprio
+selinux_task_getscheduler
+selinux_task_setnice
+selinux_task_setioprio
+selinux_task_getsecid
+selinux_task_getsid
+selinux_task_getpgid
+selinux_task_setpgid
+selinux_file_send_sigiotask
+selinux_capget
+selinux_ptrace_traceme
+selinux_ptrace_access_check
+selinux_binder_transfer_binder
+selinux_binder_transaction
+selinux_binder_set_context_mgr
+ptrace_parent_sid
+selinux_getprocattr
+show_sid
+selinux_bprm_committed_creds
+selinux_nf_unregister
+selinux_nf_register
+selinux_netlink_send
+selinux_sctp_sk_clone
+check_nnp_nosuid
+selinux_inode_listsecurity
+inode_doinit_use_xattr
+selinux_lsm_notifier_avc_callback
+selinux_netcache_avc_callback
+selinux_syslog
+selinux_task_prlimit
+selinux_key_permission
+selinux_msg_queue_msgctl.part.0
+selinux_sem_semctl
+selinux_shm_shmctl
+selinux_msg_queue_msgctl
+bpf_fd_pass
+file_has_perm
+match_file
+selinux_file_receive
+selinux_file_fcntl
+selinux_file_lock
+file_map_prot_check
+selinux_mmap_file
+selinux_file_mprotect
+selinux_inet_sys_rcv_skb
+selinux_task_setrlimit
+selinux_ip_output.part.0
+selinux_ipv6_output
+selinux_ipv4_output
+selinux_sctp_bind_connect
+selinux_secmark_enabled
+selinux_peerlbl_enabled
+selinux_sb_eat_lsm_opts
+cred_has_capability
+has_cap_mac_admin
+selinux_setprocattr
+selinux_vm_enough_memory
+selinux_capable
+selinux_ib_free_security
+selinux_bpf_map_alloc
+selinux_bpf_prog_alloc
+selinux_perf_event_alloc
+selinux_tun_dev_alloc_security
+selinux_ib_alloc_security
+selinux_sb_alloc_security
+selinux_key_alloc
+selinux_sk_alloc_security
+selinux_fs_context_dup
+selinux_inet_conn_request
+selinux_sctp_assoc_request
+selinux_socket_create
+selinux_inode_invalidate_secctx
+selinux_inode_free_security
+selinux_socket_post_create
+selinux_socket_accept
+selinux_task_to_inode
+selinux_inode_setsecurity
+selinux_inode_notifysecctx
+selinux_parse_skb.constprop.0
+selinux_ip_forward
+selinux_ipv6_forward
+selinux_ipv4_forward
+selinux_ip_postroute_compat
+selinux_ip_postroute
+selinux_ipv6_postroute
+selinux_ipv4_postroute
+selinux_sock_rcv_skb_compat
+selinux_socket_sock_rcv_skb
+selinux_bprm_committing_creds
+inode_doinit_with_dentry
+sb_finish_set_opts
+selinux_set_mnt_opts
+delayed_superblock_init
+selinux_d_instantiate
+__inode_security_revalidate
+selinux_kernel_module_from_file
+selinux_kernel_read_file
+selinux_kernel_load_data
+selinux_kernel_create_files_as
+selinux_determine_inode_label
+selinux_dentry_create_files_as
+selinux_dentry_init_security
+selinux_inode_init_security
+may_create
+selinux_inode_mknod
+selinux_inode_mkdir
+selinux_inode_symlink
+selinux_inode_create
+selinux_file_open
+selinux_file_permission
+selinux_inode_getsecurity
+selinux_inode_getsecctx
+selinux_bprm_creds_for_exec
+selinux_path_notify
+selinux_inode_post_setxattr
+selinux_inode_rename
+may_link
+selinux_inode_rmdir
+selinux_inode_unlink
+selinux_inode_link
+selinux_sb_clone_mnt_opts
+selinux_sb_remount
+selinux_binder_transfer_file
+selinux_inode_setxattr
+selinux_sb_show_options
+inode_security_rcu
+selinux_inode_permission
+selinux_inode_follow_link
+selinux_file_ioctl
+selinux_inode_getattr
+selinux_move_mount
+selinux_quota_on
+selinux_inode_getxattr
+selinux_inode_listxattr
+selinux_inode_readlink
+selinux_mount
+selinux_inode_setattr
+selinux_inode_removexattr
+selinux_kernfs_init_security
+selinux_complete_init
+sel_avc_stats_seq_stop
+sel_get_tree
+sel_open_avc_cache_stats
+sel_read_policyvers
+sel_mmap_policy
+sel_init_fs_context
+selinux_fs_info_free
+sel_kill_sb
+sel_avc_get_stat_idx
+sel_avc_stats_seq_next
+sel_avc_stats_seq_start
+sel_make_inode
+sel_avc_stats_seq_show
+sel_read_avc_hash_stats
+sel_read_policy
+sel_write_avc_cache_threshold
+sel_read_avc_cache_threshold
+sel_read_class
+sel_read_perm
+sel_read_sidtab_hash_stats
+sel_read_initcon
+sel_make_dir
+sel_read_policycap
+sel_mmap_policy_fault
+sel_open_handle_status
+sel_read_handle_unknown
+sel_read_mls
+sel_commit_bools_write
+selinux_transaction_write
+sel_write_context
+sel_write_bool
+sel_read_bool
+sel_write_load
+sel_read_enforce
+sel_write_enforce
+sel_read_checkreqprot
+sel_write_checkreqprot
+sel_read_handle_status
+sel_release_policy
+sel_mmap_handle_status
+sel_write_access
+sel_write_create
+sel_write_relabel
+sel_write_user
+sel_write_member
+sel_write_validatetrans
+sel_fill_super
+sel_open_policy
+selnl_notify
+selnl_notify_setenforce
+selnl_notify_policyload
+selinux_nlmsg_lookup
+sel_netif_destroy
+sel_netif_netdev_notifier_handler
+sel_netif_sid
+sel_netif_flush
+sel_netnode_find
+sel_netnode_sid
+sel_netnode_flush
+sel_netport_sid
+sel_netport_flush
+selinux_kernel_status_page
+selinux_status_update_setenforce
+selinux_status_update_policyload
+ebitmap_cmp
+ebitmap_netlbl_export
+ebitmap_contains
+ebitmap_get_bit
+ebitmap_set_bit
+ebitmap_and
+ebitmap_destroy
+ebitmap_cpy
+ebitmap_netlbl_import
+ebitmap_read
+ebitmap_write
+ebitmap_hash
+hashtab_init
+__hashtab_insert
+hashtab_destroy
+hashtab_map
+hashtab_stat
+hashtab_duplicate
+symcmp
+symhash
+symtab_init
+symtab_insert
+symtab_search
+context_to_sid
+sidtab_sid2str_put.part.0
+sidtab_destroy_tree
+sidtab_convert_tree
+sidtab_do_lookup
+sidtab_search_core
+sidtab_init
+sidtab_set_initial
+sidtab_hash_stats
+sidtab_search_entry
+sidtab_search_entry_force
+sidtab_context_to_sid
+sidtab_convert
+sidtab_cancel_convert
+sidtab_destroy
+sidtab_sid2str_put
+sidtab_sid2str_get
+avtab_insert_node.isra.0
+avtab_destroy.part.0
+avtab_insertf
+avtab_insert_nonunique
+avtab_search
+avtab_search_node
+avtab_search_node_next
+avtab_destroy
+avtab_init
+avtab_alloc
+avtab_duplicate
+avtab_hash_eval
+avtab_read_item
+avtab_read
+avtab_write_item
+avtab_write
+perm_destroy
+common_destroy
+range_tr_destroy
+user_destroy
+role_destroy
+filenametr_hash
+rangetr_hash
+rangetr_cmp
+role_trans_hash
+role_trans_cmp
+common_index
+class_index
+role_index
+type_index
+user_index
+sens_index
+cat_index
+filenametr_cmp
+sens_destroy
+filenametr_destroy
+type_bounds_sanity_check
+constraint_expr_destroy.part.0
+cls_destroy
+string_to_av_perm.part.0
+role_tr_destroy
+type_destroy
+cat_destroy
+ocontext_destroy.part.0
+user_bounds_sanity_check
+role_bounds_sanity_check
+filename_write_helper_compat
+mls_write_level
+write_cons_helper
+mls_read_level
+mls_write_range_helper
+context_write.isra.0
+range_write_helper
+perm_write
+mls_read_range_helper
+cat_write
+sens_write
+common_write
+role_write
+role_trans_write_one
+type_write
+user_write
+filename_write_helper
+read_cons_helper
+class_write
+str_read
+cat_read
+sens_read
+type_read
+role_read
+perm_read.isra.0
+class_read
+common_read
+user_read
+policydb_index
+policydb_filenametr_search
+policydb_rangetr_search
+policydb_roletr_search
+policydb_destroy
+policydb_load_isids
+policydb_class_isvalid
+policydb_role_isvalid
+policydb_type_isvalid
+policydb_context_isvalid
+context_read_and_validate
+string_to_security_class
+string_to_av_perm
+policydb_read
+policydb_write
+get_classes_callback
+get_permissions_callback
+selinux_notify_policy_change
+aurule_avc_callback
+unmap_class.part.0
+dump_masked_av_helper
+selinux_policy_free.part.0
+constraint_expr_eval
+string_to_context_struct
+security_context_to_sid_core
+context_struct_to_string
+sidtab_entry_to_string
+security_sid_to_context_core
+security_compute_validatetrans.part.0
+convert_context
+security_compute_sid.part.0
+security_compute_sid
+security_dump_masked_av.constprop.0
+security_mls_enabled
+services_compute_xperms_drivers
+context_struct_compute_av
+type_attribute_bounds_av
+security_validate_transition_user
+security_validate_transition
+security_bounded_transition
+services_compute_xperms_decision
+security_compute_xperms_decision
+security_compute_av
+security_compute_av_user
+security_sidtab_hash_stats
+security_get_initial_sid_context
+security_sid_to_context
+security_sid_to_context_force
+security_sid_to_context_inval
+security_context_to_sid
+security_context_str_to_sid
+security_context_to_sid_default
+security_context_to_sid_force
+security_transition_sid
+security_transition_sid_user
+security_member_sid
+security_change_sid
+selinux_policy_cancel
+selinux_policy_commit
+security_port_sid
+security_ib_pkey_sid
+security_ib_endport_sid
+security_netif_sid
+security_node_sid
+security_get_user_sids
+security_genfs_sid
+selinux_policy_genfs_sid
+security_fs_use
+security_get_bools
+security_load_policy
+security_set_bools
+security_get_bool_value
+security_sid_mls_copy
+security_net_peersid_resolve
+security_get_classes
+security_get_permissions
+security_get_reject_unknown
+security_get_allow_unknown
+security_policycap_supported
+selinux_audit_rule_free
+selinux_audit_rule_init
+selinux_audit_rule_known
+selinux_audit_rule_match
+security_netlbl_secattr_to_sid
+security_netlbl_sid_to_secattr
+security_read_policy
+cond_bools_destroy
+cond_bools_index
+cond_list_destroy
+cond_insertf
+cond_bools_copy
+cond_write_av_list
+cond_read_av_list
+cond_dup_av_list
+evaluate_cond_nodes
+cond_policydb_init
+cond_policydb_destroy
+cond_init_bool_indexes
+cond_destroy_bool
+cond_index_bool
+cond_read_bool
+cond_read_list
+cond_write_bool
+cond_write_list
+cond_compute_xperms
+cond_compute_av
+cond_policydb_destroy_dup
+cond_policydb_dup
+mls_context_to_sid.part.0
+mls_compute_context_len
+mls_sid_to_context
+mls_level_isvalid
+mls_range_isvalid
+mls_context_isvalid
+mls_context_to_sid
+mls_from_string
+mls_range_set
+mls_setup_user_range
+mls_convert_context
+mls_compute_sid
+mls_export_netlbl_lvl
+mls_import_netlbl_lvl
+mls_export_netlbl_cat
+mls_import_netlbl_cat
+context_compute_hash
+selinux_xfrm_delete
+selinux_xfrm_alloc_user
+selinux_xfrm_free.part.0
+selinux_xfrm_skb_sid_ingress
+selinux_xfrm_policy_lookup
+selinux_xfrm_state_pol_flow_match
+selinux_xfrm_decode_session
+selinux_xfrm_skb_sid
+selinux_xfrm_policy_alloc
+selinux_xfrm_policy_clone
+selinux_xfrm_policy_free
+selinux_xfrm_policy_delete
+selinux_xfrm_state_alloc
+selinux_xfrm_state_alloc_acquire
+selinux_xfrm_state_free
+selinux_xfrm_state_delete
+selinux_xfrm_sock_rcv_skb
+selinux_xfrm_postroute_last
+selinux_netlbl_sidlookup_cached
+selinux_netlbl_sock_genattr
+selinux_netlbl_socket_connect_helper
+selinux_netlbl_cache_invalidate
+selinux_netlbl_err
+selinux_netlbl_sk_security_free
+selinux_netlbl_sk_security_reset
+selinux_netlbl_skbuff_getsid
+selinux_netlbl_skbuff_setsid
+selinux_netlbl_sctp_assoc_request
+selinux_netlbl_inet_conn_request
+selinux_netlbl_inet_csk_clone
+selinux_netlbl_sctp_sk_clone
+selinux_netlbl_socket_post_create
+selinux_netlbl_sock_rcv_skb
+selinux_netlbl_socket_setsockopt
+selinux_netlbl_socket_connect_locked
+selinux_netlbl_socket_connect
+sel_ib_pkey_sid
+sel_ib_pkey_flush
+smack_inode_copy_up_xattr
+smack_ismaclabel
+smack_inode_alloc_security
+smack_inode_getsecid
+smack_file_alloc_security
+smack_file_set_fowner
+smack_kernel_create_files_as
+smack_socket_socketpair
+smack_msg_msg_alloc_security
+smack_ipc_alloc_security
+smack_ipc_getsecid
+smack_sock_graft
+smack_key_alloc
+smack_key_free
+smack_audit_rule_known
+smack_dentry_create_files_as
+smack_task_to_inode
+smack_task_getsecid
+smack_cred_getsecid
+smack_inode_copy_up
+smack_inode_getsecctx
+smack_inode_setsecctx
+smack_secctx_to_secid
+smack_secid_to_secctx
+smack_inet_csk_clone
+smack_kernel_act_as
+smack_mmap_file
+smack_audit_rule_init
+smack_inode_post_setxattr
+smack_key_getsecurity
+smack_getprocattr
+smack_inode_getsecurity
+smack_inode_init_security
+smack_syslog
+smack_sk_free_security
+smack_free_mnt_opts
+smack_sb_free_security
+smack_socket_getpeersec_stream
+smack_ipv6host_label
+smack_setprocattr
+smack_cred_transfer
+smack_cred_alloc_blank
+smack_cred_free
+smack_set_mnt_opts
+smack_inode_listsecurity
+smack_audit_rule_match
+smack_add_opt
+smack_sb_eat_lsm_opts
+smack_fs_context_parse_param
+smack_from_netlbl
+smack_socket_getpeersec_dgram
+smack_cred_prepare
+smack_sb_alloc_security
+smk_fetch.part.0
+smack_d_instantiate
+smack_fs_context_dup
+smack_sk_alloc_security
+smack_netlbl_add
+smack_socket_post_create
+smack_inode_setsecurity
+smack_inode_notifysecctx
+smk_skb_to_addr_ipv6
+smack_sb_statfs
+smack_inode_getxattr
+smk_curacc_sem
+smack_sem_semop
+smack_sem_semctl
+smack_sem_associate
+smk_curacc_msq
+smack_msg_queue_msgrcv
+smack_msg_queue_msgsnd
+smack_msg_queue_msgctl
+smack_msg_queue_associate
+smk_curacc_shm
+smack_shm_shmat
+smack_shm_shmctl
+smack_shm_associate
+smack_socket_sock_rcv_skb
+smk_curacc_on_task
+smack_task_movememory
+smack_task_getscheduler
+smack_task_setscheduler
+smack_task_getioprio
+smack_task_setioprio
+smack_task_setnice
+smack_task_getsid
+smack_task_getpgid
+smack_task_setpgid
+smack_inode_getattr
+smack_file_open
+smack_unix_may_send
+smack_file_lock
+smk_ipv6_check.constprop.0
+smack_ipc_permission
+smack_inode_setattr
+smack_inode_rename
+smack_inode_link
+smack_post_notification
+smack_file_send_sigiotask
+smack_file_ioctl
+smack_inode_permission
+smack_file_receive
+smack_task_kill
+smack_inet_conn_request
+smack_inode_setxattr
+smack_watch_key
+smk_ipv4_check
+smack_socket_sendmsg
+smack_socket_connect
+smack_inode_unlink
+smack_inode_rmdir
+smack_unix_stream_connect
+smack_inode_removexattr
+smack_file_fcntl
+smk_ptrace_rule_check
+smack_bprm_creds_for_exec
+smack_ptrace_traceme
+smack_ptrace_access_check
+smack_key_permission
+smack_log_callback
+smk_access_entry
+smack_log
+smk_access
+smk_insert_entry
+smk_find_entry
+smk_parse_smack
+smk_netlbl_mls
+smack_populate_secattr
+smk_import_entry
+smack_from_secid
+smack_privileged_cred
+smack_privileged
+smk_tskacc
+smk_curacc
+smk_get_tree
+smk_fill_super
+smk_open_relabel_self
+smk_open_net6addr
+smk_open_cipso2
+smk_open_load_self2
+smk_open_load2
+smk_open_load_self
+smk_open_onlycap
+smk_open_net4addr
+smk_open_cipso
+smk_open_load
+smk_seq_stop
+smk_write_syslog
+smk_perm_from_str
+load2_seq_start
+cipso_seq_start
+net4addr_seq_start
+net6addr_seq_start
+onlycap_seq_start
+load2_seq_next
+cipso_seq_next
+net4addr_seq_next
+net6addr_seq_next
+onlycap_seq_next
+load_self_seq_start
+load_self2_seq_start
+load_self_seq_next
+load_self2_seq_next
+relabel_self_seq_start
+relabel_self_seq_next
+smk_init_fs_context
+relabel_self_seq_show
+onlycap_seq_show
+net6addr_seq_show
+net4addr_seq_show
+smk_write_logging
+smk_write_ptrace
+smk_write_mapped
+smk_write_direct
+smk_rule_show
+load_self2_seq_show
+load_self_seq_show
+load2_seq_show
+load_seq_show
+smk_fill_rule
+smk_parse_long_rule
+smk_set_access
+smk_write_revoke_subj
+cipso2_seq_show
+cipso_seq_show
+smk_cipso_doi
+smk_write_doi
+smk_unlbl_ambient
+smk_write_ambient
+smk_read_ptrace
+smk_read_syslog
+smk_read_mapped
+smk_read_logging
+smk_read_ambient
+smk_read_direct
+smk_read_doi
+smk_write_rules_list.isra.0
+smk_write_change_rule
+smk_write_load_self2
+smk_write_load2
+smk_write_load_self
+smk_write_load
+smk_set_cipso.isra.0
+smk_write_cipso2
+smk_write_cipso
+smk_user_access.isra.0
+smk_write_access2
+smk_write_access
+smk_parse_label_list
+smk_write_net4addr
+smk_write_net6addr
+smk_destroy_label_list
+smk_write_relabel_self
+smk_write_onlycap
+smack_nf_unregister
+smack_nf_register
+smack_ipv6_output
+smack_ipv4_output
+ipv4_skb_to_auditdata
+ipv6_skb_to_auditdata
+common_lsm_audit
+tomoyo_init_log
+tomoyo_write_log2
+tomoyo_write_log
+tomoyo_read_log
+tomoyo_poll_log
+tomoyo_write_domain2
+tomoyo_same_manager
+tomoyo_same_task_acl
+tomoyo_write_pid
+tomoyo_write_stat
+tomoyo_truncate
+tomoyo_write_task
+tomoyo_find_yesno
+tomoyo_addprintf
+tomoyo_flush
+tomoyo_write_domain
+tomoyo_write_exception
+tomoyo_parse_policy
+tomoyo_poll_query
+tomoyo_set_string
+tomoyo_io_printf
+tomoyo_print_config
+tomoyo_read_pid
+tomoyo_print_name_union
+tomoyo_print_number_union_nospace.part.0
+tomoyo_print_number_union_nospace
+tomoyo_write_manager
+tomoyo_read_manager
+tomoyo_print_namespace
+tomoyo_set_group
+tomoyo_print_entry
+tomoyo_read_domain2
+tomoyo_read_group
+tomoyo_read_exception
+tomoyo_read_profile
+tomoyo_read_version
+tomoyo_read_stat
+tomoyo_read_domain
+tomoyo_write_answer
+tomoyo_write_profile
+tomoyo_read_query
+tomoyo_yesno
+tomoyo_init_policy_namespace
+tomoyo_profile
+tomoyo_update_stat
+tomoyo_supervisor
+tomoyo_open_control
+tomoyo_poll_control
+tomoyo_read_control
+tomoyo_write_control
+tomoyo_close_control
+tomoyo_check_profile
+tomoyo_condition_type
+tomoyo_get_dqword
+tomoyo_get_condition
+tomoyo_get_attributes
+tomoyo_condition
+tomoyo_same_transition_control
+tomoyo_same_aggregator
+tomoyo_find_namespace
+tomoyo_update_policy
+tomoyo_update_domain
+tomoyo_check_acl
+tomoyo_write_transition_control
+tomoyo_write_aggregator
+tomoyo_assign_namespace
+tomoyo_assign_domain
+tomoyo_dump_page
+tomoyo_find_next_domain
+tomoyo_same_env_acl
+tomoyo_check_env_acl
+tomoyo_env_perm
+tomoyo_write_misc
+tomoyo_same_path_acl
+tomoyo_same_path2_acl
+tomoyo_same_mkdev_acl
+tomoyo_same_path_number_acl
+tomoyo_same_mount_acl
+tomoyo_merge_path_acl
+tomoyo_merge_mkdev_acl
+tomoyo_merge_path2_acl
+tomoyo_merge_path_number_acl
+tomoyo_path_permission
+tomoyo_add_slash
+tomoyo_put_name_union
+tomoyo_update_mkdev_acl
+tomoyo_update_mount_acl
+tomoyo_compare_name_union
+tomoyo_check_path_acl
+tomoyo_check_path2_acl
+tomoyo_put_number_union
+tomoyo_compare_number_union
+tomoyo_check_path_number_acl
+tomoyo_check_mkdev_acl
+tomoyo_execute_permission
+tomoyo_path_number_perm
+tomoyo_check_open_permission
+tomoyo_path_perm
+tomoyo_mkdev_perm
+tomoyo_path2_perm
+tomoyo_write_file
+tomoyo_del_acl
+tomoyo_del_condition
+tomoyo_try_to_gc
+tomoyo_collect_acl
+tomoyo_collect_member
+tomoyo_gc_thread
+tomoyo_notify_gc
+tomoyo_same_path_group
+tomoyo_same_number_group
+tomoyo_same_address_group
+tomoyo_write_group
+tomoyo_path_matches_group
+tomoyo_number_matches_group
+tomoyo_address_matches_group
+tomoyo_load_policy
+tomoyo_warn_oom
+tomoyo_memory_ok
+tomoyo_commit_ok
+tomoyo_get_name
+tomoyo_get_group
+tomoyo_check_mount_acl
+tomoyo_mount_acl
+tomoyo_mount_permission
+tomoyo_same_unix_acl
+tomoyo_merge_inet_acl
+tomoyo_merge_unix_acl
+tomoyo_print_ipv6
+tomoyo_check_unix_acl
+tomoyo_same_inet_acl
+tomoyo_audit_inet_log
+tomoyo_check_inet_acl
+tomoyo_unix_entry
+tomoyo_check_inet_address
+tomoyo_parse_ipaddr_union
+tomoyo_print_ip
+tomoyo_write_inet_network
+tomoyo_write_unix_network
+tomoyo_socket_listen_permission
+tomoyo_socket_connect_permission
+tomoyo_socket_bind_permission
+tomoyo_socket_sendmsg_permission
+tomoyo_get_local_path
+tomoyo_encode2.part.0
+tomoyo_encode2
+tomoyo_encode
+tomoyo_realpath_from_path
+tomoyo_realpath_nofollow
+tomoyo_check_task_acl
+tomoyo_read_self
+tomoyo_release
+tomoyo_open
+tomoyo_poll
+tomoyo_write
+tomoyo_read
+tomoyo_write_self
+tomoyo_socket_sendmsg
+tomoyo_socket_listen
+tomoyo_socket_connect
+tomoyo_socket_bind
+tomoyo_sb_pivotroot
+tomoyo_path_chroot
+tomoyo_inode_getattr
+tomoyo_path_truncate
+tomoyo_sb_mount
+tomoyo_path_chmod
+tomoyo_file_ioctl
+tomoyo_path_chown
+tomoyo_cred_prepare
+tomoyo_bprm_committed_creds
+tomoyo_task_alloc
+tomoyo_task_free
+tomoyo_path_rename
+tomoyo_path_link
+tomoyo_sb_umount
+tomoyo_path_symlink
+tomoyo_path_rmdir
+tomoyo_path_unlink
+tomoyo_path_mkdir
+tomoyo_path_mknod
+tomoyo_bprm_creds_for_exec
+tomoyo_bprm_check_security
+tomoyo_domain
+tomoyo_file_open
+tomoyo_file_fcntl
+tomoyo_file_matches_pattern2
+tomoyo_file_matches_pattern
+tomoyo_path_matches_pattern2
+tomoyo_correct_word2.part.0
+tomoyo_correct_path2
+tomoyo_domain_def.part.0
+tomoyo_convert_time
+tomoyo_permstr
+tomoyo_read_token
+tomoyo_parse_ulong
+tomoyo_print_ulong
+tomoyo_parse_number_union
+tomoyo_str_starts
+tomoyo_normalize_line
+tomoyo_correct_word
+tomoyo_parse_name_union
+tomoyo_correct_path
+tomoyo_correct_domain
+tomoyo_get_domainname
+tomoyo_domain_def
+tomoyo_fill_path_info
+tomoyo_find_domain
+tomoyo_path_matches_pattern
+tomoyo_get_exe
+tomoyo_get_mode
+tomoyo_init_request_info
+tomoyo_domain_quota_is_ok
+profiles_release
+profiles_open
+apparmorfs_init_fs_context
+seq_show_profile
+ns_revision_poll
+seq_ns_name_open
+seq_ns_level_open
+seq_ns_nsstacked_open
+seq_ns_stacked_open
+aa_sfs_seq_open
+seq_rawdata_compressed_size_show
+seq_rawdata_revision_show
+seq_rawdata_abi_show
+aafs_show_path
+profile_query_cb
+rawdata_read
+aafs_remove
+remove_rawdata_dents
+seq_rawdata_hash_show
+apparmorfs_get_tree
+apparmorfs_fill_super
+rawdata_link_cb
+aafs_free_inode
+mangle_name
+ns_revision_read
+policy_readlink
+aa_sfs_seq_show
+__next_ns
+next_profile
+p_next
+aa_simple_write_to_buffer.part.0
+__aafs_setup_d_inode.constprop.0
+aafs_create.constprop.0
+multi_transaction_release
+rawdata_f_data_free
+rawdata_release
+rawdata_open
+seq_profile_name_show
+seq_profile_mode_show
+seq_profile_release
+seq_rawdata_release
+seq_profile_attach_show
+seq_profile_hash_show
+p_stop
+ns_revision_release
+seq_profile_open
+seq_profile_hash_open
+seq_profile_attach_open
+seq_profile_mode_open
+seq_profile_name_open
+policy_get_link
+p_start
+seq_rawdata_open
+seq_rawdata_compressed_size_open
+seq_rawdata_hash_open
+seq_rawdata_revision_open
+seq_rawdata_abi_open
+seq_ns_stacked_show
+ns_rmdir_op
+seq_ns_level_show
+seq_ns_name_show
+seq_ns_nsstacked_show
+policy_update
+profile_replace
+profile_load
+ns_mkdir_op
+create_profile_file
+profile_remove
+query_label.constprop.0
+ns_revision_open
+rawdata_get_link_base
+rawdata_get_link_data
+rawdata_get_link_abi
+rawdata_get_link_sha1
+aa_write_access
+multi_transaction_read
+__aa_bump_ns_revision
+__aa_fs_remove_rawdata
+__aa_fs_create_rawdata
+__aafs_profile_rmdir
+__aafs_profile_migrate_dents
+__aafs_profile_mkdir
+__aafs_ns_rmdir
+__aafs_ns_mkdir
+audit_pre
+aa_audit_msg
+aa_audit
+aa_audit_rule_free
+aa_audit_rule_init
+aa_audit_rule_known
+aa_audit_rule_match
+audit_cb
+aa_capable
+aa_get_task_label
+aa_replace_current_label
+aa_set_current_onexec
+aa_set_current_hat
+aa_restore_previous_label
+audit_ptrace_cb
+audit_signal_cb
+profile_ptrace_perm
+profile_signal_perm.part.0
+aa_may_ptrace
+aa_may_signal
+aa_split_fqname
+skipn_spaces
+aa_splitn_fqname
+aa_info_message
+aa_str_alloc
+aa_str_kref
+aa_perm_mask_to_str
+aa_audit_perm_names
+aa_audit_perm_mask
+aa_audit_perms_cb
+aa_apply_modes_to_perms
+aa_compute_perms
+aa_perms_accum_raw
+aa_perms_accum
+aa_profile_match_label
+aa_check_perms
+aa_profile_label_perm
+aa_policy_init
+aa_policy_destroy
+dfa_free.part.0
+aa_dfa_free_kref
+aa_teardown_dfa_engine
+aa_dfa_unpack
+aa_setup_dfa_engine
+aa_dfa_match_len
+aa_dfa_match
+aa_dfa_next
+aa_dfa_outofband_transition
+aa_dfa_match_until
+aa_dfa_matchn_until
+aa_dfa_leftmatch
+prepend
+disconnect
+aa_path_name
+label_match.constprop.0
+profile_onexec
+may_change_ptraced_domain
+find_attach
+build_change_hat
+change_hat.isra.0
+aa_free_domain_entries
+x_table_lookup
+profile_transition
+handle_onexec
+apparmor_bprm_creds_for_exec
+aa_change_hat
+aa_change_profile
+aa_free_data
+audit_policy
+audit_cb
+__lookupn_profile
+__lookup_profile
+__find_child
+__add_profile
+__replace_profile
+__aa_profile_list_release
+__remove_profile
+aa_free_profile
+aa_alloc_profile
+aa_find_child
+aa_lookupn_profile
+aa_lookup_profile
+aa_fqlookupn_profile
+aa_new_null_profile
+policy_view_capable
+policy_admin_capable
+aa_may_manage_policy
+aa_replace_profiles
+aa_remove_profiles
+unpack_nameX
+unpack_u32
+unpack_str
+unpack_blob
+datacmp
+audit_cb
+unpack_dfa
+deflate_compress
+unpack_strdup.constprop.0
+unpack_array.constprop.0
+unpack_u8.constprop.0
+audit_iface.constprop.0
+do_loaddata_free
+strhash
+unpack_profile
+__aa_loaddata_update
+aa_rawdata_eq
+aa_loaddata_kref
+aa_loaddata_alloc
+aa_load_ent_free
+aa_load_ent_alloc
+aa_unpack
+aa_getprocattr
+aa_setprocattr_changehat
+apparmor_socket_getpeersec_dgram
+param_get_mode
+param_get_audit
+param_set_mode
+param_set_audit
+param_get_aabool
+param_get_aalockpolicy
+param_set_aabool
+param_set_aalockpolicy
+param_get_aacompressionlevel
+param_get_aauint
+apparmor_cred_alloc_blank
+param_get_aaintbool
+apparmor_nf_unregister
+apparmor_inet_conn_request
+apparmor_socket_sock_rcv_skb
+apparmor_nf_register
+apparmor_bprm_committing_creds
+apparmor_socket_shutdown
+apparmor_socket_getpeername
+apparmor_socket_getsockname
+apparmor_socket_setsockopt
+apparmor_socket_getsockopt
+apparmor_socket_recvmsg
+apparmor_socket_sendmsg
+apparmor_socket_accept
+apparmor_socket_listen
+apparmor_socket_connect
+apparmor_socket_bind
+apparmor_dointvec
+param_set_aaintbool
+param_set_aacompressionlevel
+param_set_aauint
+apparmor_ip_postroute.isra.0
+apparmor_ipv4_postroute
+apparmor_sk_alloc_security
+apparmor_ipv6_postroute
+apparmor_task_alloc
+apparmor_sock_graft
+aa_put_buffer.part.0
+apparmor_cred_prepare
+apparmor_cred_transfer
+apparmor_bprm_committed_creds
+apparmor_task_getsecid
+apparmor_cred_free
+apparmor_sk_free_security
+apparmor_task_free
+apparmor_capable
+apparmor_file_free_security
+apparmor_sk_clone_security
+apparmor_sb_umount
+apparmor_task_setrlimit
+common_file_perm
+apparmor_file_lock
+common_mmap.part.0
+apparmor_file_mprotect
+apparmor_mmap_file
+apparmor_file_permission
+apparmor_file_receive
+common_perm
+common_perm_cond
+apparmor_inode_getattr
+apparmor_path_truncate
+apparmor_path_chown
+apparmor_path_chmod
+common_perm_create.constprop.0
+apparmor_path_symlink
+apparmor_path_mkdir
+apparmor_path_mknod
+common_perm_rm.constprop.0
+apparmor_path_unlink
+apparmor_path_rmdir
+apparmor_capget
+apparmor_ptrace_traceme
+apparmor_ptrace_access_check
+apparmor_sb_mount
+apparmor_socket_getpeersec_stream
+apparmor_sb_pivotroot
+apparmor_file_alloc_security
+apparmor_file_open
+apparmor_socket_create
+apparmor_task_kill
+apparmor_getprocattr
+apparmor_path_link
+apparmor_path_rename
+apparmor_socket_post_create
+apparmor_setprocattr
+aa_get_buffer
+aa_put_buffer
+audit_resource
+audit_cb
+aa_map_resource
+aa_task_setrlimit
+__aa_transition_rlimits
+aa_secid_update
+aa_secid_to_label
+apparmor_secid_to_secctx
+apparmor_secctx_to_secid
+apparmor_release_secctx
+aa_alloc_secid
+aa_free_secid
+aa_secids_init
+map_old_perms
+file_audit_cb
+update_file_ctx
+aa_audit_file
+path_name
+aa_compute_fperms
+aa_str_perms
+profile_path_link
+__aa_path_perm.part.0
+profile_path_perm
+__aa_path_perm
+aa_path_perm
+aa_path_link
+aa_file_perm
+match_file
+aa_inherit_files
+aa_free_ns.part.0
+alloc_ns
+__aa_create_ns
+aa_ns_visible
+aa_ns_name
+aa_free_ns
+aa_findn_ns
+aa_find_ns
+__aa_lookupn_ns
+aa_lookupn_ns
+__aa_find_or_create_ns
+aa_prepare_ns
+__aa_remove_ns
+destroy_ns.part.0
+label_modename
+fqlookupn_profile
+profile_cmp
+sort_cmp
+vec_cmp
+__vec_find
+vec_find
+aa_alloc_proxy
+aa_label_kref
+aa_proxy_kref
+aa_label_destroy
+label_free_switch
+aa_label_free
+__aa_proxy_redirect
+__label_remove
+__proxy_share
+__label_insert
+label_free_or_put_new
+aa_vec_unique
+aa_label_init
+aa_label_alloc
+aa_label_next_confined
+__aa_label_next_not_in_set
+aa_label_is_subset
+aa_label_is_unconfined_subset
+aa_label_remove
+label_free_rcu
+aa_label_replace
+aa_vec_find_or_create_label
+aa_label_find
+aa_label_insert
+aa_label_next_in_merge
+aa_label_find_merge
+aa_label_merge
+aa_label_match
+aa_label_snxprint
+aa_label_asxprint
+aa_label_acntsxprint
+aa_update_label_name
+aa_label_xaudit
+aa_label_seq_xprint
+aa_label_xprintk
+aa_label_audit
+aa_label_seq_print
+aa_label_printk
+aa_label_strn_parse
+aa_label_parse
+aa_labelset_destroy
+aa_labelset_init
+__aa_labelset_update_subtree
+compute_mnt_perms
+audit_cb
+audit_mount.constprop.0
+match_mnt_path_str
+match_mnt
+build_pivotroot
+aa_remount
+aa_bind_mount
+aa_mount_change_type
+aa_move_mount
+aa_new_mount
+aa_umount
+aa_pivotroot
+audit_net_cb
+aa_profile_af_perm
+aa_label_sk_perm.part.0
+aa_af_perm
+aa_sk_perm
+aa_sock_file_perm
+apparmor_secmark_check
+aa_hash_size
+aa_calc_hash
+aa_calc_profile_hash
+yama_dointvec_minmax
+task_is_descendant.part.0
+yama_ptracer_del
+yama_task_free
+yama_relation_cleanup
+yama_ptracer_add
+yama_task_prctl
+__report_access
+report_access
+yama_ptrace_traceme
+yama_ptrace_access_check
+_setid_policy_lookup
+setid_policy_lookup
+safesetid_security_capable
+id_permitted_for_cred
+safesetid_task_fix_setgid
+safesetid_task_fix_setuid
+__release_ruleset
+insert_rule
+handle_policy_update
+safesetid_gid_file_write
+safesetid_uid_file_write
+safesetid_file_read.isra.0
+safesetid_gid_file_read
+safesetid_uid_file_read
+lockdown_write
+lockdown_read
+lockdown_is_locked_down
+match_exception
+match_exception_partial
+verify_new_ex
+set_access
+devcgroup_offline
+dev_exception_add
+__dev_exception_clean
+devcgroup_css_free
+dev_exception_rm
+devcgroup_check_permission
+set_majmin
+devcgroup_seq_show
+dev_exceptions_copy
+devcgroup_online
+devcgroup_access_write
+devcgroup_css_alloc
+init_once
+integrity_iint_find
+integrity_inode_get
+integrity_inode_free
+integrity_kernel_read
+integrity_audit_message
+integrity_audit_msg
+integrity_keyring_from_id.part.0
+integrity_digsig_verify
+integrity_modsig_verify
+asymmetric_verify
+integrity_kernel_module_request
+ima_measurements_stop
+ima_open_policy
+ima_release_policy
+ima_write_policy
+ima_show_htable_violations
+ima_ascii_measurements_open
+ima_measurements_open
+ima_ascii_measurements_show
+ima_measurements_next
+ima_measurements_start
+ima_measurements_show
+ima_show_measurements_count
+ima_putc
+ima_print_digest
+ima_add_digest_entry
+ima_get_binary_runtime_size
+ima_add_template_entry
+ima_restore_measurement_entry
+ima_file_hash
+process_measurement
+ima_file_check
+ima_file_free
+ima_file_mmap
+ima_file_mprotect
+ima_bprm_check
+ima_post_create_tmpfile
+ima_post_path_mknod
+ima_read_file
+ima_post_read_file
+ima_load_data
+ima_post_load_data
+process_buffer_measurement
+ima_kexec_cmdline
+ima_alloc_atfm
+ima_alloc_tfm
+calc_buffer_shash_tfm
+ima_calc_field_array_hash_tfm
+ima_pcrread
+ima_calc_boot_aggregate_tfm
+ima_free_tfm.part.0
+ima_calc_file_hash_tfm
+param_set_bufsize
+ima_alloc_pages
+ima_calc_file_hash_atfm
+ima_calc_file_hash
+ima_calc_field_array_hash
+ima_calc_buffer_hash
+ima_calc_boot_aggregate
+ima_free_template_entry
+ima_alloc_init_template
+ima_store_template
+ima_add_violation
+ima_get_action
+ima_collect_measurement
+ima_store_measurement
+ima_audit_measurement
+ima_d_path
+ima_lsm_free_rule
+ima_log_string_op
+ima_lsm_rule_init
+ima_free_rule.part.0
+ima_lsm_policy_change
+ima_match_policy
+ima_update_policy_flag
+ima_check_policy
+ima_update_policy
+ima_parse_add_rule
+ima_delete_rules
+ima_appraise_signature
+template_desc_init_fields.part.0
+ima_template_has_modsig
+lookup_template_desc
+template_desc_init_fields
+ima_init_template_list
+ima_template_desc_current
+ima_restore_measurement_list
+ima_show_template_field_data
+ima_write_template_field_data
+ima_eventdigest_init_common
+ima_eventname_init_common
+ima_show_template_digest
+ima_show_template_digest_ng
+ima_show_template_string
+ima_show_template_sig
+ima_show_template_buf
+ima_parse_buf
+ima_eventdigest_init
+ima_eventdigest_ng_init
+ima_eventdigest_modsig_init
+ima_eventname_init
+ima_eventname_ng_init
+ima_eventsig_init
+ima_eventbuf_init
+ima_eventmodsig_init
+ima_fix_xattr
+ima_reset_appraise_flags
+ima_must_appraise.part.0
+is_ima_appraise_enabled
+ima_must_appraise
+ima_get_cache_status
+ima_get_hash_algo
+ima_read_xattr
+ima_check_blacklist
+ima_appraise_measurement
+ima_update_xattr
+ima_inode_post_setattr
+ima_inode_setxattr
+ima_inode_removexattr
+ima_read_modsig
+ima_collect_modsig
+ima_modsig_verify
+ima_get_modsig_digest
+ima_get_raw_modsig
+ima_free_modsig
+ima_post_key_create_or_update
+ima_free_key_entry.part.0
+ima_init_key_queue
+ima_queue_key
+ima_process_queued_keys
+ima_keys_handler
+evm_protected_xattr
+evm_verify_hmac
+evm_verifyxattr
+evm_verify_current_integrity
+evm_protect_xattr.isra.0
+evm_inode_init_security
+evm_inode_setxattr
+evm_inode_removexattr
+evm_inode_post_setxattr
+evm_inode_post_removexattr
+evm_inode_setattr
+evm_inode_post_setattr
+hmac_add_misc
+init_desc
+evm_calc_hmac_or_hash
+evm_set_key
+evm_calc_hmac
+evm_calc_hash
+evm_update_evmxattr
+evm_init_hmac
+evm_init_key
+evm_write_key
+evm_write_xattrs
+evm_read_key
+evm_read_xattrs
+posix_xattr_acl
+crypto_shoot_alg
+crypto_req_done
+crypto_probing_notify
+crypto_create_tfm_node
+__crypto_alloc_tfm
+crypto_mod_get
+crypto_larval_alloc
+crypto_mod_put
+crypto_larval_kill
+__crypto_alg_lookup
+crypto_alg_lookup
+crypto_larval_wait
+crypto_destroy_tfm
+crypto_larval_destroy
+crypto_alg_mod_lookup
+crypto_find_alg
+crypto_has_alg
+crypto_alloc_base
+crypto_alloc_tfm_node
+crypto_cipher_decrypt_one
+crypto_cipher_setkey
+crypto_cipher_encrypt_one
+crypto_comp_compress
+crypto_comp_decompress
+__crypto_memneq
+crypto_check_alg
+crypto_get_attr_type
+crypto_attr_u32
+crypto_init_queue
+crypto_enqueue_request_head
+__crypto_xor
+crypto_alg_extsize
+crypto_check_attr_type
+crypto_enqueue_request
+crypto_dequeue_request
+crypto_destroy_instance
+crypto_register_template
+__crypto_lookup_template
+crypto_grab_spawn
+crypto_type_has_alg
+crypto_register_notifier
+crypto_unregister_notifier
+crypto_inst_setname
+crypto_inc
+crypto_stats_init
+__crypto_register_alg
+crypto_drop_spawn
+crypto_attr_alg_name
+crypto_remove_instance
+crypto_lookup_template
+crypto_remove_spawns
+crypto_spawn_alg
+crypto_spawn_tfm
+crypto_spawn_tfm2
+crypto_stats_get
+crypto_remove_final
+crypto_unregister_template
+crypto_register_templates
+crypto_unregister_templates
+crypto_unregister_alg
+crypto_unregister_algs
+crypto_alg_tested
+crypto_wait_for_test
+crypto_register_alg
+crypto_register_algs
+crypto_register_instance
+crypto_unregister_instance
+crypto_stats_kpp_compute_shared_secret
+crypto_stats_kpp_set_secret
+crypto_stats_kpp_generate_public_key
+crypto_stats_ahash_update
+crypto_stats_akcipher_sign
+crypto_stats_rng_seed
+crypto_stats_akcipher_verify
+crypto_stats_skcipher_decrypt
+crypto_stats_compress
+crypto_stats_skcipher_encrypt
+crypto_stats_ahash_final
+crypto_stats_akcipher_encrypt
+crypto_stats_aead_decrypt
+crypto_stats_akcipher_decrypt
+crypto_stats_aead_encrypt
+crypto_stats_decompress
+crypto_stats_rng_generate
+scatterwalk_ffwd
+scatterwalk_copychunks
+scatterwalk_map_and_copy
+c_next
+c_stop
+c_show
+c_start
+crypto_aead_setauthsize
+crypto_aead_exit_tfm
+crypto_aead_init_tfm
+crypto_aead_free_instance
+crypto_aead_setkey
+crypto_aead_encrypt
+crypto_aead_decrypt
+crypto_grab_aead
+crypto_aead_report
+crypto_aead_show
+crypto_alloc_aead
+crypto_register_aead
+crypto_unregister_aead
+crypto_register_aeads
+crypto_unregister_aeads
+aead_register_instance
+aead_geniv_free
+aead_geniv_setauthsize
+aead_geniv_setkey
+aead_exit_geniv
+aead_init_geniv
+aead_geniv_alloc
+skcipher_walk_atomise
+crypto_skcipher_exit_tfm
+crypto_skcipher_init_tfm
+crypto_skcipher_free_instance
+skcipher_prepare_alg
+skcipher_walk_complete
+crypto_skcipher_encrypt
+crypto_skcipher_decrypt
+crypto_grab_skcipher
+crypto_skcipher_report
+crypto_skcipher_show
+crypto_alloc_skcipher
+crypto_alloc_sync_skcipher
+skcipher_exit_tfm_simple
+crypto_has_skcipher
+crypto_register_skcipher
+crypto_unregister_skcipher
+crypto_register_skciphers
+crypto_unregister_skciphers
+skcipher_register_instance
+skcipher_init_tfm_simple
+skcipher_setkey_simple
+skcipher_free_instance_simple
+skcipher_alloc_instance_simple
+skcipher_walk_done
+skcipher_walk_next
+crypto_skcipher_setkey
+skcipher_walk_first
+skcipher_walk_skcipher
+skcipher_walk_virt
+skcipher_walk_async
+skcipher_walk_aead_common
+skcipher_walk_aead_encrypt
+skcipher_walk_aead_decrypt
+seqiv_aead_decrypt
+seqiv_aead_create
+seqiv_aead_encrypt_complete2
+seqiv_aead_encrypt_complete
+seqiv_aead_encrypt
+ahash_nosetkey
+hash_walk_next
+hash_walk_new_entry
+crypto_ahash_exit_tfm
+crypto_ahash_free_instance
+crypto_hash_alg_has_setkey
+crypto_hash_walk_done
+crypto_ahash_setkey
+ahash_restore_req
+ahash_op_unaligned_done
+ahash_def_finup_finish1
+ahash_def_finup_done1
+ahash_def_finup_done2
+crypto_grab_ahash
+crypto_ahash_report
+crypto_ahash_show
+crypto_ahash_init_tfm
+crypto_ahash_extsize
+crypto_alloc_ahash
+crypto_has_ahash
+crypto_register_ahash
+crypto_unregister_ahash
+crypto_register_ahashes
+crypto_unregister_ahashes
+ahash_register_instance
+crypto_hash_walk_first
+ahash_save_req
+crypto_ahash_op
+crypto_ahash_final
+crypto_ahash_finup
+crypto_ahash_digest
+ahash_def_finup
+shash_no_setkey
+shash_async_export
+shash_async_init
+shash_async_import
+crypto_shash_exit_tfm
+crypto_shash_free_instance
+shash_prepare_alg
+crypto_shash_init_tfm
+shash_default_export
+shash_default_import
+crypto_shash_setkey
+shash_async_setkey
+shash_update_unaligned
+crypto_shash_update
+shash_final_unaligned
+crypto_shash_final
+shash_finup_unaligned
+crypto_shash_finup
+shash_digest_unaligned
+crypto_shash_digest
+crypto_shash_tfm_digest
+shash_async_final
+shash_ahash_update
+shash_async_update
+crypto_exit_shash_ops_async
+crypto_shash_report
+crypto_shash_show
+crypto_grab_shash
+crypto_alloc_shash
+crypto_register_shash
+crypto_unregister_shash
+crypto_register_shashes
+crypto_unregister_shashes
+shash_register_instance
+shash_free_singlespawn_instance
+shash_ahash_finup
+shash_ahash_digest
+shash_async_digest
+shash_async_finup
+crypto_init_shash_ops_async
+akcipher_default_op
+crypto_akcipher_exit_tfm
+crypto_akcipher_init_tfm
+crypto_akcipher_free_instance
+crypto_grab_akcipher
+crypto_akcipher_report
+crypto_akcipher_show
+crypto_alloc_akcipher
+crypto_register_akcipher
+crypto_unregister_akcipher
+akcipher_register_instance
+crypto_kpp_exit_tfm
+crypto_kpp_init_tfm
+crypto_kpp_report
+crypto_kpp_show
+crypto_alloc_kpp
+crypto_register_kpp
+crypto_unregister_kpp
+dh_init
+dh_max_size
+dh_clear_ctx
+dh_exit_tfm
+dh_compute_value
+dh_set_secret
+dh_exit
+crypto_dh_key_len
+crypto_dh_decode_key
+crypto_dh_encode_key
+rsa_exit
+rsa_max_size
+rsa_free_mpi_key
+rsa_exit_tfm
+rsa_set_priv_key
+rsa_set_pub_key
+rsa_dec
+rsa_enc
+rsa_init
+rsa_parse_pub_key
+rsa_parse_priv_key
+rsa_get_n
+rsa_get_e
+rsa_get_d
+rsa_get_p
+rsa_get_q
+rsa_get_dp
+rsa_get_dq
+rsa_get_qinv
+pkcs1pad_set_pub_key
+pkcs1pad_set_priv_key
+pkcs1pad_get_max_size
+pkcs1pad_verify_complete
+pkcs1pad_verify_complete_cb
+pkcs1pad_decrypt_complete
+pkcs1pad_decrypt_complete_cb
+pkcs1pad_exit_tfm
+pkcs1pad_init_tfm
+pkcs1pad_free
+pkcs1pad_encrypt_sign_complete
+pkcs1pad_encrypt_sign_complete_cb
+pkcs1pad_create
+pkcs1pad_sg_set_buf
+pkcs1pad_decrypt
+pkcs1pad_encrypt
+pkcs1pad_sign
+pkcs1pad_verify
+crypto_acomp_exit_tfm
+crypto_acomp_report
+crypto_acomp_show
+crypto_acomp_init_tfm
+crypto_acomp_extsize
+crypto_alloc_acomp
+crypto_alloc_acomp_node
+acomp_request_free
+crypto_register_acomp
+crypto_unregister_acomp
+crypto_register_acomps
+crypto_unregister_acomps
+acomp_request_alloc
+scomp_acomp_comp_decomp
+scomp_acomp_decompress
+scomp_acomp_compress
+crypto_scomp_free_scratches
+crypto_exit_scomp_ops_async
+crypto_scomp_report
+crypto_scomp_show
+crypto_scomp_init_tfm
+crypto_register_scomp
+crypto_unregister_scomp
+crypto_register_scomps
+crypto_unregister_scomps
+crypto_init_scomp_ops_async
+crypto_acomp_scomp_alloc_ctx
+crypto_acomp_scomp_free_ctx
+cryptomgr_test
+cryptomgr_probe
+cryptomgr_notify
+alg_test
+hmac_update
+hmac_export
+hmac_import
+hmac_init
+hmac_exit_tfm
+hmac_init_tfm
+hmac_setkey
+hmac_finup
+hmac_final
+hmac_create
+null_init
+null_update
+null_final
+null_digest
+crypto_get_default_null_skcipher
+crypto_put_default_null_skcipher
+null_crypt
+null_skcipher_crypt
+null_compress
+null_skcipher_setkey
+null_setkey
+null_hash_setkey
+md5_transform
+md5_init
+md5_export
+md5_import
+md5_update
+md5_final
+sha1_generic_block_fn
+sha1_final
+crypto_sha1_finup
+crypto_sha1_update
+crypto_sha256_update
+crypto_sha256_init
+crypto_sha224_init
+crypto_sha256_final
+crypto_sha256_finup
+sha512_transform
+sha512_generic_block_fn
+sha512_final
+crypto_sha512_finup
+crypto_sha512_update
+gf128mul_x8_ble
+gf128mul_64k_bbe
+gf128mul_4k_lle
+gf128mul_4k_bbe
+gf128mul_lle
+gf128mul_bbe
+gf128mul_free_64k
+gf128mul_init_4k_lle
+gf128mul_init_64k_bbe
+gf128mul_init_4k_bbe
+crypto_ecb_crypt
+crypto_ecb_decrypt
+crypto_ecb_encrypt
+crypto_ecb_create
+crypto_cbc_create
+crypto_cbc_encrypt
+crypto_cbc_decrypt
+cts_cbc_crypt_done
+crypto_cts_setkey
+crypto_cts_exit_tfm
+crypto_cts_init_tfm
+crypto_cts_free
+crypto_cts_create
+cts_cbc_encrypt
+crypto_cts_encrypt_done
+crypto_cts_encrypt
+cts_cbc_decrypt
+crypto_cts_decrypt
+crypto_cts_decrypt_done
+xts_xor_tweak
+xts_cts_final
+xts_decrypt_done
+xts_encrypt_done
+xts_cts_done
+xts_setkey
+xts_exit_tfm
+xts_init_tfm
+xts_free_instance
+xts_decrypt
+xts_create
+xts_encrypt
+crypto_rfc3686_exit_tfm
+crypto_rfc3686_init_tfm
+crypto_rfc3686_crypt
+crypto_rfc3686_setkey
+crypto_rfc3686_free
+crypto_ctr_create
+crypto_rfc3686_create
+crypto_ctr_crypt
+crypto_gcm_setauthsize
+gcm_hash_len_done
+crypto_rfc4543_copy_src_to_dst
+crypto_rfc4543_crypt
+crypto_rfc4543_decrypt
+crypto_rfc4543_encrypt
+crypto_rfc4543_setauthsize
+crypto_rfc4106_setauthsize
+crypto_rfc4543_setkey
+crypto_rfc4106_setkey
+crypto_rfc4543_exit_tfm
+crypto_rfc4106_exit_tfm
+crypto_gcm_exit_tfm
+crypto_rfc4543_init_tfm
+crypto_rfc4106_init_tfm
+crypto_gcm_init_tfm
+crypto_rfc4106_free
+crypto_rfc4543_free
+crypto_gcm_free
+gcm_hash_update
+gcm_hash_crypt_remain_continue
+gcm_hash_crypt_continue
+gcm_hash_crypt_done
+gcm_hash_assoc_remain_continue
+gcm_hash_assoc_continue
+gcm_hash_assoc_done
+gcm_hash_init_continue
+gcm_hash
+gcm_encrypt_continue
+gcm_encrypt_done
+gcm_hash_init_done
+gcm_hash_assoc_remain_done
+gcm_hash_crypt_remain_done
+crypto_gcm_verify
+gcm_dec_hash_continue
+gcm_decrypt_done
+gcm_enc_copy_hash
+crypto_rfc4543_create
+crypto_rfc4106_create
+crypto_gcm_create_common
+crypto_gcm_create
+crypto_gcm_base_create
+crypto_rfc4106_crypt
+crypto_rfc4106_decrypt
+crypto_rfc4106_encrypt
+crypto_gcm_init_common
+crypto_gcm_decrypt
+crypto_gcm_encrypt
+crypto_gcm_setkey
+crypto_aes_set_key
+crypto_aes_decrypt
+crypto_aes_encrypt
+deflate_comp_init
+deflate_decomp_init
+__deflate_decompress
+deflate_sdecompress
+deflate_decompress
+deflate_scompress
+__deflate_exit
+deflate_free_ctx
+deflate_exit
+gen_deflate_alloc_ctx.isra.0
+zlib_deflate_alloc_ctx
+deflate_alloc_ctx
+deflate_compress
+deflate_init
+chksum_init
+chksum_setkey
+chksum_final
+crc32c_cra_init
+chksum_finup
+chksum_digest
+chksum_update
+crc_t10dif_generic
+chksum_init
+chksum_final
+chksum_digest
+chksum_finup
+chksum_update
+lzo_free_ctx
+lzo_alloc_ctx
+lzo_sdecompress
+lzo_decompress
+lzo_scompress
+lzo_compress
+lzo_exit
+lzo_init
+lzorle_free_ctx
+lzorle_alloc_ctx
+lzorle_sdecompress
+lzorle_decompress
+lzorle_scompress
+lzorle_compress
+lzorle_exit
+lzorle_init
+crypto_rng_init_tfm
+crypto_rng_report
+crypto_rng_show
+crypto_alloc_rng
+crypto_put_default_rng
+crypto_del_default_rng
+crypto_register_rng
+crypto_unregister_rng
+crypto_register_rngs
+crypto_unregister_rngs
+crypto_rng_reset
+crypto_get_default_rng
+drbg_kcapi_set_entropy
+drbg_fini_sym_kernel
+drbg_fini_hash_kernel
+drbg_kcapi_symsetkey
+drbg_kcapi_hash
+drbg_kcapi_hmacsetkey
+drbg_hmac_update
+drbg_schedule_async_seed
+drbg_kcapi_init
+drbg_hash_hashgen
+drbg_hash_df
+drbg_hash_update
+drbg_hmac_generate
+drbg_kcapi_sym
+drbg_ctr_df
+drbg_seed
+drbg_kcapi_random
+drbg_uninstantiate
+drbg_kcapi_cleanup
+drbg_kcapi_sym_ctr
+drbg_ctr_update
+drbg_ctr_generate
+drbg_async_seed
+drbg_hash_process_addtl
+drbg_hash_generate
+drbg_init_hash_kernel
+drbg_init_sym_kernel
+drbg_kcapi_seed
+jent_apt_reset
+jent_apt_insert
+jent_rct_insert
+jent_rct_failure
+jent_stuck
+jent_health_failure
+jent_loop_shuffle
+jent_lfsr_time
+jent_memaccess
+jent_measure_jitter
+jent_gen_entropy
+jent_read_entropy
+jent_entropy_collector_alloc
+jent_entropy_collector_free
+jent_entropy_init
+jent_kcapi_reset
+jent_kcapi_init
+jent_kcapi_random
+jent_kcapi_cleanup
+jent_zalloc
+jent_zfree
+jent_fips_enabled
+jent_memcpy
+jent_get_nstime
+ghash_exit_tfm
+ghash_init
+ghash_final
+ghash_update
+ghash_setkey
+asymmetric_key_eds_op
+asymmetric_key_match_free
+asymmetric_key_verify_signature
+asymmetric_key_preparse
+register_asymmetric_key_parser
+unregister_asymmetric_key_parser
+asymmetric_key_id_same.part.0
+asymmetric_key_id_same
+asymmetric_key_id_partial
+asymmetric_key_cmp_partial
+asymmetric_key_free_kids.part.0
+asymmetric_key_destroy
+asymmetric_key_free_preparse
+asymmetric_key_describe
+asymmetric_key_hex_to_key_id.part.0
+asymmetric_key_match_preparse
+asymmetric_lookup_restriction
+asymmetric_key_cmp
+asymmetric_key_generate_id
+find_asymmetric_key
+asymmetric_key_hex_to_key_id
+match_either_id
+key_or_keyring_common
+restrict_link_by_signature
+restrict_link_by_key_or_keyring
+restrict_link_by_key_or_keyring_chain
+query_asymmetric_key
+verify_signature
+encrypt_blob
+decrypt_blob
+create_signature
+public_key_signature_free
+pkey_pack_u32
+public_key_describe
+public_key_destroy
+software_key_determine_akcipher
+public_key_free
+software_key_query
+software_key_eds_op
+public_key_verify_signature
+public_key_verify_signature_2
+x509_decode_time
+x509_free_certificate.part.0
+x509_free_certificate
+x509_fabricate_name.constprop.0
+x509_cert_parse
+x509_note_OID
+x509_note_tbs_certificate
+x509_note_pkey_algo
+x509_note_signature
+x509_note_serial
+x509_extract_name_segment
+x509_note_issuer
+x509_note_subject
+x509_note_params
+x509_extract_key_data
+x509_process_extension
+x509_note_not_before
+x509_note_not_after
+x509_akid_note_kid
+x509_akid_note_name
+x509_akid_note_serial
+x509_key_preparse
+x509_get_sig_params
+x509_check_for_self_signed
+pkcs7_get_content_data
+pkcs7_free_message.part.0
+pkcs7_free_message
+pkcs7_parse_message
+pkcs7_note_OID
+pkcs7_sig_note_digest_algo
+pkcs7_sig_note_pkey_algo
+pkcs7_check_content_type
+pkcs7_note_signeddata_version
+pkcs7_note_signerinfo_version
+pkcs7_extract_cert
+pkcs7_note_certificate_list
+pkcs7_note_content
+pkcs7_note_data
+pkcs7_sig_note_authenticated_attr
+pkcs7_sig_note_set_of_authattrs
+pkcs7_sig_note_serial
+pkcs7_sig_note_issuer
+pkcs7_sig_note_skid
+pkcs7_sig_note_signature
+pkcs7_note_signed_info
+pkcs7_validate_trust
+pkcs7_digest
+pkcs7_verify
+pkcs7_get_digest
+pkcs7_supply_detached_data
+verify_pefile_signature
+mscode_parse
+mscode_note_content_type
+mscode_note_digest_algo
+mscode_note_digest
+__bio_add_page
+bio_init
+punt_bios_to_rescuer
+__bio_clone_fast
+bio_devname
+submit_bio_wait
+submit_bio_wait_endio
+bioset_exit
+bioset_init
+bioset_init_from_src
+bio_advance
+bio_chain
+bio_trim
+__bio_try_merge_page
+bio_add_page
+bio_uninit
+bio_reset
+bio_alloc_rescue
+bio_free_pages
+zero_fill_bio_iter
+bio_copy_data_iter
+bio_copy_data
+bio_list_copy_data
+bio_release_pages.part.0
+bio_release_pages
+bvec_nr_vecs
+bvec_free
+bio_free
+bio_put
+bio_endio
+bio_chain_endio
+bio_dirty_fn
+bvec_alloc
+bio_alloc_bioset
+bio_clone_fast
+bio_split
+bio_truncate
+guard_bio_eod
+bio_add_hw_page
+bio_add_pc_page
+bio_iov_iter_get_pages
+bio_set_pages_dirty
+bio_check_pages_dirty
+biovec_init_pool
+elv_rqhash_del
+elv_rb_find
+elv_attr_store
+elv_attr_show
+elevator_release
+elv_rb_add
+elv_rb_former_request
+elv_rb_latter_request
+elv_bio_merge_ok
+elv_rqhash_add
+elv_rb_del
+elevator_match
+elevator_find
+elv_unregister_queue.part.0
+elevator_alloc
+elv_unregister
+elv_register
+elevator_get
+__elevator_exit
+elv_rqhash_reposition
+elv_rqhash_find
+elv_merge
+elv_attempt_insert_merge
+elv_merged_request
+elv_merge_requests
+elv_latter_request
+elv_former_request
+elv_register_queue
+elv_unregister_queue
+elevator_switch_mq
+elevator_switch
+elevator_init_mq
+elv_iosched_store
+elv_iosched_show
+blk_queue_flag_test_and_set
+errno_to_blk_status
+blk_set_pm_only
+blk_timeout_work
+blk_queue_flag_set
+blk_queue_flag_clear
+__traceiter_block_touch_buffer
+__traceiter_block_dirty_buffer
+__traceiter_block_rq_requeue
+__traceiter_block_rq_complete
+__traceiter_block_rq_insert
+__traceiter_block_rq_issue
+__traceiter_block_rq_merge
+__traceiter_block_bio_bounce
+__traceiter_block_bio_complete
+__traceiter_block_bio_backmerge
+__traceiter_block_bio_frontmerge
+__traceiter_block_bio_queue
+__traceiter_block_getrq
+__traceiter_block_sleeprq
+__traceiter_block_plug
+__traceiter_block_unplug
+__traceiter_block_split
+__traceiter_block_bio_remap
+__traceiter_block_rq_remap
+should_fail_bio
+blk_steal_bios
+blk_lld_busy
+blk_start_plug
+blk_rq_init
+blk_status_to_errno
+update_io_ticks
+__part_start_io_acct
+disk_start_io_acct
+blk_sync_queue
+blk_queue_usage_counter_release
+blk_put_queue
+blk_alloc_queue
+blk_get_queue
+blk_get_request
+blk_put_request
+handle_bad_sector
+part_start_io_acct
+__part_end_io_acct
+disk_end_io_acct
+blk_rq_unprep_clone
+blk_rq_prep_clone
+kblockd_schedule_work
+blk_rq_timed_out_timer
+kblockd_mod_delayed_work_on
+blk_io_schedule
+blk_clear_pm_only
+blk_rq_err_bytes
+blk_check_plugged
+blk_dump_rq_flags
+blk_set_queue_dying
+blk_cleanup_queue
+submit_bio_checks
+part_end_io_acct
+blk_update_request
+blk_queue_enter
+submit_bio_noacct
+submit_bio
+blk_queue_exit
+blk_account_io_done
+blk_account_io_start
+blk_insert_cloned_request
+blk_flush_plug_list
+blk_finish_plug
+blk_free_queue_rcu
+queue_io_timeout_store
+queue_discard_zeroes_data_show
+queue_wc_store
+queue_random_store
+queue_stable_writes_store
+queue_iostats_store
+queue_rq_affinity_store
+queue_nomerges_store
+queue_nonrot_store
+queue_dax_show
+queue_poll_show
+queue_random_show
+queue_stable_writes_show
+queue_iostats_show
+queue_rq_affinity_show
+queue_nomerges_show
+queue_nonrot_show
+queue_fua_show
+queue_nr_zones_show
+queue_max_open_zones_show
+queue_max_active_zones_show
+queue_max_sectors_show
+queue_max_hw_sectors_show
+queue_max_segments_show
+queue_max_discard_segments_show
+queue_max_segment_size_show
+queue_logical_block_size_show
+queue_physical_block_size_show
+queue_io_min_show
+queue_io_opt_show
+queue_attr_visible
+queue_attr_store
+queue_attr_show
+blk_release_queue
+queue_io_timeout_show
+queue_poll_delay_show
+queue_discard_granularity_show
+queue_chunk_sectors_show
+queue_max_integrity_segments_show
+queue_ra_show
+queue_requests_show
+queue_zone_append_max_show
+queue_write_zeroes_max_show
+queue_write_same_max_show
+queue_discard_max_hw_show
+queue_discard_max_show
+queue_poll_delay_store
+queue_wb_lat_store
+queue_requests_store
+queue_poll_store
+queue_discard_max_store
+queue_max_sectors_store
+queue_ra_store
+blk_register_queue
+queue_wc_show
+queue_zoned_show
+queue_wb_lat_show
+blk_unregister_queue
+blk_flush_cur_seq
+blk_flush_complete_seq
+blkdev_issue_flush
+flush_end_io
+mq_flush_data_end_io
+blk_insert_flush
+blk_alloc_flush_queue
+blk_free_flush_queue
+blk_queue_write_cache
+blk_queue_rq_timeout
+blk_set_default_limits
+blk_set_stacking_limits
+blk_queue_chunk_sectors
+blk_queue_max_discard_sectors
+blk_queue_max_write_same_sectors
+blk_queue_max_write_zeroes_sectors
+blk_queue_max_discard_segments
+blk_queue_logical_block_size
+blk_queue_physical_block_size
+blk_queue_alignment_offset
+blk_queue_update_readahead
+blk_limits_io_min
+blk_queue_io_min
+blk_limits_io_opt
+blk_queue_io_opt
+blk_queue_update_dma_pad
+blk_queue_virt_boundary
+blk_queue_can_use_dma_map_merging
+blk_queue_dma_alignment
+blk_queue_required_elevator_features
+blk_queue_bounce_limit
+blk_queue_max_hw_sectors
+blk_queue_max_segments
+blk_queue_segment_boundary
+blk_queue_max_zone_append_sectors
+blk_queue_max_segment_size
+blk_stack_limits
+disk_stack_limits
+blk_set_queue_depth
+blk_queue_set_zoned
+blk_queue_update_dma_alignment
+icq_free_icq_rcu
+ioc_destroy_icq
+ioc_lookup_icq
+ioc_release_fn
+get_io_context
+put_io_context
+put_io_context_active
+exit_io_context
+ioc_clear_queue
+create_task_io_context
+get_task_io_context
+ioc_create_icq
+bio_map_kern_endio
+bio_copy_kern_endio
+blk_rq_append_bio
+blk_rq_map_kern
+bio_copy_kern_endio_read
+blk_rq_unmap_user
+blk_rq_map_user_iov
+blk_rq_map_user
+blk_execute_rq_nowait
+blk_execute_rq
+blk_end_sync_rq
+bvec_split_segs
+blk_account_io_merge_bio
+__blk_rq_map_sg
+bio_attempt_discard_merge
+__blk_queue_split
+blk_queue_split
+blk_recalc_rq_segments
+ll_back_merge_fn
+blk_rq_set_mixed_merge
+attempt_merge
+bio_attempt_back_merge
+bio_attempt_front_merge
+blk_mq_sched_try_merge
+blk_attempt_req_merge
+blk_rq_merge_ok
+blk_try_merge
+blk_attempt_bio_merge.part.0
+blk_bio_list_merge
+blk_attempt_plug_merge
+blk_abort_request
+blk_rq_timeout
+blk_add_timer
+blk_next_bio
+__blkdev_issue_discard
+blkdev_issue_discard
+blkdev_issue_write_same
+__blkdev_issue_write_zeroes
+__blkdev_issue_zero_pages
+__blkdev_issue_zeroout
+blkdev_issue_zeroout
+blk_mq_freeze_queue_wait
+blk_mq_freeze_queue_wait_timeout
+blk_mq_quiesce_queue_nowait
+blk_mq_kick_requeue_list
+blk_mq_delay_kick_requeue_list
+blk_mq_stop_hw_queue
+blk_mq_check_inflight
+blk_done_softirq
+blk_mq_rq_inflight
+plug_rq_cmp
+blk_mq_has_request
+blk_mq_poll_stats_fn
+blk_mq_rq_cpu
+blk_mq_unfreeze_queue
+blk_mq_quiesce_queue
+blk_mq_hctx_notify_online
+blk_mq_queue_stopped
+blk_mq_poll_stats_bkt
+blk_mq_rq_ctx_init
+__blk_mq_alloc_request
+blk_mq_alloc_request
+blk_mq_alloc_request_hctx
+__blk_mq_free_request
+blk_mq_start_request
+blk_mq_get_driver_tag
+hctx_unlock
+__blk_mq_run_hw_queue
+blk_mq_run_work_fn
+__blk_mq_delay_run_hw_queue
+blk_mq_delay_run_hw_queue
+blk_mq_delay_run_hw_queues
+blk_mq_run_hw_queue
+blk_mq_start_hw_queue
+blk_mq_start_stopped_hw_queue
+blk_mq_run_hw_queues
+blk_mq_unquiesce_queue
+blk_freeze_queue_start
+blk_mq_freeze_queue
+blk_mq_start_hw_queues
+blk_mq_start_stopped_hw_queues
+blk_mq_stop_hw_queues
+blk_mq_update_tag_set_shared
+blk_mq_remove_cpuhp
+blk_mq_queue_inflight
+blk_mq_hctx_mark_pending
+blk_mq_update_dispatch_busy.part.0
+blk_mq_update_queue_map
+blk_add_rq_to_plug
+blk_mq_hctx_notify_offline
+blk_mq_tag_to_rq
+blk_poll
+blk_mq_check_expired
+__blk_mq_requeue_request
+__blk_mq_try_issue_directly
+blk_mq_free_request
+blk_softirq_cpu_dead
+blk_mq_trigger_softirq
+blk_mq_complete_request_remote
+blk_mq_complete_request
+__blk_mq_complete_request_remote
+blk_mq_timeout_work
+blk_mq_end_request
+blk_mq_dispatch_wake
+blk_mq_flush_busy_ctxs
+blk_mq_exit_hctx
+blk_mq_hctx_notify_dead
+blk_mq_realloc_tag_set_tags.part.0
+blk_mq_in_flight
+blk_mq_in_flight_rw
+blk_freeze_queue
+blk_mq_wake_waiters
+blk_mq_add_to_requeue_list
+blk_mq_requeue_request
+blk_mq_dequeue_from_ctx
+blk_mq_dispatch_rq_list
+__blk_mq_insert_request
+blk_mq_request_bypass_insert
+blk_mq_try_issue_directly
+blk_mq_requeue_work
+blk_mq_insert_requests
+blk_mq_flush_plug_list
+blk_mq_request_issue_directly
+blk_mq_try_issue_list_directly
+blk_mq_submit_bio
+blk_mq_free_rqs
+blk_mq_free_rq_map
+blk_mq_free_map_and_requests
+blk_mq_realloc_hw_ctxs
+blk_mq_free_tag_set
+blk_mq_alloc_rq_map
+blk_mq_alloc_rqs
+__blk_mq_alloc_map_and_request
+blk_mq_map_swqueue
+blk_mq_init_allocated_queue
+blk_mq_init_queue_data
+blk_mq_init_queue
+blk_mq_update_nr_hw_queues
+blk_mq_alloc_tag_set
+blk_mq_init_sq_queue
+blk_mq_release
+blk_mq_exit_queue
+blk_mq_update_nr_requests
+bt_tags_iter
+blk_mq_tagset_count_completed_rqs
+blk_mq_unique_tag
+__blk_mq_get_tag
+bt_iter
+__blk_mq_all_tag_iter
+blk_mq_tagset_busy_iter
+blk_mq_tagset_wait_completed_request
+__blk_mq_tag_busy
+blk_mq_tag_wakeup_all
+__blk_mq_tag_idle
+blk_mq_put_tag
+blk_mq_get_tag
+blk_mq_all_tag_iter
+blk_mq_queue_tag_busy_iter
+blk_mq_init_shared_sbitmap
+blk_mq_exit_shared_sbitmap
+blk_mq_init_tags
+blk_mq_free_tags
+blk_mq_tag_update_depth
+blk_mq_tag_resize_shared_sbitmap
+blk_stat_enable_accounting
+blk_stat_free_callback_rcu
+blk_rq_stat_init
+blk_rq_stat_sum
+blk_stat_timer_fn
+blk_rq_stat_add
+blk_stat_add
+blk_stat_alloc_callback
+blk_stat_add_callback
+blk_stat_remove_callback
+blk_stat_free_callback
+blk_alloc_queue_stats
+blk_free_queue_stats
+blk_mq_unregister_hctx
+blk_mq_ctx_sysfs_release
+blk_mq_hw_sysfs_cpus_show
+blk_mq_hw_sysfs_nr_reserved_tags_show
+blk_mq_hw_sysfs_nr_tags_show
+blk_mq_hw_sysfs_store
+blk_mq_hw_sysfs_show
+blk_mq_sysfs_store
+blk_mq_sysfs_show
+blk_mq_hw_sysfs_release
+blk_mq_sysfs_release
+blk_mq_register_hctx
+blk_mq_unregister_dev
+blk_mq_hctx_kobj_init
+blk_mq_sysfs_deinit
+blk_mq_sysfs_init
+__blk_mq_register_dev
+blk_mq_sysfs_unregister
+blk_mq_sysfs_register
+blk_mq_map_queues
+blk_mq_hw_queue_to_node
+blk_mq_sched_mark_restart_hctx
+blk_mq_sched_try_insert_merge
+sched_rq_cmp
+blk_mq_sched_request_inserted
+__blk_mq_do_dispatch_sched
+blk_mq_do_dispatch_ctx
+blk_mq_sched_tags_teardown
+__blk_mq_sched_dispatch_requests
+blk_mq_sched_assign_ioc
+blk_mq_sched_restart
+blk_mq_sched_dispatch_requests
+__blk_mq_sched_bio_merge
+blk_mq_sched_insert_request
+blk_mq_sched_insert_requests
+blk_mq_sched_free_requests
+blk_mq_exit_sched
+blk_mq_init_sched
+__blkdev_driver_ioctl
+blkdev_compat_ptr_ioctl
+blkdev_pr_preempt
+blkpg_do_ioctl
+blkdev_bszset
+blk_ioctl_discard
+blkdev_common_ioctl
+blkdev_ioctl
+compat_blkdev_ioctl
+exact_match
+disk_events_async_show
+disk_visible
+block_devnode
+set_device_ro
+bdev_read_only
+disk_part_iter_init
+disk_has_partitions
+disk_part_iter_next
+disk_part_iter_exit
+set_disk_ro
+register_blkdev
+unregister_blkdev
+blk_register_region
+blk_unregister_region
+disk_events_poll_jiffies
+disk_check_events
+disk_events_workfn
+__disk_unblock_events
+disk_events_show
+part_size_show
+disk_capability_show
+disk_discard_alignment_show
+disk_alignment_offset_show
+disk_ro_show
+disk_hidden_show
+disk_removable_show
+disk_ext_range_show
+disk_range_show
+put_disk
+part_in_flight
+part_stat_read_all
+disk_seqf_next
+disk_seqf_start
+disk_seqf_stop
+base_probe
+part_inflight_show
+disk_badblocks_store
+get_disk_and_module
+exact_lock
+set_capacity_revalidate_and_notify
+disk_events_poll_msecs_show
+disk_badblocks_show
+show_partition_start
+blk_free_devt.part.0
+blk_invalidate_devt.part.0
+disk_release
+put_disk_and_module
+part_stat_show
+disk_name
+bdevname
+show_partition
+diskstats_show
+__disk_get_part
+disk_get_part
+bdget_disk
+invalidate_partition
+disk_map_sector_rcu
+blkdev_show
+blk_alloc_devt
+__device_add_disk
+device_add_disk
+device_add_disk_no_queue_reg
+blk_free_devt
+blk_invalidate_devt
+get_gendisk
+disk_expand_part_tbl
+__alloc_disk_node
+blk_lookup_devt
+disk_block_events
+disk_events_poll_msecs_store
+del_gendisk
+bdev_check_media_change
+disk_unblock_events
+disk_flush_events
+disk_events_set_dfl_poll_msecs
+set_task_ioprio
+get_task_ioprio
+__ia32_sys_ioprio_get
+__x64_sys_ioprio_get
+ioprio_check_cap
+__ia32_sys_ioprio_set
+__x64_sys_ioprio_set
+ioprio_best
+badblocks_check
+badblocks_set
+badblocks_clear
+badblocks_show
+badblocks_store
+badblocks_exit
+devm_init_badblocks
+badblocks_init
+ack_all_badblocks
+whole_disk_show
+part_release
+part_uevent
+part_ro_show
+part_start_show
+part_partition_show
+part_discard_alignment_show
+part_alignment_offset_show
+hd_struct_free
+partition_overlaps
+hd_struct_free_work
+add_partition
+hd_ref_init
+delete_partition
+bdev_add_partition
+bdev_del_partition
+bdev_resize_partition
+blk_drop_partitions
+blk_add_partitions
+read_part_sector
+amiga_partition
+atari_partition
+read_lba
+aix_partition
+add_part
+cmdline_partition
+mac_partition
+ldm_relative
+ldm_free_vblks
+ldm_get_vnum
+ldm_get_vstr
+ldm_ldmdb_add
+ldm_partition
+set_info
+parse_minix
+parse_bsd.constprop.0
+parse_freebsd
+parse_netbsd
+parse_openbsd
+parse_unixware
+parse_solaris_x86
+msdos_partition
+osf_partition
+sgi_partition
+sun_partition
+ultrix_partition
+last_lba
+read_lba
+compare_gpts
+is_gpt_valid.part.0
+efi_partition
+karma_partition
+sysv68_partition
+rq_qos_wake_function
+rq_wait_inc_below
+__rq_qos_cleanup
+__rq_qos_done
+__rq_qos_issue
+__rq_qos_requeue
+__rq_qos_throttle
+__rq_qos_track
+__rq_qos_merge
+__rq_qos_done_bio
+__rq_qos_queue_depth_changed
+rq_depth_calc_max_depth
+rq_depth_scale_up
+rq_depth_scale_down
+rq_qos_wait
+rq_qos_exit
+mempool_alloc_pages_isa
+copy_to_high_bio_irq
+bounce_end_io
+bounce_end_io_read
+bounce_end_io_write_isa
+bounce_end_io_write
+bounce_end_io_read_isa
+init_emergency_isa_pool
+blk_queue_bounce
+scsi_verify_blk_ioctl
+scsi_req_init
+put_sg_io_hdr
+get_sg_io_hdr
+blk_verify_command
+__blk_send_generic.constprop.0
+sg_io
+scsi_cdrom_send_packet
+sg_scsi_ioctl
+scsi_cmd_ioctl
+scsi_cmd_blk_ioctl
+bsg_scsi_check_proto
+bsg_unregister_queue
+bsg_scsi_free_rq
+bsg_scsi_complete_rq
+bsg_sg_io
+bsg_ioctl
+bsg_devnode
+bsg_scsi_fill_hdr
+bsg_release
+bsg_open
+bsg_register_queue
+bsg_scsi_register_queue
+bsg_timeout
+bsg_exit_rq
+bsg_teardown_job
+bsg_job_done
+bsg_transport_free_rq
+bsg_transport_complete_rq
+bsg_transport_fill_hdr
+bsg_transport_check_proto
+bsg_initialize_rq
+bsg_remove_queue
+bsg_map_buffer
+bsg_queue_rq
+bsg_job_get
+bsg_setup_queue
+bsg_init_rq
+bsg_job_put
+bsg_complete
+blkg_release
+blkg_lookup_slowpath
+blkcg_rstat_flush
+blkcg_scale_delay
+blkg_async_bio_workfn
+blkg_destroy
+blkcg_bind
+blkcg_css_free
+__blkg_prfill_u64
+blkcg_exit
+blkcg_policy_register
+blkcg_policy_unregister
+blkg_free.part.0
+blkg_alloc
+blkcg_css_alloc
+blkcg_css_online
+blkcg_can_attach
+blkg_lookup_check
+blkcg_print_blkgs
+blkcg_print_stat
+blkg_conf_finish
+blkg_destroy_all
+bio_clone_blkg_association
+blkcg_deactivate_policy
+blkcg_reset_stats
+__blkg_release
+blkcg_activate_policy
+blkg_create
+bio_associate_blkg_from_css
+bio_associate_blkg
+blkg_dev_name
+blkcg_conf_get_disk
+blkg_conf_prep
+blkcg_destroy_blkgs
+blkcg_css_offline
+blkcg_init_queue
+blkcg_exit_queue
+__blkcg_punt_bio_submit
+blkcg_maybe_throttle_current
+blkcg_schedule_throttle
+blkcg_add_delay
+blk_cgroup_bio_start
+blkg_rwstat_exit
+__blkg_prfill_rwstat
+blkg_prfill_rwstat
+blkg_rwstat_recursive_sum
+blkg_rwstat_init
+throtl_pd_free
+tg_prfill_rwstat_recursive
+tg_last_low_overflow_time
+throtl_pd_init
+throtl_pd_alloc
+throtl_dequeue_tg
+tg_print_rwstat_recursive
+tg_print_rwstat
+tg_print_conf_uint
+tg_print_conf_u64
+tg_print_limit
+tg_prfill_conf_uint
+tg_prfill_conf_u64
+throtl_charge_bio
+tg_prfill_limit
+throtl_adjusted_limit
+tg_iops_limit
+tg_bps_limit
+throtl_enqueue_tg
+tg_update_has_rules
+throtl_pd_online
+throtl_pop_queued
+throtl_qnode_add_bio
+throtl_add_bio_tg
+blk_throtl_update_limit_valid
+blk_throtl_dispatch_work_fn
+throtl_tg_is_idle
+throtl_can_upgrade
+throtl_schedule_next_dispatch
+tg_may_dispatch
+tg_update_disptime
+tg_conf_updated
+tg_set_limit
+tg_set_conf.constprop.0
+tg_set_conf_u64
+tg_set_conf_uint
+tg_dispatch_one_bio
+throtl_select_dispatch
+throtl_upgrade_state
+throtl_pd_offline
+throtl_pending_timer_fn
+blk_throtl_bio
+blk_throtl_init
+blk_throtl_exit
+blk_throtl_register_queue
+__traceiter_iocost_iocg_activate
+__traceiter_iocost_inuse_shortage
+__traceiter_iocost_inuse_transfer
+__traceiter_iocost_inuse_adjust
+__traceiter_iocost_ioc_vrate_adj
+__traceiter_iocost_iocg_forgive_debt
+calc_vtime_cost_builtin
+ioc_rqos_done_bio
+__propagate_weights
+current_hweight
+iocg_build_inner_walk
+ioc_cpd_free
+ioc_pd_alloc
+ioc_start_period
+iocg_wake_fn
+ioc_cost_model_prfill
+ioc_weight_prfill
+ioc_cost_model_show
+ioc_qos_show
+ioc_weight_show
+ioc_pd_stat
+ioc_rqos_done
+ioc_qos_prfill
+iocg_lock
+calc_lcoefs
+ioc_refresh_params
+iocg_flush_stat_one.isra.0
+commit_weights
+weight_updated
+iocg_incur_debt
+ioc_cpd_alloc
+transfer_surpluses
+ioc_now
+ioc_pd_init
+ioc_pd_free
+iocg_kick_delay
+iocg_kick_waitq
+iocg_unlock
+iocg_waitq_timer_fn
+ioc_rqos_queue_depth_changed
+ioc_rqos_exit
+ioc_weight_write
+blk_iocost_init
+ioc_cost_model_write
+adjust_inuse_and_calc_cost
+ioc_rqos_merge
+ioc_qos_write
+ioc_timer_fn
+ioc_rqos_throttle
+dd_prepare_request
+dd_has_work
+deadline_dispatch_next
+deadline_write_fifo_next
+deadline_read_fifo_next
+deadline_dispatch_start
+deadline_write_fifo_start
+deadline_read_fifo_start
+deadline_starved_show
+deadline_batching_show
+deadline_write_next_rq_show
+deadline_read_next_rq_show
+deadline_fifo_batch_store
+deadline_front_merges_store
+deadline_writes_starved_store
+deadline_write_expire_store
+deadline_read_expire_store
+deadline_fifo_batch_show
+deadline_front_merges_show
+deadline_writes_starved_show
+deadline_write_expire_show
+deadline_read_expire_show
+deadline_remove_request
+dd_merged_requests
+dd_insert_requests
+dd_request_merged
+dd_finish_request
+dd_init_queue
+deadline_next_request
+dd_request_merge
+dd_exit_queue
+deadline_fifo_request
+deadline_read_fifo_stop
+deadline_write_fifo_stop
+deadline_dispatch_stop
+dd_bio_merge
+dd_dispatch_request
+cmdline_parts_set
+cmdline_parts_free
+cmdline_parts_find
+cmdline_parts_parse
+__bio_integrity_free
+bio_integrity_add_page
+bio_integrity_trim
+bioset_integrity_create
+bio_integrity_process
+bio_integrity_alloc
+bio_integrity_clone
+bio_integrity_prep
+blk_flush_integrity
+bio_integrity_free
+bio_integrity_verify_fn
+__bio_integrity_endio
+bio_integrity_advance
+bioset_integrity_free
+blk_integrity_nop_fn
+blk_integrity_nop_prepare
+blk_integrity_nop_complete
+integrity_attr_show
+integrity_attr_store
+blk_integrity_compare
+blk_integrity_register
+blk_integrity_unregister
+integrity_device_show
+integrity_generate_show
+integrity_verify_show
+integrity_interval_show
+integrity_tag_size_show
+integrity_generate_store
+integrity_verify_store
+blk_rq_map_integrity_sg
+integrity_format_show
+blk_rq_count_integrity_sg
+blk_integrity_merge_rq
+blk_integrity_merge_bio
+blk_integrity_add
+blk_integrity_del
+t10_pi_type3_prepare
+t10_pi_type3_complete
+t10_pi_crc_fn
+t10_pi_ip_fn
+t10_pi_generate
+t10_pi_type1_generate_crc
+t10_pi_type1_generate_ip
+t10_pi_type3_generate_crc
+t10_pi_type3_generate_ip
+t10_pi_type1_complete
+t10_pi_verify.part.0
+t10_pi_type1_verify_crc
+t10_pi_type1_verify_ip
+t10_pi_type3_verify_crc
+t10_pi_type3_verify_ip
+t10_pi_type1_prepare
+blk_mq_pci_map_queues
+blk_mq_virtio_map_queues
+blk_mq_rdma_map_queues
+blk_zone_cond_str
+blkdev_nr_zones
+blkdev_report_zones
+blkdev_zone_mgmt
+blkdev_copy_zone_to_user
+blk_revalidate_disk_zones
+blk_req_needs_zone_write_lock
+blk_revalidate_zone_cb
+blk_req_zone_write_trylock
+__blk_req_zone_write_lock
+__blk_req_zone_write_unlock
+blkdev_report_zones_ioctl
+blkdev_zone_mgmt_ioctl
+blk_queue_free_zone_bitmaps
+__traceiter_wbt_stat
+__traceiter_wbt_lat
+__traceiter_wbt_step
+__traceiter_wbt_timer
+wbt_issue
+wbt_requeue
+wbt_data_dir
+rwb_trace_step
+rwb_wake_all
+wbt_disable_default
+wbt_background_show
+wbt_normal_show
+wbt_unknown_cnt_show
+wbt_min_lat_nsec_show
+wbt_inflight_show
+wbt_id_show
+wbt_enabled_show
+wbt_curr_win_nsec_show
+wbt_exit
+wbt_rqw_done
+__wbt_done
+wbt_cleanup_cb
+wbt_inflight_cb
+calc_wb_limits.part.0
+wbt_update_limits
+wbt_queue_depth_changed
+bio_to_wbt_flags.part.0
+wbt_track
+wbt_cleanup
+scale_up
+scale_down
+wbt_done
+rwb_arm_timer
+wbt_wait
+wb_timer_fn
+wbt_get_min_lat
+wbt_set_min_lat
+wbt_set_write_cache
+wbt_default_latency_nsec
+wbt_init
+wbt_enable_default
+queue_pm_only_show
+hctx_active_show
+queue_requeue_list_stop
+queue_write_hint_store
+hctx_io_poll_write
+hctx_dispatched_write
+hctx_queued_write
+hctx_run_write
+ctx_dispatched_write
+ctx_merged_write
+ctx_completed_write
+blk_mq_debugfs_show
+blk_mq_debugfs_write
+queue_write_hint_show
+hctx_type_show
+hctx_dispatch_busy_show
+hctx_run_show
+hctx_queued_show
+hctx_io_poll_show
+ctx_completed_show
+ctx_merged_show
+ctx_dispatched_show
+print_stat
+queue_poll_stat_show
+blk_flags_show
+queue_state_show
+hctx_flags_show
+hctx_state_show
+hctx_dispatched_show
+__blk_mq_debugfs_rq_show
+blk_mq_debugfs_rq_show
+hctx_show_busy_rq
+queue_state_write
+queue_requeue_list_next
+hctx_dispatch_next
+ctx_poll_rq_list_next
+ctx_read_rq_list_next
+ctx_default_rq_list_next
+queue_requeue_list_start
+hctx_dispatch_start
+ctx_poll_rq_list_start
+ctx_read_rq_list_start
+ctx_default_rq_list_start
+blk_mq_debugfs_release
+blk_mq_debugfs_open
+hctx_ctx_map_show
+hctx_sched_tags_bitmap_show
+hctx_tags_bitmap_show
+hctx_busy_show
+debugfs_create_files.part.0
+blk_mq_debugfs_tags_show
+hctx_sched_tags_show
+hctx_tags_show
+ctx_poll_rq_list_stop
+ctx_read_rq_list_stop
+hctx_dispatch_stop
+ctx_default_rq_list_stop
+blk_mq_debugfs_unregister
+blk_mq_debugfs_register_hctx
+blk_mq_debugfs_unregister_hctx
+blk_mq_debugfs_register_hctxs
+blk_mq_debugfs_unregister_hctxs
+blk_mq_debugfs_register_sched
+blk_mq_debugfs_unregister_sched
+blk_mq_debugfs_unregister_rqos
+blk_mq_debugfs_register_rqos
+blk_mq_debugfs_unregister_queue_rqos
+blk_mq_debugfs_register_sched_hctx
+blk_mq_debugfs_register
+blk_mq_debugfs_unregister_sched_hctx
+queue_zone_wlock_show
+clean_opal_dev
+execute_step
+init_opal_dev
+clear_opal_cmd
+opal_discovery0
+free_opal_dev
+execute_steps
+opal_reverttper
+__opal_lock_unlock
+response_get_token
+response_get_u64
+can_add.part.0
+add_token_u8
+finalize_and_send
+add_bytestring_header
+add_token_bytestring
+cmd_start
+generic_lr_enable_disable
+set_mbr_done
+internal_activate_user
+set_mbr_enable_disable
+gen_key
+generic_pw_cmd
+add_user_to_lr
+add_token_u64
+generic_get_column
+response_get_string
+end_opal_session
+set_sid_cpin_pin
+set_new_pw
+revert_tper
+start_generic_opal_session.part.0
+start_admin1LSP_opal_session
+start_anybodyASP_opal_session
+start_PSID_opal_session
+start_SIDASP_opal_session
+get_msid_cpin_pin
+get_lsp_lifecycle
+opal_unlock_from_suspend
+generic_get_table_info.constprop.0
+read_table_data
+parse_and_check_status
+end_session_cont
+start_opal_session_cont
+read_table_data_cont
+build_locking_range.constprop.0
+setup_locking_range
+activate_lsp
+get_active_key
+erase_locking_range
+lock_unlock_locking_range
+lock_unlock_locking_range_sum
+sed_ioctl
+start_auth_opal_session
+generic_table_write_data
+write_shadow_mbr
+write_table_data
+blk_pm_runtime_init
+blk_pre_runtime_resume
+blk_post_runtime_suspend
+blk_set_runtime_active
+blk_post_runtime_resume
+blk_pre_runtime_suspend
+blk_ksm_remove_slot_from_lru_list
+blk_ksm_get_slot_idx
+blk_ksm_reprogram_all_keys
+blk_ksm_register
+blk_ksm_destroy.part.0
+blk_ksm_destroy
+blk_ksm_init
+blk_ksm_find_keyslot
+blk_ksm_find_and_grab_keyslot
+blk_ksm_get_slot_for_key
+blk_ksm_put_slot
+blk_ksm_crypto_cfg_supported
+blk_ksm_evict_key
+blk_ksm_unregister
+__bio_crypt_clone
+bio_crypt_set_ctx
+__bio_crypt_free_ctx
+bio_crypt_dun_increment
+__bio_crypt_advance
+bio_crypt_dun_is_contiguous
+bio_crypt_rq_ctx_compatible
+bio_crypt_ctx_mergeable
+__blk_crypto_init_request
+__blk_crypto_free_request
+__blk_crypto_bio_prep
+__blk_crypto_rq_bio_prep
+blk_crypto_init_key
+blk_crypto_config_supported
+blk_crypto_start_using_key
+blk_crypto_evict_key
+blk_crypto_fallback_decrypt_endio
+blk_crypto_fallback_encrypt_endio
+blk_crypto_evict_keyslot
+blk_crypto_keyslot_evict
+blk_crypto_keyslot_program
+blk_crypto_alloc_cipher_req
+blk_crypto_fallback_decrypt_bio
+blk_crypto_fallback_encrypt_bio
+blk_crypto_fallback_bio_prep
+blk_crypto_fallback_evict_key
+blk_crypto_fallback_start_using_mode
+iter_div_u64_rem
+gcd
+lcm.part.0
+lcm
+lcm_not_zero
+int_pow
+int_sqrt
+reciprocal_value
+reciprocal_value_adv
+rational_best_approximation
+chacha_permute
+chacha_block_generic
+hchacha_block_generic
+inv_mix_columns
+aes_expandkey
+aes_decrypt
+aes_encrypt
+blake2s_compress_generic
+sha256_transform
+sha256_update
+sha224_update
+__sha256_final
+sha256_final
+sha224_final
+sha256
+inflate_fast
+zlib_updatewindow
+zlib_inflate_workspacesize
+zlib_inflateReset
+zlib_inflateInit2
+zlib_inflate
+zlib_inflateEnd
+zlib_inflateIncomp
+zlib_inflate_blob
+zlib_inflate_table
+longest_match
+fill_window
+deflate_stored
+deflate_slow
+deflate_fast
+zlib_deflateReset
+zlib_deflateInit2
+zlib_deflate
+zlib_deflateEnd
+zlib_deflate_workspacesize
+zlib_deflate_dfltcc_enabled
+init_block
+pqdownheap
+scan_tree
+send_tree
+compress_block
+gen_codes
+build_tree
+zlib_tr_init
+zlib_tr_stored_block
+zlib_tr_stored_type_only
+zlib_tr_align
+zlib_tr_flush_block
+zlib_tr_tally
+lzo1x_1_do_compress
+lzogeneric1x_1_compress
+lzo1x_1_compress
+lzorle1x_1_compress
+lzo1x_decompress_safe
+LZ4_saveDict
+LZ4_compress_fast_continue
+LZ4_loadDict
+LZ4_compress_fast_extState
+LZ4_compress_fast
+LZ4_compress_default
+LZ4_compress_destSize
+LZ4_resetStream
+LZ4_decompress_safe
+LZ4_decompress_safe_partial
+LZ4_decompress_fast
+LZ4_decompress_safe_withSmallPrefix
+LZ4_setStreamDecode
+LZ4_decompress_fast_extDict
+LZ4_decompress_fast_usingDict
+LZ4_decompress_fast_continue
+LZ4_decompress_safe_withPrefix64k
+LZ4_decompress_safe_forceExtDict
+LZ4_decompress_safe_continue
+LZ4_decompress_safe_usingDict
+FSE_writeNCount_generic
+FSE_compress_usingCTable_generic
+FSE_buildCTable_wksp
+FSE_NCountWriteBound
+FSE_writeNCount
+FSE_count_simple
+FSE_countFast_wksp
+FSE_count_wksp
+FSE_sizeof_CTable
+FSE_optimalTableLog_internal
+FSE_optimalTableLog
+FSE_normalizeCount
+FSE_buildCTable_raw
+FSE_buildCTable_rle
+FSE_compress_usingCTable
+FSE_compressBound
+HUF_sort
+HUF_setMaxHeight
+HUF_compress1X_usingCTable.part.0
+HUF_optimalTableLog
+HUF_compressWeights_wksp
+HUF_writeCTable_wksp
+HUF_readCTable_wksp
+HUF_buildCTable_wksp
+HUF_compressBound
+HUF_compress1X_usingCTable
+HUF_compress4X_usingCTable
+HUF_compress1X_wksp
+HUF_compress1X_repeat
+HUF_compress4X_wksp
+HUF_compress4X_repeat
+ZSTD_checkCParams
+ZSTD_CStreamInSize
+ZSTD_maxCLevel
+ZSTD_compressBound
+ZSTD_CStreamOutSize
+ZSTD_CCtxWorkspaceBound
+ZSTD_hashPtr
+ZSTD_getBlockSizeMax
+ZSTD_adjustCParams
+ZSTD_resetCCtx_advanced
+ZSTD_noCompressLiterals
+ZSTD_count
+ZSTD_count_2segments
+ZSTD_writeFrameHeader.isra.0
+ZSTD_copyCCtx.part.0
+ZSTD_copyCCtx
+ZSTD_updateTree
+ZSTD_hashPtr.constprop.0
+ZSTD_hashPtr.constprop.1
+ZSTD_hashPtr.constprop.3
+ZSTD_hashPtr.constprop.4
+ZSTD_getCParams
+ZSTD_initCCtx
+ZSTD_getParams
+ZSTD_CDictWorkspaceBound
+ZSTD_CStreamWorkspaceBound
+ZSTD_compressBlock_greedy_extDict
+ZSTD_insertBtAndFindBestMatch
+ZSTD_BtFindBestMatch_selectMLS.constprop.0
+ZSTD_compressBlock_btlazy2
+ZSTD_insertBt1.constprop.1
+ZSTD_BtFindBestMatch_selectMLS_extDict.constprop.0
+ZSTD_compressBlock_btlazy2_extDict
+ZSTD_compressBlock_lazy2
+ZSTD_compressBlock_greedy
+ZSTD_compressBlock_lazy
+ZSTD_compressBlock_lazy2_extDict
+ZSTD_insertBtAndGetAllMatches
+ZSTD_BtGetAllMatches_selectMLS
+ZSTD_compressBlock_btopt
+ZSTD_BtGetAllMatches_selectMLS_extDict
+ZSTD_compressBlock_btopt_extDict
+ZSTD_compressBlock_btopt2_extDict
+ZSTD_compressBlock_lazy_extDict
+ZSTD_compressBlock_doubleFast_extDict_generic
+ZSTD_compressBlock_doubleFast_extDict
+ZSTD_compressBlock_doubleFast
+ZSTD_loadDictionaryContent
+ZSTD_loadZstdDictionary
+ZSTD_compressBegin
+ZSTD_compressBegin_usingCDict
+ZSTD_resetCStream
+ZSTD_compressBegin_advanced
+ZSTD_compressBegin_usingDict
+ZSTD_initCDict
+ZSTD_createCDict_advanced
+ZSTD_compressBlock_fast_extDict_generic
+ZSTD_compressBlock_fast_extDict
+ZSTD_resetCStream_internal
+ZSTD_compressBlock_btopt2
+ZSTD_compressBlock_fast
+ZSTD_freeCCtx
+ZSTD_getSeqStore
+ZSTD_invalidateRepCodes
+ZSTD_noCompressBlock
+ZSTD_seqToCodes
+ZSTD_compressBlock_internal
+ZSTD_compressContinue_internal
+ZSTD_compressContinue
+ZSTD_compressEnd
+ZSTD_compress_usingDict
+ZSTD_compressStream_generic
+ZSTD_compressStream
+ZSTD_flushStream
+ZSTD_endStream
+ZSTD_compress_usingCDict
+ZSTD_compressCCtx
+ZSTD_compressBlock
+ZSTD_freeCDict
+ZSTD_freeCStream
+ZSTD_createCStream_advanced
+ZSTD_initCStream
+ZSTD_initCStream_usingCDict
+FSE_versionNumber
+FSE_isError
+HUF_isError
+FSE_readNCount
+HUF_readStats_wksp
+FSE_buildDTable_wksp
+FSE_buildDTable_rle
+FSE_buildDTable_raw
+FSE_decompress_usingDTable
+FSE_decompress_wksp
+ZSTD_stackFree
+ZSTD_stackAlloc
+ZSTD_initStack
+ZSTD_stackAllocAll
+ZSTD_malloc
+ZSTD_free
+HUF_decodeLastSymbolX4
+HUF_fillDTableX4Level2
+HUF_decompress1X4_usingDTable_internal
+HUF_decompress1X2_usingDTable_internal
+HUF_decompress4X2_usingDTable_internal.part.0
+HUF_decompress4X4_usingDTable_internal.part.0
+HUF_readDTableX2_wksp
+HUF_decompress1X2_usingDTable
+HUF_decompress1X2_DCtx_wksp
+HUF_decompress4X2_usingDTable
+HUF_decompress4X2_DCtx_wksp
+HUF_readDTableX4_wksp
+HUF_decompress1X4_usingDTable
+HUF_decompress1X4_DCtx_wksp
+HUF_decompress4X4_usingDTable
+HUF_decompress4X4_DCtx_wksp
+HUF_decompress1X_usingDTable
+HUF_decompress4X_usingDTable
+HUF_selectDecoder
+HUF_decompress4X_DCtx_wksp
+HUF_decompress4X_hufOnly_wksp
+HUF_decompress1X_DCtx_wksp
+ZSTD_DCtxWorkspaceBound
+ZSTD_DDictWorkspaceBound
+ZSTD_DStreamWorkspaceBound
+ZSTD_DStreamInSize
+ZSTD_DStreamOutSize
+ZSTD_insertBlock
+ZSTD_nextSrcSizeToDecompress
+ZSTD_nextInputType
+ZSTD_resetDStream
+ZSTD_copyDCtx
+ZSTD_decompressBegin
+ZSTD_loadEntropy
+ZSTD_isFrame
+ZSTD_getDictID_fromDDict
+ZSTD_execSequenceLast7.isra.0
+ZSTD_getFrameParams
+ZSTD_findFrameCompressedSize
+ZSTD_getDictID_fromDict
+ZSTD_decompressBegin_usingDict
+ZSTD_initDCtx
+ZSTD_initDDict
+ZSTD_findDecompressedSize
+ZSTD_getDictID_fromFrame
+ZSTD_getFrameContentSize
+ZSTD_decodeSequenceLong
+ZSTD_createDCtx_advanced
+ZSTD_freeDCtx
+ZSTD_getcBlockSize
+ZSTD_decodeLiteralsBlock
+ZSTD_decodeSeqHeaders
+ZSTD_decompressSequencesLong
+ZSTD_decompressSequences
+ZSTD_decompressContinue
+ZSTD_decompressBlock
+ZSTD_decompressStream
+ZSTD_decompressDCtx
+ZSTD_decompress_usingDict
+ZSTD_decompress_usingDDict
+ZSTD_generateNxBytes
+ZSTD_isSkipFrame
+ZSTD_freeDDict
+ZSTD_freeDStream
+ZSTD_initDStream
+ZSTD_initDStream_usingDDict
+index_update
+dec_vli
+crc32_validate
+fill_temp
+xz_dec_reset
+xz_dec_run
+xz_dec_init
+xz_dec_end
+dict_repeat
+lzma_len
+lzma_main
+xz_dec_lzma2_run
+xz_dec_lzma2_create
+xz_dec_lzma2_reset
+xz_dec_lzma2_end
+bcj_flush
+bcj_apply
+xz_dec_bcj_run
+xz_dec_bcj_create
+xz_dec_bcj_reset
+mpihelp_lshift
+mpihelp_mul_1
+mpihelp_addmul_1
+mpihelp_submul_1
+mpihelp_rshift
+mpihelp_sub_n
+mpihelp_add_n
+mpi_point_init
+mpi_point_new
+mpi_point_free_parts
+point_resize
+mpi_ec_coefficient_normalize
+mpi_ec_init
+ec_subm_448
+ec_addm_448
+ec_mul2_448
+ec_subm_25519
+ec_addm_25519
+ec_mul2_25519
+ec_mulm_25519
+ec_pow2_25519
+ec_subm
+point_set
+ec_invm
+point_swap_cond
+ec_mod
+ec_mul2
+ec_mulm
+ec_pow2
+ec_addm
+mpi_ec_get_affine
+mpi_ec_dup_point
+mpi_ec_add_points
+mpi_ec_mul_point
+mpi_ec_curve_point
+ec_mulm_448
+ec_pow2_448
+mpi_point_release
+mpi_ec_deinit
+twocompl
+mpi_read_raw_data
+mpi_read_from_buffer
+mpi_fromstr
+mpi_scanval
+mpi_read_buffer
+mpi_get_buffer
+mpi_read_raw_from_sgl
+mpi_write_to_sgl
+mpi_print
+mpi_add
+mpi_addm
+mpi_add_ui
+mpi_sub
+mpi_subm
+mpi_normalize
+mpi_get_nbits
+mpi_test_bit
+mpi_clear_bit
+mpi_set_highbit
+mpi_set_bit
+mpi_clear_highbit
+mpi_rshift_limbs
+mpi_rshift
+mpi_lshift_limbs
+mpi_lshift
+do_mpi_cmp
+mpi_cmp
+mpi_cmpabs
+mpi_cmp_ui
+mpi_sub_ui
+mpi_tdiv_qr
+mpi_fdiv_qr
+mpi_fdiv_q
+mpi_tdiv_r
+mpi_fdiv_r
+mpi_invm
+mpi_mod
+mpi_barrett_init
+mpi_barrett_free
+mpi_mod_barrett
+mpi_mul_barrett
+mpi_mul
+mpi_mulm
+mpihelp_cmp
+mpihelp_mod_1
+mpihelp_divrem
+mpihelp_divmod_1
+mul_n_basecase
+mul_n
+mpih_sqr_n_basecase
+mpih_sqr_n
+mpihelp_mul_n
+mpihelp_release_karatsuba_ctx
+mpihelp_mul
+mpihelp_mul_karatsuba_case
+mpi_powm
+mpi_const
+mpi_clear
+mpi_free
+mpi_alloc_limb_space
+mpi_alloc
+mpi_free_limb_space
+mpi_assign_limb_space
+mpi_resize
+mpi_set
+mpi_set_ui
+mpi_copy
+mpi_alloc_like
+mpi_snatch
+mpi_alloc_set_ui
+mpi_swap_cond
+dim_turn
+dim_park_on_top
+dim_park_tired
+dim_on_top
+dim_calc_stats
+net_dim_get_rx_moderation
+net_dim_get_def_rx_moderation
+net_dim_get_tx_moderation
+net_dim_get_def_tx_moderation
+net_dim_step
+net_dim_stats_compare
+net_dim
+rdma_dim
+find_font
+get_default_font
+pldmfw_op_pci_match_record
+pldm_check_fw_space
+pldmfw_flash_image
+rdmsr_safe_regs_on_cpu
+wrmsr_safe_regs_on_cpu
+__rdmsr_on_cpu
+__wrmsr_on_cpu
+__wrmsr_safe_on_cpu
+wrmsr_on_cpu
+wrmsrl_on_cpu
+wrmsr_safe_on_cpu
+wrmsrl_safe_on_cpu
+rdmsr_on_cpu
+rdmsrl_on_cpu
+__rwmsr_on_cpus
+rdmsr_on_cpus
+wrmsr_on_cpus
+__rdmsr_safe_on_cpu
+rdmsr_safe_on_cpu
+rdmsrl_safe_on_cpu
+__rdmsr_safe_regs_on_cpu
+__wrmsr_safe_regs_on_cpu
+__wbinvd
+wbinvd_on_cpu
+wbinvd_on_all_cpus
+__traceiter_read_msr
+__traceiter_write_msr
+__traceiter_rdpmc
+do_trace_write_msr
+do_trace_read_msr
+do_trace_rdpmc
+msrs_free
+msrs_alloc
+msr_read
+msr_write
+msr_set_bit
+msr_clear_bit
+memcpy_fromio
+memcpy_toio
+memset_io
+copy_mc_to_kernel
+enable_copy_mc_fragile
+copy_mc_to_user
+x86_family
+x86_model
+x86_stepping
+do_csum
+csum_partial
+ip_compute_csum
+csum_partial_copy_nocheck
+csum_ipv6_magic
+csum_and_copy_to_user
+csum_and_copy_from_user
+delay_loop
+delay_halt_tpause
+delay_halt_mwaitx
+__delay
+__const_udelay
+__udelay
+__ndelay
+delay_tsc
+delay_halt
+use_mwaitx_delay
+read_current_timer
+override_function_with_return
+inat_get_opcode_attribute
+inat_get_last_prefix_id
+inat_get_escape_attribute
+inat_get_group_attribute
+inat_get_avx_attribute
+get_segment_selector
+get_desc
+is_string_insn
+resolve_default_seg
+get_reg_offset.isra.0
+get_eff_addr_reg
+get_eff_addr_modrm
+get_eff_addr_sib
+insn_has_rep_prefix
+insn_get_seg_base
+get_seg_base_limit
+insn_get_code_seg_params
+insn_get_modrm_rm_off
+insn_get_modrm_reg_off
+insn_get_addr_ref
+insn_fetch_from_user
+insn_decode
+insn_init
+insn_get_prefixes
+insn_get_opcode
+insn_get_modrm
+insn_rip_relative
+insn_get_sib
+insn_get_displacement
+insn_get_immediate
+insn_get_length
+kaslr_get_random_long
+num_digits
+copy_from_user_nmi
+__clear_user
+clear_user
+arch_wb_cache_pmem
+__memcpy_flushcache
+__copy_user_flushcache
+memcpy_page_flushcache
+of_phy_get
+phy_pm_runtime_get_sync
+phy_pm_runtime_put_sync
+phy_pm_runtime_put
+phy_pm_runtime_allow
+phy_pm_runtime_forbid
+devm_of_phy_get
+devm_of_phy_get_by_index
+phy_destroy
+phy_pm_runtime_get
+devm_phy_match
+phy_set_mode_ext
+phy_calibrate
+phy_configure
+phy_validate
+of_phy_provider_unregister
+devm_phy_provider_release
+phy_reset
+phy_power_on
+of_phy_put
+phy_put
+devm_phy_release
+of_phy_simple_xlate
+phy_get
+phy_optional_get
+devm_phy_get
+devm_phy_optional_get
+devm_phy_consume
+phy_release
+phy_remove_lookup
+phy_init
+phy_exit
+phy_power_off
+devm_phy_put
+devm_phy_destroy
+devm_of_phy_provider_unregister
+phy_create_lookup
+phy_create
+devm_phy_create
+__of_phy_provider_register
+__devm_of_phy_provider_register
+pinctrl_add_gpio_range
+pinctrl_add_gpio_ranges
+pinctrl_remove_gpio_range
+pinctrl_dev_get_name
+pinctrl_dev_get_devname
+pinctrl_dev_get_drvdata
+pinctrl_find_gpio_range_from_pin_nolock
+pinctrl_find_gpio_range_from_pin
+devm_pinctrl_match
+pinctrl_get_device_gpio_range
+pinctrl_gpio_can_use_line
+pinctrl_gpio_free
+pinctrl_gpio_direction
+pinctrl_gpio_direction_input
+pinctrl_gpio_direction_output
+pinctrl_gpio_set_config
+devm_pinctrl_dev_match
+pinctrl_gpio_request
+pinctrl_unregister_mappings
+pinctrl_free
+pinctrl_gpioranges_open
+pinctrl_groups_open
+pinctrl_pins_open
+pinctrl_open
+pinctrl_maps_open
+pinctrl_devices_open
+pinctrl_gpioranges_show
+pinctrl_pins_show
+pinctrl_devices_show
+pinctrl_show
+pinctrl_maps_show
+pinctrl_commit_state
+pinctrl_select_state
+pinctrl_select_bound_state
+pinctrl_select_default_state
+pinctrl_pm_select_default_state
+pinctrl_pm_select_sleep_state
+pinctrl_pm_select_idle_state
+pinctrl_force_sleep
+pinctrl_force_default
+pinctrl_free_pindescs
+devm_pinctrl_unregister
+pin_get_name
+pinctrl_groups_show
+devm_pinctrl_put
+pinctrl_register_mappings
+pinctrl_unregister.part.0
+pinctrl_unregister
+devm_pinctrl_dev_release
+create_state
+pinctrl_lookup_state
+pinctrl_init_controller.part.0
+pinctrl_register_and_init
+devm_pinctrl_register_and_init
+devm_pinctrl_release
+pinctrl_put
+pinctrl_provide_dummies
+get_pinctrl_dev_from_devname
+pinctrl_find_and_add_gpio_range
+create_pinctrl
+pinctrl_get
+devm_pinctrl_get
+pinctrl_enable
+pinctrl_register
+devm_pinctrl_register
+get_pinctrl_dev_from_of_node
+pin_get_from_name
+pinctrl_get_group_selector
+pinctrl_get_group_pins
+pinctrl_init_done
+pinctrl_utils_add_map_mux
+pinctrl_utils_add_map_configs
+pinctrl_utils_free_map
+pinctrl_utils_reserve_map
+pinctrl_utils_add_config
+pin_free
+pinmux_pins_open
+pinmux_functions_open
+pinmux_functions_show
+pin_request
+pinmux_pins_show
+pinmux_check_ops
+pinmux_validate_map
+pinmux_can_be_used_for_gpio
+pinmux_request_gpio
+pinmux_free_gpio
+pinmux_gpio_direction
+pinmux_map_to_setting
+pinmux_free_setting
+pinmux_enable_setting
+pinmux_disable_setting
+pinmux_show_map
+pinmux_show_setting
+pinmux_init_device_debugfs
+pinconf_show_config
+pinconf_groups_open
+pinconf_pins_open
+pinconf_groups_show
+pinconf_pins_show
+pinconf_check_ops
+pinconf_validate_map
+pin_config_get_for_pin
+pin_config_group_get
+pinconf_map_to_setting
+pinconf_free_setting
+pinconf_apply_setting
+pinconf_set_config
+pinconf_show_map
+pinconf_show_setting
+pinconf_init_device_debugfs
+pinconf_generic_dump_config
+pinconf_generic_dump_one
+pinconf_generic_dump_pins
+amd_irq_ack
+amd_gpio_remove
+amd_gpio_should_save
+amd_gpio_resume
+amd_gpio_suspend
+amd_gpio_irq_handler
+amd_gpio_irq_set_type
+amd_gpio_irq_eoi
+amd_gpio_irq_unmask
+amd_gpio_irq_mask
+amd_gpio_irq_disable
+amd_gpio_irq_enable
+amd_gpio_set_config
+amd_gpio_set_value
+amd_gpio_get_value
+amd_gpio_direction_output
+amd_gpio_direction_input
+amd_gpio_get_direction
+amd_gpio_dbg_show
+amd_get_group_pins
+amd_pinconf_set
+amd_pinconf_group_set
+amd_pinconf_get
+amd_pinconf_group_get
+amd_get_group_name
+amd_get_groups_count
+amd_gpio_probe
+sx150x_pinctrl_get_groups_count
+sx150x_pinctrl_get_group_name
+sx150x_pinctrl_get_group_pins
+sx150x_irq_bus_lock
+sx150x_regmap_reg_width
+sx150x_reg_volatile
+sx150x_irq_thread_fn
+sx150x_irq_bus_sync_unlock
+sx150x_irq_set_type
+sx150x_irq_unmask
+sx150x_irq_mask
+sx150x_gpio_set_multiple
+__sx150x_gpio_set
+sx150x_pin_is_oscio
+sx150x_gpio_set
+sx150x_gpio_get
+sx150x_gpio_direction_output
+sx150x_gpio_direction_input
+sx150x_gpio_get_direction
+sx150x_pinconf_set
+sx150x_pinconf_get
+sx150x_probe
+sx150x_regmap_reg_read
+sx150x_regmap_reg_write
+byt_gpio_runtime_suspend
+byt_gpio_reg
+byt_gpio_clear_triggering
+byt_gpio_set
+byt_gpio_get
+byt_gpio_direction_input
+byt_gpio_get_direction
+byt_irq_mask
+byt_irq_unmask
+byt_gpio_suspend
+byt_gpio_resume
+byt_pin_config_set
+byt_pin_config_get
+byt_get_function_groups
+byt_get_function_name
+byt_get_functions_count
+byt_get_group_pins
+byt_get_group_name
+byt_get_groups_count
+byt_gpio_disable_free
+byt_get_gpio_mux
+byt_gpio_request_enable
+byt_pinctrl_probe
+byt_init_irq_valid_mask
+byt_gpio_irq_init_hw
+byt_irq_type
+byt_gpio_add_pin_ranges
+byt_gpio_dbg_show
+byt_set_group_simple_mux.isra.0
+byt_set_mux
+byt_gpio_direct_irq_check
+byt_gpio_set_direction
+byt_gpio_direction_output
+byt_irq_ack
+byt_gpio_runtime_resume
+byt_gpio_irq_handler
+chv_pin_dbg_show
+chv_gpio_get
+chv_gpio_get_direction
+chv_gpio_irq_mask_unmask
+chv_gpio_irq_unmask
+chv_gpio_irq_mask
+chv_gpio_clear_triggering
+chv_gpio_disable_free
+chv_config_set_oden
+chv_gpio_set_direction
+chv_gpio_set
+chv_pinctrl_mmio_access_handler
+chv_pinctrl_suspend_noirq
+chv_pinctrl_resume_noirq
+chv_pinctrl_remove
+chv_get_group_pins
+chv_config_set
+chv_config_group_set
+chv_config_get
+chv_config_group_get
+chv_gpio_request_enable
+chv_get_function_groups
+chv_get_function_name
+chv_get_functions_count
+chv_get_group_name
+chv_get_groups_count
+chv_pinmux_set_mux
+chv_pinctrl_probe
+chv_init_irq_valid_mask
+chv_gpio_irq_type
+chv_gpio_irq_init_hw
+chv_gpio_irq_startup
+chv_gpio_irq_handler
+chv_gpio_add_pin_ranges
+chv_gpio_direction_output
+chv_gpio_direction_input
+chv_gpio_irq_ack
+intel_gpio_to_pin
+intel_get_function_groups
+intel_get_function_name
+intel_get_functions_count
+intel_get_group_pins
+intel_get_group_name
+intel_get_groups_count
+intel_gpio_irq
+intel_gpio_irq_mask_unmask
+intel_gpio_irq_unmask
+intel_gpio_irq_mask
+intel_gpio_irq_ack
+intel_gpio_irq_wake
+intel_gpio_add_pin_ranges
+intel_gpio_direction_input
+intel_pinctrl_probe
+intel_pinctrl_probe_by_hid
+intel_pinctrl_get_soc_data
+intel_pinctrl_probe_by_uid
+intel_get_community
+intel_pad_owned_by_host
+intel_pad_locked
+intel_pad_usable
+intel_get_padcfg
+intel_gpio_set_direction
+intel_gpio_request_enable
+intel_gpio_set
+intel_gpio_direction_output
+intel_gpio_get
+intel_gpio_get_direction
+intel_pinmux_set_mux
+intel_restore_padcfg
+intel_config_set
+intel_pad_acpi_mode
+intel_pin_dbg_show
+intel_gpio_irq_type
+intel_pinctrl_should_save
+intel_pinctrl_suspend_noirq
+intel_pinctrl_resume_noirq
+intel_config_get
+gpiochip_child_offset_to_irq_noop
+gpiolib_seq_stop
+__traceiter_gpio_direction
+__traceiter_gpio_value
+gpiochip_get_desc
+desc_to_gpio
+gpiod_to_chip
+gpiochip_get_data
+gpiochip_find
+gpiochip_irqchip_add_domain
+gpio_set_bias
+gpiolib_seq_start
+gpiolib_seq_next
+gpiod_get_direction
+gpiochip_line_is_valid
+gpiochip_is_requested
+gpiod_to_irq
+gpiochip_irqchip_irq_valid
+gpiochip_disable_irq
+gpiochip_irq_mask
+gpiochip_irq_disable
+gpiochip_enable_irq
+gpiochip_irq_unmask
+gpiochip_irq_enable
+gpiod_request_commit
+gpiodevice_release
+validate_desc
+gpiod_set_config
+gpiod_set_debounce
+gpiod_is_active_low
+gpiod_toggle_active_low
+gpiod_set_consumer_name
+gpiochip_populate_parent_fwspec_twocell
+gpiochip_populate_parent_fwspec_fourcell
+gpio_name_to_desc
+gpiochip_unlock_as_irq
+gpiochip_irq_domain_deactivate
+gpiochip_match_name
+gpiochip_allocate_mask
+gpiod_add_lookup_table
+gpiod_remove_lookup_table
+gpiod_find_lookup_table
+gpiochip_to_irq
+gpiod_set_transitory
+gpiochip_hierarchy_irq_domain_alloc
+gpiochip_set_irq_hooks
+gpiochip_irqchip_add_key
+gpiochip_irqchip_remove
+gpiochip_generic_request
+gpiochip_generic_free
+gpiochip_generic_config
+gpiochip_remove_pin_ranges
+gpiochip_relres_irq
+gpiochip_irq_relres
+gpiod_count
+gpiochip_lock_as_irq
+gpiochip_irq_domain_activate
+gpiochip_reqres_irq
+gpiochip_irq_reqres
+gpiod_cansleep
+gpiochip_irq_unmap
+gpiod_free_commit
+gpiochip_free_own_desc
+gpiochip_free_hogs
+gpiochip_remove
+gpiolib_seq_show
+gpiochip_line_is_irq
+gpiochip_line_is_persistent
+gpiod_direction_input
+gpio_to_desc
+gpiochip_hierarchy_irq_domain_translate
+gpiochip_irq_map
+gpiochip_setup_dev
+gpio_chip_get_multiple
+gpio_chip_set_multiple
+gpiolib_open
+gpiochip_set_nested_irqchip
+gpiochip_line_is_open_drain
+gpiochip_line_is_open_source
+gpiochip_add_pingroup_range
+gpiochip_add_pin_range
+gpio_set_open_drain_value_commit
+gpio_set_open_source_value_commit
+gpiod_set_raw_value_commit
+gpiod_set_raw_value_cansleep
+gpiod_set_value_nocheck
+gpiod_set_value_cansleep
+gpiod_set_value
+gpiod_set_raw_value
+gpiod_get_raw_value_commit
+gpiod_get_raw_value_cansleep
+gpiod_get_value_cansleep
+gpiod_get_raw_value
+gpiod_get_value
+gpiod_direction_output_raw_commit
+gpiod_direction_output_raw
+gpiod_direction_output
+gpiod_request
+gpiod_free
+gpiod_put
+gpiod_put_array
+gpiod_get_array_value_complex
+gpiod_get_raw_array_value
+gpiod_get_array_value
+gpiod_get_raw_array_value_cansleep
+gpiod_get_array_value_cansleep
+gpiod_set_array_value_complex
+gpiod_set_raw_array_value
+gpiod_set_array_value
+gpiod_set_raw_array_value_cansleep
+gpiod_set_array_value_cansleep
+gpiod_add_lookup_tables
+gpiod_configure_flags
+gpiochip_request_own_desc
+gpiod_get_index
+gpiod_get
+gpiod_get_index_optional
+gpiod_get_optional
+gpiod_get_array
+gpiod_get_array_optional
+fwnode_get_named_gpiod
+fwnode_gpiod_get_index
+gpiod_hog
+gpiochip_machine_hog
+gpiochip_add_data_with_key
+gpiod_add_hogs
+devm_gpiod_get_from_of_node
+devm_gpiod_match
+devm_gpiod_match_array
+devm_gpio_match
+devm_gpiod_release
+devm_gpiod_get_index
+devm_gpiod_get
+devm_gpiod_get_index_optional
+devm_gpiod_get_optional
+devm_fwnode_gpiod_get_index
+devm_gpiod_get_array
+devm_gpiod_get_array_optional
+devm_gpiod_release_array
+devm_gpio_request
+devm_gpio_release
+devm_gpio_request_one
+devm_gpiochip_add_data_with_key
+devm_gpio_chip_release
+devm_gpiod_put
+devm_gpiod_put_array
+devm_gpio_free
+devm_gpiod_unhinge
+gpio_free
+gpio_request
+gpio_request_one
+gpio_free_array
+gpio_request_array
+linehandle_validate_flags
+linehandle_flags_to_desc_flags
+gpio_v2_line_config_flags_to_desc_flags
+gpio_chrdev_release
+gpio_v2_line_config_debounce_period
+gpio_v2_line_config_debounced
+gpio_v2_line_config_flags
+gpio_v2_line_config_output_value
+lineevent_irq_handler
+edge_irq_handler
+gpio_desc_to_lineinfo
+linehandle_free
+linehandle_release
+lineevent_free
+lineevent_release
+gpio_v2_line_info_to_v1
+lineevent_ioctl
+lineevent_ioctl_compat
+edge_detector_stop
+edge_detector_setup
+debounce_irq_handler
+linereq_free
+linereq_release
+linehandle_set_config
+linehandle_ioctl
+linehandle_ioctl_compat
+gpio_v2_line_config_validate
+linereq_set_config
+lineinfo_changed_notify.part.0
+lineinfo_changed_notify
+gpio_chrdev_open
+linehandle_create
+lineinfo_watch_poll
+lineevent_poll
+linereq_poll
+linereq_put_event
+edge_irq_thread
+debounce_work_func
+lineevent_irq_thread
+lineevent_read
+lineinfo_watch_read
+linereq_read
+linereq_create
+gpio_ioctl
+gpio_ioctl_compat
+linereq_ioctl
+linereq_ioctl_compat
+gpiolib_cdev_register
+gpiolib_cdev_unregister
+unexport_store
+match_export
+gpio_sysfs_free_irq
+gpio_sysfs_irq
+gpio_sysfs_request_irq
+active_low_store
+active_low_show
+edge_show
+ngpio_show
+label_show
+base_show
+value_store
+value_show
+edge_store
+direction_store
+direction_show
+gpiod_unexport
+gpio_is_visible
+gpiod_export_link
+gpiod_export
+export_store
+gpiochip_sysfs_register
+gpiochip_sysfs_unregister
+acpi_gpio_chip_dh
+acpi_gpio_get_irq_resource
+acpi_dev_add_driver_gpios
+acpi_dev_remove_driver_gpios
+acpi_find_gpio_count
+devm_acpi_dev_release_driver_gpios
+acpi_gpiochip_find
+acpi_gpio_irq_handler_evt
+acpi_gpio_irq_handler
+devm_acpi_dev_add_driver_gpios
+acpi_gpiochip_request_irq
+acpi_gpiochip_request_interrupts
+acpi_gpiochip_free_interrupts
+acpi_gpio_property_lookup
+devm_acpi_dev_remove_driver_gpios
+acpi_gpio_resource_lookup
+acpi_get_gpiod_by_index.part.0
+acpi_dev_gpio_irq_get
+acpi_populate_gpio_lookup
+acpi_gpiochip_alloc_event
+acpi_gpio_adr_space_handler
+acpi_gpio_update_gpiod_flags
+acpi_gpio_update_gpiod_lookup_flags
+acpi_find_gpio
+acpi_node_get_gpiod
+acpi_gpiochip_add
+acpi_gpiochip_remove
+acpi_gpio_count
+crystalcove_bus_lock
+crystalcove_gpio_irq_handler
+crystalcove_irq_type
+crystalcove_irq_unmask
+crystalcove_irq_mask
+crystalcove_gpio_probe
+crystalcove_gpio_dbg_show
+crystalcove_bus_sync_unlock
+crystalcove_gpio_dir_in
+crystalcove_gpio_dir_out
+crystalcove_gpio_get
+crystalcove_gpio_set
+palmas_gpio_get
+palmas_gpio_set
+palmas_gpio_to_irq
+palmas_gpio_output
+palmas_gpio_input
+palmas_gpio_probe
+rc5t583_gpio_to_irq
+rc5t583_gpio_get
+rc5t583_gpio_free
+rc5t583_gpio_set
+rc5t583_gpio_dir_output
+rc5t583_gpio_dir_input
+rc5t583_gpio_probe
+tps6586x_gpio_to_irq
+tps6586x_gpio_get
+tps6586x_gpio_set
+tps6586x_gpio_output
+tps6586x_gpio_probe
+tps65910_gpio_get
+tps65910_gpio_input
+tps65910_gpio_set
+tps65910_gpio_output
+tps65910_gpio_probe
+__traceiter_pwm_apply
+__traceiter_pwm_get
+pwm_set_chip_data
+pwm_get_chip_data
+devm_pwm_match
+pwm_capture
+pwm_seq_stop
+pwmchip_remove
+pwm_device_request
+pwm_request
+pwmchip_find_by_name
+pwm_seq_next
+pwm_seq_start
+pwm_apply_state
+pwm_adjust_config
+pwm_seq_show
+pwm_request_from_chip.part.0
+pwm_request_from_chip
+acpi_pwm_get
+of_pwm_xlate_with_flags
+pwm_put.part.0
+pwm_put
+pwm_free
+devm_pwm_release
+pwm_get
+devm_pwm_get
+devm_of_pwm_get
+devm_pwm_put
+pwm_debugfs_open
+pwmchip_add_with_polarity
+pwmchip_add
+devm_fwnode_pwm_get
+of_pwm_get
+pwm_add_table
+pwm_remove_table
+pwm_export_release
+pwmchip_sysfs_match
+pwm_class_get_state
+pwm_unexport_match
+polarity_show
+duty_cycle_show
+period_show
+capture_show
+npwm_show
+pwm_unexport_child
+unexport_store
+polarity_store
+enable_store
+duty_cycle_store
+period_store
+pwm_class_resume_npwm
+pwm_class_resume
+pwm_class_suspend
+enable_show
+export_store
+pwmchip_sysfs_export
+pwmchip_sysfs_unexport
+crystalcove_pwm_remove
+crc_pwm_get_state
+crystalcove_pwm_probe
+crc_pwm_apply
+pwm_lpss_get_state
+pwm_lpss_probe
+pwm_lpss_remove
+pwm_lpss_prepare_enable
+pwm_lpss_apply
+pwm_lpss_runtime_suspend_pci
+pwm_lpss_remove_pci
+pwm_lpss_probe_pci
+pwm_lpss_runtime_resume_pci
+pwm_lpss_remove_platform
+pwm_lpss_probe_platform
+pwm_lpss_prepare
+pci_cfg_access_trylock
+pci_cfg_access_unlock
+pci_bus_read_config_byte
+pci_bus_read_config_word
+pci_bus_read_config_dword
+pci_bus_write_config_byte
+pci_bus_write_config_word
+pci_bus_write_config_dword
+pci_generic_config_read
+pci_generic_config_write
+pci_bus_set_ops
+pci_read_config_byte
+pci_read_config_word
+pci_read_config_dword
+pci_write_config_byte
+pci_write_config_word
+pci_write_config_dword
+pci_generic_config_read32
+pci_generic_config_write32
+pcie_capability_reg_implemented.part.0
+pcie_capability_write_word
+pcie_capability_write_dword
+pcie_capability_read_word
+pcie_capability_clear_and_set_word
+pcie_capability_read_dword
+pcie_capability_clear_and_set_dword
+pci_wait_cfg
+pci_user_read_config_dword
+pci_cfg_access_lock
+pci_user_write_config_byte
+pci_user_read_config_byte
+pci_user_write_config_word
+pci_user_write_config_dword
+pci_user_read_config_word
+pcie_cap_has_lnkctl
+pcie_cap_has_rtctl
+pci_free_resource_list
+pci_add_resource_offset
+pci_add_resource
+devm_request_pci_bus_resources
+pci_walk_bus
+pci_bus_resource_n.part.0
+pci_bus_resource_n
+pci_bus_alloc_from_region
+pci_bus_alloc_resource
+pci_bus_add_resource
+pci_bus_remove_resources
+pci_bus_clip_resource
+pci_bus_clip_resource
+pcibios_bus_add_device
+pci_bus_add_device
+pci_bus_add_devices
+pci_bus_get
+pci_bus_put
+pci_speed_string
+pci_free_host_bridge
+devm_pci_alloc_host_bridge_release
+no_pci_devices
+pci_cfg_space_size_ext
+pcie_relaxed_ordering_enabled
+pci_lock_rescan_remove
+pci_unlock_rescan_remove
+pcie_update_link_speed
+release_pcibus_dev
+pci_release_host_bridge_dev
+pci_set_bus_msi_domain
+pci_release_dev
+next_fn
+pci_read_irq.part.0
+pcie_bus_configure_set.part.0
+pcie_bus_configure_set
+pcie_bus_configure_settings
+pci_alloc_host_bridge
+devm_pci_alloc_host_bridge
+pcie_find_smpss
+pci_alloc_dev
+pci_alloc_bus.isra.0
+__pci_read_base
+pci_read_bases
+pci_read_bridge_bases
+set_pcie_port_type
+set_pcie_hotplug_bridge
+pci_cfg_space_size
+pci_setup_device
+pci_configure_extended_tags
+pci_bus_generic_read_dev_vendor_id
+pci_bus_read_dev_vendor_id
+pcie_report_downtraining
+pci_device_add
+pci_scan_single_device
+pci_scan_slot
+pci_scan_slot
+pci_scan_slot
+pci_scan_slot
+pci_add_new_bus
+pci_add_new_bus
+pci_bus_insert_busn_res
+pci_register_host_bridge
+pci_create_root_bus
+pci_bus_update_busn_res_end
+pci_scan_bridge_extend
+pci_scan_bridge
+pci_scan_child_bus_extend
+pci_scan_child_bus
+pci_scan_bus
+pci_rescan_bus
+pci_hp_add_bridge
+pci_scan_root_bus_bridge
+pci_host_probe
+pci_scan_root_bus
+pci_bus_release_busn_res
+pci_rescan_bus_bridge_resize
+pci_set_host_bridge_release
+pcibios_resource_to_bus
+pcibios_bus_to_resource
+pci_find_host_bridge
+pci_get_host_bridge_device
+pci_put_host_bridge_device
+pci_remove_bus
+pci_stop_bus_device
+pci_remove_bus_device
+pci_stop_and_remove_bus_device
+pci_stop_and_remove_bus_device_locked
+pci_stop_root_bus
+pci_remove_root_bus
+pci_unmap_iospace
+pci_fixup_cardbus
+pci_status_get_and_clear_errors
+pci_clear_mwi
+pci_wakeup
+__pci_set_master
+pci_clear_master
+pcie_wait_for_link_delay
+pcie_get_readrq
+pcie_get_mps
+pci_restore_config_dword
+pci_bus_max_busnr
+__pci_dev_set_current_state
+devm_pci_unmap_iospace
+pci_check_and_set_intx_mask
+pci_check_and_mask_intx
+pci_check_and_unmask_intx
+pci_bus_resetable
+pci_ignore_hotplug
+pci_acs_flags_enabled
+pci_ioremap_bar
+__pci_find_next_cap_ttl
+pci_find_next_capability
+__pci_find_next_ht_cap
+pci_find_next_ht_capability
+pci_target_state
+pci_select_bars
+pci_raw_set_power_state
+pci_choose_state
+pcie_bandwidth_available
+pci_dev_str_match
+pci_common_swizzle
+pcie_get_width_cap
+pci_enable_atomic_ops_to_root
+pcie_set_readrq
+pcie_set_mps
+devm_pci_remap_cfgspace
+devm_pci_remap_cfg_resource
+pci_set_cacheline_size
+pci_reset_hotplug_slot
+pci_dev_reset_slot_function
+pci_bus_lock
+pci_bus_unlock
+pci_slot_unlock
+pci_slot_reset
+pci_probe_reset_slot
+pci_ats_disabled
+_pci_find_saved_cap
+pci_load_saved_state
+pci_load_and_free_saved_state
+pci_enable_acs
+__pci_bus_find_cap_start
+pci_bus_find_capability
+pci_find_capability
+pcix_get_max_mmrbc
+pcix_get_mmrbc
+pcix_set_mmrbc
+pci_find_ht_capability
+pci_find_resource
+__pci_pme_active.part.0
+pci_pme_active
+pci_ioremap_wc_bar
+pci_find_next_ext_capability.part.0
+pci_find_next_ext_capability
+pci_find_ext_capability.part.0
+pci_find_ext_capability
+pci_get_dsn
+pci_rebar_find_pos
+pci_pme_capable.part.0
+pci_pme_capable
+pci_dev_run_wake
+pci_dev_check_d3cold
+find_pci_dr.part.0
+pcim_pin_device
+pci_release_region
+pci_release_selected_regions
+pci_release_regions
+__pci_request_region
+pci_request_region
+__pci_request_selected_regions
+pci_request_selected_regions
+pci_request_regions
+pci_request_selected_regions_exclusive
+pci_request_regions_exclusive
+pci_intx
+__pci_enable_wake
+pci_enable_wake
+pci_wake_from_d3
+pcie_has_flr.part.0
+pcie_has_flr
+pcie_get_speed_cap
+pci_set_mwi
+pcim_set_mwi
+pci_try_set_mwi
+pci_dev_trylock
+pci_bus_trylock
+pci_pr3_present
+pci_device_is_present.part.0
+pci_device_is_present
+pci_remap_iospace
+devm_pci_remap_iospace
+pci_save_state
+pci_restore_state.part.0
+pci_restore_state
+pci_dev_restore
+pci_bus_restore_locked
+pci_dev_wait.constprop.0
+pci_store_saved_state
+pci_probe_reset_bus
+pci_find_parent_resource
+resource_alignment_store
+resource_alignment_show
+_pci_add_cap_save_buffer
+pci_wait_for_pending
+pci_wait_for_pending_transaction
+pcie_flr
+pci_af_flr
+pci_request_acs
+pci_set_platform_pm
+pci_update_current_state
+pci_platform_power_transition
+pci_refresh_power_state
+pci_wakeup_bus
+pci_power_up
+pci_set_power_state
+pci_prepare_to_sleep
+pci_back_from_sleep
+pci_dev_save_and_disable
+pci_bus_save_and_disable_locked
+pci_bus_set_current_state
+pci_find_saved_cap
+pci_find_saved_ext_cap
+pci_find_saved_ext_cap
+do_pci_enable_device
+pci_reenable_device
+pci_reenable_device
+pci_reenable_device
+pci_reenable_device
+do_pci_disable_device
+pci_disable_device
+pcim_release
+pcim_release
+pci_disable_enabled_device
+pcibios_set_pcie_reset_state
+pci_set_pcie_reset_state
+pcie_clear_device_status
+pcie_clear_root_pme_status
+pci_check_pme_status
+pci_pme_wakeup
+pci_pme_list_scan
+pci_pme_wakeup_bus
+pci_pme_restore
+pci_finish_runtime_suspend
+pci_dev_need_resume
+pci_dev_adjust_pme
+pci_dev_complete_resume
+pci_config_pm_runtime_get
+pci_config_pm_runtime_put
+pci_bridge_d3_possible
+pci_bridge_d3_update
+pci_d3cold_enable
+pci_d3cold_disable
+pci_pm_init
+pci_ea_init
+pci_add_cap_save_buffer
+pci_add_ext_cap_save_buffer
+pci_allocate_cap_save_buffers
+pci_free_cap_save_buffers
+pci_configure_ari
+pci_acs_enabled
+pci_acs_path_enabled
+pci_acs_init
+pci_rebar_get_possible_sizes
+pci_rebar_get_current_size
+pci_rebar_set_size
+pci_swizzle_interrupt_pin
+pci_get_interrupt_pin
+pci_register_io_range
+pci_pio_to_address
+pci_address_to_pio
+pcibios_set_master
+pci_set_master
+pci_enable_bridge
+pci_enable_device_flags
+pci_enable_device_io
+pci_enable_device_mem
+pci_enable_device
+pcim_enable_device
+pcie_wait_for_link
+pci_bridge_wait_for_secondary_bus
+pci_reset_secondary_bus
+pcibios_reset_secondary_bus
+pci_bridge_secondary_bus_reset
+pci_parent_bus_reset
+__pci_reset_function_locked
+pci_reset_function
+pci_reset_function_locked
+pci_try_reset_function
+pci_reset_bus
+pci_probe_reset_function
+pci_bus_error_reset
+pcie_bandwidth_capable
+__pcie_print_link_status
+pcie_print_link_status
+pci_set_vga_state
+pci_add_dma_alias
+pci_add_dma_alias
+pci_devs_are_dma_aliases
+pcibios_default_alignment
+pci_resource_to_user
+pci_reassigndev_resource_alignment
+pci_reassigndev_resource_alignment
+pci_dev_get
+pci_dev_put
+pci_pm_default_resume
+pci_pm_default_resume_early
+pci_pm_resume_early
+pci_pm_reenable_device
+pci_bus_num_vf
+pci_pm_runtime_idle
+__pci_register_driver
+pci_restore_standard_config
+pci_pm_runtime_resume
+pci_legacy_resume
+pci_pm_prepare
+pci_pm_complete
+pci_dma_configure
+local_pci_probe
+pci_uevent
+remove_id_store
+pci_pm_runtime_suspend
+pci_legacy_suspend
+pci_device_shutdown
+pci_pm_poweroff_late
+pci_pm_suspend_late
+pci_legacy_suspend_late.isra.0
+pci_dev_driver
+pcie_port_bus_match
+pci_has_legacy_pm_support
+pci_pm_thaw_noirq
+pci_pm_restore_noirq
+pci_pm_freeze_noirq
+pci_pm_poweroff_noirq
+pci_pm_resume_noirq
+pci_pm_restore
+pci_pm_thaw
+pci_pm_resume
+pci_pm_poweroff
+pci_pm_freeze
+pci_pm_suspend_noirq
+pci_pm_suspend
+pci_match_id.part.0
+pci_match_id
+pci_unregister_driver
+pci_add_dynid
+new_id_store
+pci_match_device
+pci_bus_match
+pcibios_alloc_irq
+pcibios_free_irq
+pci_device_remove
+pci_device_probe
+pci_uevent_ers
+pci_get_dev_by_id
+pci_get_subsys
+pci_get_device
+pci_get_class
+match_pci_dev_by_id
+pci_do_find_bus
+pci_find_next_bus
+pci_find_bus
+pci_get_slot
+pci_get_domain_bus_and_slot
+pci_dev_present
+pci_for_each_dma_alias
+rescan_store
+broken_parity_status_store
+d3cold_allowed_show
+broken_parity_status_show
+reset_store
+d3cold_allowed_store
+max_link_speed_show
+max_link_width_show
+current_link_width_show
+current_link_speed_show
+secondary_bus_number_show
+subordinate_bus_number_show
+remove_store
+enable_show
+local_cpulist_show
+local_cpus_show
+cpulistaffinity_show
+cpuaffinity_show
+pci_write_rom
+pci_dev_attrs_are_visible
+pci_dev_hp_attrs_are_visible
+pci_bridge_attrs_are_visible
+pcie_dev_attrs_are_visible
+dev_rescan_store
+bus_rescan_store
+pci_remove_resource_files
+pci_read_rom
+pci_write_config
+pci_read_config
+ari_enabled_show
+msi_bus_show
+consistent_dma_mask_bits_show
+dma_mask_bits_show
+numa_node_show
+modalias_show
+irq_show
+class_show
+revision_show
+subsystem_device_show
+subsystem_vendor_show
+device_show
+vendor_show
+resource_show
+driver_override_store
+driver_override_show
+msi_bus_store
+enable_store
+numa_node_store
+boot_vga_show
+pci_write_resource_io
+pci_create_attr
+pci_read_resource_io
+pci_mmap_fits
+pci_mmap_resource
+pci_mmap_resource_uc
+pci_mmap_resource_wc
+pci_create_sysfs_dev_files
+pci_remove_sysfs_dev_files
+pci_enable_rom
+pci_disable_rom.part.0
+pci_disable_rom
+pci_unmap_rom
+pci_map_rom
+pci_map_rom
+pci_claim_resource
+_pci_assign_resource
+pci_resize_resource
+pci_update_resource
+pci_disable_bridge_window
+pci_disable_bridge_window
+pci_assign_resource
+pci_reassign_resource
+pci_enable_resources
+pci_request_irq
+pci_free_irq
+pci_read_vpd
+pci_vpd_size
+pci_write_vpd
+pci_set_vpd_size
+pci_vpd_set_size
+read_vpd_attr
+write_vpd_attr
+pci_vpd_find_tag
+pci_vpd_find_info_keyword
+quirk_brcm_570x_limit_vpd
+quirk_blacklist_vpd
+pci_vpd_wait
+pci_vpd_write
+pci_vpd_read
+pci_vpd_f0_set_size
+pci_vpd_f0_write
+pci_vpd_f0_read
+quirk_f0_vpd_link
+quirk_chelsio_extend_vpd
+pci_vpd_init
+pci_vpd_release
+pcie_vpd_create_sysfs_dev_files
+pcie_vpd_remove_sysfs_dev_files
+pci_bus_get_depth
+iov_resources_unassigned
+pci_setup_cardbus
+pci_setup_bridge_mmio
+pci_setup_bridge_mmio_pref
+pci_setup_bridge_io
+__pci_setup_bridge
+pci_bus_allocate_dev_resources
+find_bus_resource_of_type
+pci_bus_dump_resources
+remove_from_list
+free_list
+pci_bus_release_bridge_resources
+adjust_bridge_window
+add_to_list
+assign_requested_resources_sorted
+__dev_sort_resources
+__assign_resources_sorted
+pci_bus_distribute_available_resources
+pci_bridge_distribute_available_resources
+pcibios_setup_bridge
+pci_setup_bridge
+pci_claim_bridge_resource
+pci_bus_allocate_resources
+pci_bus_claim_resources
+pcibios_window_alignment
+window_alignment
+pbus_size_mem
+pci_cardbus_resource_alignment
+__pci_bus_size_bridges
+pci_bus_size_bridges
+__pci_bus_assign_resources
+pci_bus_assign_resources
+__pci_bridge_assign_resources
+pci_assign_unassigned_bridge_resources
+pci_assign_unassigned_bus_resources
+pci_assign_unassigned_root_bus_resources
+pci_reassign_bridge_resources
+pci_vc_save_restore_dwords
+pci_vc_do_save_buffer
+pci_save_vc_state
+pci_restore_vc_state
+pci_allocate_vc_save_buffers
+pci_mmap_resource_range
+pci_mmap_page_range
+pci_assign_irq
+pcie_port_shutdown_service
+release_pcie_device
+pcie_port_find_device
+pcie_port_service_unregister
+pm_iter
+find_service_iter
+pcie_port_remove_service
+remove_iter
+pcie_port_probe_service
+pcie_port_service_register
+pcie_port_device_register
+pcie_port_device_suspend
+pcie_port_device_resume_noirq
+pcie_port_device_resume
+pcie_port_device_runtime_suspend
+pcie_port_device_runtime_resume
+pcie_port_device_remove
+pcie_port_runtime_idle
+pcie_portdrv_error_detected
+pcie_portdrv_mmio_enabled
+pcie_port_runtime_suspend
+pcie_portdrv_err_resume
+pcie_portdrv_slot_reset
+pcie_portdrv_remove
+resume_iter
+pcie_portdrv_probe
+report_resume
+merge_result.part.0
+report_slot_reset
+report_mmio_enabled
+report_error_detected
+report_normal_detected
+report_frozen_detected
+pcie_do_recovery
+pci_clear_and_set_dword
+pcie_aspm_get_policy
+pcie_aspm_get_link
+pcie_aspm_enabled
+clkpm_show
+aspm_ctrl_attrs_are_visible
+pcie_config_aspm_link
+pcie_config_aspm_path
+pcie_set_clkpm_nocheck
+__pci_disable_link_state
+pci_disable_link_state_locked
+pci_disable_link_state
+pcie_aspm_set_policy
+pcie_aspm_support_enabled
+clkpm_store
+calc_l1ss_pwron
+pcie_aspm_check_latency.part.0
+pcie_update_aspm_capable
+aspm_attr_store_common.constprop.0
+l0s_aspm_store
+l1_aspm_store
+l1_1_aspm_store
+l1_2_aspm_store
+l1_1_pcipm_store
+l1_2_pcipm_store
+aspm_attr_show_common.constprop.0
+l0s_aspm_show
+l1_aspm_show
+l1_1_aspm_show
+l1_2_aspm_show
+l1_1_pcipm_show
+l1_2_pcipm_show
+pcie_aspm_init_link_state
+pcie_aspm_exit_link_state
+pcie_aspm_pm_state_change
+pcie_aspm_powersave_config_link
+pcie_no_aspm
+cper_severity_to_aer
+aer_stats_attrs_are_visible
+aer_rootport_total_err_nonfatal_show
+aer_rootport_total_err_fatal_show
+aer_rootport_total_err_cor_show
+aer_dev_nonfatal_show
+aer_dev_fatal_show
+aer_dev_correctable_show
+__aer_print_error
+aer_irq
+aer_root_reset
+aer_print_port_info
+aer_recover_queue
+find_device_iter
+find_source_device
+pci_no_aer
+pci_aer_available
+pcie_aer_is_native
+pci_enable_pcie_error_reporting
+pci_disable_pcie_error_reporting
+set_device_error_reporting
+set_downstream_devices_error_reporting
+aer_remove
+aer_probe
+pci_aer_clear_nonfatal_status
+pci_aer_clear_fatal_status
+pci_aer_raw_clear_status
+pci_aer_clear_status
+pci_save_aer_state
+pci_restore_aer_state
+pci_aer_init
+pci_aer_exit
+aer_print_error
+cper_print_aer
+aer_recover_work_func
+aer_get_device_error_info
+aer_isr
+pcie_pme_can_wakeup
+pcie_pme_check_wakeup
+pcie_pme_walk_bus
+pcie_pme_irq
+pcie_pme_from_pci_bridge.part.0
+pcie_pme_interrupt_enable.part.0
+pcie_pme_probe
+pcie_pme_disable_interrupt
+pcie_pme_suspend
+pcie_pme_remove
+pcie_pme_work_fn
+pcie_pme_resume
+pcie_pme_interrupt_enable
+dpc_remove
+dpc_irq
+dpc_reset_link
+dpc_probe
+pci_save_dpc_state
+pci_restore_dpc_state
+dpc_process_error
+dpc_handler
+pci_dpc_init
+pci_ptm_info
+pci_enable_ptm
+pci_ptm_init
+edr_handle_event
+pci_acpi_add_edr_notifier
+pci_acpi_remove_edr_notifier
+pci_seq_stop
+proc_bus_pci_open
+proc_bus_pci_mmap
+proc_bus_pci_ioctl
+proc_bus_pci_release
+proc_bus_pci_lseek
+pci_seq_next
+pci_seq_start
+proc_bus_pci_read
+show_device
+proc_bus_pci_write
+pci_proc_attach_device
+pci_proc_detach_device
+pci_proc_detach_bus
+pci_slot_attr_show
+pci_slot_attr_store
+pci_slot_release
+pci_destroy_slot
+cur_speed_read_file
+max_speed_read_file
+pci_hp_create_module_link
+pci_hp_remove_module_link
+pci_slot_init
+make_slot_name
+address_read_file
+pci_create_slot
+pci_dev_assign_slot
+pci_acpi_bus_match
+acpi_pci_get_power_state
+acpi_pci_power_manageable
+program_hpx_type0
+program_type3_hpx_record
+pci_acpi_wake_bus
+pci_acpi_wake_dev
+acpi_pci_need_resume
+acpi_pci_choose_state
+acpi_pci_refresh_power_state
+acpi_pci_set_power_state
+acpi_pci_find_companion
+pci_acpi_cleanup
+acpi_pci_wakeup
+pci_acpi_setup
+acpi_pci_bridge_d3
+acpi_pci_root_get_mcfg_addr
+pci_acpi_program_hp_params
+pciehp_is_native
+shpchp_is_native
+pci_acpi_add_bus_pm_notifier
+pci_acpi_add_pm_notifier
+acpi_pci_add_bus
+acpi_pci_remove_bus
+pci_msi_register_fwnode_provider
+pci_host_bridge_acpi_msi_domain
+quirk_mmio_always_on
+quirk_mellanox_tavor
+quirk_transparent_bridge
+quirk_pcie_mch
+quirk_intel_pcie_pm
+quirk_hotplug_bridge
+quirk_broken_intx_masking
+pci_quirk_xgene_acs
+pci_quirk_mf_endpoint_acs
+quirk_passive_release
+quirk_via_vt8237_bypass_apic_deassert
+quirk_mediagx_master
+quirk_sis_96x_smbus
+quirk_nvidia_ck804_pcie_aer_ext_cap
+quirk_unhide_mch_dev6
+quirk_tigerpoint_bm_sts
+piix4_io_quirk
+ich6_lpc_generic_decode
+ich7_lpc_generic_decode
+quirk_via_cx700_pci_parking_caching
+quirk_vt82c598_id
+quirk_cardbus_legacy
+quirk_amd_ordering
+vtd_mask_spec_errors
+asus_hides_smbus_lpc_ich6_resume_early
+asus_hides_smbus_lpc_ich6_resume
+pci_quirk_al_acs
+pci_quirk_rciep_acs
+quirk_fsl_no_msi
+quirk_citrine
+quirk_nfp6000
+quirk_s3_64M
+quirk_dunord
+quirk_no_ata_d3
+quirk_eisa_bridge
+quirk_tc86c001_ide
+quirk_msi_intx_disable_bug
+fixup_mpss_256
+quirk_remove_d3hot_delay
+quirk_no_bus_reset
+quirk_no_pm_reset
+quirk_use_pcie_bridge_dma_alias
+quirk_bridge_cavm_thrx2_pcie_root
+pci_quirk_cavium_acs
+pci_quirk_zhaoxin_pcie_ports_acs
+quirk_no_flr
+apex_pci_fixup_class
+quirk_extend_bar_to_page
+quirk_amd_nl_class
+quirk_synopsys_haps
+quirk_amd_8131_mmrbc
+quirk_ryzen_xhci_d3hot
+quirk_netmos
+fixup_rev1_53c810
+fixup_ti816x_class
+quirk_tw686x_class
+quirk_relaxedordering_disable
+dmi_disable_ioapicreroute
+quirk_via_acpi
+quirk_intel_ntb
+quirk_amd_ide_mode
+quirk_svwks_csb5ide
+quirk_ide_samemode
+quirk_vialatency
+quirk_msi_intx_disable_ati_bug
+quirk_io
+quirk_sis_503
+quirk_io_region
+quirk_ali7101_acpi
+quirk_vt8235_acpi
+quirk_disable_msi
+quirk_via_vlink
+quirk_disable_intel_boot_interrupt
+quirk_nvidia_hda
+asus_hides_smbus_hostbridge
+quirk_e100_interrupt
+quirk_disable_all_msi
+quirk_amd_780_apc_msi
+msi_ht_cap_enabled
+quirk_msi_ht_cap
+quirk_nvidia_ck804_msi_ht_cap
+ht_enable_msi_mapping
+ht_check_msi_mapping
+ricoh_mmc_fixup_rl5c476
+ricoh_mmc_fixup_r5c832
+disable_igfx_irq
+reset_intel_82599_sfp_virtfn
+quirk_dma_func0_alias
+quirk_dma_func1_alias
+quirk_mic_x200_dma_alias
+quirk_pex_vca_alias
+quirk_fixed_dma_alias
+quirk_chelsio_T5_disable_root_port_attributes
+pci_quirk_amd_sb_acs
+quirk_no_ext_tags
+quirk_switchtec_ntb_dma_alias
+pci_fixup_device
+quirk_apple_poweroff_thunderbolt
+quirk_isa_dma_hangs
+quirk_nopcipci
+quirk_triton
+quirk_viaetbf
+quirk_vsfx
+quirk_alimagik
+quirk_natoma
+quirk_jmicron_async_suspend
+quirk_nopciamd
+quirk_p64h2_1k_io
+asus_hides_smbus_lpc
+asus_hides_smbus_lpc_ich6_suspend
+asus_hides_smbus_lpc_ich6
+quirk_via_bridge
+quirk_thunderbolt_hotplug_msi
+pci_quirk_intel_pch_acs
+pci_quirk_intel_spt_pch_acs_match.part.0
+quirk_radeon_pm
+quirk_plx_pci9050
+quirk_msi_intx_disable_qca_bug
+quirk_amd_harvest_no_ats
+pci_quirk_intel_spt_pch_acs
+quirk_cs5536_vsa
+quirk_ich4_lpc_acpi
+ich6_lpc_acpi_gpio
+quirk_ich6_lpc
+quirk_ich7_lpc
+quirk_vt82c686_acpi
+quirk_amd_ioapic
+quirk_disable_pxb
+quirk_disable_amd_8111_boot_interrupt
+quirk_jmicron_ata
+quirk_disable_broadcom_boot_interrupt
+quirk_disable_amd_813x_boot_interrupt
+pci_quirk_disable_intel_spt_pch_acs_redir
+pci_quirk_enable_intel_spt_pch_acs
+asus_hides_ac97_lpc
+quirk_alder_ioapic
+quirk_reroute_to_boot_interrupts_intel
+quirk_brcm_5719_limit_mrrs
+nvenet_msi_disable
+nvbridge_check_legacy_irq_routing
+__nv_msi_ht_cap_quirk.part.0
+nv_msi_ht_cap_quirk_all
+nv_msi_ht_cap_quirk_leaf
+mellanox_check_broken_intx_masking
+reset_chelsio_generic_dev
+delay_250ms_after_flr
+nvme_disable_and_flr
+reset_ivb_igd
+quirk_reset_lenovo_thinkpad_p50_nvgpu
+quirk_intel_mc_errata
+pci_create_device_link.constprop.0
+quirk_gpu_usb_typec_ucsi
+quirk_gpu_usb
+quirk_gpu_hda
+piix4_mem_quirk.constprop.0
+quirk_piix4_acpi
+quirk_intel_qat_vf_cap
+pci_quirk_brcm_acs
+pci_quirk_nvidia_tegra_disable_rp_msi
+pci_quirk_qcom_rp_acs
+quirk_vt82c586_acpi
+pci_quirk_enable_intel_pch_acs
+pci_dev_specific_reset
+pci_dev_specific_acs_enabled
+pci_dev_specific_enable_acs
+pci_dev_specific_disable_acs_redir
+pci_idt_bus_quirk
+__pci_hp_initialize
+presence_read_file
+latch_read_file
+attention_read_file
+power_read_file
+pci_hp_destroy
+test_write_file
+attention_write_file
+power_write_file
+pci_hp_add
+__pci_hp_register
+pci_hp_del
+pci_hp_deregister
+set_attention_status
+get_power_status
+get_adapter_status
+get_latch_status
+enable_slot
+get_attention_status
+disable_slot
+cpci_hp_unregister_bus
+cpci_hp_register_controller
+cpci_hp_unregister_controller
+cpci_hp_stop
+check_slots
+event_thread
+cpci_hp_intr
+cpci_hp_start
+poll_thread
+cpci_hp_register_bus
+cpci_get_attention_status
+cpci_set_attention_status
+cpci_get_hs_csr
+cpci_check_and_clear_ins
+cpci_check_ext
+cpci_clear_ext
+cpci_led_on
+cpci_led_off
+cpci_configure_slot
+cpci_unconfigure_slot
+acpi_pci_detect_ejectable
+acpi_get_hp_hw_control_from_firmware
+pcihp_is_ejectable
+check_hotplug
+acpi_pci_check_ejectable
+pciehp_resume_noirq
+pciehp_check_presence
+pciehp_remove
+set_attention_status
+get_adapter_status
+get_latch_status
+get_power_status
+pme_is_native
+pciehp_disable_interrupt
+pciehp_runtime_suspend
+pciehp_suspend
+pciehp_resume
+pciehp_runtime_resume
+pciehp_probe
+pciehp_disable_slot
+pciehp_request
+pciehp_queue_pushbutton_work
+pciehp_handle_button_press
+pciehp_handle_disable_request
+pciehp_handle_presence_or_link_change
+pciehp_sysfs_enable_slot
+pciehp_sysfs_disable_slot
+pciehp_configure_device
+pciehp_unconfigure_device
+pcie_wait_cmd
+pcie_do_write_cmd
+pciehp_isr
+quirk_cmd_compl
+pcie_disable_notification
+pciehp_check_link_active
+pciehp_check_link_status
+pciehp_get_raw_indicator_status
+pciehp_get_attention_status
+pciehp_get_power_status
+pciehp_get_latch_status
+pciehp_card_present
+pciehp_card_present_or_link_active
+pciehp_query_power_fault
+pciehp_set_raw_indicator_status
+pciehp_set_indicators
+pciehp_ist
+pciehp_poll
+pciehp_power_on_slot
+pciehp_power_off_slot
+pcie_clear_hotplug_events
+pcie_enable_interrupt
+pcie_disable_interrupt
+pciehp_reset_slot
+pcie_init_notification
+pcie_shutdown_notification
+pcie_init
+pciehp_release_ctrl
+shpc_remove
+set_attention_status
+get_power_status
+get_attention_status
+get_latch_status
+get_adapter_status
+disable_slot
+enable_slot
+cleanup_slots
+shpc_probe
+update_slot_info
+queue_interrupt_event
+interrupt_event_handler
+change_bus_speed
+board_added
+shpchp_enable_slot
+shpchp_disable_slot
+shpchp_pushbutton_thread
+shpchp_handle_attention_button
+shpchp_handle_switch_change
+shpchp_handle_presence_change
+shpchp_handle_power_fault
+shpchp_queue_pushbutton_work
+shpchp_sysfs_enable_slot
+shpchp_sysfs_disable_slot
+shpchp_configure_device
+shpchp_unconfigure_device
+show_ctrl
+shpchp_create_ctrl_files
+shpchp_remove_ctrl_files
+hpc_get_attention_status
+hpc_get_power_status
+hpc_get_latch_status
+hpc_get_adapter_status
+hpc_get_prog_int
+hpc_query_power_fault
+hpc_get_mode1_ECC_cap
+hpc_get_adapter_speed
+shpc_isr
+int_poll_timeout
+hpc_release_ctlr
+shpc_get_cur_bus_speed
+shpc_write_cmd
+hpc_set_green_led_blink
+hpc_set_green_led_off
+hpc_set_green_led_on
+hpc_set_attention_status
+hpc_slot_disable
+hpc_slot_enable
+hpc_power_on_slot
+hpc_set_bus_speed_mode
+shpc_init
+acpiphp_unregister_attention
+acpiphp_register_attention
+get_adapter_status
+get_latch_status
+get_attention_status
+set_attention_status
+get_power_status
+disable_slot
+enable_slot
+acpiphp_register_hotplug_slot
+acpiphp_unregister_hotplug_slot
+get_slot_status
+disable_slot
+acpiphp_rescan_slot
+acpiphp_disable_and_eject_slot
+cleanup_bridge
+acpiphp_put_context.part.0
+acpiphp_add_context
+trim_stale_devices
+enable_slot
+acpiphp_check_bridge
+acpiphp_grab_context
+free_bridge
+acpiphp_hotplug_notify
+acpiphp_post_dock_fixup
+acpiphp_check_host_bridge
+acpiphp_enumerate_slots
+acpiphp_remove_slots
+acpiphp_enable_slot
+acpiphp_disable_slot
+acpiphp_get_power_status
+acpiphp_get_latch_status
+acpiphp_get_adapter_status
+pci_msi_enabled
+msi_desc_to_pci_dev
+msi_desc_to_pci_sysdata
+pci_msi_domain_handle_error
+pci_msi_domain_set_desc
+get_msi_id_cb
+pci_irq_vector
+pci_msi_vec_count
+pci_msix_vec_count
+free_msi_irqs
+msi_verify_entries
+msi_mode_show
+pci_msi_create_irq_domain
+pci_msi_setup_msi_irqs.isra.0
+pci_msi_supported
+pci_msi_domain_check_cap
+pci_irq_get_affinity
+pci_disable_msix
+populate_msi_sysfs
+__pci_msi_desc_mask_irq
+__pci_enable_msi_range
+pci_enable_msi
+pci_disable_msi
+pci_free_irq_vectors
+__pci_msix_desc_mask_irq
+msi_set_mask_bit
+pci_msi_mask_irq
+pci_msi_unmask_irq
+__pci_enable_msix_range
+pci_enable_msix_range
+pci_alloc_irq_vectors_affinity
+__pci_read_msi_msg
+__pci_write_msi_msg
+default_restore_msi_irq
+default_restore_msi_irqs
+default_restore_msi_irqs
+pci_restore_msi_state
+pci_write_msi_msg
+pci_msi_domain_write_msg
+pci_no_msi
+pci_msi_domain_get_msi_rid
+pci_msi_get_device_domain
+pci_dev_has_special_msi_domain
+pci_ats_supported
+pci_pri_supported
+pci_enable_ats
+pci_disable_pasid
+pci_disable_ats
+pci_disable_pri
+pci_enable_pasid
+pci_pasid_features
+pci_max_pasids
+pci_ats_init
+pci_restore_ats_state
+pci_ats_queue_depth
+pci_ats_page_aligned
+pci_pri_init
+pci_enable_pri
+pci_restore_pri_state
+pci_reset_pri
+pci_prg_resp_pasid_required
+pci_pasid_init
+pci_restore_pasid_state
+sriov_attrs_are_visible
+pci_num_vf
+pci_sriov_set_totalvfs
+pci_sriov_get_totalvfs
+sriov_totalvfs_show
+sriov_vf_device_show
+sriov_stride_show
+sriov_offset_show
+sriov_numvfs_store
+sriov_numvfs_show
+sriov_drivers_autoprobe_show
+sriov_drivers_autoprobe_store
+pci_vfs_assigned.part.0
+pci_vfs_assigned
+pci_iov_virtfn_bus
+pci_iov_virtfn_devfn
+pci_iov_resource_size
+pci_iov_sysfs_link
+pci_iov_add_virtfn
+pci_iov_remove_virtfn
+pcibios_sriov_enable
+pcibios_sriov_disable
+sriov_enable
+pci_enable_sriov
+sriov_disable
+pci_disable_sriov
+pci_sriov_configure_simple
+pci_iov_init
+pci_iov_release
+pci_iov_remove
+pci_iov_update_resource
+pcibios_iov_resource_alignment
+pci_sriov_resource_alignment
+pci_restore_iov_state
+pci_vf_drivers_autoprobe
+pci_iov_bus_range
+device_has_dsm
+acpi_index_string_exist
+dsm_get_label
+acpiindex_show
+acpilabel_show
+find_smbios_instance_string
+smbiosinstance_show
+smbioslabel_show
+smbios_instance_string_exist
+pci_create_firmware_label_files
+pci_remove_firmware_label_files
+pci_ep_cfs_add_epf_group
+pci_epf_drop
+pci_ep_cfs_remove_epf_group
+pci_epf_msix_interrupts_show
+pci_epf_msi_interrupts_show
+pci_epf_interrupt_pin_show
+pci_epf_subsys_id_show
+pci_epf_subsys_vendor_id_show
+pci_epf_cache_line_size_show
+pci_epf_baseclass_code_show
+pci_epf_subclass_code_show
+pci_epf_progif_code_show
+pci_epf_revid_show
+pci_epf_deviceid_show
+pci_epf_vendorid_show
+pci_epc_epf_link
+pci_epf_msix_interrupts_store
+pci_epf_subsys_id_store
+pci_epf_subsys_vendor_id_store
+pci_epf_deviceid_store
+pci_epf_vendorid_store
+pci_epf_msi_interrupts_store
+pci_epf_interrupt_pin_store
+pci_epf_cache_line_size_store
+pci_epf_baseclass_code_store
+pci_epf_subclass_code_store
+pci_epf_progif_code_store
+pci_epf_revid_store
+pci_epf_release
+pci_epc_start_store
+pci_epc_start_show
+pci_epc_epf_unlink
+pci_ep_cfs_remove_epc_group
+pci_epf_make
+pci_ep_cfs_add_epc_group
+pci_epc_linkup
+pci_epc_init_notify
+devm_pci_epc_match
+pci_epc_get_first_free_bar
+pci_epc_put
+pci_epc_get
+pci_epc_stop
+pci_epc_start
+pci_epc_raise_irq
+pci_epc_set_msix
+pci_epc_map_addr
+pci_epc_set_bar
+pci_epc_write_header
+pci_epc_set_msi
+pci_epc_add_epf
+pci_epc_destroy
+devm_pci_epc_release
+pci_epc_get_features
+pci_epc_get_msix
+pci_epc_unmap_addr
+pci_epc_clear_bar
+pci_epc_remove_epf
+pci_epc_get_msi
+devm_pci_epc_destroy
+__pci_epc_create
+__devm_pci_epc_create
+pci_epf_destroy
+pci_epf_device_probe
+pci_epf_device_remove
+pci_epf_free_space
+pci_epf_alloc_space
+pci_epf_remove_cfs
+pci_epf_unregister_driver
+__pci_epf_register_driver
+pci_epf_dev_release
+pci_epf_unbind
+pci_epf_bind
+pci_epf_device_match
+pci_epf_match_device
+pci_epf_create
+pci_epc_mem_get_order
+pci_epc_mem_exit
+pci_epc_mem_alloc_addr
+pci_epc_mem_free_addr
+pci_epc_multi_mem_init
+pci_epc_mem_init
+dw_pcie_read
+dw_pcie_read_dbi
+__dw_pcie_find_next_cap
+dw_pcie_find_capability
+dw_pcie_writel_atu
+dw_pcie_readl_atu
+dw_pcie_find_ext_capability
+dw_pcie_write
+dw_pcie_write_dbi
+dw_pcie_upconfig_setup
+__dw_pcie_prog_outbound_atu
+dw_pcie_write_dbi2
+dw_pcie_prog_outbound_atu
+dw_pcie_prog_ep_outbound_atu
+dw_pcie_prog_inbound_atu
+dw_pcie_disable_atu
+dw_pcie_link_up
+dw_pcie_wait_for_link
+dw_pcie_setup
+dw_pci_msi_set_affinity
+dw_msi_unmask_irq
+dw_msi_mask_irq
+dw_msi_ack_irq
+dw_pcie_own_conf_map_bus
+dw_pcie_msi_init
+dw_pcie_wr_other_conf
+dw_pcie_rd_other_conf
+dw_pcie_other_conf_map_bus
+dw_pci_setup_msi_msg
+dw_pci_bottom_unmask
+dw_pci_bottom_mask
+dw_pci_bottom_ack
+dw_pcie_setup_rc
+dw_pcie_irq_domain_alloc
+dw_pcie_irq_domain_free
+dw_handle_msi_irq
+dw_chained_msi_isr
+dw_pcie_allocate_domains
+dw_pcie_free_msi
+dw_pcie_host_init
+dw_pcie_host_deinit
+dw_pcie_ep_linkup
+dw_pcie_ep_init_notify
+dw_pcie_ep_init
+dw_pcie_ep_outbound_atu
+dw_pcie_ep_init_complete
+dw_pcie_ep_unmap_addr.constprop.0
+dw_pcie_ep_get_func_from_ep
+dw_pcie_ep_reset_bar
+dw_pcie_ep_raise_legacy_irq
+dw_pcie_ep_raise_msi_irq
+dw_pcie_ep_raise_msix_irq_doorbell
+dw_pcie_ep_raise_msix_irq
+dw_pcie_ep_exit
+dw_plat_pcie_probe
+rio_enable_rx_tx_port
+rio_release_outb_dbell
+rio_query_mport
+rio_map_inb_region
+rio_unmap_inb_region
+rio_map_outb_region
+rio_unmap_outb_region
+rio_chan_filter
+rio_local_get_device_id
+rio_local_set_device_id
+rio_release_inb_mbox
+rio_release_outb_mbox
+rio_release_inb_dbell
+rio_del_mport_pw_handler
+rio_pw_enable
+rio_unregister_scan
+rio_mport_get_feature
+rio_set_port_lockout
+rio_unlock_device
+rio_mport_chk_dev_access
+rio_lock_device
+rio_route_add_entry
+disc_work_handler
+rio_release_dma
+rio_mport_initialize
+rio_register_mport
+rio_mport_get_efb
+rio_dma_prep_xfer
+rio_dma_prep_slave_sg
+rio_request_mport_dma
+rio_request_dma
+rio_add_mport_pw_handler
+rio_register_scan
+rio_request_outb_dbell
+rio_request_inb_mbox
+rio_alloc_net
+rio_request_inb_dbell
+rio_request_outb_mbox
+rio_mport_get_physefb
+rio_clr_err_stopped
+rio_request_inb_pwrite
+rio_release_inb_pwrite
+rio_get_comptag
+rio_inb_pwrite_handler
+rio_free_net
+rio_unregister_mport
+rio_add_net
+rio_add_device
+rio_del_device
+rio_mport_cleanup_callback
+rio_get_asm
+rio_get_device
+rio_init_mports
+rio_route_clr_table
+rio_route_get_entry
+rio_find_mport
+rio_mport_scan
+__rio_local_read_config_8
+__rio_local_read_config_16
+__rio_local_read_config_32
+__rio_local_write_config_8
+__rio_local_write_config_16
+__rio_local_write_config_32
+rio_mport_read_config_8
+rio_mport_read_config_16
+rio_mport_read_config_32
+rio_mport_write_config_8
+rio_mport_write_config_16
+rio_mport_write_config_32
+rio_mport_send_doorbell
+rio_dev_get
+rio_dev_put
+rio_unregister_driver
+rio_match_device
+rio_attach_device
+rio_match_bus
+rio_device_remove
+rio_device_probe
+rio_register_driver
+rio_device_shutdown
+rio_uevent
+scan_store
+rio_dev_is_attr_visible
+rio_write_config
+rio_read_config
+hopcount_show
+lnext_show
+routes_show
+modalias_show
+destid_show
+lprev_show
+asm_rev_show
+asm_vid_show
+asm_did_show
+device_rev_show
+vid_show
+did_show
+sys_size_show
+port_destid_show
+hdmi_avi_infoframe_check
+hdmi_spd_infoframe_check
+hdmi_audio_infoframe_check
+hdmi_vendor_infoframe_check_only
+hdmi_vendor_infoframe_check
+hdmi_drm_infoframe_check
+hdmi_vendor_any_infoframe_check
+hdmi_avi_infoframe_init
+hdmi_audio_infoframe_init
+hdmi_vendor_infoframe_init
+hdmi_drm_infoframe_init
+hdmi_drm_infoframe_pack_only
+hdmi_drm_infoframe_pack
+hdmi_spd_infoframe_init
+hdmi_spd_infoframe_pack_only
+hdmi_spd_infoframe_pack
+hdmi_infoframe_check
+hdmi_infoframe_log_header
+hdmi_avi_infoframe_pack_only
+hdmi_avi_infoframe_pack
+hdmi_audio_infoframe_pack_only
+hdmi_audio_infoframe_pack
+hdmi_infoframe_log
+hdmi_vendor_infoframe_pack_only
+hdmi_vendor_infoframe_pack
+hdmi_infoframe_pack_only
+hdmi_drm_infoframe_unpack_only
+hdmi_infoframe_unpack
+hdmi_infoframe_pack
+dummycon_blank
+dummycon_startup
+dummycon_deinit
+dummycon_clear
+dummycon_cursor
+dummycon_scroll
+dummycon_switch
+dummycon_font_set
+dummycon_font_default
+dummycon_font_copy
+dummycon_putc
+dummycon_putcs
+dummycon_init
+dummycon_register_output_notifier
+dummycon_unregister_output_notifier
+vgacon_clear
+vgacon_putc
+vgacon_putcs
+vgacon_doresize
+vgacon_text_force
+vgacon_build_attr
+vgacon_invert_region
+vgacon_init
+vgacon_startup
+vgacon_set_cursor_size.isra.0
+vgacon_resize
+vga_set_palette
+vgacon_set_palette
+vgacon_set_origin
+vgacon_save_screen
+vgacon_deinit
+vgacon_scrolldelta
+vgacon_scroll
+vgacon_switch
+vgacon_cursor
+vgacon_do_font_op.constprop.0
+vgacon_font_get
+vgacon_blank
+vgacon_font_set
+devm_of_find_backlight
+backlight_generate_event
+bl_device_release
+devm_backlight_device_match
+backlight_device_get_by_type
+backlight_force_update
+backlight_device_get_by_name
+backlight_register_notifier
+backlight_unregister_notifier
+type_show
+max_brightness_show
+actual_brightness_show
+brightness_show
+bl_power_show
+backlight_device_unregister.part.0
+backlight_device_unregister
+devm_backlight_device_release
+devm_backlight_device_unregister
+scale_show
+backlight_device_register
+devm_backlight_device_register
+backlight_device_set_brightness
+brightness_store
+backlight_suspend
+backlight_resume
+bl_power_store
+fb_notifier_callback
+fb_get_options
+fb_register_client
+fb_unregister_client
+fb_notifier_call_chain
+fb_prepare_logo
+fb_pad_aligned_buffer
+fb_get_buffer_offset
+fb_seq_next
+fb_pad_unaligned_buffer
+fb_pan_display
+fb_blank
+fb_set_var
+fb_seq_start
+fb_seq_stop
+fb_set_suspend
+fb_mmap
+do_fb_ioctl
+fb_ioctl
+fb_write
+fb_read
+fb_seq_show
+put_fb_info
+do_unregister_framebuffer
+do_remove_conflicting_framebuffers
+register_framebuffer
+unregister_framebuffer
+fb_release
+fb_get_color_depth
+get_fb_info.part.0
+fb_open
+fb_compat_ioctl
+fb_show_logo
+remove_conflicting_framebuffers
+remove_conflicting_pci_framebuffers
+fb_new_modelist
+fb_destroy_modedb
+copy_string
+fb_firmware_edid
+fb_timings_vfreq
+fb_timings_hfreq
+fb_videomode_from_videomode
+fb_validate_mode
+check_edid
+fb_timings_dclk
+fix_edid
+edid_checksum
+edid_check_header
+fb_parse_edid
+fb_get_mode
+calc_mode_timings
+get_std_timing
+fb_create_modedb
+fb_edid_to_monspecs
+fb_invert_cmaps
+fb_dealloc_cmap
+fb_copy_cmap
+fb_set_cmap
+fb_default_cmap
+fb_alloc_cmap_gfp
+fb_alloc_cmap
+fb_cmap_to_user
+fb_set_user_cmap
+show_blank
+store_console
+store_fbstate
+show_name
+store_modes
+store_bl_curve
+show_bl_curve
+show_fbstate
+show_rotate
+show_stride
+show_virtual
+show_pan
+mode_string
+show_modes
+show_mode
+show_bpp
+activate
+store_rotate
+store_virtual
+store_bpp
+store_pan
+fb_bl_default_curve
+store_mode
+store_blank
+framebuffer_release
+store_cursor
+show_console
+framebuffer_alloc
+show_cursor
+fb_init_device
+fb_cleanup_device
+fb_try_mode
+fb_videomode_to_var
+fb_mode_is_equal
+fb_find_best_mode
+fb_find_nearest_mode
+fb_var_to_videomode
+fb_match_mode
+fb_find_best_display
+fb_find_mode
+fb_add_videomode
+fb_videomode_to_modelist
+fb_destroy_modelist
+fb_delete_videomode
+fb_find_mode_cvt
+fb_deferred_io_open
+fb_deferred_io_fsync
+fb_deferred_io_mkwrite
+fb_deferred_io_page
+fb_deferred_io_fault
+fb_deferred_io_cleanup
+fb_deferred_io_init
+fb_deferred_io_set_page_dirty
+fb_deferred_io_work
+fb_deferred_io_mmap
+do_fbcon_takeover
+show_rotate
+fbcon_clear_margins
+fbcon_clear
+fbcon_debug_leave
+set_vc_hi_font
+fbcon_screen_pos
+fbcon_invert_region
+fbcon_add_cursor_timer
+cursor_timer_handler
+get_color
+fb_flashcursor
+fbcon_putcs
+fbcon_putc
+fbcon_del_cursor_timer
+store_cursor_blink
+show_cursor_blink
+updatescrollmode
+fbcon_getxy
+set_blitting_type
+var_to_display
+fbcon_set_palette
+fbcon_modechanged
+fbcon_set_all_vcs
+fbcon_update_vcs
+store_rotate_all
+store_rotate
+fbcon_debug_enter
+display_to_var
+fbcon_resize
+fbcon_do_set_font
+fbcon_copy_font
+fbcon_set_def_font
+fbcon_get_font
+fbcon_switch
+fbcon_cursor
+fbcon_set_disp
+fbcon_deinit
+fbcon_output_notifier
+fbcon_blank
+fbcon_redraw_blit.isra.0
+fbcon_redraw_move.isra.0
+fbcon_redraw.isra.0
+con2fb_release_oldinfo.isra.0
+fbcon_bmove_rec.constprop.0
+fbcon_bmove.constprop.0
+fbcon_scroll
+fbcon_startup
+con2fb_acquire_newinfo
+fbcon_prepare_logo
+fbcon_init
+set_con2fb_map
+fbcon_set_font
+fbcon_suspended
+fbcon_resumed
+fbcon_mode_deleted
+fbcon_fb_unbind
+fbcon_fb_unregistered
+fbcon_remap_all
+fbcon_fb_registered
+fbcon_register_existing_fbs
+fbcon_fb_blanked
+fbcon_new_modelist
+fbcon_get_requirement
+fbcon_set_con2fb_map_ioctl
+fbcon_get_con2fb_map_ioctl
+update_attr
+bit_bmove
+bit_clear_margins
+fbcon_set_bitops
+bit_update_start
+bit_clear
+bit_putcs
+bit_cursor
+soft_cursor
+tile_clear_margins
+tile_bmove
+tile_cursor
+fbcon_set_tileops
+tile_update_start
+tile_putcs
+tile_clear
+fbcon_set_rotate
+fbcon_rotate_font
+cw_bmove
+cw_clear_margins
+fbcon_rotate_cw
+cw_update_start
+cw_update_attr
+cw_clear
+cw_putcs
+cw_cursor
+ud_update_attr
+ud_bmove
+ud_clear_margins
+fbcon_rotate_ud
+ud_update_start
+ud_clear
+ud_putcs
+ud_cursor
+ccw_bmove
+ccw_clear_margins
+fbcon_rotate_ccw
+ccw_update_start
+ccw_update_attr
+ccw_clear
+ccw_putcs
+ccw_cursor
+cfb_fillrect
+bitfill_unaligned
+bitfill_unaligned_rev
+bitfill_aligned
+bitfill_aligned_rev
+cfb_copyarea
+cfb_imageblit
+compute_imstt_regvals_tvp
+set_imstt_regvals
+imsttfb_pan_display
+imsttfb_blank
+imsttfb_fillrect
+imsttfb_copyarea
+imsttfb_remove
+imsttfb_check_var
+compute_imstt_regvals_ibm
+imsttfb_setcolreg
+imsttfb_ioctl
+imsttfb_probe
+imsttfb_set_par
+asiliantfb_remove
+asiliantfb_pci_init
+asiliantfb_set_par
+asiliantfb_check_var
+asiliantfb_setcolreg
+vesafb_pan_display
+vesafb_remove
+vesafb_destroy
+vesafb_setcolreg
+vesafb_probe
+depth_show
+height_show
+width_show
+linelength_show
+base_show
+efifb_remove
+efifb_fixup_resources
+efifb_destroy
+efifb_setcolreg
+efifb_probe
+display_timings_release
+videomode_from_timing
+videomode_from_timings
+intel_idle_cpu_online
+ipmi_dmi_get_slave_addr
+ipmi_platform_add
+acpi_table_print_madt_entry
+acpi_os_physical_table_override
+acpi_os_table_override
+acpi_osi_is_win8
+acpi_osi_handler
+acpi_resources_are_enforced
+acpi_register_debugger
+acpi_unregister_debugger
+acpi_os_get_iomem
+acpi_os_execute_deferred
+acpi_os_map_remove
+acpi_os_wait_events_complete
+acpi_hotplug_work_fn
+acpi_deactivate_mem_region
+acpi_os_map_generic_address
+acpi_irq
+acpi_os_write_port
+acpi_os_read_port
+acpi_os_unmap_generic_address.part.0
+acpi_os_unmap_generic_address
+acpi_check_resource_conflict
+acpi_check_region
+acpi_release_memory
+acpi_os_predefined_override
+acpi_os_install_interrupt_handler
+acpi_os_remove_interrupt_handler
+acpi_os_sleep
+acpi_os_stall
+acpi_os_get_timer
+acpi_os_read_iomem
+acpi_os_read_memory
+acpi_os_write_memory
+acpi_os_read_pci_configuration
+acpi_os_write_pci_configuration
+acpi_debugger_create_thread
+acpi_os_execute
+acpi_debugger_write_log
+acpi_os_vprintf
+acpi_os_printf
+acpi_debugger_read_cmd
+acpi_os_get_line
+acpi_debugger_wait_command_ready
+acpi_debugger_notify_command_complete
+acpi_hotplug_schedule
+acpi_queue_hotplug_work
+acpi_os_create_semaphore
+acpi_os_delete_semaphore
+acpi_os_wait_semaphore
+acpi_os_signal_semaphore
+acpi_os_wait_command_ready
+acpi_os_notify_command_complete
+acpi_os_signal
+acpi_os_delete_lock
+acpi_os_acquire_lock
+acpi_os_release_lock
+acpi_os_create_cache
+acpi_os_purge_cache
+acpi_os_delete_cache
+acpi_os_release_object
+acpi_os_terminate
+acpi_os_prepare_sleep
+acpi_os_set_prepare_sleep
+acpi_os_prepare_extended_sleep
+acpi_os_set_prepare_extended_sleep
+acpi_os_enter_sleep
+acpi_extract_package
+acpi_evaluate_ost
+acpi_execute_simple_method
+acpi_evaluate_reg
+acpi_handle_path
+acpi_util_eval_error
+acpi_evaluate_integer
+acpi_evaluate_reference
+acpi_get_physical_device_location
+acpi_handle_printk
+acpi_evaluate_dsm
+__acpi_handle_debug
+acpi_has_method
+acpi_dev_hid_uid_match
+acpi_dev_found
+acpi_dev_get_first_match_dev
+acpi_dev_present
+acpi_check_dsm
+acpi_dev_match_cb
+acpi_match_platform_list
+acpi_evaluate_ej0
+acpi_evaluate_lck
+acpi_reboot
+acpi_nvs_register
+acpi_nvs_for_each_region
+suspend_nvs_free
+suspend_nvs_alloc
+acpi_unregister_wakeup_handler
+acpi_register_wakeup_handler
+acpi_enable_wakeup_devices
+acpi_disable_wakeup_devices
+acpi_check_wakeup_handlers
+acpi_target_system_state
+acpi_sleep_tts_switch
+tts_notify_reboot
+acpi_save_bm_rld
+acpi_restore_bm_rld
+acpi_s2idle_end
+acpi_s2idle_prepare
+acpi_s2idle_begin
+acpi_pm_end
+acpi_pm_thaw
+acpi_pm_freeze
+acpi_pm_pre_suspend
+acpi_hibernation_leave
+acpi_suspend_begin
+acpi_hibernation_begin
+acpi_suspend_state_valid
+acpi_s2idle_restore
+acpi_sleep_run_lps0_dsm
+acpi_s2idle_wake
+acpi_s2idle_restore_early
+acpi_s2idle_prepare_late
+acpi_pm_finish
+lps0_device_attach
+acpi_hibernation_enter
+acpi_sleep_prepare.part.0
+acpi_sleep_prepare
+acpi_pm_prepare
+acpi_suspend_begin_old
+acpi_power_off_prepare
+acpi_hibernation_begin_old
+acpi_suspend_enter
+acpi_sleep_state_supported
+acpi_s2idle_wakeup
+real_power_state_show
+acpi_object_path
+acpi_device_hid_show
+acpi_data_node_release
+acpi_data_node_attr_show
+create_of_modalias
+power_state_show
+acpi_device_uid_show
+acpi_device_adr_show
+acpi_device_path_show
+data_node_show_path
+acpi_eject_store
+status_show
+acpi_device_hrv_show
+acpi_device_sun_show
+description_show
+acpi_expose_nondev_subnodes
+acpi_hide_nondev_subnodes
+create_pnp_modalias.part.0
+__acpi_device_modalias.part.0
+acpi_device_modalias_show
+acpi_device_modalias
+__acpi_device_uevent_modalias
+acpi_device_uevent_modalias
+acpi_device_setup_files
+acpi_device_remove_files
+acpi_bus_power_manageable
+acpi_pm_wakeup_event
+acpi_subsys_freeze
+acpi_subsys_poweroff_noirq
+acpi_subsys_resume_noirq
+acpi_dev_pm_get_state
+acpi_bus_can_wakeup
+acpi_pm_device_sleep_state
+acpi_dev_needs_resume
+acpi_subsys_prepare
+acpi_device_wakeup_disable
+__acpi_device_wakeup_enable
+__acpi_pm_set_device_wakeup
+acpi_pm_set_device_wakeup
+acpi_pm_set_bridge_wakeup
+acpi_pm_notify_work_func
+acpi_subsys_suspend
+acpi_subsys_poweroff
+acpi_subsys_complete
+acpi_dev_pm_explicit_set.part.0
+acpi_device_set_power
+acpi_bus_set_power
+acpi_device_fix_up_power
+acpi_pm_notify_handler
+acpi_subsys_suspend_noirq
+acpi_dev_pm_low_power.part.0
+acpi_dev_suspend
+acpi_subsys_runtime_suspend
+acpi_subsys_suspend_late
+acpi_add_pm_notifier.part.0
+acpi_dev_pm_attach
+acpi_dev_resume
+acpi_subsys_runtime_resume
+acpi_subsys_restore_early
+acpi_subsys_resume_early
+acpi_subsys_poweroff_late
+acpi_power_state_string
+acpi_device_get_power
+acpi_bus_init_power
+acpi_device_update_power
+acpi_bus_update_power
+acpi_add_pm_notifier
+acpi_remove_pm_notifier
+acpi_dev_pm_detach
+acpi_pm_device_can_wakeup
+acpi_system_wakeup_device_open_fs
+acpi_system_wakeup_device_seq_show
+acpi_system_write_wakeup_device
+acpi_bus_private_data_handler
+acpi_bus_detach_private_data
+acpi_device_notify
+acpi_device_notify_fixed
+acpi_bus_get_status_handle
+acpi_print_osc_error
+acpi_run_osc
+acpi_get_first_physical_node
+acpi_of_match_device
+acpi_bus_register_driver
+acpi_bus_unregister_driver
+acpi_device_remove
+acpi_device_fixed_event
+acpi_device_probe
+acpi_device_uevent
+set_copy_dsdt
+acpi_bus_notify
+acpi_bus_table_handler
+sb_notify_work
+acpi_bus_attach_private_data
+acpi_bus_get_private_data
+acpi_bus_get_status
+acpi_set_modalias
+acpi_sb_notify
+__acpi_match_device.part.0.constprop.0
+acpi_bus_match
+acpi_match_device_ids
+acpi_device_is_first_physical_node
+acpi_companion_match
+acpi_match_device
+acpi_device_get_match_data
+acpi_driver_match_device
+find_child_checks
+acpi_find_child_device
+acpi_get_bus_type
+acpi_physnode_link_name
+acpi_unbind_one
+register_acpi_bus_type
+unregister_acpi_bus_type
+acpi_bind_one
+acpi_platform_notify
+acpi_scan_lock_acquire
+acpi_scan_lock_release
+get_acpi_device
+acpi_dma_configure_id
+acpi_device_hid
+acpi_check_serial_bus_slave
+acpi_scan_drop_device
+acpi_scan_match_handler
+acpi_device_del
+acpi_device_del_work_fn
+acpi_initialize_hp_context
+acpi_bus_get_ejd
+acpi_is_video_device
+acpi_add_id
+acpi_get_resource_memory
+acpi_bus_trim
+acpi_scan_device_not_present
+acpi_reconfig_notifier_register
+acpi_reconfig_notifier_unregister
+acpi_get_device_data
+acpi_bus_get_device
+acpi_bus_offline
+acpi_bus_online
+acpi_backlight_cap_match
+acpi_default_enumeration
+acpi_generic_device_attach
+acpi_bus_attach
+acpi_walk_dep_device_list
+acpi_device_dep_initialize
+acpi_lock_hp_context
+acpi_unlock_hp_context
+acpi_scan_add_handler
+acpi_scan_add_handler_with_hotplug
+acpi_scan_is_offline
+acpi_bus_get_acpi_device
+acpi_bus_put_acpi_device
+acpi_device_add
+acpi_ata_match
+acpi_bay_match
+acpi_device_is_battery
+acpi_dock_match
+acpi_free_pnp_ids
+acpi_device_release
+acpi_dma_supported
+acpi_get_dma_attr
+acpi_dma_get_range
+acpi_init_device_object
+acpi_add_single_object
+acpi_bus_check_add
+acpi_bus_scan
+acpi_scan_bus_check
+acpi_device_hotplug
+acpi_table_events_fn
+acpi_bus_register_early_device
+acpi_device_add_finalize
+acpi_device_is_present
+acpi_scan_hotplug_enabled
+acpi_scan_table_handler
+acpi_dev_irq_flags
+acpi_dev_get_irq_type
+acpi_dev_free_resource_list
+acpi_dev_filter_resource_type
+__acpi_dev_get_resources
+acpi_dev_get_resources
+acpi_dev_get_dma_resources
+acpi_dev_new_resource_entry
+acpi_res_consumer_cb
+acpi_dev_resource_len_valid
+acpi_dev_memresource_flags
+acpi_dev_resource_memory
+acpi_dev_ioresource_flags
+acpi_dev_resource_io
+acpi_decode_space
+acpi_dev_resource_address_space
+acpi_dev_get_irqresource.part.0
+acpi_dev_resource_interrupt
+acpi_dev_process_resource
+acpi_dev_resource_ext_address_space
+is_memory
+acpi_resource_consumer
+acpi_processor_container_attach
+acpi_processor_evaluate_cst
+acpi_processor_claim_cst_control
+acpi_processor_claim_cst_control
+acpi_processor_claim_cst_control
+acpi_processor_claim_cst_control
+acpi_processor_add
+acpi_processor_add
+acpi_processor_remove
+acpi_duplicate_processor_id
+get_madt_table
+map_lsapic_id
+map_madt_entry
+acpi_get_phys_id
+acpi_map_cpuid
+acpi_get_cpuid
+acpi_get_ioapic_id
+acpi_processor_set_pdc
+__acpi_ec_flush_work
+ec_transaction_completed
+ec_get_handle
+ec_clear_on_resume
+ec_honor_ecdt_gpe
+ec_correct_ecdt
+acpi_ec_enter_noirq
+acpi_ec_free
+ec_guard
+acpi_ec_suspend_noirq
+acpi_ec_leave_noirq
+acpi_ec_resume_noirq
+ec_parse_device
+ec_parse_io_ports
+acpi_ec_complete_request
+param_get_event_clearing
+param_set_event_clearing
+acpi_ec_mark_gpe_for_wake
+acpi_ec_alloc
+acpi_ec_delete_query
+acpi_ec_event_processor
+acpi_ec_add_query_handler
+acpi_ec_register_query_methods
+acpi_ec_mask_events.part.0
+acpi_ec_suspend
+acpi_ec_stop
+advance_transaction
+acpi_ec_handle_interrupt
+acpi_ec_gpe_handler
+acpi_ec_irq_handler
+acpi_ec_unmask_events
+acpi_ec_complete_query
+acpi_ec_submit_request
+acpi_ec_transaction
+ec_read
+ec_write
+ec_transaction
+acpi_ec_query
+acpi_ec_event_handler
+acpi_ec_enable_event
+acpi_ec_resume
+acpi_ec_space_handler
+acpi_ec_start
+acpi_ec_setup
+acpi_ec_add
+acpi_ec_remove_query_handlers
+acpi_ec_remove_query_handler
+acpi_ec_remove
+acpi_ec_flush_work
+acpi_ec_block_transactions
+acpi_ec_unblock_transactions
+acpi_ec_set_gpe_wake_mask
+acpi_ec_dispatch_gpe
+handle_dock
+dock_hotplug_event
+dock_event
+show_dock_type
+show_dock_uid
+show_flags
+show_docked
+is_dock_device
+dock_present.part.0
+handle_eject_request
+write_undock
+add_dock_dependent_device
+register_dock_dependent_device
+dock_notify
+acpi_dock_add
+acpi_is_root_bridge
+acpi_pci_root_scan_dependent
+acpi_pci_find_root
+acpi_pci_root_validate_resources
+acpi_pci_run_osc
+__acpi_pci_root_release_info
+acpi_pci_root_release_info
+acpi_pci_root_remove
+get_root_bridge_busnr_callback
+decode_osc_bits.constprop.0
+acpi_pci_osc_control_set
+acpi_get_pci_dev
+acpi_pci_root_add
+acpi_pci_probe_root_resources
+acpi_pci_root_create
+acpi_pci_link_remove
+acpi_irq_get_penalty
+acpi_pci_link_check_possible
+acpi_pci_link_get_current
+acpi_pci_link_check_current
+acpi_pci_link_add
+acpi_pci_link_set
+irqrouter_resume
+acpi_pci_link_allocate_irq
+acpi_pci_link_free_irq
+acpi_penalize_isa_irq
+acpi_isa_irq_available
+acpi_penalize_sci_irq
+acpi_pci_irq_find_prt_entry
+acpi_pci_irq_lookup
+acpi_pci_irq_enable
+acpi_pci_irq_disable
+is_memory
+acpi_lpss_find_device
+acpi_lpss_dismiss
+lpss_uart_setup
+lpss_deassert_reset
+acpi_lpss_unbind
+acpi_lpss_set_ltr
+acpi_lpss_bind
+match_hid_uid
+acpi_lpss_save_ctx
+byt_i2c_setup
+lpss_reg_read
+lpss_ltr_mode_show
+acpi_lpss_platform_notify
+lpss_ltr_show
+acpi_lpss_activate
+acpi_lpss_resume
+acpi_lpss_runtime_resume
+acpi_lpss_restore_noirq
+acpi_lpss_resume_noirq
+acpi_lpss_dep.part.0
+acpi_lpss_dep
+bsw_pwm_setup
+byt_pwm_setup
+acpi_lpss_suspend
+acpi_lpss_runtime_suspend
+acpi_lpss_do_suspend_late
+acpi_lpss_suspend_noirq
+acpi_lpss_suspend_late
+register_device_clock
+acpi_lpss_create_device
+acpi_lpss_resume_early
+acpi_lpss_do_poweroff_late
+acpi_lpss_poweroff_noirq
+acpi_lpss_poweroff_late
+acpi_lpss_restore_early
+misc_check_res
+acpi_apd_setup
+fch_misc_setup
+acpi_apd_create_device
+acpi_platform_device_remove_notify
+acpi_create_platform_device.part.0
+acpi_create_platform_device
+acpi_pnp_attach
+acpi_pnp_match
+acpi_is_pnp_device
+acpi_power_sysfs_remove
+acpi_power_resource_remove_dependent
+acpi_power_hide_list
+acpi_power_expose_list
+acpi_power_get_state
+__acpi_power_on
+acpi_power_in_use_show
+acpi_release_power_resource
+__acpi_power_off
+acpi_power_off_unlocked
+acpi_power_on_unlocked
+acpi_power_on_list
+acpi_power_resources_list_free
+acpi_device_power_add_dependent
+acpi_device_power_remove_dependent
+acpi_power_add_remove_device
+acpi_power_wakeup_list_init
+acpi_device_sleep_wake
+acpi_enable_wakeup_device_power
+acpi_disable_wakeup_device_power
+acpi_power_get_inferred_state
+acpi_power_on_resources
+acpi_power_transition
+acpi_add_power_resource
+acpi_extract_power_resources
+acpi_resume_power_resources
+acpi_turn_off_unused_power_resources
+acpi_notifier_call_chain
+register_acpi_notifier
+unregister_acpi_notifier
+acpi_bus_generate_netlink_event
+ged_shutdown
+ged_remove
+ged_probe
+acpi_ged_request_interrupt
+acpi_ged_irq_handler
+param_get_debug_layer
+param_get_debug_level
+param_get_acpica_version
+acpi_show_profile
+force_remove_show
+param_get_trace_method_name
+hotplug_enabled_show
+param_set_trace_method_name
+param_set_trace_state
+delete_gpe_attr_array
+acpi_bert_data_init
+acpi_table_show
+acpi_table_attr_init
+hotplug_enabled_store
+acpi_data_show
+force_remove_store
+param_get_trace_state
+get_status
+counter_show
+counter_set
+acpi_global_event_handler
+acpi_sysfs_table_handler
+acpi_irq_stats_init
+acpi_sysfs_add_hotplug_profile
+is_acpi_device_node
+is_acpi_data_node
+acpi_device_data_of_node
+acpi_get_next_subnode
+acpi_data_get_property
+acpi_dev_get_property
+acpi_fwnode_property_present
+acpi_destroy_nondev_subnodes
+acpi_node_get_parent
+acpi_fwnode_get_parent
+acpi_fwnode_get_named_child_node
+__acpi_node_get_property_reference
+acpi_fwnode_get_reference_args
+acpi_fwnode_graph_parse_endpoint
+acpi_graph_get_child_prop_value
+acpi_graph_get_remote_endpoint
+is_acpi_graph_node
+acpi_graph_get_next_endpoint
+acpi_fwnode_get_name_prefix
+acpi_fwnode_get_name
+acpi_fwnode_device_get_match_data
+acpi_fwnode_device_is_available
+acpi_data_prop_read_single
+acpi_data_prop_read
+acpi_fwnode_property_read_string_array
+acpi_fwnode_property_read_int_array
+acpi_data_add_props
+acpi_extract_properties
+acpi_nondev_subnode_extract
+acpi_nondev_subnode_data_ok
+acpi_enumerate_nondev_subnodes
+acpi_init_properties
+acpi_free_properties
+acpi_node_prop_get
+acpi_dev_prop_read_single
+acpi_dev_prop_read
+acpi_node_prop_read
+acpi_remove_cmos_rtc_space_handler
+acpi_install_cmos_rtc_space_handler
+acpi_cmos_rtc_space_handler
+acpi_extract_apple_properties
+acpi_device_always_present
+acpi_lpat_raw_to_temp
+acpi_lpat_temp_to_raw
+acpi_lpat_free_conversion_table
+acpi_lpat_get_conversion_table
+lpit_read_residency_count_address
+lpit_update_residency
+lpit_read_residency_counter_us
+low_power_idle_cpu_residency_us_show
+low_power_idle_system_residency_us_show
+acpi_init_lpit
+acpi_watchdog_get_wdat
+acpi_has_watchdog
+adxl_get_component_names
+adxl_dsm
+adxl_decode
+acpi_ds_execute_arguments
+acpi_ds_get_buffer_field_arguments
+acpi_ds_get_bank_field_arguments
+acpi_ds_get_buffer_arguments
+acpi_ds_get_package_arguments
+acpi_ds_get_region_arguments
+acpi_ds_exec_begin_control_op
+acpi_ds_exec_end_control_op
+acpi_ds_print_node_pathname.constprop.0
+acpi_ds_dump_method_stack
+acpi_ds_get_field_names
+acpi_ds_create_buffer_field
+acpi_ds_create_field
+acpi_ds_init_field_objects
+acpi_ds_create_bank_field
+acpi_ds_create_index_field
+acpi_ds_init_one_object
+acpi_ds_initialize_objects
+acpi_ds_detect_named_opcodes
+acpi_ds_auto_serialize_method
+acpi_ds_method_error
+acpi_ds_begin_method_execution
+acpi_ds_restart_control_method
+acpi_ds_terminate_control_method
+acpi_ds_call_control_method
+acpi_ds_method_data_init
+acpi_ds_method_data_delete_all
+acpi_ds_method_data_get_node
+acpi_ds_method_data_set_value
+acpi_ds_method_data_init_args
+acpi_ds_method_data_get_value
+acpi_ds_store_object_to_local
+acpi_ds_build_internal_buffer_obj
+acpi_ds_init_object_from_op
+acpi_ds_build_internal_object
+acpi_ds_create_node
+acpi_ds_init_buffer_field
+acpi_ds_initialize_region
+acpi_ds_eval_buffer_field_operands
+acpi_ds_eval_region_operands
+acpi_ds_eval_table_region_operands
+acpi_ds_eval_data_object_operands
+acpi_ds_eval_bank_field_operands
+acpi_ds_init_package_element
+acpi_ds_build_internal_package_obj
+acpi_ds_clear_implicit_return
+acpi_ds_do_implicit_return
+acpi_ds_is_result_used
+acpi_ds_delete_result_if_not_used
+acpi_ds_resolve_operands
+acpi_ds_clear_operands
+acpi_ds_create_operand
+acpi_ds_create_operands
+acpi_ds_evaluate_name_path
+acpi_ds_get_predicate_value
+acpi_ds_exec_begin_op
+acpi_ds_exec_end_op
+acpi_ds_load1_begin_op
+acpi_ds_load1_end_op
+acpi_ds_init_callbacks
+acpi_ds_load2_begin_op
+acpi_ds_load2_end_op
+acpi_ds_scope_stack_clear
+acpi_ds_scope_stack_push
+acpi_ds_scope_stack_pop
+acpi_ds_result_pop
+acpi_ds_result_push
+acpi_ds_obj_stack_push
+acpi_ds_obj_stack_pop
+acpi_ds_obj_stack_pop_and_delete
+acpi_ds_get_current_walk_state
+acpi_ds_push_walk_state
+acpi_ds_pop_walk_state
+acpi_ds_create_walk_state
+acpi_ds_init_aml_walk
+acpi_ds_delete_walk_state
+acpi_ev_initialize_events
+acpi_ev_install_xrupt_handlers
+acpi_ev_fixed_event_detect
+acpi_any_fixed_event_status_set
+acpi_ev_update_gpe_enable_mask
+acpi_ev_enable_gpe
+acpi_ev_mask_gpe
+acpi_ev_add_gpe_reference
+acpi_ev_remove_gpe_reference
+acpi_ev_low_get_gpe_info
+acpi_ev_get_gpe_event_info
+acpi_ev_finish_gpe
+acpi_ev_asynch_enable_gpe
+acpi_ev_asynch_execute_gpe_method
+acpi_ev_gpe_dispatch
+acpi_ev_detect_gpe
+acpi_ev_gpe_detect
+acpi_ev_delete_gpe_block
+acpi_ev_create_gpe_block
+acpi_ev_initialize_gpe_block
+acpi_ev_match_gpe_method
+acpi_ev_gpe_initialize
+acpi_ev_update_gpes
+acpi_ev_walk_gpe_list
+acpi_ev_get_gpe_device
+acpi_ev_get_gpe_xrupt_block
+acpi_ev_delete_gpe_xrupt
+acpi_ev_delete_gpe_handlers
+acpi_ev_global_lock_handler
+acpi_ev_init_global_lock_handler
+acpi_ev_remove_global_lock_handler
+acpi_ev_acquire_global_lock
+acpi_ev_release_global_lock
+acpi_ev_has_default_handler
+acpi_ev_find_region_handler
+acpi_ev_install_handler
+acpi_ev_install_space_handler
+acpi_ev_install_region_handlers
+acpi_ev_notify_dispatch
+acpi_ev_is_notify_object
+acpi_ev_queue_notify_request
+acpi_ev_terminate
+acpi_ev_address_space_dispatch
+acpi_ev_attach_region
+acpi_ev_execute_reg_method
+acpi_ev_detach_region
+acpi_ev_reg_run
+acpi_ev_execute_reg_methods
+acpi_ev_initialize_op_regions
+acpi_ev_system_memory_region_setup
+acpi_ev_io_space_region_setup
+acpi_ev_is_pci_root_bridge
+acpi_ev_pci_config_region_setup
+acpi_ev_pci_bar_region_setup
+acpi_ev_cmos_region_setup
+acpi_ev_default_region_setup
+acpi_ev_initialize_region
+acpi_ev_sci_dispatch
+acpi_ev_sci_xrupt_handler
+acpi_ev_gpe_xrupt_handler
+acpi_ev_install_sci_handler
+acpi_ev_remove_all_sci_handlers
+acpi_acquire_global_lock
+acpi_install_global_event_handler
+acpi_install_fixed_event_handler
+acpi_remove_fixed_event_handler
+acpi_release_global_lock
+acpi_install_notify_handler
+acpi_remove_notify_handler
+acpi_remove_sci_handler
+acpi_remove_gpe_handler
+acpi_install_sci_handler
+acpi_ev_install_gpe_handler
+acpi_install_gpe_handler
+acpi_install_gpe_raw_handler
+acpi_get_event_status
+acpi_disable
+acpi_enable
+acpi_clear_event
+acpi_enable_event
+acpi_disable_event
+acpi_update_all_gpes
+acpi_dispatch_gpe
+acpi_disable_gpe
+acpi_mask_gpe
+acpi_clear_gpe
+acpi_get_gpe_status
+acpi_finish_gpe
+acpi_get_gpe_device
+acpi_mark_gpe_for_wake
+acpi_enable_gpe
+acpi_set_gpe
+acpi_set_gpe_wake_mask
+acpi_disable_all_gpes
+acpi_enable_all_runtime_gpes
+acpi_enable_all_wakeup_gpes
+acpi_any_gpe_status_set
+acpi_install_gpe_block
+acpi_remove_gpe_block
+acpi_setup_gpe_for_wake
+acpi_install_address_space_handler
+acpi_remove_address_space_handler
+acpi_ex_convert_to_object_type_string
+acpi_ex_do_concatenate
+acpi_ex_concat_template
+acpi_ex_region_read
+acpi_ex_add_table
+acpi_ex_unload_table
+acpi_ex_load_table_op
+acpi_ex_load_op
+acpi_ex_convert_to_ascii
+acpi_ex_convert_to_integer
+acpi_ex_convert_to_buffer
+acpi_ex_convert_to_string
+acpi_ex_convert_to_target_type
+acpi_ex_create_alias
+acpi_ex_create_event
+acpi_ex_create_mutex
+acpi_ex_create_region
+acpi_ex_create_processor
+acpi_ex_create_power_resource
+acpi_ex_create_method
+acpi_ex_do_debug_object
+acpi_ex_dump_reference_obj
+acpi_ex_dump_package_obj
+acpi_ex_dump_object
+acpi_ex_dump_operand
+acpi_ex_dump_operands
+acpi_ex_dump_namespace_node
+acpi_ex_dump_object_descriptor
+acpi_ex_get_protocol_buffer_length
+acpi_ex_read_data_from_field
+acpi_ex_write_data_to_field
+acpi_ex_register_overflow
+acpi_ex_access_region
+acpi_ex_insert_into_field
+acpi_ex_field_datum_io
+acpi_ex_write_with_update_rule
+acpi_ex_extract_from_field
+acpi_ex_get_object_reference
+acpi_ex_do_math_op
+acpi_ex_do_logical_numeric_op
+acpi_ex_do_logical_op
+acpi_ex_unlink_mutex
+acpi_ex_acquire_mutex_object
+acpi_ex_acquire_mutex
+acpi_ex_release_mutex_object
+acpi_ex_release_mutex
+acpi_ex_release_all_mutexes
+acpi_ex_allocate_name_string
+acpi_ex_name_segment
+acpi_ex_get_name_string
+acpi_ex_opcode_0A_0T_1R
+acpi_ex_opcode_1A_0T_0R
+acpi_ex_opcode_1A_1T_0R
+acpi_ex_opcode_1A_1T_1R
+acpi_ex_opcode_1A_0T_1R
+acpi_ex_opcode_2A_0T_0R
+acpi_ex_opcode_2A_2T_1R
+acpi_ex_opcode_2A_1T_1R
+acpi_ex_opcode_2A_0T_1R
+acpi_ex_opcode_3A_0T_0R
+acpi_ex_opcode_3A_1T_1R
+acpi_ex_do_match
+acpi_ex_opcode_6A_0T_1R
+acpi_ex_prep_common_field_object
+acpi_ex_prep_field_value
+acpi_ex_system_memory_space_handler
+acpi_ex_system_io_space_handler
+acpi_ex_pci_config_space_handler
+acpi_ex_cmos_space_handler
+acpi_ex_pci_bar_space_handler
+acpi_ex_data_table_space_handler
+acpi_ex_resolve_node_to_value
+acpi_ex_resolve_to_value
+acpi_ex_resolve_multiple
+acpi_ex_check_object_type
+acpi_ex_resolve_operands
+acpi_ex_read_gpio
+acpi_ex_write_gpio
+acpi_ex_read_serial_bus
+acpi_ex_write_serial_bus
+acpi_ex_store_direct_to_node
+acpi_ex_store_object_to_node
+acpi_ex_store
+acpi_ex_resolve_object
+acpi_ex_store_object_to_object
+acpi_ex_store_buffer_to_buffer
+acpi_ex_store_string_to_string
+acpi_ex_system_wait_semaphore
+acpi_ex_system_wait_mutex
+acpi_ex_system_do_stall
+acpi_ex_system_do_sleep
+acpi_ex_system_signal_event
+acpi_ex_system_wait_event
+acpi_ex_system_reset_event
+acpi_ex_interpreter_trace_enabled
+acpi_ex_trace_point
+acpi_ex_start_trace_method
+acpi_ex_stop_trace_method
+acpi_ex_start_trace_opcode
+acpi_ex_stop_trace_opcode
+acpi_ex_enter_interpreter
+acpi_ex_exit_interpreter
+acpi_ex_truncate_for32bit_table
+acpi_ex_acquire_global_lock
+acpi_ex_release_global_lock
+acpi_ex_eisa_id_to_string
+acpi_ex_integer_to_string
+acpi_ex_pci_cls_to_string
+acpi_is_valid_space_id
+acpi_hw_set_mode
+acpi_hw_get_mode
+acpi_hw_execute_sleep_method
+acpi_hw_extended_sleep
+acpi_hw_extended_wake_prep
+acpi_hw_extended_wake
+acpi_hw_gpe_read
+acpi_hw_get_gpe_block_status
+acpi_hw_gpe_write
+acpi_hw_enable_runtime_gpe_block
+acpi_hw_disable_gpe_block
+acpi_hw_enable_wakeup_gpe_block
+acpi_hw_get_gpe_register_bit
+acpi_hw_low_set_gpe
+acpi_hw_clear_gpe
+acpi_hw_get_gpe_status
+acpi_hw_clear_gpe_block
+acpi_hw_disable_all_gpes
+acpi_hw_enable_all_runtime_gpes
+acpi_hw_enable_all_wakeup_gpes
+acpi_hw_check_all_gpes
+acpi_hw_get_access_bit_width
+acpi_hw_validate_register
+acpi_hw_read
+acpi_hw_read_multiple
+acpi_hw_write
+acpi_hw_write_multiple
+acpi_hw_get_bit_register_info
+acpi_hw_write_pm1_control
+acpi_hw_register_read
+acpi_hw_register_write
+acpi_hw_clear_acpi_status
+acpi_hw_legacy_sleep
+acpi_hw_legacy_wake_prep
+acpi_hw_legacy_wake
+acpi_hw_validate_io_request
+acpi_hw_read_port
+acpi_hw_write_port
+acpi_hw_validate_io_block
+acpi_write
+acpi_read
+acpi_read_bit_register
+acpi_write_bit_register
+acpi_reset
+acpi_get_sleep_type_data
+acpi_leave_sleep_state_prep
+acpi_leave_sleep_state
+acpi_set_firmware_waking_vector
+acpi_enter_sleep_state_s4bios
+acpi_enter_sleep_state_prep
+acpi_enter_sleep_state
+acpi_hw_delete_pci_list
+acpi_hw_derive_pci_id
+acpi_ns_root_initialize
+acpi_ns_lookup
+acpi_ns_create_node
+acpi_ns_delete_node
+acpi_ns_remove_node
+acpi_ns_install_node
+acpi_ns_delete_children
+acpi_ns_delete_namespace_subtree
+acpi_ns_delete_namespace_by_owner
+acpi_ns_check_argument_types
+acpi_ns_check_acpi_compliance
+acpi_ns_check_argument_count
+acpi_ns_convert_to_integer
+acpi_ns_convert_to_string
+acpi_ns_convert_to_buffer
+acpi_ns_convert_to_unicode
+acpi_ns_convert_to_resource
+acpi_ns_convert_to_reference
+acpi_ns_get_max_depth
+acpi_ns_dump_one_object
+acpi_ns_dump_one_object_path
+acpi_ns_print_pathname
+acpi_ns_dump_objects
+acpi_ns_dump_object_paths
+acpi_ns_dump_entry
+acpi_ns_evaluate
+acpi_ns_init_one_device
+acpi_ns_find_ini_methods
+acpi_ns_initialize_objects
+acpi_ns_initialize_devices
+acpi_ns_init_one_package
+acpi_ns_init_one_object
+acpi_ns_load_table
+acpi_ns_handle_to_name
+acpi_ns_build_normalized_path
+acpi_ns_get_pathname_length
+acpi_ns_handle_to_pathname
+acpi_ns_get_normalized_pathname
+acpi_ns_get_external_pathname
+acpi_ns_normalize_pathname
+acpi_ns_build_prefixed_pathname
+acpi_ns_detach_object
+acpi_ns_attach_object
+acpi_ns_get_attached_object
+acpi_ns_get_secondary_object
+acpi_ns_attach_data
+acpi_ns_detach_data
+acpi_ns_get_attached_data
+acpi_ns_execute_table
+acpi_ns_one_complete_parse
+acpi_ns_parse_table
+acpi_ns_check_object_type
+acpi_ns_check_return_value
+acpi_ns_check_package_elements
+acpi_ns_check_package_list
+acpi_ns_check_package
+acpi_ns_repair_null_element
+acpi_ns_remove_null_elements
+acpi_ns_wrap_with_package
+acpi_ns_simple_repair
+acpi_ns_repair_PRT
+acpi_ns_repair_HID
+acpi_ns_repair_CID
+acpi_ns_repair_FDE
+acpi_ns_check_sorted_list.part.0
+acpi_ns_repair_CST
+acpi_ns_repair_ALR
+acpi_ns_repair_PSS
+acpi_ns_repair_TSS
+acpi_ns_complex_repairs
+acpi_ns_search_one_scope
+acpi_ns_search_and_enter
+acpi_ns_print_node_pathname
+acpi_ns_get_type
+acpi_ns_local
+acpi_ns_get_internal_name_length
+acpi_ns_build_internal_name
+acpi_ns_internalize_name
+acpi_ns_externalize_name
+acpi_ns_validate_handle
+acpi_ns_terminate
+acpi_ns_opens_scope
+acpi_ns_get_node_unlocked
+acpi_ns_get_node
+acpi_ns_get_next_node
+acpi_ns_get_next_node_typed
+acpi_ns_walk_namespace
+acpi_get_devices
+acpi_evaluate_object
+acpi_evaluate_object_typed
+acpi_walk_namespace
+acpi_attach_data
+acpi_detach_data
+acpi_ns_get_device_callback
+acpi_get_data_full
+acpi_get_data
+acpi_get_handle
+acpi_ns_copy_device_id
+acpi_get_name
+acpi_get_object_info
+acpi_install_method
+acpi_get_type
+acpi_get_parent
+acpi_get_next_object
+acpi_ps_get_next_package_length
+acpi_ps_get_next_package_end
+acpi_ps_get_next_namestring
+acpi_ps_get_next_namepath
+acpi_ps_get_next_simple_arg
+acpi_ps_get_next_arg
+acpi_ps_parse_loop
+acpi_ps_build_named_op
+acpi_ps_create_op
+acpi_ps_complete_op
+acpi_ps_complete_final_op
+acpi_ps_get_opcode_info
+acpi_ps_get_opcode_name
+acpi_ps_get_argument_count
+acpi_ps_get_opcode_size
+acpi_ps_peek_opcode
+acpi_ps_complete_this_op
+acpi_ps_next_parse_state
+acpi_ps_parse_aml
+acpi_ps_get_parent_scope
+acpi_ps_has_completed_scope
+acpi_ps_init_scope
+acpi_ps_push_scope
+acpi_ps_pop_scope
+acpi_ps_cleanup_scope
+acpi_ps_get_arg
+acpi_ps_append_arg
+acpi_ps_get_depth_next
+acpi_ps_init_op
+acpi_ps_alloc_op
+acpi_ps_create_scope_op
+acpi_ps_free_op
+acpi_ps_is_leading_char
+acpi_ps_get_name
+acpi_ps_set_name
+acpi_ps_delete_parse_tree
+acpi_ps_update_parameter_list
+acpi_debug_trace
+acpi_ps_execute_method
+acpi_ps_execute_table
+acpi_rs_get_address_common
+acpi_rs_set_address_common
+acpi_rs_get_aml_length
+acpi_rs_get_list_length
+acpi_rs_get_pci_routing_table_length
+acpi_buffer_to_resource
+acpi_rs_create_resource_list
+acpi_rs_create_pci_routing_table
+acpi_rs_create_aml_resources
+acpi_rs_convert_aml_to_resources
+acpi_rs_convert_resources_to_aml
+acpi_rs_convert_aml_to_resource
+acpi_rs_convert_resource_to_aml
+acpi_rs_decode_bitmask
+acpi_rs_encode_bitmask
+acpi_rs_move_data
+acpi_rs_set_resource_length
+acpi_rs_set_resource_header
+acpi_rs_get_resource_source
+acpi_rs_set_resource_source
+acpi_rs_get_prt_method_data
+acpi_rs_get_crs_method_data
+acpi_rs_get_prs_method_data
+acpi_rs_get_aei_method_data
+acpi_rs_get_method_data
+acpi_rs_set_srs_method_data
+acpi_walk_resource_buffer
+acpi_rs_validate_parameters
+acpi_get_irq_routing_table
+acpi_get_current_resources
+acpi_get_possible_resources
+acpi_get_event_resources
+acpi_resource_to_address64
+acpi_set_current_resources
+acpi_rs_match_vendor_resource
+acpi_walk_resources
+acpi_get_vendor_resource
+acpi_tb_init_table_descriptor
+acpi_tb_acquire_table
+acpi_tb_release_table
+acpi_tb_acquire_temp_table
+acpi_tb_validate_table
+acpi_tb_invalidate_table
+acpi_tb_release_temp_table
+acpi_tb_validate_temp_table
+acpi_tb_verify_temp_table
+acpi_tb_resize_root_table_list
+acpi_tb_get_next_table_descriptor
+acpi_tb_terminate
+acpi_tb_delete_namespace_by_owner
+acpi_tb_allocate_owner_id
+acpi_tb_release_owner_id
+acpi_tb_get_owner_id
+acpi_tb_is_table_loaded
+acpi_tb_set_table_loaded_flag
+acpi_tb_notify_table
+acpi_tb_load_table
+acpi_tb_install_and_load_table
+acpi_tb_unload_table
+acpi_tb_create_local_fadt
+acpi_tb_parse_fadt
+acpi_tb_find_table
+acpi_tb_uninstall_table
+acpi_tb_override_table
+acpi_tb_install_table_with_override
+acpi_tb_install_standard_table
+acpi_tb_fix_string
+acpi_tb_print_table_header
+acpi_tb_checksum
+acpi_tb_verify_checksum
+acpi_tb_initialize_facs
+acpi_tb_check_dsdt_header
+acpi_tb_copy_dsdt
+acpi_tb_get_table
+acpi_tb_put_table
+acpi_remove_table_handler
+acpi_install_table_handler
+acpi_get_table_header
+acpi_get_table
+acpi_get_table_by_index
+acpi_put_table
+acpi_allocate_root_table
+acpi_unload_parent_table
+acpi_load_table
+acpi_unload_table
+acpi_tb_load_namespace
+acpi_tb_get_rsdp_length
+acpi_tb_validate_rsdp
+acpi_tb_scan_memory_for_rsdp
+acpi_ut_add_address_range
+acpi_ut_remove_address_range
+acpi_ut_check_address_range
+acpi_ut_delete_address_lists
+acpi_ut_create_caches
+acpi_ut_delete_caches
+acpi_ut_validate_buffer
+acpi_ut_initialize_buffer
+acpi_ut_valid_name_char
+acpi_ut_valid_nameseg
+acpi_ut_check_and_repair_ascii
+acpi_ut_dump_buffer
+acpi_ut_debug_dump_buffer
+acpi_ut_copy_isimple_to_esimple
+acpi_ut_copy_ielement_to_eelement
+acpi_ut_copy_simple_object
+acpi_ut_copy_ielement_to_ielement
+acpi_ut_copy_iobject_to_eobject
+acpi_ut_copy_eobject_to_iobject
+acpi_ut_copy_iobject_to_iobject
+acpi_ut_validate_exception
+acpi_format_exception
+acpi_debug_print_raw
+acpi_debug_print
+acpi_ut_exit
+acpi_ut_value_exit
+acpi_ut_status_exit
+acpi_ut_init_stack_ptr_trace
+acpi_ut_track_stack_ptr
+acpi_ut_trace
+acpi_trace_point
+acpi_ut_trace_ptr
+acpi_ut_trace_str
+acpi_ut_trace_u32
+acpi_ut_ptr_exit
+acpi_ut_str_exit
+acpi_ut_get_region_name
+acpi_ut_get_event_name
+acpi_ut_get_type_name
+acpi_ut_get_node_name
+acpi_ut_get_descriptor_name
+acpi_ut_get_object_type_name
+acpi_ut_get_reference_name
+acpi_ut_get_mutex_name
+acpi_ut_get_notify_name
+acpi_ut_get_argument_type_name
+acpi_ut_valid_object_type
+acpi_ut_remove_reference
+acpi_ut_delete_internal_object_list
+acpi_ut_update_ref_count.part.0
+acpi_ut_update_object_reference
+acpi_ut_add_reference
+acpi_ut_predefined_warning
+acpi_ut_predefined_info
+acpi_ut_predefined_bios_error
+acpi_ut_prefixed_namespace_error
+acpi_ut_method_error
+acpi_ut_evaluate_object
+acpi_ut_evaluate_numeric_object
+acpi_ut_execute_STA
+acpi_ut_execute_power_methods
+acpi_ut_hex_to_ascii_char
+acpi_ut_ascii_char_to_hex
+acpi_ut_ascii_to_hex_byte
+acpi_ut_execute_HID
+acpi_ut_execute_UID
+acpi_ut_execute_CID
+acpi_ut_execute_CLS
+acpi_ut_init_globals
+acpi_ut_subsystem_shutdown
+acpi_ut_create_rw_lock
+acpi_ut_delete_rw_lock
+acpi_ut_acquire_read_lock
+acpi_ut_release_read_lock
+acpi_ut_acquire_write_lock
+acpi_ut_release_write_lock
+acpi_ut_short_multiply
+acpi_ut_short_shift_left
+acpi_ut_short_shift_right
+acpi_ut_short_divide
+acpi_ut_divide
+acpi_ut_is_pci_root_bridge
+acpi_ut_dword_byte_swap
+acpi_ut_set_integer_width
+acpi_ut_create_update_state_and_push
+acpi_ut_walk_package_tree
+acpi_ut_display_init_pathname
+acpi_ut_mutex_initialize
+acpi_ut_mutex_terminate
+acpi_ut_acquire_mutex
+acpi_ut_release_mutex
+acpi_ut_strlwr
+acpi_ut_strupr
+acpi_ut_stricmp
+acpi_ut_safe_strcpy
+acpi_ut_safe_strcat
+acpi_ut_safe_strncat
+acpi_ut_safe_strncpy
+acpi_ut_get_simple_object_size
+acpi_ut_get_element_length
+acpi_ut_valid_internal_object
+acpi_ut_allocate_object_desc_dbg
+acpi_ut_delete_object_desc
+acpi_ut_create_internal_object_dbg
+acpi_ut_create_package_object
+acpi_ut_create_integer_object
+acpi_ut_create_buffer_object
+acpi_ut_create_string_object
+acpi_ut_get_object_size
+acpi_ut_initialize_interfaces
+acpi_ut_interface_terminate
+acpi_ut_install_interface
+acpi_ut_remove_interface
+acpi_ut_update_interfaces
+acpi_ut_get_interface
+acpi_ut_osi_implementation
+acpi_ut_allocate_owner_id
+acpi_ut_release_owner_id
+acpi_ut_get_next_predefined_method
+acpi_ut_match_predefined_method
+acpi_ut_get_expected_return_types
+acpi_ut_get_resource_type
+acpi_ut_get_resource_length
+acpi_ut_validate_resource
+acpi_ut_get_resource_header_length
+acpi_ut_get_descriptor_length
+acpi_ut_walk_aml_resources
+acpi_ut_get_resource_end_tag
+acpi_ut_push_generic_state
+acpi_ut_pop_generic_state
+acpi_ut_create_generic_state
+acpi_ut_create_thread_state
+acpi_ut_create_update_state
+acpi_ut_create_pkg_state
+acpi_ut_create_control_state
+acpi_ut_delete_generic_state
+acpi_ut_print_string
+acpi_ut_repair_name
+acpi_ut_insert_digit
+acpi_ut_convert_octal_string
+acpi_ut_convert_decimal_string
+acpi_ut_convert_hex_string
+acpi_ut_remove_leading_zeros
+acpi_ut_remove_whitespace
+acpi_ut_remove_hex_prefix
+acpi_ut_detect_hex_prefix
+acpi_ut_detect_octal_prefix
+acpi_ut_strtoul64
+acpi_ut_implicit_strtoul64
+acpi_ut_explicit_strtoul64
+acpi_purge_cached_objects
+acpi_install_interface_handler
+acpi_check_address_range
+acpi_install_interface
+acpi_remove_interface
+acpi_decode_pld_buffer
+acpi_update_interfaces
+acpi_error
+acpi_warning
+acpi_info
+acpi_bios_error
+acpi_bios_warning
+acpi_exception
+acpi_bios_exception
+acpi_ut_get_mutex_object.part.0
+acpi_acquire_mutex
+acpi_release_mutex
+acpi_db_resource_callback
+acpi_db_do_one_sleep_state
+acpi_db_device_resources
+acpi_db_convert_to_node
+acpi_db_sleep
+acpi_db_display_locks
+acpi_db_display_table_info
+acpi_db_unload_acpi_table
+acpi_db_send_notify
+acpi_db_display_interfaces
+acpi_db_display_template
+acpi_db_display_resources
+acpi_db_generate_gpe
+acpi_db_generate_sci
+acpi_db_trace
+acpi_db_hex_char_to_value
+acpi_db_convert_to_object
+acpi_db_convert_to_package
+acpi_db_encode_pld_buffer
+acpi_db_dump_pld_buffer
+acpi_db_display_non_root_handlers
+acpi_db_decode_and_display_object
+acpi_db_display_method_info
+acpi_db_display_locals
+acpi_db_display_arguments
+acpi_db_display_results
+acpi_db_display_calling_tree
+acpi_db_display_object_type
+acpi_db_display_result_object
+acpi_db_display_argument_object
+acpi_db_display_gpes
+acpi_db_display_handlers
+acpi_db_execution_walk
+acpi_db_execute_setup.constprop.0
+acpi_db_delete_objects
+acpi_db_execute_method
+acpi_db_single_execution_thread
+acpi_db_method_thread
+acpi_db_execute
+acpi_db_create_execution_thread
+acpi_db_create_execution_threads
+acpi_db_add_to_history
+acpi_db_display_history
+acpi_db_get_history_by_index
+acpi_db_get_from_history
+acpi_db_display_command_info
+acpi_db_get_next_token
+acpi_db_command_dispatch
+acpi_db_user_commands
+acpi_db_execute_thread
+acpi_db_evaluate_object
+acpi_db_walk_for_execute
+acpi_db_walk_for_execute_all
+acpi_db_set_method_breakpoint
+acpi_db_set_method_call_breakpoint
+acpi_db_set_method_data
+acpi_db_evaluate_predefined_names
+acpi_db_evaluate_all
+acpi_db_walk_for_object_counts
+acpi_db_walk_and_match_name
+acpi_db_walk_for_specific_objects
+acpi_db_walk_for_predefined_names
+acpi_db_walk_for_fields
+acpi_db_integrity_walk
+acpi_db_bus_walk
+acpi_db_walk_for_references
+acpi_db_set_scope
+acpi_db_dump_namespace
+acpi_db_dump_namespace_paths
+acpi_db_dump_namespace_by_owner
+acpi_db_find_name_in_namespace
+acpi_db_check_predefined_names
+acpi_db_display_objects
+acpi_db_display_fields
+acpi_db_check_integrity
+acpi_db_find_references
+acpi_db_get_bus_info
+acpi_db_decode_internal_object
+acpi_db_decode_node
+acpi_db_display_internal_object
+acpi_db_decode_locals
+acpi_db_decode_arguments
+acpi_db_dump_method_info
+acpi_db_enumerate_object
+acpi_db_classify_one_object
+acpi_db_display_statistics
+acpi_db_match_argument
+acpi_db_set_output_destination
+acpi_db_dump_external_object
+acpi_db_prep_namestring
+acpi_db_local_ns_lookup
+acpi_db_uint32_to_hex_string
+acpi_set_debugger_thread_id
+acpi_terminate_debugger
+acpi_initialize_debugger
+acpi_db_signal_break_point
+acpi_db_single_step
+acpi_rs_out_string
+acpi_rs_dump_short_byte_list
+acpi_rs_dump_descriptor
+acpi_rs_dump_resource_list
+acpi_rs_dump_irq_list
+acpi_ac_get_state
+acpi_ac_resume
+acpi_ac_notify
+acpi_ac_remove
+acpi_ac_battery_notify
+get_ac_property
+acpi_ac_add
+param_set_lid_init_state
+acpi_button_suspend
+acpi_lid_evaluate_state
+acpi_lid_open
+param_get_lid_init_state
+acpi_button_state_seq_show
+acpi_lid_notify_state
+acpi_lid_update_state
+acpi_lid_initialize_state
+acpi_button_resume
+acpi_lid_input_open
+acpi_button_notify
+acpi_button_remove_fs.part.0
+acpi_button_remove
+acpi_button_add
+acpi_fan_speed_cmp
+show_state
+fan_get_max_state
+acpi_fan_remove
+fan_set_cur_state
+fan_get_cur_state
+acpi_fan_probe
+acpi_fan_suspend
+acpi_fan_resume
+do_sta_before_sun
+register_slot
+acpi_pci_slot_enumerate
+acpi_pci_slot_remove
+acpi_pss_perf_exit
+acpi_processor_stop
+__acpi_processor_start
+acpi_processor_start
+acpi_soft_cpu_dead
+acpi_soft_cpu_online
+acpi_processor_notifier
+acpi_processor_notify
+flatten_lpi_states
+__lapic_timer_propagate_broadcast
+set_max_cstate
+acpi_processor_setup_cpuidle_states.part.0
+acpi_processor_evaluate_lpi
+acpi_processor_get_lpi_info
+acpi_processor_get_power_info
+acpi_idle_enter_bm
+acpi_idle_enter
+acpi_idle_play_dead
+acpi_idle_enter_s2idle
+acpi_processor_ffh_lpi_probe
+acpi_processor_setup_cpuidle_dev
+acpi_processor_ffh_lpi_enter
+acpi_idle_lpi_enter
+acpi_processor_hotplug
+acpi_processor_power_state_has_changed
+acpi_processor_power_init
+acpi_processor_power_exit
+__acpi_processor_get_throttling
+acpi_processor_set_throttling_fadt
+acpi_processor_get_platform_limit
+acpi_processor_throttling_notifier
+acpi_processor_set_throttling_ptc
+acpi_processor_throttling_fn
+acpi_processor_get_throttling
+__acpi_processor_set_throttling
+acpi_processor_get_throttling_ptc
+acpi_processor_get_throttling_fadt
+acpi_processor_throttling_init
+acpi_processor_tstate_has_changed
+acpi_processor_reevaluate_tstate
+acpi_processor_set_throttling
+acpi_processor_get_throttling_info
+phys_package_first_cpu
+cpu_has_cpufreq
+acpi_processor_max_state
+processor_get_max_state
+processor_get_cur_state
+cpufreq_set_cur_state.part.0
+processor_set_cur_state
+acpi_thermal_cpufreq_init
+acpi_thermal_cpufreq_exit
+acpi_processor_get_bios_limit
+acpi_processor_get_platform_limit
+acpi_processor_get_psd
+acpi_processor_unregister_performance
+acpi_processor_ppc_ost
+acpi_processor_get_performance_info
+acpi_processor_register_performance
+acpi_processor_preregister_performance
+acpi_processor_ppc_has_changed
+acpi_processor_ignore_ppc_init
+acpi_processor_ppc_init
+acpi_processor_ppc_exit
+acpi_processor_pstate_control
+acpi_processor_notify_smm
+acpi_container_release
+container_device_online
+container_device_detach
+acpi_container_offline
+container_device_attach
+acpi_thermal_suspend
+thermal_get_trip_type
+thermal_get_trip_temp
+thermal_get_crit_temp
+thermal_get_trend
+acpi_thermal_resume
+acpi_thermal_get_temperature
+thermal_get_temp
+thermal_nocrt
+acpi_thermal_trips_update
+acpi_thermal_notify
+acpi_thermal_check_fn
+acpi_thermal_remove
+acpi_thermal_cooling_device_cb
+acpi_thermal_unbind_cooling_device
+acpi_thermal_bind_cooling_device
+thermal_notify
+thermal_tzp
+thermal_psv
+thermal_act
+acpi_thermal_add
+pxm_to_node
+acpi_get_node
+acpi_map_pxm_to_node
+node_to_pxm
+hmat_update_target_access
+hmat_update_best
+hmat_normalize.part.0
+hmat_initiator_perf
+initiator_cmp
+hmat_register_target
+hmat_callback
+acpi_unbind_memblk
+acpi_bind_memblk
+acpi_memory_free_device_resources
+acpi_memory_device_free.part.0
+acpi_memory_device_remove
+acpi_memory_device_add
+acpi_memory_get_resource
+setup_res
+handle_ioapic_add
+acpi_ioapic_add
+pci_ioapic_remove
+acpi_ioapic_remove
+__battery_hook_unregister
+battery_hook_unregister
+battery_hook_register
+sysfs_remove_battery
+acpi_battery_alarm_show
+acpi_battery_set_alarm
+acpi_battery_alarm_store
+sysfs_add_battery
+acpi_battery_remove
+extract_package.part.0
+acpi_battery_get_info
+acpi_battery_get_state
+find_battery
+acpi_battery_init_alarm
+acpi_battery_refresh
+battery_notify
+acpi_battery_update
+acpi_battery_resume
+acpi_battery_notify
+acpi_battery_add
+acpi_battery_get_property
+acpi_hed_remove
+register_acpi_hed_notifier
+unregister_acpi_hed_notifier
+acpi_hed_notify
+acpi_hed_add
+show_yoffset
+show_xoffset
+show_type
+show_status
+show_version
+image_read
+cppc_get_transition_latency
+acpi_cppc_processor_exit
+check_pcc_chan
+cppc_chan_tx_done
+send_pcc_cmd
+acpi_get_psd_map
+acpi_get_psd_map
+acpi_cppc_processor_probe
+acpi_cppc_processor_probe
+cpc_read
+cppc_get_desired_perf
+cppc_get_perf_caps
+show_lowest_freq
+show_nominal_freq
+show_nominal_perf
+show_lowest_nonlinear_perf
+show_lowest_perf
+show_highest_perf
+cppc_get_perf_ctrs
+show_wraparound_time
+show_reference_perf
+show_feedback_ctrs
+show_feedback_ctrs
+cppc_set_perf
+acpi_aml_notify_command_complete
+acpi_aml_wait_command_ready
+acpi_aml_busy
+acpi_aml_unlock_fifo
+acpi_aml_thread
+acpi_aml_create_thread
+acpi_aml_release
+acpi_aml_open
+acpi_aml_kern_readable
+acpi_aml_kern_writable
+acpi_aml_user_readable
+acpi_aml_lock_read
+acpi_aml_read_cmd
+acpi_aml_user_writable
+acpi_aml_poll
+acpi_aml_lock_write
+acpi_aml_write_log
+acpi_aml_write
+acpi_aml_read
+apei_exec_noop
+apei_exec_noop
+apei_exec_noop
+apei_exec_ctx_init
+__apei_exec_run
+apei_exec_for_each_entry
+apei_exec_post_unmap_gars
+apei_exec_collect_resources
+apei_check_gar
+apei_exec_pre_map_gars
+post_unmap_gar_callback
+apei_res_clean
+apei_resources_fini
+apei_res_add
+apei_resources_add
+apei_get_res_callback
+collect_res_callback
+apei_res_sub
+apei_resources_sub
+apei_resources_release
+apei_read
+apei_write
+apei_get_debugfs_dir
+apei_osc_setup
+apei_map_generic_address
+pre_map_gar_callback
+apei_resources_request
+__apei_exec_read_register
+apei_exec_read_register
+apei_exec_read_register_value
+__apei_exec_write_register
+apei_exec_write_register
+apei_exec_write_register_value
+apei_hest_parse
+erst_exec_set_dst_address_base
+erst_exec_set_src_address_base
+erst_exec_load_var2
+erst_exec_load_var1
+erst_exec_add
+erst_exec_subtract
+erst_exec_goto
+erst_exec_skip_next_instruction_if_true
+erst_exec_move_data
+erst_timedout
+erst_exec_stall_while_true
+erst_exec_stall
+erst_exec_subtract_value
+erst_exec_add_value
+erst_exec_store_var1
+erst_get_record_count
+pr_unimpl_nvram
+erst_get_record_id_next
+__erst_record_id_cache_compact.part.0
+erst_get_record_id_begin
+erst_open_pstore
+erst_get_record_id_end
+erst_close_pstore
+erst_clear
+erst_clearer
+erst_read
+erst_write
+erst_writer
+erst_reader
+ghes_register_vendor_record_notifier
+ghes_unregister_vendor_record_notifier
+ghes_copy_tofrom_phys
+__ghes_peek_estatus
+__ghes_print_estatus
+ghes_estatus_cache_free
+ghes_estatus_cache_rcu_free
+ghes_vendor_record_work_func
+ghes_estatus_cached
+ghes_estatus_cache_add
+ghes_fini
+ghes_remove
+ghes_add_timer
+ghes_kick_task_work
+__ghes_read_estatus.part.0
+__ghes_check_estatus
+ghes_clear_estatus.part.0
+__ghes_panic
+ghes_print_estatus.constprop.0
+ghes_notify_nmi
+ghes_do_proc.isra.0
+ghes_proc
+ghes_irq_func
+ghes_notify_hed
+ghes_poll_func
+ghes_probe
+ghes_proc_in_irq
+ghes_estatus_pool_init
+intel_pmic_power_handler
+pmic_read_temp
+intel_pmic_thermal_handler
+intel_pmic_install_opregion_handler
+intel_soc_pmic_exec_mipi_pmic_seq_element
+intel_pmic_regs_handler
+intel_crc_pmic_get_raw_temp
+intel_crc_pmic_update_policy
+intel_crc_pmic_update_aux
+intel_crc_pmic_update_power
+intel_crc_pmic_opregion_probe
+intel_crc_pmic_get_policy
+intel_crc_pmic_get_power
+intel_chtcrc_pmic_opregion_probe
+intel_xpower_pmic_gpio_handler
+intel_xpower_pmic_get_raw_temp
+intel_xpower_pmic_opregion_probe
+intel_xpower_pmic_get_power
+intel_xpower_pmic_update_power
+intel_bxtwc_pmic_update_policy
+intel_bxtwc_pmic_update_power
+intel_bxtwc_pmic_get_raw_temp
+intel_bxtwc_pmic_update_aux
+intel_bxtwc_pmic_opregion_probe
+intel_bxtwc_pmic_get_policy
+intel_bxtwc_pmic_get_power
+intel_cht_wc_pmic_update_power
+intel_cht_wc_pmic_opregion_probe
+intel_cht_wc_pmic_get_power
+intel_cht_wc_exec_mipi_pmic_seq_element
+chtdc_ti_pmic_get_raw_temp
+chtdc_ti_pmic_update_power
+chtdc_ti_pmic_opregion_probe
+chtdc_ti_pmic_get_power
+int340x_thermal_handler_attach
+pnp_delist_device
+pnp_alloc
+pnp_register_protocol
+pnp_unregister_protocol
+pnp_free_resource
+pnp_free_resources
+pnp_release_device
+pnp_alloc_dev
+__pnp_add_device
+pnp_add_device
+__pnp_remove_device
+pnp_show_card_name
+pnp_unregister_card_driver
+card_remove
+card_suspend
+card_resume
+pnp_release_card
+card_remove_first
+pnp_show_card_ids
+pnp_request_card_device
+pnp_release_card_device
+card_probe
+pnp_register_card_driver
+pnp_alloc_card
+pnp_add_card
+pnp_add_card_device
+pnp_remove_card_device
+pnp_remove_card
+pnp_device_shutdown
+pnp_device_attach
+pnp_device_detach
+pnp_bus_resume
+pnp_device_remove
+pnp_register_driver
+pnp_unregister_driver
+__pnp_bus_suspend
+pnp_bus_poweroff
+pnp_bus_freeze
+pnp_bus_suspend
+compare_pnp_id
+match_device
+pnp_device_probe
+pnp_bus_match
+pnp_add_id
+pnp_test_handler
+pnp_range_reserved
+pnp_possible_config
+pnp_get_resource
+pnp_register_irq_resource
+pnp_register_dma_resource
+pnp_register_port_resource
+pnp_register_mem_resource
+pnp_free_options
+pnp_check_port
+pnp_check_mem
+pnp_check_irq
+pnp_check_dma
+pnp_resource_type
+pnp_add_resource
+pnp_add_irq_resource
+pnp_add_dma_resource
+pnp_add_io_resource
+pnp_add_mem_resource
+pnp_add_bus_resource
+pnp_clean_resource_table
+pnp_assign_resources
+pnp_start_dev
+pnp_stop_dev
+pnp_disable_dev
+pnp_init_resources
+pnp_auto_config_dev
+pnp_activate_dev
+pnp_is_active
+pnp_eisa_id_to_string
+pnp_resource_type_name
+dbg_pnp_show_resources
+pnp_option_priority_name
+dbg_pnp_show_option
+id_show
+pnp_printf
+options_show
+resources_show
+pnp_get_resource_value.isra.0
+resources_store
+quirk_ad1815_mpu_resources
+quirk_sb16audio_resources
+quirk_intel_mch
+quirk_amd_mmconfig_area
+quirk_system_pci_resources
+quirk_add_irq_optional_dependent_sets
+quirk_awe32_add_ports
+quirk_awe32_resources
+quirk_cmi8330_resources
+pnp_fixup_device
+reserve_range
+system_pnp_probe
+pnpacpi_get_resources
+pnpacpi_suspend
+pnpacpi_disable_resources
+pnpacpi_set_resources
+pnpacpi_resume
+pnpacpi_can_wakeup
+dma_flags
+pnpacpi_count_resources
+pnpacpi_type_resources
+decode_irq_flags
+pnpacpi_allocated_resource
+pnpacpi_parse_allocated_resource
+pnpacpi_build_resource_template
+pnpacpi_encode_resources
+devm_get_clk_from_child
+devm_clk_release
+devm_clk_get
+devm_clk_get_optional
+__devm_clk_bulk_get
+devm_clk_bulk_get
+devm_clk_bulk_get_optional
+devm_clk_bulk_release
+devm_clk_bulk_get_all
+devm_clk_put
+devm_clk_match
+clk_bulk_get_all
+clk_bulk_put
+__clk_bulk_get
+clk_bulk_get
+clk_bulk_get_optional
+clk_bulk_unprepare
+clk_bulk_prepare
+clk_bulk_disable
+clk_bulk_enable
+clk_bulk_put_all
+clk_put
+__clkdev_add
+devm_clk_match_clkdev
+clk_find
+clkdev_add
+clkdev_drop
+devm_clkdev_release
+devm_clk_release_clkdev
+clkdev_hw_alloc
+clkdev_create
+clkdev_hw_create
+do_clk_register_clkdev
+clk_register_clkdev
+clk_hw_register_clkdev
+devm_clk_hw_register_clkdev
+clk_find_hw
+clk_get
+clk_add_alias
+clk_get_sys
+clkdev_add_table
+clk_nodrv_prepare_enable
+clk_nodrv_disable_unprepare
+clk_nodrv_set_rate
+clk_nodrv_set_parent
+__traceiter_clk_enable
+__traceiter_clk_enable_complete
+__traceiter_clk_disable
+__traceiter_clk_disable_complete
+__traceiter_clk_prepare
+__traceiter_clk_prepare_complete
+__traceiter_clk_unprepare
+__traceiter_clk_unprepare_complete
+__traceiter_clk_set_rate
+__traceiter_clk_set_rate_complete
+__traceiter_clk_set_parent
+__traceiter_clk_set_parent_complete
+__traceiter_clk_set_phase
+__traceiter_clk_set_phase_complete
+__traceiter_clk_set_duty_cycle
+__traceiter_clk_set_duty_cycle_complete
+__clk_get_name
+clk_hw_get_name
+__clk_get_hw
+clk_hw_get_num_parents
+clk_hw_get_parent
+clk_hw_get_rate
+clk_hw_get_flags
+clk_hw_rate_is_protected
+clk_core_get_boundaries
+clk_hw_set_rate_range
+clk_core_rate_protect
+clk_gate_restore_context
+clk_core_save_context
+clk_core_restore_context
+clk_restore_context
+__clk_recalc_accuracies
+clk_core_update_orphan_status
+clk_rate_get
+clk_core_evict_parent_cache_subtree
+clk_core_update_duty_cycle_nolock
+clk_core_set_duty_cycle_nolock
+clk_core_get
+clk_enable_lock
+clk_core_init_rate_req
+devm_clk_match
+devm_clk_hw_match
+clk_core_rate_unprotect
+clk_core_disable
+clk_core_enable
+__clk_notify
+clk_propagate_rate_change
+clk_dump_open
+clk_summary_open
+possible_parents_open
+current_parent_open
+clk_duty_cycle_open
+clk_flags_open
+clk_max_rate_open
+clk_min_rate_open
+current_parent_show
+clk_duty_cycle_show
+clk_flags_show
+clk_rate_fops_open
+clk_core_free_parent_map
+__clk_release
+clk_reparent
+clk_core_is_enabled
+clk_hw_is_enabled
+clk_save_context
+clk_core_determine_round_nolock.part.0
+__clk_lookup_subtree
+clk_core_lookup
+clk_core_get_parent_by_index
+clk_hw_get_parent_by_index
+__clk_init_parent
+possible_parent_show
+possible_parents_show
+clk_has_parent
+clk_fetch_parent_index.part.0
+clk_hw_get_parent_index
+clk_is_match
+clk_enable_unlock
+clk_core_disable_lock
+clk_disable
+clk_core_enable_lock
+clk_core_round_rate_nolock
+clk_hw_round_rate
+clk_prepare_lock
+clk_prepare_unlock
+clk_get_parent
+clk_set_phase
+clk_set_duty_cycle
+clk_core_get_scaled_duty_cycle
+clk_max_rate_show
+clk_min_rate_show
+clk_notifier_unregister
+clk_rate_exclusive_put
+clk_rate_exclusive_get
+clk_round_rate
+clk_get_accuracy
+clk_get_phase
+clk_enable
+clk_get_scaled_duty_cycle
+clk_debug_create_one.part.0
+devm_clk_unregister
+devm_clk_hw_unregister
+clk_pm_runtime_get
+clk_pm_runtime_put
+clk_core_is_prepared
+clk_hw_is_prepared
+clk_recalc
+clk_calc_subtree
+clk_calc_new_rates
+__clk_recalc_rates
+clk_core_get_rate_recalc
+clk_summary_show_subtree
+clk_summary_show
+__clk_speculate_rates
+clk_get_rate
+clk_dump_subtree
+clk_dump_show
+__clk_is_enabled
+alloc_clk
+__clk_determine_rate
+clk_notifier_register
+clk_mux_determine_rate_flags
+__clk_mux_determine_rate
+__clk_mux_determine_rate_closest
+clk_core_unprepare
+clk_unprepare
+clk_core_disable_unprepare
+__clk_set_parent_after
+clk_core_prepare
+clk_prepare
+clk_core_prepare_enable
+__clk_set_parent_before
+clk_change_rate
+clk_core_set_rate_nolock
+clk_set_rate
+clk_set_rate_exclusive
+clk_set_rate_range
+clk_set_min_rate
+clk_set_max_rate
+__clk_register
+clk_register
+devm_clk_register
+clk_hw_register
+devm_clk_hw_register
+of_clk_hw_register
+clk_core_set_parent_nolock
+clk_hw_set_parent
+clk_set_parent
+clk_unregister
+clk_hw_unregister
+devm_clk_hw_release
+devm_clk_release
+__clk_get_enable_count
+__clk_lookup
+clk_hw_reparent
+clk_hw_create_clk
+__clk_put
+clk_unregister_divider
+clk_hw_unregister_divider
+divider_get_val
+_next_div
+_get_div
+divider_ro_round_rate_parent
+divider_recalc_rate
+_get_maxdiv
+divider_round_rate_parent
+clk_divider_set_rate
+__clk_hw_register_divider
+clk_register_divider_table
+clk_divider_recalc_rate
+clk_divider_round_rate
+clk_factor_set_rate
+clk_unregister_fixed_factor
+clk_hw_unregister_fixed_factor
+clk_factor_recalc_rate
+clk_factor_round_rate
+__clk_hw_register_fixed_factor.constprop.0
+clk_register_fixed_factor
+clk_hw_register_fixed_factor
+clk_unregister_fixed_rate
+clk_hw_unregister_fixed_rate
+clk_fixed_rate_recalc_rate
+clk_fixed_rate_recalc_accuracy
+__clk_hw_register_fixed_rate
+clk_register_fixed_rate
+clk_unregister_gate
+clk_hw_unregister_gate
+clk_gate_endisable
+clk_gate_disable
+clk_gate_enable
+__clk_hw_register_gate
+clk_register_gate
+clk_gate_is_enabled
+clk_multiplier_round_rate
+clk_multiplier_set_rate
+clk_multiplier_recalc_rate
+clk_unregister_mux
+clk_hw_unregister_mux
+clk_mux_val_to_index
+clk_mux_index_to_val
+clk_mux_determine_rate
+clk_mux_set_parent
+__clk_hw_register_mux
+clk_register_mux_table
+clk_mux_get_parent
+clk_hw_unregister_composite
+clk_composite_get_parent
+clk_composite_set_parent
+clk_composite_recalc_rate
+clk_composite_round_rate
+clk_composite_set_rate
+clk_composite_set_rate_and_parent
+clk_composite_is_enabled
+clk_composite_enable
+clk_composite_disable
+clk_composite_determine_rate
+__clk_hw_register_composite
+clk_hw_register_composite
+clk_hw_register_composite_pdata
+clk_register_composite
+clk_register_composite_pdata
+clk_unregister_composite
+clk_fd_set_rate
+clk_fd_round_rate
+clk_hw_register_fractional_divider
+clk_register_fractional_divider
+clk_fd_recalc_rate
+clk_hw_unregister_fractional_divider
+clk_sleeping_gpio_gate_is_prepared
+clk_sleeping_gpio_gate_unprepare
+clk_sleeping_gpio_gate_prepare
+clk_gpio_gate_is_enabled
+clk_gpio_gate_disable
+clk_gpio_gate_enable
+clk_register_gpio.constprop.0
+gpio_clk_driver_probe
+plt_clk_reg_update
+plt_clk_set_parent
+plt_clk_enable
+plt_clk_disable
+plt_clk_get_parent
+plt_clk_is_enabled
+plt_clk_unregister_fixed_rate_loop
+plt_clk_remove
+plt_clk_free_parent_names_loop
+plt_clk_probe
+fch_clk_remove
+fch_clk_probe
+lpt_clk_probe
+dma_find_channel
+dma_run_dependencies
+dma_async_tx_descriptor_init
+dmaengine_desc_attach_metadata
+dmaengine_desc_get_metadata_ptr
+dmaengine_desc_set_metadata_len
+dma_sync_wait
+dma_issue_pending_all
+dma_channel_rebalance
+dma_device_release
+chan_dev_release
+in_use_show
+bytes_transferred_show
+memcpy_count_show
+dmaengine_summary_open
+dmaengine_summary_show
+dma_get_slave_caps
+__dma_async_device_channel_unregister
+dma_async_device_channel_unregister
+dma_wait_for_async_tx
+__get_unmap_pool.part.0
+dmaengine_get_unmap_data
+__dma_async_device_channel_register
+dma_async_device_channel_register
+dma_chan_get
+dmaengine_get
+dma_async_device_register
+dmaenginem_async_device_register
+find_candidate
+dma_get_any_slave_channel
+__dma_request_channel
+dma_request_chan_by_mask
+dma_request_chan
+dmaengine_unmap_put
+dma_async_device_unregister
+dmam_device_release
+dma_chan_put
+dmaengine_put
+dma_release_channel
+dma_get_slave_channel
+vchan_find_desc
+vchan_tx_submit
+vchan_tx_desc_free
+vchan_init
+vchan_complete
+vchan_dma_desc_free_list
+acpi_dma_controller_free
+devm_acpi_dma_release
+acpi_dma_request_slave_chan_by_index
+acpi_dma_request_slave_chan_by_name
+acpi_dma_simple_xlate
+devm_acpi_dma_controller_free
+acpi_dma_parse_fixed_dma
+acpi_dma_controller_register
+devm_acpi_dma_controller_register
+hsu_dma_synchronize
+hsu_dma_pause
+hsu_dma_resume
+hsu_dma_get_status
+hsu_dma_chan_start
+hsu_dma_start_transfer
+hsu_dma_issue_pending
+hsu_dma_do_irq
+hsu_dma_slave_config
+hsu_dma_desc_free
+hsu_dma_terminate_all
+hsu_dma_remove
+hsu_dma_tx_status
+hsu_dma_prep_slave_sg
+hsu_dma_probe
+hsu_dma_free_chan_resources
+unregister_virtio_driver
+virtio_init
+virtio_dev_match
+is_virtio_device
+virtio_add_status
+virtio_dev_remove
+virtio_uevent
+modalias_show
+status_show
+vendor_show
+device_show
+register_virtio_device
+unregister_virtio_device
+__virtio_config_changed
+virtio_config_changed
+virtio_check_driver_offered_feature
+features_show
+register_virtio_driver
+virtio_finalize_features
+virtio_config_disable
+virtio_config_enable
+virtio_dev_probe
+virtio_device_restore
+virtio_device_freeze
+virtqueue_get_vring
+virtio_break_device
+vring_transport_features
+virtqueue_get_vring_size
+virtqueue_is_broken
+virtqueue_notify
+virtqueue_get_desc_addr
+virtqueue_get_avail_addr
+virtqueue_get_used_addr
+vring_map_one_sg
+vring_unmap_desc_packed
+detach_buf_packed
+vring_map_single.constprop.0
+virtqueue_add_indirect_packed
+vring_use_dma_api
+virtio_max_dma_size
+vring_alloc_queue
+vring_free_queue
+vring_del_virtqueue
+virtqueue_poll
+vring_interrupt
+__vring_new_virtqueue
+vring_new_virtqueue
+vring_create_virtqueue
+vring_unmap_one_split
+virtqueue_kick_prepare
+virtqueue_kick
+detach_buf_split
+virtqueue_detach_unused_buf
+virtqueue_disable_cb
+virtqueue_enable_cb_prepare
+virtqueue_enable_cb
+virtqueue_enable_cb_delayed
+virtqueue_add_sgs
+virtqueue_get_buf_ctx
+virtqueue_get_buf
+virtqueue_add_outbuf
+virtqueue_add_inbuf
+virtqueue_add_inbuf_ctx
+vm_get_features
+vm_generation
+vm_get_status
+vm_reset
+vm_notify
+vm_bus_name
+vm_get_shm_region
+vm_cmdline_get
+vm_cmdline_get_device
+virtio_mmio_remove
+vm_finalize_features
+vm_del_vqs
+vm_interrupt
+vm_set
+vm_get
+virtio_mmio_release_dev
+vm_unregister_cmdline_device
+vm_set_status
+vm_find_vqs
+vm_cmdline_set
+virtio_mmio_probe
+del_vq
+vp_config_vector
+vp_get_shm_region
+vp_finalize_features
+vp_get_features
+vp_reset
+vp_get_status
+vp_generation
+vp_set
+vp_get
+map_capability
+setup_vq
+vp_modern_find_vqs
+vp_set_status
+virtio_pci_modern_probe
+virtio_pci_modern_remove
+virtio_pci_release_dev
+vp_config_changed
+vp_vring_interrupt
+vp_setup_vq
+vp_interrupt
+virtio_pci_restore
+virtio_pci_freeze
+virtio_pci_remove
+virtio_pci_sriov_configure
+virtio_pci_probe
+vp_synchronize_vectors
+vp_notify
+vp_del_vqs
+vp_find_vqs_msix
+vp_find_vqs
+vp_bus_name
+vp_set_vq_affinity
+vp_get_vq_affinity
+vp_get_status
+vp_get
+del_vq
+vp_config_vector
+vp_get_features
+setup_vq
+vp_set
+vp_reset
+vp_finalize_features
+vp_set_status
+virtio_pci_legacy_probe
+virtio_pci_legacy_remove
+balloon_init_fs_context
+virtio_balloon_shrinker_count
+balloon_ack
+update_balloon_size
+virtio_balloon_cmd_id_received
+tell_host
+virtballoon_free_page_report
+stats_request
+virtballoon_changed
+virtballoon_migratepage
+virtballoon_validate
+leak_balloon
+virtio_balloon_oom_notify
+update_balloon_size_func
+update_balloon_stats
+init_vqs
+virtballoon_restore
+virtballoon_probe
+update_balloon_stats_func
+return_free_pages_to_mm
+remove_common
+virtballoon_freeze
+virtballoon_remove
+virtio_balloon_shrinker_scan
+report_free_page_func
+vcpu_online
+disable_hotplug_cpu
+setup_cpu_watcher
+handle_vcpu_hotplug_event
+gnttab_max_grant_frames
+gnttab_unmap_frames_v1
+do_free_callbacks
+gnttab_update_entry_v1
+gnttab_update_entry_v2
+gnttab_grant_foreign_access_ref
+gnttab_query_foreign_access_v1
+gnttab_query_foreign_access_v2
+gnttab_query_foreign_access
+gnttab_end_foreign_access_ref_v1
+gnttab_end_foreign_access_ref_v2
+gnttab_end_foreign_access_ref
+gnttab_grant_foreign_transfer_ref
+gnttab_end_foreign_transfer_ref
+gnttab_empty_grant_references
+gnttab_release_grant_reference
+gnttab_cancel_free_callback
+gnttab_pages_set_private
+gnttab_page_cache_init
+gnttab_page_cache_put
+gnttab_pages_clear_private
+gnttab_free_pages
+put_free_entry
+gnttab_free_grant_reference
+gnttab_end_foreign_transfer
+gnttab_request_free_callback
+gnttab_claim_grant_reference
+gnttab_unmap_frames_v2
+gnttab_page_cache_shrink
+unmap_refs_callback
+gnttab_dma_free_pages
+gnttab_dma_alloc_pages
+gnttab_free_auto_xlat_frames
+gnttab_map_frames_v1
+gnttab_alloc_pages
+gnttab_page_cache_get
+gnttab_free_grant_references
+gnttab_end_foreign_transfer_ref_v1
+gnttab_end_foreign_transfer_ref_v2
+gnttab_end_foreign_access
+gnttab_unmap_refs.part.0
+gnttab_unmap_refs
+__gnttab_unmap_refs_async
+gnttab_unmap_refs_async
+gnttab_unmap_refs_sync
+gnttab_unmap_work
+gnttab_setup_auto_xlat_frames
+gnttab_map
+gnttab_setup
+get_free_entries
+gnttab_grant_foreign_access
+gnttab_grant_foreign_transfer
+gnttab_alloc_grant_references
+gnttab_map_frames_v2
+gnttab_request_version
+gnttab_init
+__gnttab_init
+gnttab_map_refs
+gnttab_foreach_grant_in_range
+gnttab_batch_copy
+gnttab_batch_map
+gnttab_handle_deferred
+gnttab_foreach_grant
+gnttab_resume
+gnttab_suspend
+xen_setup_features
+balloon_set_new_target
+balloon_append
+xen_online_page
+free_xenballooned_pages
+decrease_reservation
+xen_memory_notifier
+reserve_additional_memory
+balloon_process
+alloc_xenballooned_pages
+poweroff_nb
+xen_resume_notifier_register
+xen_resume_notifier_unregister
+xen_setup_shutdown_event
+do_suspend
+do_reboot
+do_poweroff
+sysrq_handler
+shutdown_event
+xen_suspend
+shutdown_handler
+xen_get_runstate_snapshot_cpu_delta
+xen_get_runstate_snapshot_cpu
+xen_steal_clock
+xen_manage_runstate_time
+xen_get_runstate_snapshot
+xen_vcpu_stolen
+xen_setup_runstate_info
+xenmem_reservation_increase
+xenmem_reservation_decrease
+__xenmem_reservation_va_mapping_update
+__xenmem_reservation_va_mapping_reset
+xen_set_callback_via
+xen_irq_from_gsi
+xen_evtchn_nr_channels
+xen_evtchn_cpu_dead
+xen_irq_lateeoi_locked
+__xen_evtchn_do_upcall
+xen_hvm_evtchn_do_upcall
+set_evtchn_to_irq
+xen_cpu_init_eoi
+xen_evtchn_cpu_prepare
+xen_evtchn_close.part.0
+info_for_irq.part.0
+xen_test_irq_shared
+xen_irq_lateeoi
+xen_free_irq
+pirq_from_irq
+xen_pirq_from_irq
+pirq_check_eoi_map
+virq_from_irq
+ipi_from_irq
+pirq_query_unmask
+pirq_needs_eoi_flag
+xen_irq_info_common_setup.constprop.0
+xen_irq_info_pirq_setup.constprop.0
+xen_irq_info_ipi_setup
+xen_irq_info_virq_setup
+xen_irq_info_evtchn_setup
+xen_irq_lateeoi_worker
+xen_irq_init
+xen_allocate_irqs_dynamic
+get_evtchn_to_irq
+irq_from_evtchn
+bind_evtchn_to_cpu
+evtchn_make_refcounted
+evtchn_get
+evtchn_from_irq
+notify_remote_via_irq
+retrigger_dynirq
+set_affinity_irq
+xen_set_affinity_evtchn
+enable_dynirq
+enable_pirq
+disable_dynirq
+disable_pirq
+eoi_pirq
+mask_ack_pirq
+shutdown_pirq
+__startup_pirq
+startup_pirq
+__unbind_from_irq
+bind_evtchn_to_irq_chip
+bind_evtchn_to_irq
+bind_evtchn_to_irq_lateeoi
+bind_interdomain_evtchn_to_irq_lateeoi
+unbind_from_irq
+bind_evtchn_to_irqhandler_lateeoi
+unbind_from_irqhandler
+evtchn_put
+bind_interdomain_evtchn_to_irqhandler_lateeoi
+bind_evtchn_to_irqhandler
+ack_dynirq
+mask_ack_dynirq
+xen_set_irq_priority
+xen_clear_irq_pending
+xen_poll_irq_timeout
+irq_from_virq
+cpu_from_evtchn
+xen_bind_pirq_gsi_to_irq
+xen_allocate_pirq_msi
+xen_bind_pirq_msi_to_irq
+xen_destroy_irq
+xen_irq_from_pirq
+bind_virq_to_irq
+bind_virq_to_irqhandler
+bind_ipi_to_irqhandler
+xen_send_IPI_one
+handle_irq_for_port
+xen_evtchn_do_upcall
+rebind_evtchn_irq
+xen_set_irq_pending
+xen_test_irq_pending
+xen_poll_irq
+xen_irq_resume
+xen_setup_callback_vector
+evtchn_2l_max_channels
+evtchn_2l_clear_pending
+evtchn_2l_set_pending
+evtchn_2l_test_and_set_mask
+evtchn_2l_mask
+evtchn_2l_bind_to_cpu
+evtchn_2l_is_pending
+evtchn_2l_resume
+evtchn_2l_handle_events
+evtchn_2l_unmask
+xen_debug_interrupt
+evtchn_fifo_max_channels
+evtchn_fifo_nr_channels
+evtchn_fifo_bind_to_cpu
+evtchn_fifo_clear_pending
+evtchn_fifo_set_pending
+evtchn_fifo_test_and_set_mask
+evtchn_fifo_mask
+evtchn_fifo_is_pending
+evtchn_fifo_unmask
+__evtchn_fifo_handle_events
+evtchn_fifo_percpu_deinit
+evtchn_fifo_handle_events
+init_control_block
+evtchn_fifo_resume
+evtchn_fifo_alloc_control_block
+evtchn_fifo_percpu_init
+evtchn_fifo_setup
+xenbus_strstate
+xenbus_read_driver_state
+xenbus_unmap_ring_vfree
+xenbus_va_dev_error
+xenbus_dev_error
+xenbus_free_evtchn
+__xenbus_switch_state
+xenbus_switch_fatal
+xenbus_switch_state
+xenbus_dev_fatal
+xenbus_frontend_closed
+xenbus_watch_path
+xenbus_watch_pathfmt
+xenbus_alloc_evtchn
+map_ring_apply
+xenbus_unmap_ring.part.0
+__xenbus_map_ring.part.0
+xenbus_map_ring_hvm
+xenbus_map_ring_valloc
+xenbus_grant_ring
+xenbus_unmap_ring_hvm
+xenbus_map_ring_setup_grant_hvm
+xenbus_unmap_ring_pv
+xenbus_unmap_ring_setup_grant_hvm
+xenbus_map_ring_pv
+xb_read
+wake_waiting
+xb_thread_work
+xenbus_thread
+xb_init_comms
+xb_deinit_comms
+xs_wake_up
+xs_reboot_notify
+join
+count_strings
+find_watch
+test_reply
+xenwatch_thread
+xs_suspend_exit
+xs_send
+xenbus_dev_request_and_reply
+xs_request_exit
+xs_talkv
+xs_single
+xenbus_directory
+xenbus_exists
+xenbus_read
+xenbus_scanf
+xenbus_read_unsigned
+xenbus_gather
+xenbus_mkdir
+xenbus_rm
+xenbus_transaction_start
+xenbus_transaction_end
+xenbus_write
+xenbus_printf
+xs_watch
+register_xenbus_watch
+unregister_xenbus_watch
+xs_watch_msg
+xs_suspend
+xs_resume
+xs_suspend_cancel
+xs_init
+xenbus_dev_release
+xenbus_match
+xenbus_read_otherend_details
+xenbus_otherend_changed
+xenbus_dev_suspend
+watch_otherend
+xenbus_register_driver_common
+xenbus_unregister_driver
+state_show
+modalias_show
+devtype_show
+nodename_show
+xenbus_probe_devices
+cleanup_dev
+cmp_dev
+register_xenstore_notifier
+unregister_xenstore_notifier
+xenbus_probe
+xenbus_dev_remove
+xenbus_dev_cancel
+xenbus_probe_node
+xenbus_dev_changed
+talk_to_otherend
+xenbus_dev_probe
+xenbus_dev_resume
+xenbus_resume_cb
+frontend_changed
+read_frontend_details
+backend_shrink_memory_count
+backend_probe_and_watch
+backend_changed
+xenbus_dev_is_online
+__xenbus_register_backend
+xenbus_uevent_backend
+xenbus_probe_backend
+backend_bus_id
+backend_reclaim_memory
+xenbus_file_free
+xenbus_file_poll
+queue_cleanup
+free_watch_adapter
+xenbus_worker
+xenbus_file_read
+queue_reply.part.0
+watch_fired
+xenbus_file_open
+xenbus_file_release
+xenbus_command_reply
+xenbus_file_write
+xenbus_dev_queue_reply
+xenbus_backend_open
+xenbus_backend_mmap
+xenbus_backend_ioctl
+xenbus_frontend_delayed_resume
+backend_changed
+xenbus_frontend_dev_shutdown
+xenbus_frontend_dev_probe
+xenbus_uevent_frontend
+is_device_connecting
+non_essential_device_connecting
+essential_device_connecting
+xenbus_probe_frontend
+frontend_bus_id
+read_backend_details
+print_device_status
+wait_loop
+wait_for_devices
+__xenbus_register_frontend
+frontend_changed
+xenbus_reset_backend_state_changed
+xenbus_frontend_dev_resume
+frontend_probe_and_watch
+xen_pci_notifier
+xen_dbgp_op
+xen_dbgp_reset_prep
+xen_dbgp_external_startup
+xen_acpi_notify_hypervisor_state
+xen_acpi_notify_hypervisor_sleep
+xen_acpi_notify_hypervisor_extended_sleep
+xen_acpi_pad_idle_cpus
+xen_acpi_pad_idle_cpus_num
+acpi_pad_remove
+acpi_pad_notify
+acpi_pad_add
+xen_pcpu_down
+xen_pcpu_up
+xen_pcpu_id
+xen_pcpu_hotplug_sync
+xen_pcpu_interrupt
+pcpu_release
+pcpu_dev_is_visible
+show_online
+sync_pcpu
+xen_sync_pcpus
+xen_pcpu_work_fn
+xen_biovec_phys_mergeable
+balloon_init_watcher
+show_high_kb
+show_low_kb
+show_current_kb
+show_target
+show_target_kb
+store_target
+store_target_kb
+watch_target
+xen_balloon_init
+type_show
+minor_show
+major_show
+pagesize_show
+pmu_features_show
+pmu_mode_show
+extra_show
+compile_date_show
+compiled_by_show
+compiler_show
+changeset_show
+capabilities_show
+pmu_features_store
+pmu_mode_store
+hyp_sysfs_show
+hyp_sysfs_store
+buildid_show
+virtual_start_show
+guest_type_show
+uuid_show
+features_show
+do_hvm_evtchn_intr
+platform_pci_resume
+platform_pci_probe
+xen_swiotlb_dma_supported
+is_xen_swiotlb_buffer
+xen_swiotlb_map_page
+xen_swiotlb_sync_single_for_device
+xen_swiotlb_sync_sg_for_device
+xen_swiotlb_sync_single_for_cpu
+xen_swiotlb_sync_sg_for_cpu
+xen_swiotlb_unmap_page
+xen_swiotlb_unmap_sg
+xen_swiotlb_map_sg
+xen_swiotlb_free_coherent
+xen_swiotlb_alloc_coherent
+xen_mce_chrdev_ioctl
+xen_mce_chrdev_poll
+xen_mce_chrdev_read
+xen_mce_interrupt
+convert_log.constprop.0
+mc_queue_handle
+xen_mce_work_fn
+xen_mce_chrdev_release
+xen_mce_chrdev_open
+xen_acpi_processor_resume
+read_acpi_id
+xen_acpi_processor_resume_worker
+xen_efi_update_capsule
+xen_efi_query_variable_info
+xen_efi_get_next_high_mono_count
+xen_efi_query_capsule_caps
+xen_efi_set_time
+xen_efi_set_wakeup_time
+xen_efi_set_variable
+xen_efi_get_time
+xen_efi_get_wakeup_time
+xen_efi_get_variable
+xen_efi_get_next_variable
+xen_efi_reset_system
+unmap_gfn
+setup_hparams
+setup_balloon_gfn
+xen_remap_vma_range
+xen_for_each_gfn
+xen_xlate_unmap_gfn_range
+remap_pte_fn
+xen_xlate_remap_gfn_array.part.0
+xen_xlate_remap_gfn_array
+remap_pfn_fn
+xen_free_unpopulated_pages
+xen_alloc_unpopulated_pages
+regulator_mode_to_status
+regulator_has_full_constraints
+rdev_get_dev
+__traceiter_regulator_enable
+__traceiter_regulator_enable_delay
+__traceiter_regulator_enable_complete
+__traceiter_regulator_disable
+__traceiter_regulator_disable_complete
+__traceiter_regulator_bypass_enable
+__traceiter_regulator_bypass_enable_complete
+__traceiter_regulator_bypass_disable
+__traceiter_regulator_bypass_disable_complete
+__traceiter_regulator_set_voltage
+__traceiter_regulator_set_voltage_complete
+regulator_count_voltages
+regulator_get_hardware_vsel_register
+regulator_list_hardware_vsel
+regulator_get_linear_step
+regulator_attr_is_visible
+rdev_get_drvdata
+regulator_get_drvdata
+regulator_set_drvdata
+rdev_get_id
+rdev_get_regmap
+regulator_get_init_drvdata
+regulator_find_supply_alias
+regulator_dev_lookup
+regulator_unregister_supply_alias
+regulator_bulk_unregister_supply_alias
+unset_regulator_supplies
+regulator_dev_release
+regulator_unlock
+regulator_unlock_recursive
+_regulator_list_voltage
+regulator_list_voltage
+regulator_summary_unlock_one
+constraint_flags_read_file
+regulator_ena_gpio_ctrl
+_regulator_enable_delay
+regulator_notifier_call_chain
+regulator_map_voltage
+regulator_register_notifier
+regulator_unregister_notifier
+regulator_init_complete_work_function
+regulator_ena_gpio_free
+regulator_suspend_disk_mode_show
+regulator_suspend_mem_mode_show
+regulator_suspend_standby_mode_show
+regulator_suspend_disk_uV_show
+regulator_suspend_mem_uV_show
+regulator_suspend_standby_uV_show
+regulator_status_show
+num_users_show
+regulator_summary_open
+supply_map_open
+regulator_bypass_show
+_regulator_is_enabled.part.0
+regulator_summary_show
+regulator_print_state
+regulator_suspend_disk_state_show
+regulator_suspend_mem_state_show
+regulator_suspend_standby_state_show
+regulator_min_uA_show
+type_show
+regulator_suspend_disable
+rdev_get_name.part.0
+regulator_ops_is_valid
+regulator_match
+regulator_mode_constrain
+_regulator_do_enable
+_regulator_do_disable
+_regulator_set_voltage_time
+regulator_set_voltage_time
+regulator_set_voltage_time_sel
+regulator_get_voltage_rdev
+_regulator_call_set_voltage_sel
+_regulator_do_set_voltage
+regulator_get_suspend_state_check
+__suspend_set_state
+rdev_init_debugfs
+name_show
+regulator_summary_show_subtree
+regulator_summary_show_roots
+regulator_summary_show_children
+supply_map_show
+generic_coupler_attach
+regulator_register_supply_alias
+regulator_bulk_register_supply_alias
+regulator_max_uA_show
+regulator_min_uV_show
+regulator_max_uV_show
+regulator_suspend_enable
+regulator_lock_recursive
+regulator_lock_dependent
+regulator_get_voltage
+regulator_is_supported_voltage
+drms_uA_update
+_regulator_handle_consumer_disable
+regulator_remove_coupling
+regulator_get_error_flags
+_regulator_get_mode
+regulator_get_mode
+regulator_opmode_show
+_regulator_get_current_limit
+regulator_get_current_limit
+regulator_uA_show
+print_constraints_debug
+regulator_uV_show
+regulator_state_show
+_regulator_put.part.0
+regulator_put
+regulator_bulk_free
+regulator_set_load
+regulator_total_uA_show
+regulator_set_current_limit
+regulator_set_mode
+regulator_suspend
+regulator_is_enabled
+regulator_summary_lock_one
+regulator_resume
+create_regulator
+regulator_late_cleanup
+regulator_allow_bypass
+rdev_get_name
+regulator_check_voltage
+regulator_check_consumers
+regulator_sync_voltage
+regulator_get_regmap
+regulator_do_balance_voltage
+regulator_balance_voltage
+_regulator_disable
+regulator_disable
+regulator_disable_deferred
+regulator_bulk_enable
+regulator_unregister
+_regulator_enable
+regulator_enable
+regulator_resolve_supply
+_regulator_get
+regulator_get
+regulator_bulk_get
+regulator_get_exclusive
+regulator_get_optional
+regulator_register_resolve_supply
+regulator_bulk_enable_async
+set_machine_constraints
+regulator_register
+regulator_bulk_disable
+regulator_force_disable
+regulator_bulk_force_disable
+regulator_set_voltage_unlocked
+regulator_set_voltage_rdev
+regulator_set_voltage
+regulator_set_suspend_voltage
+regulator_disable_work
+regulator_coupler_register
+dummy_regulator_probe
+regulator_fixed_release
+regulator_register_always_on
+regulator_map_voltage_iterate
+regulator_map_voltage_ascend
+regulator_list_voltage_linear
+regulator_bulk_set_supply_names
+regulator_is_equal
+regulator_get_bypass_regmap
+regulator_set_bypass_regmap
+regulator_set_soft_start_regmap
+regulator_set_pull_down_regmap
+regulator_set_active_discharge_regmap
+regulator_get_voltage_sel_regmap
+regulator_set_voltage_sel_regmap
+regulator_set_current_limit_regmap
+regulator_get_current_limit_regmap
+regulator_get_voltage_sel_pickable_regmap
+regulator_set_voltage_sel_pickable_regmap
+regulator_list_voltage_pickable_linear_range
+regulator_list_voltage_table
+regulator_map_voltage_linear
+regulator_map_voltage_linear_range
+regulator_map_voltage_pickable_linear_range
+regulator_is_enabled_regmap
+regulator_enable_regmap
+regulator_disable_regmap
+regulator_desc_list_voltage_linear_range
+regulator_list_voltage_linear_range
+devm_regulator_match_notifier
+devm_regulator_release
+_devm_regulator_get
+devm_regulator_get
+devm_regulator_get_exclusive
+devm_regulator_get_optional
+devm_regulator_bulk_get
+devm_regulator_bulk_release
+devm_regulator_register
+devm_rdev_release
+devm_regulator_register_supply_alias
+devm_regulator_destroy_supply_alias
+devm_regulator_match_supply_alias
+devm_regulator_register_notifier
+devm_regulator_destroy_notifier
+devm_regulator_unregister
+devm_regulator_unregister_supply_alias
+devm_regulator_bulk_unregister_supply_alias
+devm_regulator_bulk_register_supply_alias
+devm_regulator_match
+devm_rdev_match
+devm_regulator_put
+devm_regulator_unregister_notifier
+__of_reset_control_get
+of_reset_control_array_get
+reset_controller_unregister
+of_reset_simple_xlate
+reset_controller_register
+devm_reset_controller_release
+devm_reset_controller_register
+reset_controller_add_lookup
+reset_control_get_count
+__reset_control_release
+devm_reset_control_array_get
+reset_control_status
+reset_control_release
+reset_control_reset
+reset_control_acquire
+__reset_control_get
+__devm_reset_control_get
+reset_control_put
+devm_reset_control_release
+__device_reset
+reset_control_deassert
+reset_control_assert
+tty_name
+hung_up_tty_read
+hung_up_tty_write
+hung_up_tty_poll
+hung_up_tty_ioctl
+hung_up_tty_fasync
+tty_show_fdinfo
+tty_hung_up_p
+tty_put_char
+tty_set_operations
+tty_devnum
+tty_devnode
+this_tty
+tty_reopen
+compat_tty_tiocsserial
+compat_tty_tiocgserial
+tty_write_lock
+tty_save_termios
+tty_write_unlock
+tty_dev_name_to_number
+tty_wakeup
+tty_hangup
+queue_release_one_tty
+tty_init_termios
+free_tty_struct
+tty_flush_works
+tty_do_resize
+send_break
+tty_device_create_release
+tty_cdev_add
+tty_unregister_driver
+tty_line_name
+show_cons_active
+tty_paranoia_check
+tty_poll
+tty_read
+do_SAK
+tty_unregister_device
+destruct_tty_driver
+stop_tty
+__start_tty.part.0
+start_tty
+tty_register_device_attr
+tty_register_device
+tty_register_driver
+tty_find_polling_driver
+hung_up_tty_compat_ioctl
+put_tty_driver
+tty_driver_kref_put
+tty_kref_put
+release_tty
+tty_kclose
+tty_release_struct
+tty_standard_install
+tty_driver_lookup_tty
+check_tty_count
+release_one_tty
+tty_lookup_driver
+__do_SAK.part.0
+do_SAK_work
+__tty_fasync
+tty_fasync
+__tty_hangup.part.0
+tty_vhangup
+do_tty_hangup
+tty_release
+tty_ioctl
+tty_compat_ioctl
+tty_write
+redirected_tty_write
+__tty_alloc_driver
+tty_alloc_file
+tty_add_file
+tty_free_file
+tty_driver_name
+tty_vhangup_self
+tty_vhangup_session
+__stop_tty
+__start_tty
+tty_write_message
+tty_send_xchar
+__do_SAK
+alloc_tty_struct
+tty_init_dev
+tty_open
+tty_kopen
+tty_default_fops
+console_sysfs_notify
+n_tty_write_wakeup
+echo_char
+n_tty_inherit_ops
+n_tty_packet_mode_flush
+__isig
+do_output_char
+__process_echoes
+n_tty_close
+n_tty_kick_worker
+zero_buffer.part.0
+commit_echoes.part.0
+process_echoes
+n_tty_write
+commit_echoes
+n_tty_ioctl
+n_tty_flush_buffer
+n_tty_poll
+isig
+n_tty_receive_char_flagged
+n_tty_receive_signal_char
+n_tty_receive_char_lnext
+copy_from_read_buf
+n_tty_read
+n_tty_set_termios
+n_tty_open
+n_tty_receive_char_special
+n_tty_receive_buf_common
+n_tty_receive_buf2
+n_tty_receive_buf
+tty_chars_in_buffer
+tty_write_room
+tty_driver_flush_buffer
+tty_termios_copy_hw
+tty_throttle
+tty_unthrottle
+tty_change_softcar
+tty_wait_until_sent
+tty_set_termios
+set_termiox
+copy_termios
+get_termio
+tty_termios_hw_change
+__tty_perform_flush
+tty_perform_flush
+set_termios
+tty_mode_ioctl
+n_tty_ioctl_helper
+tty_throttle_safe
+tty_unthrottle_safe
+tty_ldiscs_seq_stop
+tty_register_ldisc
+tty_unregister_ldisc
+tty_ldiscs_seq_start
+tty_ldiscs_seq_next
+get_ldops
+tty_ldisc_open
+put_ldops
+tty_ldiscs_seq_show
+tty_ldisc_ref_wait
+tty_ldisc_deref
+tty_ldisc_ref
+tty_ldisc_flush
+tty_ldisc_close
+tty_ldisc_put
+tty_ldisc_kill
+tty_ldisc_get.part.0
+tty_ldisc_failto
+tty_ldisc_release
+tty_ldisc_lock
+tty_ldisc_unlock
+tty_set_ldisc
+tty_ldisc_reinit
+tty_ldisc_hangup
+tty_ldisc_setup
+tty_ldisc_init
+tty_ldisc_deinit
+tty_sysctl_init
+tty_buffer_lock_exclusive
+tty_buffer_space_avail
+tty_ldisc_receive_buf
+tty_buffer_set_limit
+tty_flip_buffer_push
+tty_schedule_flip
+tty_buffer_free
+__tty_buffer_request_room
+tty_buffer_request_room
+tty_insert_flip_string_flags
+flush_to_ldisc
+tty_insert_flip_string_fixed_flag
+tty_prepare_flip_string
+tty_buffer_unlock_exclusive
+__tty_insert_flip_char
+tty_buffer_free_all
+tty_buffer_flush
+tty_buffer_init
+tty_buffer_set_lock_subclass
+tty_buffer_restart_work
+tty_buffer_cancel_work
+tty_buffer_flush_work
+tty_port_tty_wakeup
+tty_port_carrier_raised
+tty_port_raise_dtr_rts
+tty_port_lower_dtr_rts
+tty_port_default_receive_buf
+tty_port_init
+tty_port_link_device
+tty_port_register_device_attr
+tty_port_register_device
+tty_port_register_device_attr_serdev
+tty_port_register_device_serdev
+tty_port_unregister_device
+tty_port_alloc_xmit_buf
+tty_port_shutdown
+tty_port_free_xmit_buf
+tty_port_destroy
+tty_port_hangup
+tty_port_close_end
+tty_port_install
+tty_port_close_start.part.0
+tty_port_close_start
+tty_port_put
+tty_port_tty_set
+tty_port_close
+tty_port_tty_get
+tty_port_default_wakeup
+tty_port_tty_hangup
+tty_port_block_til_ready
+tty_port_open
+tty_unlock
+tty_lock
+tty_lock_interruptible
+tty_lock_slave
+tty_unlock_slave
+tty_set_lock_subclass
+__ldsem_wake_readers
+__ldsem_wake
+ldsem_wake
+__init_ldsem
+ldsem_down_read_trylock
+ldsem_down_write_trylock
+ldsem_up_read
+ldsem_up_write
+tty_termios_baud_rate
+tty_termios_input_baud_rate
+tty_termios_encode_baud_rate
+tty_encode_baud_rate
+__tty_check_change.part.0
+tty_check_change
+tty_get_pgrp
+get_current_tty
+__proc_set_tty
+__tty_check_change
+proc_clear_tty
+tty_open_proc_set_tty
+session_clear_tty
+disassociate_ctty.part.0
+tty_signal_session_leader
+disassociate_ctty
+no_tty
+tty_jobctrl_ioctl
+n_null_open
+n_null_close
+n_null_read
+n_null_receivebuf
+n_null_write
+pty_chars_in_buffer
+ptm_unix98_lookup
+pty_remove
+pty_signal
+pty_open
+pty_resize
+pty_start
+pty_stop
+pty_set_termios
+pty_unthrottle
+pty_write
+pty_cleanup
+pty_unix98_remove
+pts_unix98_lookup
+pty_show_fdinfo
+pty_set_lock
+pty_write_room
+ptmx_open
+pty_common_install
+pty_install
+pty_unix98_install
+pty_set_pktmode
+pty_bsd_ioctl
+pty_bsd_compat_ioctl
+pty_unix98_ioctl
+pty_unix98_compat_ioctl
+pty_close
+pty_flush_buffer
+ptm_open_peer
+tty_audit_log
+tty_audit_buf_push
+tty_audit_buf_free
+tty_audit_buf_ref.part.0
+tty_audit_exit
+tty_audit_fork
+tty_audit_push
+tty_audit_tiocsti
+tty_audit_add_data
+sysrq_handle_reboot
+sysrq_ftrace_dump
+sysrq_handle_showstate_blocked
+sysrq_handle_mountro
+sysrq_handle_showstate
+sysrq_handle_sync
+sysrq_handle_unraw
+sysrq_handle_show_timers
+sysrq_handle_showregs
+sysrq_handle_unrt
+sysrq_handle_showmem
+sysrq_handle_showallcpus
+sysrq_handle_SAK
+sysrq_handle_moom
+sysrq_handle_thaw
+moom_callback
+sysrq_handle_crash
+send_sig_all
+sysrq_handle_kill
+sysrq_handle_term
+sysrq_reset_seq_param_set
+sysrq_disconnect
+sysrq_do_reset
+sysrq_on
+sysrq_mask
+sysrq_reinject_alt_sysrq
+sysrq_connect
+__sysrq_swap_key_ops
+register_sysrq_key
+unregister_sysrq_key
+sysrq_toggle_support
+__handle_sysrq
+handle_sysrq
+sysrq_filter
+write_sysrq_trigger
+pm_set_vt_switch
+__vt_event_dequeue
+__vt_event_queue
+__vt_event_wait
+vt_disallocate_all
+vt_event_post
+vt_waitactive
+reset_vc
+complete_change_console
+vt_ioctl
+vc_SAK
+vt_compat_ioctl
+change_console
+vt_move_to_console
+vcs_open
+vcs_notifier
+vcs_release
+vcs_vc
+vcs_size
+vcs_lseek
+vcs_write
+vcs_read
+vcs_poll_data_get
+vcs_fasync
+vcs_poll
+vcs_make_sysfs
+vcs_remove_sysfs
+paste_selection
+clear_selection
+sel_pos
+set_selection_kernel
+vc_is_sel
+sel_loadlut
+set_selection_user
+fn_compose
+k_ignore
+register_keyboard_notifier
+unregister_keyboard_notifier
+kd_nosound
+vt_get_leds
+kbd_disconnect
+k_cons
+fn_lastcons
+fn_inc_console
+fn_dec_console
+fn_SAK
+fn_boot_it
+fn_scroll_back
+fn_scroll_forw
+fn_show_state
+fn_show_mem
+fn_show_ptregs
+kbd_rate_helper
+kbd_propagate_led_state
+kbd_start
+kbd_bh
+kbd_led_trigger_activate
+fn_hold
+do_compute_shiftstate
+fn_null
+getkeycode_helper
+setkeycode_helper
+k_spec
+kd_mksound
+kbd_match
+fn_caps_toggle
+fn_caps_on
+kd_sound_helper
+k_lock
+k_ascii
+kbd_connect
+fn_bare_num
+fn_spawn_con
+puts_queue
+k_cur.part.0
+k_cur
+fn_num
+k_fn.part.0
+k_fn
+fn_send_intr
+k_meta
+to_utf8
+handle_diacr
+k_deadunicode.part.0
+k_dead2
+k_dead
+fn_enter
+k_unicode.part.0
+k_self
+k_brlcommit.constprop.0
+k_brl
+k_pad
+k_shift
+k_slock
+kbd_event
+kbd_rate
+compute_shiftstate
+setledstate
+vt_set_led_state
+vt_kbd_con_start
+vt_kbd_con_stop
+vt_do_diacrit
+vt_do_kdskbmode
+vt_do_kdskbmeta
+vt_do_kbkeycode_ioctl
+vt_do_kdsk_ioctl
+vt_do_kdgkb_ioctl
+vt_do_kdskled
+vt_do_kdgkbmode
+vt_do_kdgkbmeta
+vt_reset_unicode
+vt_get_shift_state
+vt_reset_keyboard
+vt_get_kbd_mode_bit
+vt_set_kbd_mode_bit
+vt_clr_kbd_mode_bit
+inverse_translate
+con_release_unimap
+con_unify_unimap
+con_do_clear_unimap
+set_inverse_trans_unicode.isra.0
+con_insert_unipair
+set_translate
+con_get_trans_new
+con_free_unimap
+con_copy_unimap
+con_clear_unimap
+con_get_unimap
+conv_8bit_to_uni
+conv_uni_to_8bit
+conv_uni_to_pc
+set_inverse_transl
+update_user_maps
+con_set_trans_old
+con_set_trans_new
+con_set_unimap
+con_set_default_unimap
+con_get_trans_old
+con_write_room
+con_chars_in_buffer
+con_throttle
+con_open
+con_close
+register_vt_notifier
+unregister_vt_notifier
+blank_screen_t
+con_is_bound
+gotoxy
+rgb_foreground
+rgb_background
+vc_t416_color
+ucs_cmp
+vt_console_device
+con_debug_leave
+save_screen
+con_is_visible
+hide_cursor
+add_softcursor
+set_origin
+vc_uniscr_alloc
+do_update_region
+vc_scrolldelta_helper
+save_cur
+vc_port_destruct
+visual_init
+vc_setGx
+show_tty_active
+con_scroll
+lf
+con_unthrottle
+con_cleanup
+show_name
+show_bind
+con_debug_enter
+con_driver_unregister_callback
+do_blank_screen
+build_attr
+update_attr
+restore_cur
+set_palette
+do_unregister_con_driver
+give_up_console
+set_cursor
+csi_J
+con_shutdown
+update_region
+vc_cons_allocated.part.0
+con_start
+con_stop
+redraw_screen
+do_bind_con_driver
+do_unbind_con_driver
+do_take_over_console
+store_bind
+do_unblank_screen
+unblank_screen
+con_flush_chars
+vc_do_resize
+vc_resize
+vt_resize
+reset_terminal
+vc_init
+insert_char
+screen_glyph
+screen_pos
+screen_glyph_unicode
+vt_console_print
+schedule_console_callback
+vc_uniscr_check
+vc_uniscr_copy_line
+invert_screen
+set_mode
+complement_pos
+clear_buffer_attributes
+vc_cons_allocated
+vc_allocate
+con_install
+vc_deallocate
+scrollback
+scrollfront
+mouse_report
+mouse_reporting
+set_console
+vt_kmsg_redirect
+tioclinux
+poke_blanked_console
+console_callback
+con_set_cmap
+con_get_cmap
+reset_palette
+do_con_trol
+do_con_write
+con_put_char
+con_write
+con_font_op
+getconsxy
+putconsxy
+vcs_scr_readw
+vcs_scr_writew
+vcs_scr_updated
+hvc_poll_init
+hvc_console_device
+hvc_console_setup
+hvc_write_room
+hvc_chars_in_buffer
+hvc_tiocmget
+hvc_tiocmset
+hvc_poll_get_char
+hvc_poll_put_char
+hvc_push
+hvc_console_print
+hvc_cleanup
+hvc_kick
+hvc_unthrottle
+__hvc_resize
+hvc_set_winsz
+hvc_port_destruct
+hvc_hangup
+hvc_write
+hvc_close
+hvc_remove
+hvc_open
+hvc_alloc
+__hvc_poll
+hvc_poll
+khvcd
+hvc_get_by_index
+hvc_install
+hvc_instantiate
+hvc_handle_interrupt
+notifier_add_irq
+notifier_del_irq
+notifier_hangup_irq
+dom0_read_console
+dom0_write_console
+xenboot_earlycon_write
+xencons_disconnect_backend
+xencons_backend_changed
+domU_write_console
+domU_read_console
+xencons_connect_backend
+xencons_resume
+xen_hvm_early_write.isra.0
+xenboot_write_console
+xencons_info_pv_init
+xencons_remove
+xen_pv_console_init
+xen_hvm_console_init
+xen_cons_init
+xencons_probe
+xen_console_resume
+xen_raw_console_write
+xen_raw_printk
+uart_try_toggle_sysrq
+__uart_start
+uart_update_mctrl
+uart_console_write
+serial_match_port
+uart_console_device
+uart_update_timeout
+uart_get_divisor
+uart_get_baud_rate
+uart_parse_earlycon
+uart_parse_options
+uart_set_options
+uart_poll_init
+uart_tiocmset
+uart_set_ldisc
+uart_break_ctl
+uart_port_shutdown
+uart_proc_show
+uart_get_info
+uart_get_info_user
+uart_open
+uart_install
+uart_unregister_driver
+console_show
+iomem_reg_shift_show
+iomem_base_show
+io_type_show
+custom_divisor_show
+closing_wait_show
+close_delay_show
+xmit_fifo_size_show
+flags_show
+irq_show
+port_show
+line_show
+type_show
+uartclk_show
+uart_remove_one_port
+uart_handle_dcd_change
+uart_get_rs485_mode
+console_store
+uart_port_dtr_rts
+uart_match_port
+uart_write_wakeup.part.0
+uart_write_wakeup
+uart_handle_cts_change
+uart_add_one_port
+uart_register_driver
+uart_insert_char
+uart_poll_get_char
+uart_dtr_rts
+uart_poll_put_char
+uart_tiocmget
+uart_send_xchar
+uart_start
+uart_flush_chars
+uart_chars_in_buffer
+uart_write_room
+uart_throttle
+uart_unthrottle
+uart_get_icount
+uart_carrier_raised
+uart_stop
+uart_tty_port_shutdown
+uart_flush_buffer
+uart_wait_modem_status
+uart_shutdown
+uart_hangup
+uart_change_speed
+uart_set_termios
+uart_write
+uart_wait_until_sent
+uart_startup.part.0
+uart_port_activate
+uart_set_info_user
+uart_ioctl
+uart_close
+uart_put_char
+uart_suspend_port
+uart_resume_port
+serial8250_get_port
+serial8250_set_isa_configurator
+serial_8250_overrun_backoff_work
+univ8250_console_match
+univ8250_console_setup
+univ8250_console_exit
+univ8250_console_write
+serial8250_interrupt
+serial8250_timeout
+serial8250_backup_timeout
+serial8250_release_rsa_resource
+univ8250_release_port
+serial8250_request_rsa_resource
+univ8250_config_port
+serial8250_suspend
+serial8250_resume_port
+serial8250_resume
+serial8250_register_8250_port
+serial8250_unregister_port
+serial8250_remove
+serial8250_probe
+serial8250_suspend_port
+univ8250_request_port
+serial_do_unlink
+univ8250_release_irq
+univ8250_setup_irq
+serial_pnp_resume
+serial_pnp_suspend
+serial_pnp_remove
+serial_pnp_probe
+serial8250_pnp_init
+serial8250_pnp_exit
+default_serial_dl_read
+default_serial_dl_write
+autoconfig_read_divisor_id
+au_serial_dl_read
+au_serial_dl_write
+set_io_from_upio
+serial_icr_read
+__enable_rsa
+serial8250_throttle
+serial8250_unthrottle
+serial8250_do_set_divisor
+serial8250_set_divisor
+serial8250_verify_port
+serial8250_type
+serial8250_init_port
+serial8250_set_defaults
+au_serial_in
+io_serial_out
+io_serial_in
+mem32_serial_out
+mem32_serial_in
+mem16_serial_out
+mem16_serial_in
+mem_serial_out
+mem_serial_in
+hub6_serial_out
+hub6_serial_in
+serial8250_em485_destroy
+serial8250_em485_config
+serial8250_read_char
+serial8250_rx_chars
+start_hrtimer_ms
+__stop_tx_rs485
+serial8250_modem_status
+mem32be_serial_out
+mem32be_serial_in
+wait_for_xmitr
+serial8250_console_putchar
+rx_trig_bytes_show
+serial8250_clear_fifos.part.0
+serial8250_clear_and_reinit_fifos
+rx_trig_bytes_store
+au_serial_out
+serial8250_port_size
+serial8250_request_std_resource
+serial8250_request_port
+serial8250_release_std_resource
+serial8250_release_port
+serial8250_rpm_get.part.0
+serial8250_rpm_get
+serial8250_rpm_get_tx
+serial8250_rpm_put.part.0
+serial8250_rpm_put
+serial8250_get_poll_char
+serial8250_em485_handle_stop_tx
+serial8250_stop_rx
+serial8250_set_sleep
+serial8250_do_pm
+serial8250_pm
+serial8250_break_ctl
+serial8250_tx_empty
+serial8250_do_get_mctrl
+serial8250_get_mctrl
+serial8250_put_poll_char
+serial8250_rpm_put_tx
+serial8250_get_divisor
+serial8250_update_uartclk
+serial8250_enable_ms.part.0
+serial8250_enable_ms
+serial_port_out_sync.constprop.0
+serial8250_stop_tx
+serial8250_do_set_ldisc
+serial8250_set_ldisc
+serial8250_em485_start_tx
+serial8250_em485_stop_tx
+serial8250_do_set_mctrl
+serial8250_set_mctrl
+serial8250_do_startup
+serial8250_startup
+serial8250_do_set_termios
+serial8250_set_termios
+serial8250_tx_chars
+serial8250_em485_handle_start_tx
+serial8250_handle_irq.part.0
+serial8250_handle_irq
+serial8250_default_handle_irq
+serial8250_tx_threshold_handle_irq
+serial8250_start_tx
+serial8250_do_shutdown
+serial8250_shutdown
+size_fifo
+serial8250_config_port
+serial8250_console_write
+serial8250_console_setup
+serial8250_console_exit
+__dma_rx_complete
+serial8250_rx_dma_flush
+serial8250_request_dma
+serial8250_release_dma
+serial8250_tx_dma
+__dma_tx_complete
+serial8250_rx_dma
+dw8250_get_divisor
+dw8250_set_divisor
+dw8250_setup_port
+fintek_8250_enter_key
+fintek_8250_rs485_config
+fintek_8250_set_termios
+fintek_8250_probe
+pci_quatech_exit
+pci_eg20t_init
+pci_xircom_init
+sbs_exit
+sbs_init
+pci_ite887x_exit
+kt_handle_break
+pericom_do_set_divisor
+pci_hp_diva_init
+pci_timedia_init
+f815xxa_mem_serial_out
+kt_serial_in
+pci_wch_ch38x_init
+pci_wch_ch38x_exit
+find_quirk
+moan_device
+pci_netmos_init
+pci_fintek_f815xxa_setup
+pci_fintek_f815xxa_init
+setup_port
+pci_omegapci_setup
+pci_moxa_setup
+pci_timedia_setup
+titan_400l_800l_setup
+pci_siig_setup
+sbs_setup
+ce4100_serial_setup
+pci_hp_diva_setup
+afavlab_setup
+addidata_apci7800_setup
+pci_fintek_setup
+pci_oxsemi_tornado_init
+pci_endrun_init
+pci_timedia_probe
+pci_siig_init
+pci_plx9050_init
+pci_ni8430_setup
+pci_pericom_setup
+pci_pericom_setup_four_at_eight
+pci_default_setup
+pci_brcm_trumanage_setup
+pci_asix_setup
+pci_wch_ch38x_setup
+pci_wch_ch353_setup
+pci_wch_ch355_setup
+skip_tx_en_setup
+kt_serial_setup
+pci_quatech_setup
+pci_ite887x_init
+pci_fintek_rs485_config
+pci_fintek_init
+pciserial_detach_ports
+pciserial_remove_ports
+pciserial_remove_one
+pciserial_suspend_ports
+pciserial_suspend_one
+pciserial_resume_ports
+pciserial_resume_one
+serial8250_io_error_detected
+serial_pci_guess_board
+pci_plx9050_exit
+pci_ni8430_exit
+pci_ni8420_exit
+pci_ni8420_init
+pci_netmos_9900_setup
+pci_ni8430_init
+pci_inteli960ni_init
+serial8250_io_slot_reset
+pci_quatech_init
+pciserial_init_ports
+serial8250_io_resume
+pciserial_init_one
+pci_sunix_setup
+early_serial8250_write
+serial8250_early_in
+early_serial8250_read
+serial8250_early_out
+serial_putc
+mid8250_dma_filter
+mid8250_remove
+mid8250_set_termios
+dnv_exit
+dnv_handle_irq
+tng_handle_irq
+dnv_setup
+tng_setup
+pnw_setup
+mid8250_probe.part.0
+mid8250_probe
+max310x_reg_writeable
+max310x_reg_volatile
+max310x_reg_precious
+max310x_get_mctrl
+max310x_request_port
+max310x_null_void
+max310x_type
+max310x_config_port
+max310x_verify_port
+max310x_resume
+max310x_suspend
+max310x_shutdown
+max310x_tx_empty
+max14830_detect
+max3109_detect
+max3108_detect
+max3107_detect
+max310x_start_tx
+max310x_set_mctrl
+max310x_rs485_config
+max310x_gpio_get
+max310x_gpio_set_config
+max310x_gpio_set
+max310x_gpio_direction_output
+max310x_gpio_direction_input
+max310x_rs_proc
+max310x_md_proc
+max310x_startup
+max310x_break_ctl
+max310x_set_termios
+max14830_power
+max310x_power
+max310x_batch_read
+max310x_port_irq
+max310x_ist
+max310x_spi_probe
+max310x_spi_remove
+max310x_batch_write
+max310x_tx_proc
+sccnxp_stop_tx
+sccnxp_request_port
+sccnxp_type
+sccnxp_config_port
+sccnxp_verify_port
+sccnxp_read
+sccnxp_tx_empty
+sccnxp_get_mctrl
+sccnxp_write
+sccnxp_console_putchar
+sccnxp_break_ctl
+sccnxp_stop_rx
+sccnxp_disable_irq
+sccnxp_enable_irq
+sccnxp_startup
+sccnxp_set_bit
+sccnxp_shutdown
+sccnxp_start_tx
+sccnxp_set_mctrl
+sccnxp_set_termios
+sccnxp_console_setup
+sccnxp_console_write
+sccnxp_remove
+sccnxp_handle_events
+sccnxp_timer
+sccnxp_ist
+sccnxp_release_port
+sccnxp_probe
+mctrl_gpio_to_gpiod
+mctrl_gpio_init_noauto
+mctrl_gpio_init
+mctrl_gpio_set
+mctrl_gpio_get.part.0
+mctrl_gpio_get
+mctrl_gpio_irq_handle
+mctrl_gpio_get_outputs
+mctrl_gpio_free
+mctrl_gpio_enable_ms
+mctrl_gpio_disable_ms
+kgdb_nmi_tty_write_room
+kgdb_nmi_console_setup
+kgdb_nmi_console_write
+kgdb_nmi_console_device
+kgdb_nmi_tty_write
+kgdb_nmi_tty_hangup
+kgdb_nmi_tty_cleanup
+kgdb_nmi_tty_close
+kgdb_nmi_tty_activate
+kgdb_nmi_tty_shutdown
+kgdb_nmi_tty_open
+kgdb_register_nmi_console
+kgdb_unregister_nmi_console
+kgdb_nmi_tty_receiver
+kgdb_nmi_tty_install
+kgdb_nmi_poll_knock
+kgdboc_get_char
+kgdboc_put_char
+kgdboc_earlycon_get_char
+kgdboc_earlycon_put_char
+kgdboc_earlycon_deferred_exit
+kgdboc_earlycon_deinit
+kgdboc_option_setup
+kgdboc_restore_input_helper
+kgdboc_reset_disconnect
+kgdboc_reset_connect
+kgdboc_post_exp_handler
+kgdboc_pre_exp_handler
+kgdboc_unregister_kbd
+configure_kgdboc
+kgdboc_probe
+cleanup_kgdboc
+exit_kgdboc
+param_set_kgdboc_var
+kgdboc_earlycon_pre_exp_handler
+serdev_device_write_wakeup
+serdev_device_release
+serdev_device_uevent
+modalias_show
+serdev_device_write_buf
+serdev_device_write_flush
+serdev_device_write_room
+serdev_device_set_baudrate
+serdev_device_set_flow_control
+serdev_device_set_parity
+serdev_device_wait_until_sent
+serdev_device_get_tiocm
+serdev_device_set_tiocm
+serdev_device_add
+serdev_device_remove
+serdev_device_open
+serdev_device_close
+devm_serdev_device_release
+devm_serdev_device_open
+serdev_device_write
+serdev_drv_remove
+serdev_drv_probe
+serdev_ctrl_release
+__serdev_device_driver_register
+serdev_controller_add
+serdev_controller_remove
+serdev_device_match
+serdev_remove_device
+acpi_serdev_parse_resource
+serdev_controller_alloc
+serdev_device_alloc
+acpi_serdev_add_device
+ttyport_get_tiocm
+ttyport_set_tiocm
+ttyport_write_wakeup
+ttyport_write_buf
+ttyport_wait_until_sent
+ttyport_set_baudrate
+ttyport_set_parity
+ttyport_set_flow_control
+ttyport_close
+ttyport_open
+ttyport_write_room
+ttyport_write_flush
+ttyport_receive_buf
+serdev_tty_port_register
+serdev_tty_port_unregister
+read_null
+write_null
+read_iter_null
+write_full
+splice_write_null
+read_zero
+read_iter_zero
+write_iter_null
+pipe_to_null
+null_lseek
+memory_open
+mem_devnode
+mmap_zero
+memory_lseek
+read_mem
+devmem_fs_init_fs_context
+read_port
+get_unmapped_area_zero
+open_port
+write_port
+write_mem
+write_mem
+mmap_mem
+rng_is_initialized
+random_poll
+__traceiter_add_device_randomness
+__traceiter_mix_pool_bytes
+__traceiter_mix_pool_bytes_nolock
+__traceiter_credit_entropy_bits
+__traceiter_push_to_pool
+__traceiter_debit_entropy
+__traceiter_add_input_randomness
+__traceiter_add_disk_randomness
+__traceiter_xfer_secondary_pool
+__traceiter_get_random_bytes
+__traceiter_get_random_bytes_arch
+__traceiter_extract_entropy
+__traceiter_extract_entropy_user
+__traceiter_random_read
+__traceiter_urandom_read
+__traceiter_prandom_u32
+_mix_pool_bytes
+__mix_pool_bytes
+del_random_ready_callback
+add_device_randomness
+random_fasync
+proc_do_entropy
+add_random_ready_callback
+_warn_unseeded_randomness
+mix_pool_bytes.constprop.0
+write_pool.constprop.0
+random_write
+wait_for_random_bytes.part.0
+wait_for_random_bytes
+invalidate_batched_entropy
+crng_fast_load
+proc_do_uuid
+get_random_bytes_arch
+extract_buf
+_extract_entropy.constprop.0
+_extract_crng
+extract_crng
+_crng_backtrack_protect
+crng_reseed
+credit_entropy_bits.constprop.0
+add_hwgenerator_randomness
+add_bootloader_randomness
+random_ioctl
+entropy_timer
+add_timer_randomness
+add_input_randomness
+add_disk_randomness
+crng_backtrack_protect
+_get_random_bytes
+get_random_bytes
+do_numa_crng_init
+urandom_read_nowarn.isra.0
+urandom_read
+random_read
+__ia32_sys_getrandom
+__x64_sys_getrandom
+get_random_u64
+get_random_u32
+add_interrupt_randomness
+rand_initialize_disk
+randomize_page
+tpk_write_room
+tpk_flush
+tpk_ioctl
+tpk_close
+tpk_open
+tpk_write
+misc_seq_stop
+misc_seq_next
+misc_devnode
+misc_open
+misc_seq_show
+misc_seq_start
+misc_register
+misc_deregister
+find_port_by_vtermno
+find_port_by_id
+find_port_by_vq
+notifier_del_vio
+add_inbuf
+show_port_name
+control_intr
+config_intr
+port_debugfs_open
+port_fops_fasync
+send_sigio_to_port
+port_debugfs_show
+get_inbuf.part.0
+port_has_data
+free_buf
+flush_bufs
+out_intr
+discard_port_data
+in_intr
+remove_vqs
+reclaim_consumed_buffers.part.0
+__send_to_port
+put_chars
+fill_readbuf.part.0
+will_read_block
+port_fops_read
+reclaim_dma_bufs
+resize_console
+notifier_add_vio
+config_work_handler
+__send_control_msg
+get_chars
+pipe_to_sg
+remove_port_data
+virtcons_freeze
+init_port_console
+will_write_block
+port_fops_poll
+wait_port_writable
+port_fops_open
+alloc_buf
+fill_queue
+add_port
+port_fops_splice_write
+port_fops_write
+init_vqs
+virtcons_restore
+unplug_port
+virtcons_remove
+virtcons_probe
+control_work_handler
+port_fops_release
+hpet_fasync
+hpet_mmap
+hpet_resources.part.0
+hpet_resources
+hpet_interrupt
+hpet_read
+hpet_release
+hpet_poll
+hpet_ioctl_common
+hpet_compat_ioctl
+hpet_ioctl
+hpet_open
+hpet_alloc
+hpet_acpi_add
+hwrng_attr_selected_show
+rng_dev_open
+hwrng_attr_available_show
+devm_hwrng_match
+devm_hwrng_unregister
+put_rng
+drop_current_rng
+set_current_rng
+enable_best_rng
+get_current_rng
+hwrng_attr_current_show
+hwrng_fillfn
+rng_dev_read
+add_early_randomness
+hwrng_register
+devm_hwrng_register
+hwrng_unregister
+devm_hwrng_release
+hwrng_attr_current_store
+agp_backend_release
+agp_put_bridge
+agp_backend_acquire
+agp_backend_cleanup
+agp_remove_bridge
+agp_alloc_bridge
+agp_add_bridge
+agp_remove_seg_from_client
+agp_remove_from_pool
+agp_controller_make_current
+agp_controller_release_current
+agp_mmap
+agpioc_info_wrap.isra.0
+agp_open
+agp_find_mem_by_key
+agp_create_segment
+agp_find_private
+agp_free_memory_wrap
+agp_allocate_memory_wrap
+agp_find_client_by_pid
+agp_create_client
+agp_remove_client
+agp_release
+agpioc_acquire_wrap
+agpioc_release_wrap
+agpioc_setup_wrap
+agpioc_protect_wrap
+agpioc_deallocate_wrap
+agp_ioctl
+agp_frontend_initialize
+agp_frontend_cleanup
+agp_generic_alloc_by_type
+ipi_handler
+agp_generic_type_to_mask_type
+agp_num_entries
+agp_generic_remove_memory
+agp_enable
+agp_generic_mask_memory
+agp_alloc_page_array
+get_agp_version
+agp_collect_device_status
+agp3_generic_tlbflush
+agp3_generic_cleanup
+agp_device_command
+agp_generic_enable
+agp_generic_create_gatt_table
+agp_generic_free_gatt_table
+agp_generic_alloc_pages
+agp_generic_alloc_page
+global_cache_flush
+agp3_generic_fetch_size
+agp3_generic_configure
+agp_copy_info
+agp_generic_insert_memory
+agp_bind_memory
+agp_get_key
+agp_free_key.part.0
+agp_free_key
+agp_generic_free_by_type
+agp_generic_destroy_page
+agp_generic_alloc_user
+agp_create_memory
+agp_generic_destroy_pages
+agp_unbind_memory
+agp_free_memory
+agp_allocate_memory
+agp_generic_find_bridge
+agp_3_5_enable
+compat_agpioc_info_wrap.isra.0
+compat_agp_ioctl
+amd64_tlbflush
+agp_amd64_suspend
+amd64_fetch_size
+nforce3_agp_init
+amd_8151_configure
+agp_amd64_resume
+agp_amd64_remove
+amd64_insert_memory
+amd64_cleanup
+agp_aperture_valid
+agp_amd64_probe
+intel_820_tlbflush
+agp_intel_remove
+__intel_8xx_fetch_size
+agp_intel_resume
+agp_intel_probe
+intel_8xx_tlbflush
+intel_tlbflush
+intel_fetch_size
+intel_cleanup
+intel_8xx_cleanup
+intel_7505_configure
+intel_860_configure
+intel_850_configure
+intel_840_configure
+intel_830mp_configure
+intel_configure
+intel_8xx_fetch_size
+intel_845_configure
+intel_820_cleanup
+intel_820_configure
+intel_815_fetch_size
+intel_815_configure
+intel_fake_agp_enable
+i810_write_entry
+i830_cleanup
+i830_write_entry
+intel_fake_agp_free_gatt_table
+i830_check_flags
+i9xx_chipset_flush
+i965_write_entry
+intel_enable_gtt
+intel_gtt_teardown_scratch_page
+i9xx_cleanup
+i830_chipset_flush
+i810_cleanup
+intel_fake_agp_fetch_size
+intel_fake_agp_create_gatt_table
+intel_gtt_insert_page
+intel_gtt_clear_range
+intel_gtt_get
+intel_gtt_chipset_flush
+intel_fake_agp_configure
+intel_gtt_insert_sg_entries
+intel_i810_free_by_type
+intel_gtt_cleanup
+i830_setup
+intel_alloc_chipset_flush_resource
+i9xx_setup
+intel_gmch_remove.part.0
+intel_gmch_remove
+intel_gmch_probe
+intel_fake_agp_alloc_by_type
+intel_fake_agp_remove_entries
+i810_setup
+intel_fake_agp_insert_entries
+agp_via_suspend
+agp_via_remove
+via_tlbflush
+via_tlbflush_agp3
+via_cleanup
+via_cleanup_agp3
+via_fetch_size
+via_fetch_size_agp3
+via_configure_agp3
+via_configure
+agp_via_resume
+agp_via_probe
+tpm_devs_release
+tpm_default_chip
+tpm_hwrng_read
+tpm_relinquish_locality
+tpm_chip_stop
+tpm_put_ops
+tpm_chip_start
+tpm_try_get_ops
+tpm_dev_release
+tpm_class_shutdown
+tpm_del_legacy_sysfs.part.0
+tpm_chip_unregister
+tpm_chip_register
+tpm_chip_alloc
+tpmm_chip_alloc
+tpm_find_get_ops
+tpm_timeout_work
+user_reader_timeout
+tpm_dev_transmit.constprop.0
+tpm_dev_async_work
+tpm_common_open
+tpm_common_read
+tpm_common_write
+tpm_common_poll
+tpm_common_release
+tpm_release
+tpm_open
+tpm_pm_resume
+tpm_calc_ordinal_duration
+tpm_get_timeouts
+tpm_is_tpm2
+tpm_pcr_read
+tpm_pcr_extend
+tpm_pm_suspend
+tpm_get_random
+tpm_transmit
+tpm_transmit_cmd
+tpm_send
+tpm_auto_startup
+tpm1_getcap
+tpm1_calc_ordinal_duration
+tpm1_get_timeouts
+tpm1_pcr_extend
+tpm1_get_random
+tpm1_pcr_read
+tpm1_do_selftest
+tpm1_auto_startup
+tpm1_pm_suspend
+tpm1_get_pcr_allocation
+tpm2_do_selftest
+tpm2_flush_context
+tpm2_get_tpm_pt
+tpm2_probe
+tpm2_get_cc_attrs_tbl
+tpm2_get_timeouts
+tpm2_calc_ordinal_duration
+tpm2_pcr_read
+tpm2_pcr_extend
+tpm2_get_random
+tpm2_shutdown
+tpm2_get_pcr_allocation
+tpm2_auto_startup
+tpm2_find_cc
+tpmrm_release
+tpmrm_open
+tpm2_flush_sessions
+tpm2_save_context
+tpm2_load_context
+tpm2_init_space
+tpm2_del_space
+tpm2_flush_space
+tpm2_prepare_space
+tpm2_commit_space
+tpm_version_major_show
+timeouts_show
+durations_show
+temp_deactivated_show
+owned_show
+active_show
+enabled_show
+pcrs_show
+cancel_store
+caps_show
+pubek_show
+tpm_sysfs_add_device
+tpm_bios_measurements_release
+tpm_bios_measurements_open
+tpm_bios_log_teardown
+tpm_bios_log_setup
+tpm1_bios_measurements_stop
+tpm1_bios_measurements_start
+tpm1_bios_measurements_next
+tpm1_ascii_bios_measurements_show
+tpm1_binary_bios_measurements_show
+tpm2_bios_measurements_stop
+tpm2_bios_measurements_start
+tpm2_binary_bios_measurements_show
+tpm2_bios_measurements_next
+tpm_show_ppi_version
+tpm_show_ppi_response
+show_ppi_operations
+tpm_show_ppi_vs_operations
+tpm_show_ppi_tcg_operations
+tpm_show_ppi_transition_action
+tpm_store_ppi_request
+tpm_show_ppi_request
+tpm_add_ppi
+tpm_read_log_acpi
+tpm_read_log_efi
+wait_for_tpm_stat_cond
+check_locality
+tpm_tis_ready
+tpm_tis_req_canceled
+tpm_tis_clkrun_enable
+tpm_tis_remove
+get_burstcount
+tpm_tis_update_timeouts
+tpm_tis_update_durations
+tis_int_handler
+disable_interrupts
+tpm_tis_resume
+tpm_tis_status
+request_locality
+release_locality
+wait_for_tpm_stat
+recv_data
+tpm_tis_send_data
+tpm_tis_core_init
+tpm_tis_send_main
+tpm_tis_send
+tpm_tis_recv
+tpm_tis_pnp_remove
+tpm_tis_plat_remove
+tpm_tcg_write32
+tpm_tcg_read32
+tpm_tcg_read16
+tpm_tcg_write_bytes
+tpm_tcg_read_bytes
+check_acpi_tpm2
+tpm_tis_disable_irq
+tpm_tis_init.part.0
+tpm_tis_pnp_init
+tpm_tis_plat_probe
+crb_acpi_remove
+crb_fixup_cmd_size
+crb_status
+crb_req_canceled
+crb_do_acpi_start
+crb_cancel
+crb_send
+crb_recv
+crb_check_resource
+crb_map_res
+crb_wait_for_reg_32.constprop.0
+__crb_go_idle
+crb_go_idle
+__crb_cmd_ready
+crb_cmd_ready
+__crb_request_locality.isra.0
+crb_request_locality
+__crb_relinquish_locality.isra.0
+crb_relinquish_locality
+crb_map_io
+crb_acpi_add
+amd_iommu_register_ga_log_notifier
+amd_iommu_capable
+free_pt_l2
+free_pt_l3
+free_pt_l4
+free_pt_l5
+set_dte_irq_entry
+irte_prepare
+irte_ga_prepare
+irte_set_allocated
+irte_is_allocated
+irte_ga_is_allocated
+irte_clear_allocated
+irq_remapping_deactivate
+ir_compose_msi_msg
+clone_alias
+build_inv_dte
+build_inv_irt
+irte_ga_set_allocated
+irte_ga_clear_allocated
+build_inv_iommu_pages
+__iommu_queue_command_sync
+free_sub_pt
+first_pte_l7
+fetch_pte
+amd_iommu_iova_to_phys
+amd_iommu_unmap
+__get_gcr3_pte
+free_page_list
+free_gcr3_tbl_level1
+amd_iommu_register_ppr_notifier
+amd_iommu_unregister_ppr_notifier
+amd_iommu_device_info
+irq_remapping_activate
+amd_ir_set_affinity
+amd_iommu_is_attach_deferred
+amd_iommu_def_domain_type
+get_irq_table
+amd_iommu_probe_finalize
+clone_aliases.part.0
+setup_aliases
+free_pagetable
+amd_iommu_enable_device_erratum
+amd_iommu_domain_get_attr
+iommu_completion_wait
+domain_flush_complete
+iommu_queue_command_sync.constprop.0
+amd_iommu_update_ga
+free_irte
+irq_remapping_free
+modify_irte_ga
+irte_ga_set_affinity
+irte_ga_deactivate
+irte_ga_activate
+amd_iommu_activate_guest_mode
+amd_iommu_deactivate_guest_mode
+amd_ir_set_vcpu_affinity
+modify_irte
+irte_set_affinity
+irte_deactivate
+irte_activate
+__flush_pasid
+amd_iommu_flush_page
+amd_iommu_flush_tlb
+amd_iommu_domain_set_gcr3
+amd_iommu_domain_clear_gcr3
+set_dte_entry
+amd_iommu_complete_ppr
+device_flush_iotlb
+device_flush_dte
+update_and_flush_device_table
+__domain_flush_pages
+do_detach
+amd_iommu_flush_iotlb_all
+amd_iommu_iotlb_sync
+update_domain
+amd_iommu_domain_enable_v2
+device_flush_dte_alias
+iommu_flush_dte
+set_remap_table_entry_alias
+set_remap_table_entry
+amd_iommu_domain_direct_map
+amd_iommu_map
+protection_domain_free
+amd_iommu_domain_free
+alloc_irq_table
+alloc_irq_index
+amd_iommu_device_group
+amd_iommu_domain_alloc
+detach_device
+check_device.part.0
+amd_iommu_release_device
+attach_device
+amd_iommu_attach_device
+amd_iommu_get_v2_domain
+amd_iommu_get_resv_regions
+amd_iommu_detach_device
+get_devid
+get_irq_domain
+irq_remapping_alloc
+amd_iommu_probe_device
+amd_iommu_int_thread
+amd_iommu_int_handler
+iommu_flush_all_caches
+amd_iommu_create_irq_domain
+_irq_notifier_release
+translation_pre_enabled
+get_amd_iommu
+amd_iommu_pc_get_max_banks
+amd_iommu_pc_get_max_counters
+iommu_update_intcapxt
+_irq_notifier_notify
+iommu_disable
+amd_iommu_show_features
+amd_iommu_show_cap
+enable_iommus_v2
+amd_iommu_v2_supported
+amd_iommu_pc_supported
+iommu_pc_get_set_reg
+amd_iommu_pc_get_reg
+amd_iommu_pc_set_reg
+iommu_init_msi
+disable_iommus
+amd_iommu_suspend
+iommu_enable_ga
+iommu_enable_event_buffer
+iommu_set_device_table
+amd_iommu_get_num_iommus
+amd_iommu_reset_cmd_buffer
+iommu_enable_command_buffer
+early_enable_iommus
+amd_iommu_resume
+amd_iommu_apply_erratum_63
+amd_iommu_disable
+amd_iommu_reenable
+dmar_platform_optin
+__dmar_enable_qi
+dmar_hp_remove_drhd
+dmar_hp_add_drhd
+warn_invalid_dmar
+dmar_walk_remapping_entries
+dmar_parse_one_rhsa
+dmar_remove_dev_scope.part.0
+dmar_fault
+dmar_get_dsm_handle
+dmar_walk_dsm_resource
+dmar_device_hotplug
+dmar_alloc_pci_notify_info
+dmar_alloc_dev_scope
+dmar_free_dev_scope
+dmar_parse_one_drhd
+dmar_free_drhd
+dmar_hp_release_drhd
+dmar_insert_dev_scope
+dmar_pci_bus_add_dev
+dmar_pci_bus_notifier
+dmar_remove_dev_scope
+dmar_find_matched_drhd_unit
+qi_submit_sync
+qi_global_iec
+qi_flush_context
+qi_flush_iotlb
+qi_flush_dev_iotlb
+qi_flush_piotlb
+qi_flush_dev_iotlb_pasid
+qi_flush_pasid_cache
+dmar_disable_qi
+dmar_enable_qi
+dmar_msi_unmask
+dmar_msi_mask
+dmar_msi_write
+dmar_msi_read
+dmar_set_interrupt
+dmar_reenable_qi
+dmar_device_add
+dmar_device_remove
+intel_get_required_mask
+intel_iommu_is_attach_deferred
+dma_pte_list_pagetables
+intel_iommu_aux_get_pasid
+domain_flush_piotlb
+__iommu_calculate_agaw
+domain_update_iommu_snooping
+intel_iommu_domain_set_attr
+domain_setup_first_level
+intel_iommu_device_group
+intel_iommu_probe_finalize
+dma_pte_clear_level
+intel_iommu_dev_disable_feat
+dev_is_real_dma_subdevice
+alloc_domain
+dma_free_pagelist
+iova_entry_free
+dma_pte_free_level
+iommu_disable_translation
+__iommu_flush_iotlb
+__iommu_flush_context
+iommu_set_root_entry
+iommu_enable_translation
+iommu_disable_protect_mem_regions
+dmar_find_atsr
+intel_iommu_show_ndoms
+intel_iommu_show_ecap
+intel_iommu_show_cap
+intel_iommu_show_address
+intel_iommu_show_version
+intel_iommu_show_ndoms_used
+intel_iommu_cpu_dead
+intel_alloc_iova
+is_downstream_to_pci_bridge.part.0
+device_def_domain_type
+domain_update_iotlb
+iommu_enable_dev_iotlb
+iommu_support_dev_iotlb
+intel_iommu_capable
+domain_update_iommu_superpage.part.0
+domain_update_iommu_cap
+intel_iommu_apply_resv_region
+risky_device.part.0
+quirk_calpella_no_shadow_gtt
+quirk_iommu_igfx
+quirk_iommu_rwbf
+quirk_igfx_skip_te_disable
+intel_iommu_init_qi
+intel_vcmd_ioasid_free
+intel_vcmd_ioasid_alloc
+iommu_flush_dev_iotlb
+iommu_flush_iotlb_psi
+iommu_flush_iova
+intel_iommu_dev_has_feat
+intel_iommu_get_resv_regions
+intel_iommu_dev_feat_enabled
+set_iommu_domain
+domain_detach_iommu
+__dmar_remove_one_dev_info
+disable_dmar_iommu.part.0
+dmar_remove_one_dev_info
+intel_iommu_detach_device
+intel_iommu_aux_detach_device
+domain_attach_iommu
+domain_unmap
+domain_exit
+intel_iommu_domain_free
+dma_pte_clear_range
+dma_pte_free_pagetable
+iommu_init_domains
+iommu_suspend
+context_present
+get_domain_info
+for_each_device_domain
+alloc_pgtable_page
+iommu_alloc_root_entry
+pfn_to_dma_pte
+intel_iommu_iova_to_phys
+bounce_sync_single
+bounce_sync_sg_for_device
+bounce_sync_sg_for_cpu
+bounce_sync_single_for_device
+bounce_sync_single_for_cpu
+intel_iommu_unmap
+__domain_mapping
+iommu_domain_identity_map
+intel_iommu_memory_notifier
+md_domain_init.constprop.0
+intel_iommu_domain_alloc
+free_pgtable_page
+iommu_calculate_max_sagaw
+iommu_calculate_agaw
+domain_get_iommu
+intel_unmap
+intel_unmap_sg
+intel_unmap_page
+intel_free_coherent
+bounce_unmap_single
+bounce_unmap_page
+bounce_unmap_sg
+bounce_unmap_resource
+intel_unmap_resource
+iommu_context_addr
+domain_context_clear_one_cb
+device_context_mapped
+domain_context_mapped_cb
+free_dmar_iommu
+device_to_iommu
+intel_iommu_sva_invalidate
+prepare_domain_attach_device
+intel_iommu_aux_attach_device
+intel_iommu_release_device
+intel_iommu_probe_device
+iommu_flush_write_buffer
+domain_mapping
+intel_iommu_map
+domain_context_mapping_one
+domain_context_mapping_cb
+iommu_resume
+find_domain
+dmar_parse_one_atsr
+dmar_release_one_atsr
+dmar_check_one_atsr
+dmar_iommu_hotplug
+dmar_find_matched_atsr_unit
+intel_iommu_attach_device
+do_deferred_attach
+__intel_map_single
+intel_map_resource
+intel_map_page
+intel_map_sg
+intel_alloc_coherent
+bounce_map_single
+bounce_map_resource
+bounce_map_page
+bounce_map_sg
+dmar_iommu_notify_scope_dev
+intel_iommu_shutdown
+intel_iommu_enable_pasid
+intel_iommu_dev_enable_feat
+pasid_cache_invalidation_with_pasid
+iotlb_invalidation_with_pasid
+search_pasid_table
+get_alias_pasid_table
+pasid_flush_caches
+vcmd_alloc_pasid
+vcmd_free_pasid
+intel_pasid_alloc_table
+intel_pasid_free_table
+intel_pasid_get_table
+intel_pasid_get_dev_max_id
+intel_pasid_get_entry
+intel_pasid_tear_down_entry
+intel_pasid_setup_first_level
+intel_pasid_setup_second_level
+intel_pasid_setup_pass_through
+intel_pasid_setup_nested
+__traceiter_map_single
+__traceiter_bounce_map_single
+__traceiter_unmap_single
+__traceiter_unmap_sg
+__traceiter_bounce_unmap_single
+__traceiter_map_sg
+__traceiter_bounce_map_sg
+intel_svm_prq_report
+prq_event_thread
+pasid_to_svm_sdev
+intel_mm_release
+intel_svm_drain_prq
+load_pasid
+_load_pasid
+intel_invalidate_range
+intel_svm_enable_prq
+intel_svm_finish_prq
+intel_svm_check
+intel_svm_bind_gpasid
+intel_svm_unbind_gpasid
+intel_svm_bind
+intel_svm_unbind
+intel_svm_get_pasid
+intel_svm_page_response
+set_msi_sid_cb
+intel_ir_compose_msi_msg
+iommu_set_irq_remapping
+iommu_enable_irq_remapping
+intel_teardown_irq_remapping
+ir_parse_ioapic_hpet_scope
+qi_flush_iec
+modify_irte
+intel_irq_remapping_deactivate
+intel_ir_set_vcpu_affinity
+intel_ir_reconfigure_irte
+intel_irq_remapping_activate
+intel_free_irq_resources
+intel_irq_remapping_free
+intel_ir_set_affinity
+intel_get_irq_domain
+iommu_disable_irq_remapping.part.0
+disable_irq_remapping
+intel_setup_irq_remapping
+intel_irq_remapping_alloc
+reenable_irq_remapping
+intel_irq_remap_add_device
+dmar_ir_hotplug
+iommu_default_passthrough
+iommu_group_attr_show
+iommu_group_attr_store
+iommu_group_get_iommudata
+iommu_group_set_iommudata
+iommu_group_for_each_dev
+iommu_group_id
+iommu_present
+iommu_capable
+iommu_domain_alloc
+iommu_domain_free
+iommu_domain_set_attr
+iommu_dev_has_feature
+iommu_dev_enable_feature
+iommu_dev_disable_feature
+iommu_dev_feature_enabled
+iommu_aux_get_pasid
+iommu_sva_get_pasid
+iommu_sva_unbind_gpasid
+iommu_iova_to_phys
+iommu_domain_window_enable
+iommu_domain_window_disable
+generic_iommu_put_resv_regions
+iommu_group_put
+iommu_group_release
+iommu_group_show_type
+iommu_group_show_name
+iommu_group_get
+get_pci_alias_or_group
+iommu_get_domain_for_dev
+iommu_sva_bind_device
+iommu_sva_unbind_device
+iommu_group_ref_get
+iommu_group_set_name
+iommu_group_remove_device
+iommu_group_register_notifier
+iommu_group_unregister_notifier
+iommu_unregister_device_fault_handler
+iommu_report_device_fault
+iommu_page_response
+iommu_sva_prepare_bind_data
+iommu_uapi_sva_bind_gpasid
+iommu_uapi_sva_unbind_gpasid
+iommu_uapi_cache_invalidate
+report_iommu_fault
+iommu_fwspec_free
+iommu_fwspec_add_ids
+iommu_group_alloc_default_domain
+iommu_domain_get_attr
+__iommu_attach_device
+iommu_set_fault_handler
+iommu_aux_detach_device
+iommu_pgsize
+__iommu_unmap
+iommu_unmap
+iommu_unmap_fast
+__iommu_map
+iommu_map_atomic
+iommu_map
+__iommu_map_sg
+iommu_map_sg
+iommu_map_sg_atomic
+iommu_create_device_direct_mappings
+iommu_group_get_by_id
+get_pci_alias_group
+get_pci_function_alias_group
+iommu_group_add_device
+__iommu_attach_group
+iommu_attach_group
+iommu_attach_device
+iommu_alloc_resv_region
+dev_iommu_get
+iommu_fwspec_init
+__iommu_probe_device
+probe_iommu_group
+iommu_group_alloc
+generic_device_group
+fsl_mc_device_group
+pci_device_group
+iommu_get_group_resv_regions
+iommu_group_show_resv_regions
+iommu_register_device_fault_handler
+iommu_device_register
+iommu_device_unregister
+__iommu_detach_group
+iommu_detach_group
+iommu_detach_device
+iommu_aux_attach_device
+iommu_release_device
+remove_iommu_group
+iommu_probe_device
+iommu_bus_notifier
+iommu_group_default_domain
+bus_iommu_probe
+bus_set_iommu
+iommu_get_dma_domain
+iommu_get_resv_regions
+iommu_put_resv_regions
+iommu_set_default_passthrough
+iommu_set_default_translated
+iommu_ops_from_fwnode
+__traceiter_add_device_to_group
+__traceiter_remove_device_from_group
+__traceiter_attach_device_to_domain
+__traceiter_detach_device_from_domain
+__traceiter_map
+__traceiter_unmap
+__traceiter_io_page_fault
+release_device
+iommu_device_sysfs_remove
+iommu_device_link
+iommu_device_unlink
+iommu_device_sysfs_add
+iommu_dma_sync_single_for_cpu
+iommu_dma_sync_sg_for_cpu
+iommu_dma_get_resv_regions
+iommu_dma_flush_iotlb_all
+iommu_put_dma_cookie
+iommu_dma_get_merge_boundary
+iommu_dma_free_iova
+__iommu_dma_unmap
+iommu_dma_unmap_page
+iommu_dma_unmap_sg
+iommu_dma_deferred_attach
+iommu_dma_mmap
+iommu_dma_init
+iommu_dma_alloc_iova
+__iommu_dma_map
+iommu_dma_map_resource
+iommu_dma_map_page
+iommu_dma_map_sg
+iommu_dma_get_sgtable
+__iommu_dma_free.isra.0
+iommu_dma_free
+iommu_dma_sync_sg_for_device
+iommu_dma_sync_single_for_device
+iommu_get_msi_cookie
+iommu_dma_unmap_resource
+iommu_get_dma_cookie
+iommu_dma_alloc
+iommu_setup_dma_ops
+iommu_dma_prepare_msi
+iommu_dma_compose_msi_msg
+default_free
+ioasid_find
+ioasid_set_data
+default_alloc
+ioasid_free
+ioasid_unregister_allocator
+ioasid_alloc
+ioasid_register_allocator
+alloc_iova_mem
+iova_cache_put
+iova_domain_flush
+init_iova_flush_queue
+__cached_rbnode_delete_update
+iova_cache_get
+private_find_iova
+find_iova
+iova_insert_rbtree
+reserve_iova
+copy_reserved_iova
+free_iova_mem.part.0
+free_iova_mem
+alloc_iova
+put_iova_domain
+private_free_iova
+__free_iova
+free_iova
+iova_magazine_free_pfns.part.0
+free_iova_fast
+fq_ring_free
+fq_flush_timeout
+queue_iova
+init_iova_domain
+has_iova_flush_queue
+split_and_remove_iova
+free_cpu_cached_iovas
+alloc_iova_fast
+irq_remapping_restore_boot_irq_mode
+irq_remapping_cap
+set_irq_remapping_broken
+irq_remapping_disable
+irq_remapping_reenable
+panic_if_irq_remap
+irq_remapping_get_irq_domain
+hyperv_irq_remapping_free
+hyperv_get_irq_domain
+hyperv_irq_remapping_activate
+hyperv_ir_set_affinity
+hyperv_irq_remapping_alloc
+mipi_dsi_packet_format_is_short
+mipi_dsi_packet_format_is_long
+mipi_dsi_uevent
+of_find_mipi_dsi_device_by_node
+mipi_dsi_attach
+mipi_dsi_detach
+mipi_dsi_device_transfer
+mipi_dsi_shutdown_peripheral
+mipi_dsi_turn_on_peripheral
+mipi_dsi_set_maximum_return_packet_size
+mipi_dsi_compression_mode
+mipi_dsi_picture_parameter_set
+mipi_dsi_generic_write
+mipi_dsi_generic_read
+mipi_dsi_dcs_write_buffer
+mipi_dsi_dcs_read
+mipi_dsi_dcs_get_power_mode
+mipi_dsi_dcs_get_pixel_format
+mipi_dsi_dcs_get_display_brightness
+mipi_dsi_drv_probe
+mipi_dsi_drv_remove
+mipi_dsi_drv_shutdown
+mipi_dsi_device_match
+mipi_dsi_dev_release
+mipi_dsi_device_unregister
+mipi_dsi_remove_device_fn
+of_find_mipi_dsi_host_by_node
+mipi_dsi_host_register
+mipi_dsi_host_unregister
+mipi_dsi_create_packet
+mipi_dsi_driver_register_full
+mipi_dsi_driver_unregister
+mipi_dsi_dcs_write
+mipi_dsi_dcs_nop
+mipi_dsi_dcs_soft_reset
+mipi_dsi_dcs_enter_sleep_mode
+mipi_dsi_dcs_exit_sleep_mode
+mipi_dsi_dcs_set_display_off
+mipi_dsi_dcs_set_display_on
+mipi_dsi_dcs_set_column_address
+mipi_dsi_dcs_set_page_address
+mipi_dsi_dcs_set_tear_off
+mipi_dsi_dcs_set_tear_on
+mipi_dsi_dcs_set_pixel_format
+mipi_dsi_dcs_set_tear_scanline
+mipi_dsi_dcs_set_display_brightness
+mipi_dsi_device_register_full
+drm_get_panel_orientation_quirk
+vga_default_device
+vga_arb_fpoll
+vga_client_register
+__vga_put
+vga_put
+__vga_set_legacy_decoding
+vga_set_legacy_decoding
+vga_arb_release
+vga_arb_read
+__vga_tryget
+vga_remove_vgacon
+vga_str_to_iostate.isra.0
+vga_arb_open
+vga_arbiter_notify_clients
+vga_check_first_use
+vga_get
+vga_arb_write
+vga_set_default_device
+vga_arbiter_add_pci_device.part.0
+pci_notify
+vga_switcheroo_handler_flags
+vga_switcheroo_debugfs_open
+set_audio_state
+vga_switcheroo_lock_ddc
+vga_switcheroo_client_fb_set
+check_can_switch
+vga_switcheroo_unlock_ddc
+vga_switcheroo_init_domain_pm_ops
+vga_switcheroo_fini_domain_pm_ops
+vga_switcheroo_ready
+vga_switcheroo_power_switch
+vga_switcheroo_runtime_resume
+vga_switcheroo_runtime_suspend
+vga_switcheroo_unregister_handler
+vga_switcheroo_unregister_client
+vga_switcheroo_client_probe_defer
+vga_switcheroo_pwr_state
+vga_switcheroo_get_client_state
+vga_switcheroo_show
+vga_switchon
+vga_switchto_stage1.part.0
+vga_switchoff
+find_active_client.constprop.0
+vga_switchto_stage2
+vga_switcheroo_process_delayed_switch
+vga_switcheroo_debugfs_write
+vga_switcheroo_register_handler
+register_client
+vga_switcheroo_register_client
+vga_switcheroo_register_audio_client
+cn_queue_release_callback
+cn_cb_equal
+cn_queue_add_callback
+cn_queue_del_callback
+cn_queue_alloc_dev
+cn_queue_free_dev
+cn_add_callback
+cn_del_callback
+cn_proc_show
+cn_fini
+cn_init
+cn_netlink_send_mult
+cn_netlink_send
+cn_rx_skb
+cn_proc_mcast_ctl
+proc_fork_connector
+proc_exec_connector
+proc_id_connector
+proc_sid_connector
+proc_ptrace_connector
+proc_comm_connector
+proc_coredump_connector
+proc_exit_connector
+devm_component_match_release
+component_devices_open
+try_to_bring_up_master
+free_master
+component_devices_show
+component_unbind
+component_unbind_all
+component_bind_all
+take_down_master
+component_del
+component_master_del
+__component_add
+component_add_typed
+component_add
+component_match_realloc.isra.0
+__component_match_add
+component_match_add_release
+component_match_add_typed
+component_master_add_with_match
+device_match_any
+class_dir_release
+root_device_release
+dev_attr_store
+device_namespace
+device_get_ownership
+devm_attr_group_match
+class_dir_child_ns_type
+kill_device
+device_set_of_node_from_dev
+device_match_of_node
+device_match_devt
+set_secondary_fwnode
+set_primary_fwnode
+devlink_dev_release
+sync_state_only_show
+runtime_pm_show
+auto_remove_on_show
+status_show
+device_show_ulong
+device_show_int
+online_show
+device_link_add_missing_supplier_links
+device_store_ulong
+device_store_int
+device_store_bool
+device_add_groups
+device_remove_groups
+devm_attr_groups_remove
+devm_attr_group_remove
+devm_device_add_group
+devm_device_add_groups
+device_create_release
+device_create_file
+device_remove_file
+device_remove_attrs
+device_remove_file_self
+device_create_bin_file
+device_remove_bin_file
+dev_attr_show
+device_release
+device_initialize
+dev_set_name
+dev_show
+get_device
+klist_children_get
+put_device
+__device_link_free_srcu
+device_links_flush_sync_list
+klist_children_put
+device_remove_class_symlinks
+device_for_each_child
+device_find_child
+device_for_each_child_reverse
+device_find_child_by_name
+device_match_name
+device_rename
+device_change_owner
+device_match_fwnode
+device_match_acpi_dev
+device_show_bool
+waiting_for_supplier_show
+__device_links_supplier_defer_sync
+device_link_init_status
+dev_driver_string
+uevent_store
+dev_err_probe
+dev_uevent_filter
+dev_uevent_name
+devm_device_remove_group
+devm_device_remove_groups
+cleanup_glue_dir.part.0
+device_platform_notify
+device_del
+device_unregister
+__device_link_del
+root_device_unregister
+device_destroy
+device_is_dependent
+device_check_offline
+devlink_add_symlinks
+devlink_remove_symlinks
+__device_links_queue_sync_state
+device_link_put_kref
+device_link_del
+device_link_remove
+__device_links_no_driver
+uevent_show
+get_device_parent
+device_add
+device_register
+__root_device_register
+device_create_groups_vargs
+device_create
+device_create_with_groups
+device_links_read_lock
+device_links_read_unlock
+device_links_read_lock_held
+device_links_check_suppliers
+device_links_supplier_sync_state_pause
+device_links_supplier_sync_state_resume
+sync_state_resume_initcall
+device_links_driver_bound
+device_links_no_driver
+device_links_driver_cleanup
+device_links_busy
+device_links_unbind_consumers
+fw_devlink_get_flags
+fw_devlink_pause
+fw_devlink_resume
+lock_device_hotplug
+unlock_device_hotplug
+lock_device_hotplug_sysfs
+devices_kset_move_last
+device_reorder_to_tail
+device_pm_move_to_tail
+device_link_add
+device_move
+virtual_device_parent
+device_get_devnode
+dev_uevent
+device_offline
+device_online
+online_store
+device_shutdown
+subsys_dev_iter_exit
+system_root_device_release
+driver_release
+bus_uevent_filter
+drv_attr_show
+drv_attr_store
+bus_attr_show
+bus_attr_store
+drivers_autoprobe_store
+bus_get_kset
+bus_get_device_klist
+bus_sort_breadthfirst
+bus_create_file
+bus_remove_file
+subsys_dev_iter_init
+bus_for_each_dev
+bus_rescan_devices
+bus_for_each_drv
+subsys_dev_iter_next
+bus_find_device
+subsys_find_device_by_id
+klist_devices_get
+subsys_interface_register
+subsys_interface_unregister
+uevent_store
+bus_uevent_store
+bus_release
+bind_store
+klist_devices_put
+unbind_store
+drivers_autoprobe_show
+bus_unregister
+bus_register_notifier
+bus_unregister_notifier
+bus_rescan_devices_helper
+device_reprobe
+drivers_probe_store
+subsys_register.part.0
+bus_register
+subsys_virtual_register
+subsys_system_register
+bus_add_device
+bus_probe_device
+bus_remove_device
+bus_add_driver
+bus_remove_driver
+wait_for_device_probe
+coredump_store
+deferred_probe_work_func
+deferred_devs_open
+deferred_devs_show
+driver_sysfs_add
+driver_sysfs_remove
+state_synced_show
+__device_attach_async_helper
+driver_attach
+__device_driver_lock
+__device_driver_unlock
+driver_deferred_probe_trigger
+deferred_probe_timeout_work_func
+deferred_probe_initcall
+driver_deferred_probe_add
+driver_deferred_probe_del
+driver_bound
+device_bind_driver
+__device_attach
+device_attach
+really_probe
+device_block_probing
+device_unblock_probing
+device_set_deferred_probe_reason
+driver_deferred_probe_check_state
+device_is_bound
+driver_probe_done
+driver_probe_device
+__driver_attach_async_helper
+driver_allows_async_probing
+__device_attach_driver
+device_initial_probe
+device_driver_attach
+__driver_attach
+device_release_driver_internal
+device_release_driver
+device_driver_detach
+driver_detach
+register_syscore_ops
+unregister_syscore_ops
+syscore_resume
+syscore_suspend
+syscore_shutdown
+driver_for_each_device
+driver_find_device
+driver_create_file
+driver_find
+driver_register
+driver_remove_file
+driver_unregister
+driver_add_groups
+driver_remove_groups
+class_dev_iter_exit
+class_attr_show
+class_attr_store
+class_child_ns_type
+klist_class_dev_put
+klist_class_dev_get
+class_create_file_ns
+class_remove_file_ns
+class_release
+class_create_release
+class_compat_unregister
+class_unregister
+class_destroy
+class_dev_iter_init
+class_dev_iter_next
+class_interface_register
+class_interface_unregister
+show_class_attr_string
+class_compat_register
+class_compat_create_link
+class_compat_remove_link
+class_for_each_device
+class_find_device
+__class_register
+__class_create
+platform_drv_probe_fail
+platform_device_put
+platform_get_resource
+platform_drv_shutdown
+platform_dev_attrs_visible
+platform_pm_suspend
+platform_pm_resume
+platform_pm_freeze
+platform_pm_thaw
+platform_pm_poweroff
+platform_pm_restore
+devm_platform_get_and_ioremap_resource
+devm_platform_ioremap_resource
+platform_get_irq_optional
+platform_irq_count
+platform_get_irq
+platform_get_resource_byname
+devm_platform_ioremap_resource_byname
+__platform_get_irq_byname
+platform_get_irq_byname
+platform_get_irq_byname_optional
+platform_device_release
+platform_device_add_resources
+platform_device_add_data
+platform_device_add_properties
+__platform_driver_register
+platform_drv_remove
+platform_driver_unregister
+platform_unregister_drivers
+__platform_register_drivers
+platform_match
+driver_override_store
+driver_override_show
+numa_node_show
+platform_find_device_by_driver
+platform_device_add
+platform_device_register
+platform_drv_probe
+__platform_driver_probe
+platform_dma_configure
+platform_uevent
+modalias_show
+platform_device_del.part.0
+platform_device_del
+platform_device_unregister
+platform_add_devices
+platform_device_alloc
+__platform_create_bundle
+platform_device_register_full
+devm_platform_ioremap_resource_wc
+cpu_device_release
+cpu_subsys_offline
+cpu_subsys_match
+crash_notes_size_show
+crash_notes_size_show
+print_cpus_kernel_max
+device_create_release
+print_cpu_modalias
+cpu_subsys_online
+crash_notes_show
+show_cpus_attr
+get_cpu_device
+cpu_is_hotpluggable
+print_cpus_offline
+print_cpus_offline
+print_cpus_offline
+print_cpus_offline
+print_cpus_offline
+print_cpus_offline
+print_cpus_offline
+print_cpus_offline
+print_cpus_offline
+cpu_uevent
+cpu_device_create
+print_cpus_isolated
+unregister_cpu
+register_cpu
+kobj_map
+kobj_unmap
+kobj_lookup
+kobj_map_init
+group_open_release
+devm_kmalloc_match
+devres_find
+devres_remove
+devm_action_match
+devm_action_release
+devm_pages_match
+devm_percpu_match
+devres_alloc_node
+devres_remove_group
+devm_pages_release
+devm_percpu_release
+devres_for_each_res
+add_dr.part.0
+devres_add
+devm_add_action
+devm_kmalloc
+devm_kstrdup
+devm_kstrdup_const
+devm_kmemdup
+devm_kvasprintf
+devm_kasprintf
+devm_get_free_pages
+__devm_alloc_percpu
+devres_open_group
+devres_close_group
+release_nodes
+devres_release_group
+devres_free
+devres_get
+devres_destroy
+devres_release
+devm_remove_action
+devm_kfree
+devm_free_percpu
+devm_release_action
+devm_free_pages
+group_close_release
+devm_krealloc
+devm_kmalloc_release
+devres_release_all
+internal_container_klist_put
+internal_container_klist_get
+attribute_container_register
+attribute_container_unregister
+attribute_container_classdev_to_container
+attribute_container_release
+attribute_container_find_class_device
+do_attribute_container_device_trigger_safe
+attribute_container_device_trigger_safe
+attribute_container_device_trigger
+attribute_container_trigger
+attribute_container_add_attrs
+attribute_container_add_class_device
+attribute_container_add_device
+attribute_container_add_class_device_adapter
+attribute_container_remove_attrs
+attribute_container_remove_device
+attribute_container_class_device_del
+anon_transport_dummy_function
+transport_class_register
+transport_class_unregister
+transport_setup_device
+transport_add_device
+transport_configure_device
+transport_remove_device
+transport_destroy_device
+transport_setup_classdev
+transport_configure
+anon_transport_class_register
+transport_remove_classdev
+transport_destroy_classdev
+anon_transport_class_unregister
+transport_add_class_device
+topology_remove_dev
+topology_add_dev
+die_cpus_list_show
+die_cpus_show
+core_siblings_list_show
+package_cpus_list_show
+core_siblings_show
+package_cpus_show
+thread_siblings_list_show
+core_cpus_list_show
+thread_siblings_show
+core_cpus_show
+core_id_show
+die_id_show
+physical_package_id_show
+trivial_online
+container_offline
+device_add_properties
+fwnode_irq_get
+dev_fwnode
+fwnode_property_get_reference_args
+fwnode_find_reference
+fwnode_get_name
+fwnode_get_parent
+fwnode_get_next_child_node
+fwnode_get_named_child_node
+device_get_named_child_node
+fwnode_handle_get
+fwnode_handle_put
+fwnode_get_next_parent
+fwnode_count_parents
+fwnode_get_nth_parent
+fwnode_graph_get_next_endpoint
+fwnode_graph_get_port_parent
+fwnode_graph_get_remote_endpoint
+fwnode_graph_get_remote_port_parent
+fwnode_graph_get_remote_port
+device_get_match_data
+fwnode_property_read_int_array
+fwnode_property_read_u8_array
+fwnode_property_read_u16_array
+fwnode_property_read_u32_array
+fwnode_property_read_u64_array
+device_property_read_u8_array
+fwnode_get_mac_addr
+device_property_read_u16_array
+device_property_read_u32_array
+device_property_read_u64_array
+fwnode_property_read_string_array
+fwnode_property_read_string
+fwnode_get_phy_mode
+device_property_read_string_array
+device_property_read_string
+device_get_phy_mode
+device_remove_properties
+device_get_next_child_node
+device_get_child_node_count
+device_dma_supported
+device_get_dma_attr
+fwnode_graph_parse_endpoint
+fwnode_device_is_available
+fwnode_connection_find_match
+fwnode_graph_get_remote_node
+fwnode_graph_get_endpoint_by_id
+fwnode_get_next_available_child_node
+fwnode_property_present
+device_property_present
+fwnode_get_mac_address
+device_get_mac_address
+fwnode_property_match_string
+device_property_match_string
+fwnode_get_name_prefix
+shared_cpu_list_show
+shared_cpu_map_show
+cpu_cache_sysfs_exit
+physical_line_partition_show
+write_policy_show
+allocation_policy_show
+size_show
+number_of_sets_show
+ways_of_associativity_show
+coherency_line_size_show
+level_show
+type_show
+id_show
+free_cache_attributes
+cacheinfo_cpu_pre_down
+cache_default_attrs_is_visible
+get_cpu_cacheinfo
+cache_setup_acpi
+cache_setup_acpi
+cache_setup_acpi
+cache_setup_acpi
+cacheinfo_cpu_online
+is_software_node
+software_node_get_name
+software_node_get_next_child
+to_software_node
+software_node_get_named_child_node
+software_node_get
+software_node_find_by_name
+software_node_get_parent
+software_node_get_name_prefix
+software_node_put
+fwnode_remove_software_node
+property_get_pointer
+property_entry_free_data
+property_entry_get.part.0
+software_node_property_present
+property_entry_find
+property_entry_read_int_array
+software_node_read_int_array
+property_entries_free.part.0
+property_entries_free
+software_node_release
+swnode_register
+software_node_read_string_array
+software_node_to_swnode
+software_node_fwnode
+software_node_unregister
+software_node_unregister_nodes
+software_node_unregister_node_group.part.0
+software_node_unregister_node_group
+software_node_get_reference_args
+software_node_register
+software_node_register_nodes
+software_node_register_node_group
+property_entries_dup.part.0
+property_entries_dup
+fwnode_create_software_node
+software_node_notify
+public_dev_mount
+devtmpfs_work_loop
+devtmpfs_submit_req
+devtmpfs_create_node
+devtmpfs_delete_node
+async_store
+pm_qos_latency_tolerance_us_store
+control_show
+runtime_enabled_show
+async_show
+wakeup_store
+autosuspend_delay_ms_store
+runtime_active_time_show
+runtime_suspended_time_show
+control_store
+pm_qos_no_power_off_store
+runtime_active_kids_show
+runtime_usage_show
+wakeup_show
+pm_qos_no_power_off_show
+autosuspend_delay_ms_show
+runtime_status_show
+pm_qos_resume_latency_us_store
+pm_qos_latency_tolerance_us_show
+pm_qos_resume_latency_us_show
+wakeup_abort_count_show.part.0
+wakeup_max_time_ms_show
+wakeup_active_count_show
+wakeup_active_show
+wakeup_count_show
+wakeup_expire_count_show
+wakeup_abort_count_show
+wakeup_last_time_ms_show
+wakeup_total_time_ms_show
+dpm_sysfs_add
+dpm_sysfs_change_owner
+wakeup_sysfs_add
+wakeup_sysfs_remove
+pm_qos_sysfs_add_resume_latency
+pm_qos_sysfs_remove_resume_latency
+pm_qos_sysfs_add_flags
+pm_qos_sysfs_remove_flags
+pm_qos_sysfs_add_latency_tolerance
+pm_qos_sysfs_remove_latency_tolerance
+rpm_sysfs_remove
+dpm_sysfs_remove
+pm_generic_runtime_suspend
+pm_generic_runtime_resume
+pm_generic_suspend_noirq
+pm_generic_suspend_late
+pm_generic_suspend
+pm_generic_freeze_noirq
+pm_generic_freeze_late
+pm_generic_freeze
+pm_generic_poweroff_noirq
+pm_generic_poweroff_late
+pm_generic_poweroff
+pm_generic_thaw_noirq
+pm_generic_thaw_early
+pm_generic_thaw
+pm_generic_resume_noirq
+pm_generic_resume_early
+pm_generic_resume
+pm_generic_restore_noirq
+pm_generic_restore_early
+pm_generic_restore
+pm_generic_prepare
+pm_generic_complete
+dev_pm_domain_attach_by_id
+dev_pm_domain_attach_by_name
+dev_pm_domain_detach
+dev_pm_domain_start
+dev_pm_domain_set
+dev_pm_domain_attach
+dev_pm_get_subsys_data
+dev_pm_put_subsys_data
+apply_constraint
+dev_pm_qos_flags
+__dev_pm_qos_update_request
+dev_pm_qos_update_request
+dev_pm_qos_remove_notifier
+dev_pm_qos_expose_latency_tolerance
+__dev_pm_qos_remove_request
+dev_pm_qos_remove_request
+__dev_pm_qos_drop_user_request
+__dev_pm_qos_hide_latency_limit
+dev_pm_qos_hide_latency_limit
+__dev_pm_qos_hide_flags
+dev_pm_qos_hide_flags
+dev_pm_qos_constraints_allocate
+__dev_pm_qos_add_request
+dev_pm_qos_add_request
+dev_pm_qos_add_ancestor_request
+dev_pm_qos_expose_latency_limit
+dev_pm_qos_expose_flags
+dev_pm_qos_update_user_latency_tolerance
+dev_pm_qos_hide_latency_tolerance
+dev_pm_qos_add_notifier
+__dev_pm_qos_flags
+__dev_pm_qos_resume_latency
+dev_pm_qos_read_value
+dev_pm_qos_constraints_destroy
+dev_pm_qos_update_flags
+dev_pm_qos_get_user_latency_tolerance
+dev_memalloc_noio
+__rpm_get_callback
+rpm_check_suspend_allowed
+pm_runtime_enable
+update_pm_runtime_accounting.part.0
+pm_runtime_suspended_time
+pm_runtime_autosuspend_expiration.part.0
+pm_runtime_autosuspend_expiration
+pm_runtime_set_memalloc_noio
+pm_runtime_get_if_active
+pm_runtime_no_callbacks
+__pm_runtime_barrier
+rpm_suspend
+rpm_idle
+__pm_runtime_idle
+rpm_put_suppliers
+rpm_resume
+__pm_runtime_resume
+rpm_get_suppliers
+__rpm_callback
+rpm_callback
+__pm_runtime_set_status
+pm_runtime_force_resume
+pm_runtime_irq_safe
+pm_runtime_forbid
+pm_runtime_barrier
+__pm_runtime_disable
+pm_runtime_force_suspend
+pm_runtime_allow
+update_autosuspend
+pm_runtime_set_autosuspend_delay
+__pm_runtime_use_autosuspend
+__pm_runtime_suspend
+pm_schedule_suspend
+pm_suspend_timer_fn
+pm_runtime_work
+pm_runtime_active_time
+pm_runtime_init
+pm_runtime_reinit
+pm_runtime_remove
+pm_runtime_get_suppliers
+pm_runtime_put_suppliers
+pm_runtime_new_link
+pm_runtime_drop_link
+dev_pm_clear_wake_irq
+dev_pm_enable_wake_irq
+dev_pm_disable_wake_irq
+handle_threaded_wake_irq
+dev_pm_attach_wake_irq.isra.0
+dev_pm_set_dedicated_wake_irq
+dev_pm_set_wake_irq
+dev_pm_enable_wake_irq_check
+dev_pm_disable_wake_irq_check
+dev_pm_arm_wake_irq
+dev_pm_disarm_wake_irq
+pm_verb
+dpm_wait
+device_pm_wait_for_dev
+pm_dev_dbg
+pm_op
+pm_late_early_op
+pm_noirq_op
+pm_ops_is_empty
+pm_dev_err
+__suspend_report_result
+dpm_show_time
+dpm_wait_for_subordinate
+dpm_wait_fn
+dpm_async_fn
+dpm_wait_for_superior
+initcall_debug_start
+dpm_for_each_dev
+dpm_propagate_wakeup_to_parent
+dpm_run_callback
+device_resume
+async_resume
+__device_suspend_noirq
+__device_suspend_late
+__device_suspend
+async_suspend_late
+async_suspend
+async_suspend_noirq
+device_pm_sleep_init
+device_pm_lock
+device_pm_unlock
+device_pm_move_before
+device_pm_move_after
+device_pm_move_last
+dev_pm_skip_resume
+device_resume_early
+async_resume_early
+device_resume_noirq
+async_resume_noirq
+dpm_resume_noirq
+dpm_resume_early
+dpm_resume_start
+dpm_resume
+dpm_complete
+dpm_resume_end
+dpm_suspend_noirq
+dpm_suspend_late
+dpm_suspend_end
+dpm_suspend
+dpm_prepare
+dpm_suspend_start
+device_pm_check_callbacks
+device_pm_add
+device_pm_remove
+dev_pm_skip_suspend
+wakeup_sources_walk_start
+wakeup_sources_read_lock
+pm_system_wakeup
+wakeup_sources_stats_open
+wakeup_source_record
+wakeup_sources_walk_next
+wakeup_source_free
+wakeup_source_add
+wakeup_source_remove
+wakeup_sources_stats_seq_start
+device_set_wakeup_capable
+wakeup_source_deactivate.part.0
+pm_wakeup_timer_fn
+__pm_relax.part.0
+__pm_relax
+pm_relax
+wakeup_source_unregister.part.0
+wakeup_source_unregister
+wakeup_source_report_event
+__pm_stay_awake.part.0
+__pm_stay_awake
+pm_stay_awake
+pm_wakeup_ws_event.part.0
+pm_wakeup_ws_event
+pm_wakeup_dev_event
+wakeup_source_create
+wakeup_source_register
+pm_print_active_wakeup_sources
+wakeup_source_destroy
+wakeup_sources_read_unlock
+wakeup_sources_stats_seq_stop
+device_wakeup_disable
+print_wakeup_source_stats
+wakeup_sources_stats_seq_show
+wakeup_sources_stats_seq_next
+device_wakeup_enable
+device_init_wakeup
+device_set_wakeup_enable
+device_wakeup_attach_irq
+device_wakeup_detach_irq
+device_wakeup_arm_wake_irqs
+device_wakeup_disarm_wake_irqs
+pm_wakeup_pending
+pm_system_cancel_wakeup
+pm_wakeup_clear
+pm_system_irq_wakeup
+pm_get_wakeup_count
+pm_save_wakeup_count
+device_create_release
+expire_count_show
+wakeup_count_show
+event_count_show
+active_count_show
+name_show
+wakeup_source_device_create
+max_time_ms_show
+last_change_ms_show
+active_time_ms_show
+prevent_suspend_time_ms_show
+total_time_ms_show
+wakeup_source_sysfs_add
+pm_wakeup_source_sysfs_add
+wakeup_source_sysfs_remove
+set_trace_device
+generate_pm_trace
+pm_trace_notify
+show_trace_dev_match
+genpd_lock_nested_mtx
+genpd_lock_mtx
+genpd_unlock_mtx
+genpd_free_default_power_state
+genpd_lock_interruptible_mtx
+genpd_sd_counter_dec
+genpd_lock_spin
+genpd_lock_nested_spin
+genpd_lock_interruptible_spin
+genpd_unlock_spin
+__genpd_runtime_resume
+genpd_dev_pm_start
+genpd_update_accounting
+_genpd_power_off
+genpd_sync_power_off
+_genpd_power_on
+genpd_sync_power_on
+genpd_syscore_switch
+pm_genpd_syscore_poweroff
+pm_genpd_syscore_poweron
+pm_genpd_remove_subdomain
+dev_pm_genpd_add_notifier
+dev_pm_genpd_remove_notifier
+genpd_complete
+genpd_restore_noirq
+genpd_finish_suspend
+genpd_poweroff_noirq
+genpd_suspend_noirq
+genpd_resume_noirq
+genpd_thaw_noirq
+genpd_freeze_noirq
+genpd_prepare
+perf_state_open
+devices_open
+total_idle_time_open
+active_time_open
+idle_states_open
+sub_domains_open
+status_open
+summary_open
+perf_state_show
+sub_domains_show
+status_show
+devices_show
+summary_show
+pm_genpd_remove
+_genpd_reeval_performance_state.part.0
+_genpd_set_performance_state
+dev_pm_genpd_set_performance_state
+genpd_update_cpumask.part.0
+total_idle_time_show
+pm_genpd_init
+pm_genpd_add_subdomain
+idle_states_show
+active_time_show
+genpd_dev_pm_qos_notifier
+genpd_power_off
+genpd_power_off_work_fn
+genpd_power_on
+genpd_runtime_suspend
+genpd_runtime_resume
+genpd_free_dev_data
+pm_genpd_remove_device
+pm_genpd_add_device
+always_on_power_down_ok
+dev_update_qos_constraint
+default_power_down_ok
+cpu_power_down_ok
+default_suspend_ok
+pm_clk_create
+pm_clk_init
+of_pm_clk_add_clk
+pm_clk_suspend
+pm_clk_runtime_suspend
+__pm_clk_remove
+of_pm_clk_add_clks
+pm_clk_resume
+pm_clk_runtime_resume
+pm_clk_add_notifier
+__pm_clk_add
+pm_clk_add
+pm_clk_add_clk
+pm_clk_destroy
+pm_clk_notify
+pm_clk_remove_clk
+pm_clk_remove
+isa_dev_release
+isa_bus_match
+isa_bus_probe
+isa_bus_remove
+isa_bus_shutdown
+isa_bus_suspend
+isa_bus_resume
+isa_unregister_driver
+isa_register_driver
+fw_suspend
+devm_name_match
+fw_set_page_data
+fw_name_devm_release
+fw_devm_match
+__fw_entry_found
+__lookup_fw_priv
+fw_shutdown_notify
+fw_add_devm_name
+firmware_request_cache
+fw_pm_notify
+request_firmware_nowait
+alloc_fw_cache_entry
+dev_create_fw_entry
+dev_cache_fw_image
+fw_is_paged_buf
+fw_free_paged_buf
+fw_get_filesystem_firmware
+free_fw_priv
+device_uncache_fw_images_work
+release_firmware.part.0
+release_firmware
+fw_grow_paged_buf
+fw_map_paged_buf
+fw_decompress_xz
+assign_fw
+_request_firmware
+request_firmware
+__async_dev_cache_fw_image
+firmware_request_nowarn
+request_firmware_direct
+firmware_request_platform
+request_firmware_into_buf
+request_partial_firmware_into_buf
+request_firmware_work_func
+fw_dev_release
+timeout_store
+timeout_show
+fw_load_abort
+firmware_loading_show
+firmware_rw
+firmware_loading_store
+firmware_uevent
+firmware_rw_data
+firmware_data_write
+firmware_data_read
+fw_fallback_set_cache_timeout
+fw_fallback_set_default_timeout
+kill_pending_fw_fallback_reqs
+register_sysfs_loader
+unregister_sysfs_loader
+firmware_fallback_sysfs
+firmware_fallback_platform
+node_access_release
+node_device_release
+write_latency_show
+write_bandwidth_show
+read_latency_show
+read_bandwidth_show
+size_show
+line_size_show
+indexing_show
+write_policy_show
+show_node_state
+do_register_memory_block_under_node
+register_mem_block_under_node_early
+register_mem_block_under_node_hotplug
+node_read_numastat
+node_read_vmstat
+node_read_distance
+node_read_meminfo
+node_memory_callback
+node_read_cpumap
+node_cacheinfo_release
+node_cache_release
+node_init_node_access
+node_hugetlb_work
+node_set_perf_attrs
+node_add_cache
+register_hugetlbfs_with_node
+unregister_node
+register_cpu_under_node
+register_memory_node_under_compute_node
+unregister_cpu_under_node
+unregister_memory_block_under_nodes
+link_mem_sections
+__register_one_node
+unregister_one_node
+unregister_one_node
+register_memory_notifier
+unregister_memory_notifier
+find_memory_block_by_id
+removable_show
+auto_online_blocks_show
+block_size_bytes_show
+memory_block_release
+hard_offline_page_store
+soft_offline_page_store
+probe_store
+for_each_memory_block_cb
+phys_device_show
+state_show
+phys_index_show
+unregister_memory
+memory_subsys_offline
+memory_subsys_online
+valid_zones_show
+memhp_online_type_from_str
+state_store
+auto_online_blocks_store
+memory_notify
+arch_get_memory_phys_device
+init_memory_block
+find_memory_block
+create_memory_block_devices
+remove_memory_block_devices
+is_memblock_offlined
+walk_memory_blocks
+for_each_memory_block
+module_add_driver
+module_remove_driver
+regmap_parse_inplace_noop
+dev_get_regmap_release
+regmap_parse_16_le
+regmap_parse_32_le
+regmap_parse_64_le
+regmap_reg_in_ranges
+__traceiter_regmap_reg_write
+__traceiter_regmap_reg_read
+__traceiter_regmap_reg_read_cache
+__traceiter_regmap_hw_read_start
+__traceiter_regmap_hw_read_done
+__traceiter_regmap_hw_write_start
+__traceiter_regmap_hw_write_done
+__traceiter_regcache_sync
+__traceiter_regmap_cache_only
+__traceiter_regmap_cache_bypass
+__traceiter_regmap_async_write_start
+__traceiter_regmap_async_io_complete
+__traceiter_regmap_async_complete_start
+__traceiter_regmap_async_complete_done
+__traceiter_regcache_drop_region
+regmap_format_12_20_write
+regmap_format_2_6_write
+regmap_format_10_14_write
+regmap_parse_8
+regmap_parse_24
+regmap_lock_spinlock
+regmap_unlock_spinlock
+regmap_get_device
+regmap_can_raw_write
+regmap_get_raw_read_max
+regmap_get_raw_write_max
+_regmap_bus_reg_write
+_regmap_bus_reg_read
+regmap_get_val_bytes
+regmap_get_max_register
+regmap_get_reg_stride
+regmap_parse_val
+regmap_parse_16_le_inplace
+regmap_parse_32_le_inplace
+regmap_parse_64_le_inplace
+regmap_parse_16_native
+regmap_parse_32_native
+regmap_parse_64_native
+regmap_set_name
+regmap_field_free
+regmap_set_work_buf_flag_mask
+regmap_format_64_native
+regmap_format_64_le
+regmap_format_32_native
+regmap_format_32_le
+regmap_format_24
+regmap_format_16_native
+regmap_format_16_le
+regmap_format_8
+regmap_field_init
+regmap_parse_64_be
+regmap_parse_64_be_inplace
+regmap_format_64_be
+regmap_parse_32_be
+regmap_parse_32_be_inplace
+regmap_format_32_be
+regmap_parse_16_be
+regmap_parse_16_be_inplace
+regmap_format_16_be
+regmap_format_7_9_write
+regmap_format_4_12_write
+regmap_unlock_mutex
+regmap_lock_mutex
+regmap_unlock_hwlock
+regmap_unlock_hwlock_irq
+regmap_unlock_hwlock_irqrestore
+regmap_lock_hwlock
+regmap_lock_hwlock_irq
+regmap_lock_hwlock_irqsave
+regmap_range_exit
+regmap_exit
+devm_regmap_release
+devm_regmap_field_alloc
+devm_regmap_field_bulk_alloc
+devm_regmap_field_free
+dev_get_regmap
+regmap_async_complete_cb
+regmap_check_range_table
+regmap_attach_dev
+regmap_get_val_endian
+regmap_reinit_cache
+dev_get_regmap_match
+regmap_lock_unlock_none
+regmap_field_bulk_free
+devm_regmap_field_bulk_free
+regmap_async_complete.part.0
+regmap_async_complete
+regmap_field_alloc
+_regmap_raw_multi_reg_write
+regmap_field_bulk_alloc
+__regmap_init
+__devm_regmap_init
+regmap_writeable
+regmap_cached
+regmap_readable
+_regmap_read
+regmap_read
+regmap_field_read
+regmap_fields_read
+regmap_test_bits
+regmap_volatile
+regmap_volatile_range
+regmap_precious
+regmap_writeable_noinc
+regmap_readable_noinc
+_regmap_write
+_regmap_update_bits
+_regmap_select_page
+_regmap_raw_write_impl
+_regmap_bus_raw_write
+_regmap_bus_formatted_write
+_regmap_raw_read
+_regmap_bus_read
+regmap_raw_read
+regmap_bulk_read
+regmap_noinc_read
+regmap_update_bits_base
+regmap_field_update_bits_base
+regmap_fields_update_bits_base
+regmap_write
+regmap_write_async
+_regmap_multi_reg_write
+regmap_multi_reg_write
+regmap_multi_reg_write_bypassed
+regmap_register_patch
+_regmap_raw_write
+regmap_raw_write
+regmap_bulk_write
+regmap_noinc_write
+regmap_raw_write_async
+regcache_mark_dirty
+regcache_default_cmp
+regcache_drop_region
+regcache_sync_block_raw_flush
+regcache_cache_only
+regcache_cache_bypass
+regcache_exit
+regcache_read
+regcache_write
+regcache_get_val
+regcache_init
+regcache_set_val
+regcache_lookup_reg
+regcache_reg_needs_sync
+regcache_default_sync
+regcache_sync
+regcache_sync_region
+regcache_sync_block
+regcache_rbtree_lookup
+regcache_rbtree_drop
+regcache_rbtree_sync
+regcache_rbtree_read
+rbtree_debugfs_init
+rbtree_open
+rbtree_show
+regcache_rbtree_exit
+regcache_rbtree_write
+regcache_rbtree_init
+regcache_flat_write
+regcache_flat_read
+regcache_flat_exit
+regcache_flat_init
+regmap_debugfs_free_dump_cache
+regmap_access_open
+regmap_access_show
+regmap_name_read_file
+regmap_cache_bypass_write_file
+regmap_cache_only_write_file
+regmap_printable
+regmap_debugfs_get_dump_start.part.0
+regmap_read_debugfs
+regmap_range_read_file
+regmap_map_read_file
+regmap_reg_ranges_read_file
+regmap_debugfs_init
+regmap_debugfs_exit
+regmap_debugfs_initcall
+regmap_smbus_byte_reg_write
+regmap_smbus_word_write_swapped
+regmap_smbus_word_reg_write
+regmap_i2c_write
+regmap_get_i2c_bus
+__regmap_init_i2c
+__devm_regmap_init_i2c
+regmap_smbus_byte_reg_read
+regmap_smbus_word_reg_read
+regmap_smbus_word_read_swapped
+regmap_i2c_smbus_i2c_read_reg16
+regmap_i2c_smbus_i2c_write_reg16
+regmap_i2c_smbus_i2c_write
+regmap_i2c_smbus_i2c_read
+regmap_i2c_read
+regmap_i2c_gather_write
+__regmap_init_spi
+regmap_spi_read
+regmap_spi_complete
+regmap_spi_async_write
+__devm_regmap_init_spi
+regmap_spi_async_alloc
+regmap_spi_write
+regmap_spi_gather_write
+regmap_mmio_write8
+regmap_mmio_write16le
+regmap_mmio_write32le
+regmap_mmio_write64le
+regmap_mmio_read8
+regmap_mmio_read16le
+regmap_mmio_read32le
+regmap_mmio_read64le
+regmap_mmio_detach_clk
+regmap_mmio_attach_clk
+regmap_mmio_write32be
+regmap_mmio_read32be
+regmap_mmio_write16be
+regmap_mmio_read16be
+regmap_mmio_read
+regmap_mmio_write
+regmap_mmio_free_context
+regmap_mmio_gen_context
+__regmap_init_mmio_clk
+__devm_regmap_init_mmio_clk
+regmap_irq_get_domain
+regmap_irq_set_wake
+regmap_irq_set_type
+regmap_irq_disable
+regmap_irq_enable
+regmap_irq_chip_get_base
+regmap_irq_lock
+regmap_irq_get_virq
+regmap_irq_thread
+devm_regmap_irq_chip_match
+regmap_irq_update_bits
+regmap_irq_sync_unlock
+regmap_del_irq_chip.part.0
+regmap_del_irq_chip
+devm_regmap_irq_chip_release
+devm_regmap_del_irq_chip
+regmap_irq_map
+regmap_add_irq_chip_fwnode
+regmap_add_irq_chip
+devm_regmap_add_irq_chip_fwnode
+devm_regmap_add_irq_chip
+pinctrl_bind_pins
+devcd_freev
+devcd_readv
+devcd_del
+devcd_data_write
+disabled_store
+devcd_free
+devcd_read_from_sgtable
+devcd_data_read
+devcd_match_failing
+devcd_dev_release
+devcd_free_sgtable
+disabled_show
+dev_coredumpm
+dev_coredumpv
+dev_coredumpsg
+platform_msi_write_msg
+platform_msi_free_descs
+platform_msi_alloc_descs_with_irq
+platform_msi_domain_free_irqs
+platform_msi_alloc_priv_data
+platform_msi_domain_alloc_irqs
+platform_msi_create_irq_domain
+platform_msi_get_host_data
+__platform_msi_create_device_domain
+platform_msi_domain_free
+platform_msi_domain_alloc
+loop_unregister_transfer
+loop_validate_file
+loop_register_transfer
+find_free_cb
+xor_init
+transfer_xor
+loop_release_xfer
+unregister_transfer_cb
+loop_remove
+loop_exit_cb
+loop_attr_do_show_dio
+loop_attr_do_show_partscan
+loop_attr_do_show_autoclear
+loop_attr_do_show_sizelimit
+loop_attr_do_show_offset
+lo_fallocate
+loop_info64_from_compat
+loop_init_request
+loop_set_status_from_info
+loop_set_size
+loop_reread_partitions
+loop_info64_to_compat
+loop_kthread_worker_fn
+lo_rw_aio_do_completion
+lo_write_bvec
+__loop_update_dio
+loop_set_status
+loop_set_status_compat
+loop_set_status_old
+__loop_clr_fd
+lo_release
+lo_complete_rq
+lo_open
+loop_lookup.part.0
+loop_lookup
+loop_get_status.part.0
+loop_get_status
+loop_get_status_compat
+loop_get_status_old
+loop_add
+loop_control_ioctl
+loop_probe
+lo_rw_aio_complete
+loop_queue_rq
+loop_attr_do_show_backing_file
+lo_rw_aio
+loop_configure
+lo_ioctl
+lo_compat_ioctl
+loop_queue_work
+encode_disk_name
+blkfront_is_ready
+blkif_ioctl
+blkif_complete_rq
+get_id_from_freelist
+write_per_ring_nodes
+blkif_open
+blkif_getgeo
+blkif_copy_from_grant
+xlvbd_flush
+blkif_set_queue_limits
+blkfront_gather_backend_features
+blkfront_delay_work
+blkif_restart_queue_callback
+blkfront_probe
+get_free_grant
+blkfront_setup_indirect
+kick_pending_request_queues
+blkif_restart_queue
+blkif_interrupt
+blkif_queue_rq
+blkif_setup_rw_req_grant
+xlbd_release_minors
+xlvbd_release_gendisk
+blkif_release
+blkif_free
+blkfront_remove
+talk_to_blkback
+blkfront_resume
+blkback_changed
+atmel_securam_wait
+sram_reserve_cmp
+sram_free_partitions
+sram_remove
+sram_write
+sram_read
+sram_probe
+pvpanic_mmio_remove
+pvpanic_panic_notify
+pvpanic_mmio_probe
+pvpanic_remove
+pvpanic_walk_resources
+pvpanic_add
+pm860x_irq_lock
+pm860x_irq_enable
+pm860x_irq_disable
+pm8606_osc_enable
+pm8606_osc_disable
+pm860x_resume
+pm860x_suspend
+device_8606_init
+pm860x_irq
+pm860x_irq_sync_unlock
+pm860x_remove
+device_8607_init
+pm860x_probe
+pm860x_irq_domain_map
+pm860x_reg_read
+pm860x_reg_write
+pm860x_bulk_read
+pm860x_bulk_write
+pm860x_set_bits
+read_device
+pm860x_page_bulk_read
+pm860x_page_reg_write
+htcpld_set_type
+htcpld_direction_input
+htcpld_chip_set_ni
+htcpld_unmask
+htcpld_mask
+htcpld_chip_to_irq
+htcpld_chip_set
+htcpld_direction_output
+htcpld_chip_get
+htcpld_core_probe
+htcpld_handler
+arizona_clk32k_disable
+arizona_connect_dcvdd
+arizona_isolate_dcvdd
+arizona_clkgen_err
+arizona_suspend_noirq
+arizona_resume
+arizona_disable_reset
+arizona_disable_freerun_sysclk
+arizona_is_jack_det_active
+arizona_underclocked
+arizona_poll_reg
+arizona_enable_freerun_sysclk
+wm5102_apply_hardware_patch
+wm5110_apply_sleep_patch
+arizona_wait_for_boot
+arizona_runtime_suspend
+arizona_resume_noirq
+arizona_suspend
+arizona_overclocked
+arizona_dev_exit
+arizona_runtime_resume
+arizona_clk32k_enable
+arizona_dev_init
+arizona_irq_enable
+arizona_map_irq
+arizona_request_irq
+arizona_free_irq
+arizona_set_irq_wake
+arizona_irq_set_wake
+arizona_ctrlif_err
+arizona_irq_thread
+arizona_boot_done
+arizona_irq_map
+arizona_irq_disable
+arizona_irq_init
+arizona_irq_exit
+wm5102_readable_register
+wm5102_volatile_register
+wm5102_patch
+wm5110_is_rev_b_adsp_memory
+wm5110_is_rev_d_adsp_memory
+wm5110_readable_register
+wm5110_patch
+wm5110_volatile_register
+wm8997_readable_register
+wm8997_volatile_register
+wm8997_patch
+wm8998_readable_register
+wm8998_volatile_register
+wm8998_patch
+cs47l24_readable_register
+cs47l24_volatile_register
+cs47l24_patch
+wm8400_volatile
+wm8400_reset_codec_reg_cache
+wm8400_register_codec
+wm8400_i2c_probe
+wm831x_reg_readable
+wm831x_reg_volatile
+wm831x_reg_read
+wm831x_bulk_read
+wm831x_reg_locked.part.0
+wm831x_reg_writeable
+wm831x_set_bits
+wm831x_device_shutdown
+wm831x_reg_write
+wm831x_reg_lock
+wm831x_reg_unlock
+wm831x_device_init
+wm831x_device_suspend
+wm831x_irq_lock
+wm831x_irq_enable
+wm831x_irq_disable
+wm831x_irq_set_type
+wm831x_irq_sync_unlock
+wm831x_irq_thread
+wm831x_irq_map
+wm831x_irq_init
+wm831x_irq_exit
+wm831x_unique_id_read
+wm831x_unique_id_show
+wm831x_otp_init
+wm831x_otp_exit
+wm831x_auxadc_read
+wm831x_auxadc_read_uv
+wm831x_auxadc_read_polled
+wm831x_auxadc_irq
+wm831x_auxadc_read_irq
+wm831x_auxadc_init
+wm831x_i2c_poweroff
+wm831x_i2c_suspend
+wm831x_i2c_probe
+wm831x_spi_poweroff
+wm831x_spi_suspend
+wm831x_spi_probe
+wm8350_auxadc_irq
+wm8350_clear_bits
+wm8350_set_bits
+wm8350_reg_read
+wm8350_reg_write
+wm8350_reg_lock
+wm8350_reg_unlock
+wm8350_read_auxadc
+wm8350_block_read
+wm8350_block_write
+wm8350_client_dev_register
+wm8350_device_init
+wm8350_readable
+wm8350_volatile
+wm8350_precious
+wm8350_writeable
+wm8350_gpio_config
+wm8350_irq_enable
+wm8350_irq_disable
+wm8350_irq
+wm8350_irq_sync_unlock
+wm8350_irq_lock
+wm8350_irq_init
+wm8350_irq_exit
+wm8350_i2c_probe
+is_volatile_reg
+tps65910_power_off
+tps65910_i2c_probe
+tps65912_device_init
+tps65912_device_exit
+tps65912_i2c_remove
+tps65912_i2c_probe
+tps65912_spi_remove
+tps65912_spi_probe
+rd_wr_reg_id0
+rd_wr_reg_id1
+is_volatile_reg_id1
+rd_wr_reg_id2
+rd_wr_reg_id3
+tps80031_power_off
+tps80031_ext_power_req_config
+tps80031_probe
+twl4030_49_nop_reg
+twl_rev
+twl_get_type
+twl_get_version
+twl_resume
+twl_suspend
+twl_remove
+add_numbered_child
+twl_get_regmap
+twl_i2c_write
+twl_i2c_read
+twl_get_hfclk_rate
+twl_set_regcache_bypass
+add_regulator_linked.constprop.0
+twl_probe
+handle_twl4030_pih
+twl4030_sih_bus_lock
+twl4030_sih_set_type
+twl4030_sih_unmask
+twl4030_sih_mask
+handle_twl4030_sih
+twl4030_sih_bus_sync_unlock
+twl4030_sih_setup
+twl4030_init_irq
+twl4030_exit_irq
+twl4030_init_chip_irq
+twl6030_interrupt_unmask
+twl6030_interrupt_mask
+twl6030_mmc_card_detect
+twl6030_mmc_card_detect_config
+twl6030_init_irq
+twl6030_exit_irq
+twl4030_audio_remove
+twl4030_audio_get_mclk
+twl4030_audio_set_resource
+twl4030_audio_disable_resource
+twl4030_audio_probe
+twl4030_audio_enable_resource
+twl6040_readable_reg
+twl6040_volatile_reg
+twl6040_writeable_reg
+twl6040_readyint_handler
+twl6040_get_pll
+twl6040_get_sysclk
+twl6040_reg_read
+twl6040_get_vibralr_status
+twl6040_reg_write
+twl6040_set_bits
+twl6040_clear_bits
+twl6040_probe
+twl6040_set_pll
+twl6040_power
+twl6040_thint_handler
+twl6040_remove
+mfd_remove_devices_late
+mfd_remove_devices
+devm_mfd_dev_release
+mfd_cell_enable
+mfd_cell_disable
+mfd_remove_devices_fn
+mfd_add_devices
+devm_mfd_add_devices
+irq_to_pcap
+pcap_to_irq
+ezx_pcap_putget
+ezx_pcap_write
+pcap_msr_work
+ezx_pcap_set_bits
+ezx_pcap_read
+pcap_set_ts_bits
+pcap_adc_trigger
+pcap_adc_async
+pcap_adc_sync_cb
+pcap_adc_sync
+pcap_remove_subdev
+ezx_pcap_remove
+pcap_irq_handler
+pcap_unmask_irq
+pcap_mask_irq
+pcap_isr_work
+ezx_pcap_probe
+pcap_adc_irq
+__remove_subdev
+da903x_irq_handler
+da903x_query_status
+da903x_register_notifier
+da903x_unregister_notifier
+da9034_unmask_events
+da9034_read_events
+da903x_remove
+da903x_irq_work
+da903x_probe
+da9034_read_status
+da903x_reads
+da9030_read_events
+da9030_mask_events
+da9030_unmask_events
+da9034_mask_events
+da903x_writes
+da9030_read_status
+da903x_read
+da903x_write
+da9030_init_chip
+da903x_set_bits
+da903x_update
+da9034_init_chip
+da903x_clr_bits
+da9052_auxadc_irq
+da9052_enable_irq
+da9052_disable_irq
+da9052_disable_irq_nosync
+da9052_request_irq
+da9052_free_irq
+da9052_irq_init
+da9052_irq_exit
+da9052_reg_readable
+da9052_reg_writeable
+da9052_reg_volatile
+da9052_adc_read_temp
+da9052_adc_manual_read
+da9052_device_init
+da9052_device_exit
+da9052_spi_remove
+da9052_spi_probe
+da9052_i2c_remove
+da9052_i2c_probe
+da9052_i2c_fix
+lp8788_read_byte
+lp8788_read_multi_bytes
+lp8788_write_byte
+lp8788_update_bits
+lp8788_remove
+lp8788_probe
+lp8788_irq_bus_lock
+lp8788_irq_enable
+lp8788_irq_disable
+lp8788_irq_handler
+lp8788_irq_bus_sync_unlock
+lp8788_irq_map
+lp8788_irq_init
+lp8788_irq_exit
+da9055_register_readable
+da9055_register_writeable
+da9055_register_volatile
+da9055_device_init
+da9055_device_exit
+da9055_i2c_remove
+da9055_i2c_probe
+da9063_device_init
+da9063_irq_init
+da9063_i2c_probe
+max14577_muic_volatile_reg
+maxim_charger_calc_reg_current
+max14577_resume
+max14577_suspend
+max14577_i2c_probe
+max77836_muic_volatile_reg
+max14577_i2c_remove
+max77693_resume
+max77693_suspend
+max77693_i2c_remove
+max77693_i2c_probe
+max77843_resume
+max77843_suspend
+max77843_probe
+max8925_irq_lock
+max8925_irq_enable
+max8925_irq_disable
+max8925_tsc_irq
+max8925_irq
+max8925_irq_sync_unlock
+max8925_irq_domain_map
+max8925_device_init
+max8925_device_exit
+max8925_resume
+max8925_suspend
+max8925_remove
+max8925_probe
+max8925_bulk_read
+max8925_reg_read
+max8925_set_bits
+max8925_reg_write
+max8925_bulk_write
+max8997_bulk_read
+max8997_write_reg
+max8997_update_reg
+max8997_bulk_write
+max8997_read_reg
+max8997_freeze
+max8997_restore
+max8997_resume
+max8997_suspend
+max8997_i2c_probe
+max8997_irq_lock
+max8997_irq_mask
+max8997_irq_unmask
+max8997_irq_sync_unlock
+max8997_irq_thread
+max8997_irq_domain_map
+max8997_irq_resume
+max8997_irq_init
+max8997_irq_exit
+max8998_bulk_read
+max8998_write_reg
+max8998_restore
+max8998_update_reg
+max8998_bulk_write
+max8998_read_reg
+max8998_freeze
+max8998_suspend
+max8998_resume
+max8998_i2c_probe
+max8998_irq_lock
+max8998_irq_unmask
+max8998_irq_mask
+max8998_irq_thread
+max8998_irq_sync_unlock
+max8998_irq_domain_map
+max8998_irq_resume
+max8998_irq_init
+max8998_irq_exit
+__adp5520_write
+adp5520_write
+__remove_subdev
+adp5520_resume
+__adp5520_read
+adp5520_read
+adp5520_suspend
+adp5520_set_bits
+adp5520_clr_bits
+adp5520_register_notifier
+adp5520_unregister_notifier
+adp5520_probe
+adp5520_irq_thread
+is_volatile_reg
+__remove_subdev
+tps6586x_irq_lock
+tps6586x_get_version
+tps6586x_write
+tps6586x_writes
+tps6586x_read
+tps6586x_reads
+tps6586x_set_bits
+tps6586x_clr_bits
+tps6586x_update
+tps6586x_irq_get_virq
+tps6586x_i2c_resume
+tps6586x_i2c_suspend
+tps6586x_i2c_remove
+tps6586x_irq_disable
+tps6586x_irq_enable
+tps6586x_irq
+tps6586x_irq_sync_unlock
+tps6586x_irq_set_wake
+tps6586x_i2c_probe
+tps6586x_power_off
+tps6586x_irq_map
+is_volatile_reg
+tps65090_i2c_probe
+aat2870_i2c_probe
+aat2870_reg_write_file
+aat2870_reg_read_file
+__aat2870_write
+aat2870_write
+__aat2870_read
+aat2870_update
+aat2870_read
+aat2870_i2c_suspend
+aat2870_i2c_resume
+palmas_ext_control_req_config
+palmas_i2c_remove
+palmas_i2c_probe
+rc5t583_i2c_probe
+volatile_reg
+rc5t583_ext_power_req_config
+rc5t583_irq_lock
+rc5t583_irq_unmask
+rc5t583_irq_set_type
+rc5t583_irq_mask
+rc5t583_irq_set_wake
+rc5t583_irq
+rc5t583_irq_sync_unlock
+rc5t583_irq_init
+syscon_node_to_regmap
+syscon_regmap_lookup_by_compatible
+syscon_regmap_lookup_by_phandle
+syscon_regmap_lookup_by_phandle_args
+syscon_probe
+device_node_to_regmap
+as3711_volatile_reg
+as3711_precious_reg
+as3711_readable_reg
+as3711_i2c_probe
+intel_soc_pmic_resume
+intel_soc_pmic_suspend
+intel_soc_pmic_shutdown
+intel_soc_pmic_i2c_remove
+intel_soc_pmic_i2c_probe
+cht_wc_resume
+cht_wc_suspend
+cht_wc_shutdown
+cht_wc_byte_reg_write
+cht_wc_byte_reg_read
+cht_wc_probe
+to_nvdimm_bus_dev
+nvdimm_bus_lock
+nvdimm_bus_unlock
+flush_namespaces
+is_nvdimm_bus_locked
+nd_fletcher64
+to_nd_desc
+exec_firmware_activate
+activate_show
+nvdimm_bus_firmware_visible
+provider_show
+activate_store
+wait_probe_show
+flush_regions_dimms
+commands_show
+nvdimm_bus_add_badrange
+capability_show
+nd_integrity_init
+nvdimm_map_put
+devm_nvdimm_memremap
+nd_uuid_store
+nd_size_select_show
+nd_size_select_store
+nd_cmd_dimm_desc
+nd_cmd_bus_desc
+nd_ns_forget_poison_check
+nd_open
+nd_device_notify
+match_dimm
+nd_pmem_forget_poison_check
+nvdimm_bus_release
+nvdimm_bus_unregister
+nd_async_device_unregister
+nd_synchronize
+nd_async_device_register
+nvdimm_check_and_set_ro
+devtype_show
+numa_node_show
+nd_cmd_in_size
+nd_cmd_out_size
+nvdimm_account_cleared_poison
+nd_device_unregister
+child_unregister
+__nd_driver_register
+to_nvdimm_bus.part.0
+to_nvdimm_bus
+nvdimm_to_bus
+nd_bus_remove
+nvdimm_clear_badblocks_region
+nvdimm_bus_register
+__nd_device_register.part.0
+nd_device_register
+nvdimm_dev_to_target_node
+nd_numa_attr_visible
+target_node_show
+to_nd_device_type
+nvdimm_bus_uevent
+modalias_show
+nvdimm_bus_match
+is_nvdimm_bus
+walk_to_nvdimm_bus
+nvdimm_bus_shutdown
+to_bus_provider
+nvdimm_bus_remove
+nvdimm_bus_probe
+nvdimm_region_notify
+nvdimm_clear_poison
+__nd_device_register
+nvdimm_bus_create_ndctl
+nd_bus_probe
+nvdimm_bus_destroy_ndctl
+wait_nvdimm_bus_probe_idle
+nd_ioctl
+dimm_ioctl
+bus_ioctl
+nvdimm_bus_exit
+nd_blk_memremap_flags
+nvdimm_kobj
+nvdimm_in_overwrite
+nvdimm_name
+nd_blk_region_to_dimm
+nvdimm_cmd_mask
+nvdimm_provider_data
+count_dimms
+to_ndd
+security_store
+shutdown_security_notify
+nvdimm_bus_check_dimm_count
+available_slots_show
+dpa_align
+alias_dpa_busy
+to_nvdimm.part.0
+to_nvdimm
+nvdimm_release
+result_show
+activate_store
+activate_show
+nvdimm_firmware_visible
+frozen_show
+commands_show
+flags_show
+state_show
+nvdimm_visible
+nvdimm_security_setup_events
+security_show
+__nvdimm_create
+nvdimm_check_config_data
+validate_dimm
+nvdimm_init_nsarea
+nvdimm_get_config_data
+nvdimm_set_config_data
+nvdimm_set_labeling
+nvdimm_set_locked
+nvdimm_clear_locked
+get_ndd
+is_nvdimm
+nvdimm_security_freeze
+nd_blk_available_dpa
+nd_pmem_max_contiguous_dpa
+nd_pmem_available_dpa
+nvdimm_free_dpa
+nvdimm_drvdata_release
+put_ndd
+nvdimm_allocate_dpa
+nvdimm_allocated_dpa
+nvdimm_remove
+nvdimm_probe
+nvdimm_exit
+nd_region_dev
+nd_region_provider_data
+nd_blk_region_provider_data
+nd_blk_region_set_provider_data
+nd_region_release_lane
+nvdimm_has_flush
+init_namespaces_show
+nd_region_acquire_lane
+is_nvdimm_sync
+to_nd_region.part.0
+to_nd_region
+deep_flush_show
+mapping_visible
+mappingN
+mapping31_show
+mapping30_show
+mapping29_show
+mapping28_show
+mapping27_show
+mapping26_show
+mapping25_show
+mapping24_show
+mapping23_show
+mapping22_show
+mapping21_show
+mapping20_show
+mapping19_show
+mapping18_show
+mapping17_show
+mapping16_show
+mapping15_show
+mapping14_show
+mapping13_show
+mapping12_show
+mapping11_show
+mapping10_show
+mapping9_show
+mapping8_show
+mapping7_show
+mapping6_show
+mapping5_show
+mapping4_show
+mapping3_show
+mapping2_show
+mapping1_show
+mapping0_show
+resource_show
+namespace_seed_show
+read_only_show
+dax_seed_show
+pfn_seed_show
+btt_seed_show
+mappings_show
+align_show
+region_badblocks_show
+read_only_store
+to_nd_blk_region
+set_cookie_show
+persistence_domain_show
+nvdimm_has_cache
+nd_region_release
+nd_region_to_nstype
+nstype_show
+region_visible
+region_size
+align_store
+size_show
+region_conflict
+nd_region_create
+nvdimm_pmem_region_create
+nvdimm_blk_region_create
+nvdimm_volatile_region_create
+nd_region_activate
+nd_region_available_dpa
+available_size_show
+nd_region_allocatable_dpa
+max_available_extent_show
+is_nd_pmem
+is_nd_blk
+is_nd_volatile
+nd_region_interleave_set_cookie
+nd_region_interleave_set_altcookie
+nd_mapping_free_labels
+nd_region_advance_seeds
+nd_blk_region_init
+generic_nvdimm_flush
+nvdimm_flush
+deep_flush_store
+nd_region_conflict
+child_unregister
+child_notify
+nd_region_remove
+nd_region_probe
+nd_region_notify
+nd_region_exit
+namespace_io_release
+namespace_pmem_release
+namespace_blk_release
+pmem_sector_size
+nd_namespace_blk_size
+nd_namespace_pmem_set_resource
+nd_namespace_blk_validate
+holder_class_show
+dpa_extents_show
+force_raw_show
+alt_name_show
+resource_show
+holder_show
+nvdimm_namespace_disk_name
+nstype_show
+cmp_dpa
+is_uuid_busy
+pmem_should_map_pages
+mode_show
+nvdimm_namespace_locked
+devm_namespace_enable
+devm_namespace_disable
+deactivate_labels
+nd_namespace_label_update
+holder_class_store
+sector_size_store
+force_raw_store
+uuid_not_set.part.0
+namespace_to_uuid
+uuid_show
+namespace_visible
+nd_dev_to_uuid
+sector_size_show
+space_valid.isra.0
+scan_allocate
+is_namespace_uuid_busy
+__reserve_free_pmem
+has_uuid_at_pos
+alt_name_store
+nd_is_uuid_unique
+namespace_update_uuid
+uuid_store
+release_free_pmem
+size_store
+__nvdimm_namespace_capacity
+nvdimm_namespace_capacity
+size_show
+nvdimm_namespace_common_probe
+nsblk_add_resource
+nd_region_create_ns_seed
+nd_region_create_dax_seed
+nd_region_create_pfn_seed
+nd_region_create_btt_seed
+nd_region_register_namespaces
+slot_valid.part.0
+sizeof_namespace_label
+nvdimm_num_label_slots
+sizeof_namespace_index
+nd_label_base
+to_slot
+nd_label_copy.part.0
+nd_label_write_index
+init_labels
+nd_label_gen_id
+nd_label_reserve_dpa
+nd_label_data_init
+nd_label_active_count
+nd_label_active
+nd_label_alloc_slot
+nd_label_free_slot
+del_labels
+__pmem_label_update
+nd_label_nfree
+to_nvdimm_cclass
+nd_pmem_namespace_label_update
+nd_blk_namespace_label_update
+badrange_init
+set_badblock
+badrange_forget
+__add_badblock_range
+nvdimm_badblocks_populate
+badrange_add
+namespace_match
+nd_sb_checksum
+nsio_rw_bytes
+__nd_detach_ndns
+nd_detach_ndns
+__nd_attach_ndns
+nd_attach_ndns
+to_nd_pfn_safe
+nd_namespace_store
+devm_nsio_enable
+devm_nsio_disable
+log_zero_flags_show
+is_nd_btt
+to_nd_btt.part.0
+to_nd_btt
+nd_btt_release
+size_show
+uuid_store
+namespace_store
+namespace_show
+sector_size_store
+sector_size_show
+uuid_show
+nd_btt_arena_is_valid
+nd_btt_version
+__nd_btt_create.constprop.0
+nd_btt_probe
+nd_btt_create
+is_nd_pfn
+align_show
+size_show
+resource_show
+namespace_show
+uuid_store
+namespace_store
+mode_store
+nd_pfn_clear_memmap_errors
+to_nd_pfn.part.0
+to_nd_pfn
+nd_pfn_release
+supported_alignments_show
+uuid_show
+mode_show
+nd_pfn_alloc
+nd_pfn_validate
+nvdimm_setup_pfn
+align_store
+nd_pfn_devinit
+nd_pfn_probe
+nd_pfn_create
+is_nd_dax
+to_nd_dax.part.0
+to_nd_dax
+nd_dax_release
+nd_dax_alloc
+nd_dax_probe
+nd_dax_create
+check_security_state
+nvdimm_request_key
+nvdimm_put_key.part.0
+nvdimm_get_user_key_payload.part.0
+nvdimm_security_unlock
+__nvdimm_security_overwrite_query
+nvdimm_security_overwrite_query
+nvdimm_security_store
+e820_pmem_remove
+e820_pmem_probe
+e820_register_one
+__set_dax_synchronous
+run_dax
+dax_inode
+dax_read_lock
+put_dax
+dax_write_cache_enabled
+__dax_synchronous
+dax_alive
+dax_flush
+bdev_dax_pgoff
+dax_test
+dax_set
+inode_dax
+dax_direct_access
+dax_zero_page_range
+dax_get_private
+dax_init_fs_context
+dax_free_inode
+dax_alloc_inode
+init_once
+dax_write_cache
+dax_copy_from_iter
+dax_copy_to_iter
+dax_destroy_inode
+alloc_dax
+dax_supported
+dax_read_unlock
+kill_dax
+dax_get_by_host
+write_cache_show
+fs_dax_get_by_bdev
+dax_visible
+write_cache_store
+__generic_fsdax_supported
+__bdev_dax_supported
+modalias_show
+dax_bus_uevent
+numa_node_show
+region_size_show
+size_show
+dax_bus_probe
+dax_bus_remove
+available_size_show
+dax_region_visible
+target_node_show
+dev_dax_visible
+kill_dev_dax
+id_show
+region_align_show
+resource_show
+align_show
+unregister_dax_mapping
+free_dev_dax_ranges
+unregister_dev_dax
+free_dev_dax_id
+dax_mapping_release
+delete_store
+seed_show
+create_show
+get_dax_range
+pgoff_show
+end_show
+start_show
+align_store
+dax_bus_match
+__dax_driver_register
+dax_driver_unregister
+adjust_dev_dax_range
+do_id_store
+remove_id_store
+new_id_store
+dev_dax_release
+devm_register_dax_mapping
+alloc_dev_dax_range
+mapping_store
+size_store
+devm_create_dev_dax
+create_store
+dax_region_unregister
+alloc_dax_region
+dax_region_put
+hmem_register_device
+dma_buf_mmap_internal
+dma_buf_llseek
+dma_buf_pin
+dma_buf_unpin
+dma_buf_move_notify
+dma_buf_end_cpu_access
+dma_buf_vmap
+dma_buf_vunmap
+dma_buf_detach
+dma_buf_poll_cb
+dma_buf_fd
+dma_buf_get
+dma_buf_put
+dma_buf_mmap
+dma_buf_unmap_attachment
+dma_buf_fs_init_context
+dma_buf_release
+dma_buf_debug_open
+dma_buf_map_attachment
+dma_buf_begin_cpu_access
+dma_buf_ioctl
+dma_buf_export
+dma_buf_dynamic_attach
+dma_buf_attach
+dma_buf_debug_show
+dma_buf_show_fdinfo
+dmabuffs_dname
+dma_buf_poll
+dma_fence_stub_get_name
+__traceiter_dma_fence_emit
+__traceiter_dma_fence_init
+__traceiter_dma_fence_destroy
+__traceiter_dma_fence_enable_signal
+__traceiter_dma_fence_signaled
+__traceiter_dma_fence_wait_start
+__traceiter_dma_fence_wait_end
+dma_fence_remove_callback
+dma_fence_context_alloc
+dma_fence_signal_locked
+dma_fence_signal
+dma_fence_get_status
+dma_fence_free
+dma_fence_release
+dma_fence_default_wait_cb
+__dma_fence_enable_signaling
+dma_fence_add_callback
+dma_fence_default_wait
+dma_fence_wait_timeout
+dma_fence_enable_sw_signaling
+dma_fence_init
+dma_fence_wait_any_timeout
+dma_fence_get_stub
+dma_fence_array_get_driver_name
+dma_fence_array_get_timeline_name
+dma_fence_array_signaled
+dma_fence_match_context
+dma_fence_array_cb_func
+dma_fence_array_create
+dma_fence_array_release
+dma_fence_array_enable_signaling
+irq_dma_fence_array_work
+dma_fence_chain_get_driver_name
+dma_fence_chain_get_timeline_name
+dma_fence_chain_init
+dma_fence_chain_cb
+dma_fence_chain_release
+dma_fence_chain_walk
+dma_fence_chain_find_seqno
+dma_fence_chain_signaled
+dma_fence_chain_enable_signaling
+dma_fence_chain_irq_work
+dma_resv_init
+dma_resv_list_alloc
+dma_resv_list_free.part.0
+dma_resv_reserve_shared
+dma_resv_copy_fences
+dma_resv_fini
+dma_resv_add_excl_fence
+dma_resv_wait_timeout_rcu
+dma_resv_add_shared_fence
+dma_resv_get_fences_rcu
+dma_resv_test_signaled_rcu
+seqno_fence_get_driver_name
+seqno_fence_get_timeline_name
+seqno_enable_signaling
+seqno_signaled
+seqno_wait
+seqno_release
+dma_heap_open
+dma_heap_devnode
+dma_heap_init
+dma_heap_ioctl
+dma_heap_get_drvdata
+dma_heap_add
+dma_heap_mmap
+dma_heap_dma_buf_vunmap
+dma_heap_dma_buf_vmap
+dma_heap_vm_fault
+dma_heap_dma_buf_end_cpu_access
+dma_heap_dma_buf_begin_cpu_access
+dma_heap_dma_buf_release
+dma_heap_unmap_dma_buf
+dma_heap_map_dma_buf
+dma_heap_detach
+dma_heap_attach
+init_heap_helper_buffer
+heap_helper_export_dmabuf
+system_heap_create
+system_heap_free
+system_heap_allocate
+sync_file_fdget
+fence_check_cb_func
+sync_file_poll
+sync_file_release
+sync_file_alloc
+sync_file_get_fence
+sync_file_create
+add_fence
+sync_file_get_name
+sync_file_ioctl
+timeline_fence_get_driver_name
+timeline_fence_enable_signaling
+timeline_fence_get_timeline_name
+__traceiter_sync_timeline
+timeline_fence_timeline_value_str
+timeline_fence_value_str
+timeline_fence_signaled
+sw_sync_debugfs_open
+timeline_fence_release
+sync_timeline_signal
+sw_sync_ioctl
+sw_sync_debugfs_release
+sync_info_debugfs_open
+sync_print_fence
+sync_print_sync_file
+sync_info_debugfs_show
+sync_timeline_debug_add
+sync_timeline_debug_remove
+sync_file_debug_add
+sync_file_debug_remove
+mmap_udmabuf
+udmabuf_vm_fault
+end_cpu_udmabuf
+get_sg_table
+begin_cpu_udmabuf
+map_udmabuf
+udmabuf_create
+udmabuf_ioctl
+unmap_udmabuf
+release_udmabuf
+__traceiter_scsi_dispatch_cmd_start
+__traceiter_scsi_dispatch_cmd_error
+__traceiter_scsi_dispatch_cmd_done
+__traceiter_scsi_dispatch_cmd_timeout
+__traceiter_scsi_eh_wakeup
+__scsi_device_lookup_by_target
+__scsi_device_lookup
+scsi_change_queue_depth
+scsi_vpd_inquiry
+scsi_get_vpd_page
+scsi_get_vpd_buf
+scsi_update_vpd_page
+scsi_report_opcode
+scsi_device_get
+scsi_device_lookup
+scsi_device_put
+__scsi_iterate_devices
+starget_for_each_device
+__starget_for_each_device
+scsi_device_lookup_by_target
+scsi_track_queue_full
+scsi_log_send
+scsi_log_completion
+scsi_finish_command
+scsi_attach_vpd
+scsi_host_cls_release
+scsi_host_put
+scsi_host_busy
+scsi_host_complete_all_commands
+scsi_host_busy_iter
+__scsi_host_match
+scsi_is_host_device
+__scsi_host_busy_iter_fn
+scsi_host_get
+scsi_host_lookup
+scsi_host_check_in_flight
+scsi_host_alloc
+scsi_host_dev_release
+complete_all_cmds_iter
+scsi_flush_work
+scsi_queue_work
+scsi_host_set_state
+scsi_remove_host
+scsi_add_host_with_dma
+scsi_init_hosts
+scsi_exit_hosts
+scsi_ioctl_block_when_processing_errors
+ioctl_internal_command.constprop.0
+scsi_set_medium_removal.part.0
+scsi_set_medium_removal
+scsi_ioctl_common
+scsi_ioctl
+scsi_compat_ioctl
+scsi_bios_ptable
+scsi_partsize
+scsicam_bios_param
+__scsi_report_device_reset
+scsi_reset_provider_done_command
+scsi_eh_finish_cmd
+scsi_eh_restore_cmnd
+scsi_eh_action
+scsi_report_bus_reset
+scsi_report_device_reset
+scsi_eh_done
+scsi_eh_prep_cmnd
+scsi_try_bus_reset
+scsi_try_host_reset
+scsi_handle_queue_ramp_up
+scsi_handle_queue_full
+scsi_try_target_reset
+eh_lock_door_done
+scsi_command_normalize_sense
+scsi_check_sense
+scsi_send_eh_cmnd
+scsi_eh_try_stu
+scsi_eh_tur
+scsi_eh_test_devices
+scsi_eh_ready_devs
+scsi_get_sense_info_fld
+scsi_block_when_processing_errors
+scsi_eh_wakeup
+scsi_schedule_eh
+scsi_eh_inc_host_failed
+scsi_eh_scmd_add
+scsi_times_out
+scsi_noretry_cmd
+scmd_eh_abort_handler
+scsi_eh_flush_done_q
+scsi_decide_disposition
+scsi_eh_get_sense
+scsi_error_handler
+scsi_ioctl_reset
+scsi_block_requests
+sdev_disable_disk_events
+scsi_kunmap_atomic_sg
+sdev_enable_disk_events
+scsi_set_blocked
+scsi_uninit_cmd
+scsi_mq_put_budget
+scsi_commit_rqs
+scsi_cmd_runtime_exceeced
+__scsi_execute
+scsi_mode_sense
+scsi_test_unit_ready
+scsi_run_queue
+scsi_free_sgtables
+scsi_mq_requeue_cmd
+scsi_cleanup_rq
+scsi_alloc_sgtables
+scsi_initialize_rq
+__scsi_init_queue
+scsi_map_queues
+scsi_mq_exit_request
+scsi_mq_init_request
+scsi_timeout
+scsi_mq_done
+scsi_device_set_state
+sdev_evt_send
+scsi_device_quiesce
+device_quiesce_fn
+scsi_device_resume
+device_resume_fn
+scsi_target_quiesce
+scsi_target_resume
+scsi_internal_device_block_nowait
+scsi_host_block
+scsi_internal_device_unblock_nowait
+device_unblock
+scsi_target_unblock
+scsi_kmap_atomic_sg
+scsi_vpd_lun_id
+scsi_vpd_tpg_id
+device_block
+scsi_result_to_blk_status
+scsi_run_queue_async
+scsi_mq_get_budget
+target_block
+target_unblock
+sdev_evt_send_simple
+scsi_end_request
+scsi_dec_host_busy
+scsi_mq_lld_busy
+scsi_host_unblock
+scsi_target_block
+sdev_evt_alloc
+scsi_mode_select
+scsi_init_sense_cache
+scsi_device_unbusy
+__scsi_queue_insert
+scsi_queue_insert
+scsi_softirq_done
+scsi_requeue_run_queue
+scsi_run_host_queues
+scsi_unblock_requests
+scsi_io_completion
+scsi_init_command
+scsi_queue_rq
+scsi_mq_alloc_queue
+scsi_mq_setup_tags
+scsi_mq_destroy_tags
+scsi_device_from_queue
+scsi_exit_queue
+scsi_evt_thread
+scsi_start_queue
+scsi_sense_key_string
+scsi_hostbyte_string
+scsi_driverbyte_string
+scsi_mlreturn_string
+scsi_extd_sense_format
+scsi_opcode_sa_name
+scsi_dma_map
+scsi_dma_unmap
+scsi_is_target_device
+scsi_sanitize_inquiry_string
+scsi_inq_str
+scsi_target_dev_release
+scsi_target_destroy
+scsi_rescan_device
+scsi_free_host_dev
+scsi_alloc_target
+scsi_alloc_sdev
+scsi_probe_and_add_lun
+scsi_complete_async_scans
+scsi_target_reap
+__scsi_add_device
+scsi_add_device
+__scsi_scan_target
+scsi_scan_target
+scsi_scan_channel
+scsi_get_host_dev
+scsi_scan_host_selected
+do_scsi_scan_host
+scsi_scan_host
+do_scan_async
+scsi_forget_host
+show_unchecked_isa_dma
+show_queue_type_field
+show_iostat_counterbits
+show_shost_mode
+show_use_blk_mq
+show_iostat_ioerr_cnt
+show_iostat_iodone_cnt
+show_iostat_iorequest_cnt
+sdev_show_device_busy
+sdev_show_device_blocked
+scsi_sdev_attr_is_visible
+scsi_is_sdev_device
+show_nr_hw_queues
+show_prot_guard_type
+show_prot_capabilities
+show_proc_name
+show_sg_prot_tablesize
+show_sg_tablesize
+show_can_queue
+show_cmd_per_lun
+show_unique_id
+sdev_show_queue_depth
+sdev_show_modalias
+sdev_show_eh_timeout
+sdev_show_timeout
+sdev_show_rev
+sdev_show_model
+sdev_show_vendor
+sdev_show_scsi_level
+sdev_show_type
+store_shost_eh_deadline
+show_shost_supported_mode
+sdev_show_access_state
+store_host_reset
+sdev_show_evt_lun_change_reported
+sdev_show_evt_mode_parameter_change_reported
+sdev_show_evt_soft_threshold_reached
+sdev_show_evt_capacity_change_reported
+sdev_show_evt_inquiry_change_reported
+sdev_show_evt_media_change
+show_state_field
+show_shost_state
+store_shost_state
+show_host_busy
+scsi_device_dev_release
+scsi_device_dev_release_usercontext
+scsi_device_cls_release
+show_inquiry
+show_vpd_pg89
+show_vpd_pg80
+show_vpd_pg83
+show_vpd_pg0
+sdev_store_evt_lun_change_reported
+sdev_store_evt_mode_parameter_change_reported
+sdev_store_evt_soft_threshold_reached
+sdev_store_evt_capacity_change_reported
+sdev_store_evt_inquiry_change_reported
+sdev_store_evt_media_change
+sdev_store_queue_depth
+sdev_store_queue_ramp_up_period
+sdev_show_queue_ramp_up_period
+sdev_store_dh_state
+store_queue_type_field
+sdev_show_blacklist
+sdev_show_wwid
+sdev_store_eh_timeout
+sdev_store_timeout
+store_state_field
+store_rescan_field
+scsi_register_driver
+scsi_register_interface
+show_shost_active_mode
+scsi_bus_match
+scsi_sdev_bin_attr_is_visible
+sdev_show_dh_state
+show_shost_eh_deadline
+sdev_show_preferred_path
+check_set
+store_scan
+scsi_bus_uevent
+scsi_device_state_name
+scsi_host_state_name
+scsi_sysfs_register
+scsi_sysfs_unregister
+scsi_sysfs_add_sdev
+__scsi_remove_device
+scsi_remove_device
+sdev_store_delete
+scsi_remove_target
+scsi_sysfs_add_host
+scsi_sysfs_device_initialize
+proc_scsi_devinfo_open
+devinfo_seq_show
+devinfo_seq_next
+devinfo_seq_stop
+scsi_dev_info_remove_list
+scsi_dev_info_add_list
+devinfo_seq_start
+scsi_strcpy_devinfo
+scsi_dev_info_list_add_keyed
+scsi_dev_info_list_add_str
+proc_scsi_devinfo_write
+scsi_dev_info_list_find
+scsi_dev_info_list_del_keyed
+scsi_get_device_flags_keyed
+scsi_get_device_flags
+scsi_exit_devinfo
+scsi_nl_rcv_msg
+scsi_netlink_init
+scsi_netlink_exit
+scsi_exit_sysctl
+proc_scsi_show
+proc_scsi_host_write
+proc_scsi_host_open
+proc_scsi_write
+proc_scsi_open
+scsi_seq_show
+scsi_seq_stop
+scsi_seq_next
+scsi_seq_start
+scsi_proc_hostdir_add
+scsi_proc_hostdir_rm
+scsi_proc_host_add
+scsi_proc_host_rm
+scsi_exit_procfs
+scsi_show_rq
+scsi_trace_parse_cdb
+sdev_prefix_printk
+scsi_format_opcode_name
+__scsi_format_command
+sdev_format_header.constprop.0
+scsi_print_result
+scsi_log_print_sense_hdr
+scsi_print_sense_hdr
+scsi_print_command
+scmd_printk
+scsi_log_print_sense
+__scsi_print_sense
+scsi_print_sense
+scsi_autopm_get_device
+scsi_autopm_put_device
+scsi_bus_prepare
+do_scsi_suspend
+do_scsi_freeze
+do_scsi_poweroff
+do_scsi_resume
+do_scsi_thaw
+do_scsi_restore
+scsi_runtime_resume
+scsi_runtime_suspend
+scsi_bus_resume_common
+scsi_bus_restore
+scsi_bus_thaw
+scsi_bus_resume
+scsi_runtime_idle
+scsi_dev_type_resume
+async_sdev_restore
+async_sdev_thaw
+async_sdev_resume
+scsi_bus_suspend_common
+scsi_bus_poweroff
+scsi_bus_freeze
+scsi_bus_suspend
+scsi_autopm_get_target
+scsi_autopm_put_target
+scsi_autopm_get_host
+scsi_autopm_put_host
+scsi_dh_handler_attach
+scsi_dh_set_params
+scsi_dh_attached_handler_name
+scsi_dh_activate
+__scsi_dh_lookup
+scsi_register_device_handler
+scsi_unregister_device_handler
+scsi_dh_attach
+scsi_dh_add_device
+scsi_dh_release_device
+scsi_sense_desc_find
+scsilun_to_int
+int_to_scsilun
+scsi_device_type
+scsi_normalize_sense
+scsi_build_sense_buffer
+scsi_set_sense_information
+scsi_set_sense_field_pointer
+sd_default_probe
+thin_provisioning_show
+app_tag_own_show
+FUA_show
+cache_type_show
+max_medium_access_timeouts_store
+sd_eh_reset
+sd_unlock_native_capacity
+scsi_disk_release
+max_retries_store
+max_retries_show
+max_medium_access_timeouts_show
+max_write_same_blocks_show
+zeroing_mode_show
+provisioning_mode_show
+protection_type_show
+manage_start_stop_show
+allow_restart_show
+protection_type_store
+sd_config_write_same
+max_write_same_blocks_store
+zeroing_mode_store
+sd_config_discard
+sd_set_flush_flag
+sd_sec_submit
+sd_eh_action
+sd_uninit_command
+sd_pr_command
+sd_pr_clear
+sd_pr_preempt
+sd_pr_release
+sd_pr_reserve
+sd_pr_register
+read_capacity_error
+scsi_disk_get
+scsi_disk_put
+sd_ioctl_common
+sd_compat_ioctl
+sd_ioctl
+sd_release
+manage_start_stop_store
+allow_restart_store
+sd_major
+media_not_present
+sd_check_events
+zoned_cap_show
+provisioning_mode_store
+protection_mode_show
+sd_getgeo
+sd_setup_write_same16_cmnd
+sd_setup_write_same10_cmnd
+sd_completed_bytes
+sd_done
+sd_init_command
+sd_print_sense_hdr
+sd_print_result
+read_capacity_10
+read_capacity_16.part.0
+sd_revalidate_disk
+cache_type_store
+sd_rescan
+sd_probe
+sd_open
+sd_sync_cache
+sd_start_stop_device
+sd_suspend_common
+sd_suspend_runtime
+sd_suspend_system
+sd_resume
+sd_shutdown
+sd_remove
+sd_dif_config_host
+sd_zbc_update_wp_offset_cb
+sd_zbc_revalidate_zones_cb
+sd_zbc_do_report_zones
+sd_zbc_parse_report
+sd_zbc_update_wp_offset_workfn
+sd_zbc_cmnd_checks
+sd_zbc_report_zones
+sd_zbc_prepare_zone_append
+sd_zbc_setup_zone_mgmt_cmnd
+sd_zbc_complete
+sd_zbc_release_disk
+sd_zbc_revalidate_zones
+sd_zbc_read_zones
+sr_runtime_suspend
+sr_done
+sr_release
+sr_init_command
+sr_packet
+sr_check_events
+sr_open
+sr_block_compat_ioctl
+sr_block_ioctl
+sr_revalidate_disk
+sr_kref_release
+scsi_cd_put
+sr_block_release
+sr_block_open
+sr_remove
+sr_block_check_events
+sr_probe
+sr_do_ioctl
+sr_read_tochdr
+sr_read_tocentry
+sr_fake_playtrkind
+sr_read_cd.constprop.0
+sr_tray_move
+sr_lock_door
+sr_drive_status
+sr_disk_status
+sr_get_last_session
+sr_get_mcn
+sr_reset
+sr_select_speed
+sr_audio_ioctl
+sr_is_xa
+sr_vendor_init
+sr_set_blocklength
+sr_cd_check
+sg_get_rq_mark
+sg_idr_max_id
+dev_seq_next
+sg_poll
+sg_device_destroy
+dev_seq_stop
+sg_fasync
+sg_remove_scat
+sg_finish_rem_req
+sg_remove_sfp
+sg_mmap
+sg_vma_fault
+sg_add_request
+sg_proc_seq_show_version
+sg_proc_seq_show_int
+sg_proc_seq_show_devstrs
+sg_proc_seq_show_dev
+sg_proc_seq_show_devhdr
+dev_seq_start
+sg_proc_write_dressz
+sg_proc_write_adio
+sg_proc_single_open_dressz
+sg_proc_single_open_adio
+sg_proc_seq_show_debug
+sg_remove_request
+sg_new_read
+sg_check_file_access
+sg_rq_end_io
+sg_rq_end_io_usercontext
+sg_release
+sg_remove_sfp_usercontext
+sg_remove_device
+sg_add_device
+sg_read
+sg_build_indirect
+sg_build_reserve
+sg_open
+sg_common_write.isra.0
+sg_new_write.isra.0
+sg_ioctl_common
+sg_compat_ioctl
+sg_ioctl
+sg_write.part.0
+sg_write
+atapi_cmd_type
+ata_pack_xfermask
+ata_mode_string
+ata_dev_classify
+ata_cable_40wire
+ata_cable_80wire
+ata_cable_unknown
+ata_cable_ignore
+ata_cable_sata
+ata_noop_qc_prep
+ata_dummy_qc_issue
+ata_dummy_error_handler
+__traceiter_ata_qc_issue
+__traceiter_ata_qc_complete_internal
+__traceiter_ata_qc_complete_failed
+__traceiter_ata_qc_complete_done
+__traceiter_ata_eh_link_autopsy
+__traceiter_ata_eh_link_autopsy_qc
+ata_rwcmd_protocol
+ata_xfer_mask2mode
+ata_xfer_mode2shift
+ata_dev_pair
+ata_std_qc_defer
+ata_qc_get_active
+ata_host_suspend
+ata_host_resume
+ata_pci_shutdown_one
+ata_host_stop
+ata_link_next
+ata_dev_next
+ata_port_runtime_idle
+ata_xfer_mode2mask
+ata_qc_complete_internal
+ata_port_request_pm
+ata_sas_port_suspend
+ata_sas_port_resume
+ata_port_runtime_resume
+ata_port_runtime_suspend
+ata_port_pm_poweroff
+ata_port_pm_freeze
+ata_port_pm_suspend
+ata_port_pm_resume
+ata_host_init
+ata_host_release
+ata_host_detach
+ata_pci_remove_one
+ata_platform_remove_one
+pci_test_config_bits
+ata_pci_device_do_suspend
+ata_pci_device_suspend
+ata_pci_device_do_resume
+ata_pci_device_resume
+ata_ratelimit
+ata_msleep
+ata_wait_register
+ata_port_printk
+ata_link_printk
+ata_dev_printk
+sata_std_hardreset
+ata_id_string
+ata_id_c_string
+ata_dev_blacklisted
+ata_dev_same_device
+ata_devres_release
+ata_finalize_port_ops
+ata_host_start
+ata_id_xfermask
+ata_pio_need_iordy
+ata_host_put
+ata_id_n_sectors
+ata_dev_phys_link
+ata_force_cbl
+ata_tf_read_block
+ata_build_rw_tf
+ata_unpack_xfermask
+sata_spd_string
+ata_tf_to_lba48
+ata_tf_to_lba
+sata_down_spd_limit
+ata_timing_cycle2mode
+ata_down_xfermask_limit
+atapi_check_dma
+ata_sg_init
+swap_buf_le16
+ata_qc_new_init
+ata_qc_free
+__ata_qc_complete
+ata_qc_complete
+ata_qc_issue
+ata_exec_internal_sg
+ata_exec_internal
+ata_do_dev_read_id
+ata_read_log_page.part.0
+ata_read_log_page
+ata_log_supported
+ata_identify_page_supported
+ata_read_native_max_address
+ata_set_max_sectors
+ata_dev_set_feature
+ata_dev_read_id
+ata_dev_reread_id
+ata_dev_configure
+ata_bus_probe
+ata_dev_revalidate
+ata_do_set_mode
+ata_phys_link_online
+ata_std_postreset
+ata_link_online
+ata_phys_link_offline
+ata_std_prereset
+ata_link_offline
+ata_wait_ready
+ata_wait_after_reset
+ata_dev_init
+ata_link_init
+sata_link_init_spd
+ata_host_register
+ata_host_activate
+ata_port_alloc
+ata_host_alloc
+ata_host_alloc_pinfo
+ata_host_get
+__ata_port_probe
+ata_port_probe
+async_port_probe
+ata_scsi_flush_xlat
+scsi_16_lba_len
+ata_scsiop_inq_b2
+ata_scsiop_report_luns
+ata_scsiop_inq_b1
+ata_std_bios_param
+ata_check_nblocks
+ata_scsiop_inq_80
+ata_scsi_dma_need_drain
+ata_scsiop_maint_in
+ata_to_sense_error
+ata_gen_passthru_sense
+atapi_qc_complete
+atapi_sense_complete
+ata_scsi_qc_complete
+ata_scsiop_inq_00
+ata_scsiop_inq_89
+ata_scsiop_inq_83
+atapi_xlat
+ata_scsi_set_invalid_field
+ata_scsi_start_stop_xlat
+ata_scsi_zbc_out_xlat
+ata_scsi_zbc_in_xlat
+ata_scsi_verify_xlat
+ata_scsi_write_same_xlat
+ata_scsiop_inq_b6
+ata_scsi_security_inout_xlat
+ata_scsi_pass_thru
+ata_scsi_var_len_cdb_xlat
+ata_scsiop_inq_b0
+ata_scsi_report_zones_complete
+ata_scsi_rw_xlat
+ata_scsiop_inq_std
+ata_scsi_handle_link_detach
+modecpy
+ata_scsiop_read_cap
+ata_msense_caching
+ata_msense_control
+ata_scsi_mode_select_xlat
+ata_scsiop_mode_sense
+ata_find_dev
+__ata_scsi_find_dev
+ata_scsi_slave_destroy
+ata_scsi_rbuf_fill
+ata_scsi_set_sense
+ata_scsi_set_sense_information
+ata_cmd_ioctl
+ata_task_ioctl
+ata_scsi_sdev_config
+ata_scsi_dev_config
+ata_scsi_slave_config
+ata_scsi_find_dev
+ata_scsi_park_store
+ata_scsi_park_show
+ata_scsi_unlock_native_capacity
+ata_sas_scsi_ioctl
+ata_scsi_ioctl
+ata_scsi_dump_cdb
+ata_scsi_simulate
+__ata_scsi_queuecmd
+ata_scsi_queuecmd
+ata_scsi_add_hosts
+ata_scsi_scan_host
+ata_scsi_offline_dev
+ata_scsi_media_change_notify
+ata_scsi_hotplug
+ata_scsi_user_scan
+ata_scsi_dev_rescan
+ata_eh_scsidone
+ata_get_cmd_descript
+ata_ehi_clear_desc
+ata_std_end_eh
+ata_port_schedule_eh
+ata_eh_categorize_error
+__ata_ehi_push_desc
+ata_ehi_push_desc
+ata_port_desc
+ata_port_pbar_desc
+__ata_port_freeze
+ata_scsi_cmd_error_handler
+ata_eh_clear_action
+ata_do_reset
+ata_port_wait_eh
+ata_do_link_abort
+ata_link_abort
+ata_port_abort
+ata_port_freeze
+__ata_eh_qc_complete
+ata_eh_freeze_port.part.0
+ata_eh_freeze_port
+ata_eh_set_pending.part.0
+ata_std_sched_eh
+ata_ering_clear
+ata_dev_disable
+ata_eh_park_issue_cmd
+ata_internal_cmd_timeout
+ata_internal_cmd_timed_out
+ata_ering_map
+ata_eh_acquire
+ata_eh_release
+ata_eh_fastdrain_timerfn
+ata_qc_schedule_eh
+ata_eh_thaw_port
+ata_eh_qc_complete
+ata_eh_qc_retry
+ata_eh_detach_dev
+ata_eh_schedule_probe
+ata_eh_about_to_do
+ata_eh_done
+atapi_eh_tur
+atapi_eh_request_sense
+ata_eh_link_autopsy
+ata_eh_autopsy
+ata_eh_report
+ata_eh_reset
+ata_set_mode
+ata_link_nr_enabled
+ata_eh_recover
+ata_eh_finish
+ata_scsi_port_error_handler
+ata_scsi_error
+ata_do_eh
+ata_std_error_handler
+ata_tlink_release
+ata_tdev_delete
+get_ata_xfer_names
+ata_tport_match
+ata_tlink_match
+ata_tdev_match
+ata_tport_release
+show_ata_dev_gscr
+show_ata_dev_id
+show_ata_dev_spdn_cnt
+show_ata_port_port_no
+show_ata_port_idle_irq
+show_ata_port_nr_pmp_links
+show_ata_dev_trim
+show_ata_dev_ering
+show_ata_dev_xfer_mode
+show_ata_dev_dma_mode
+show_ata_dev_pio_mode
+show_ata_dev_class
+show_ata_link_sata_spd
+show_ata_link_sata_spd_limit
+show_ata_link_hw_sata_spd_limit
+ata_show_ering
+ata_tdev_release
+ata_tlink_delete
+ata_tport_delete
+ata_tlink_add
+ata_tport_add
+ata_attach_transport
+ata_release_transport
+libata_trace_parse_status
+libata_trace_parse_eh_action
+libata_trace_parse_eh_err_mask
+libata_trace_parse_qc_flags
+libata_trace_parse_subcmd
+ata_sas_port_stop
+sata_scr_valid
+ata_tf_to_fis
+ata_tf_from_fis
+sata_lpm_ignore_phy_events
+ata_scsi_em_message_store
+ata_scsi_em_message_show
+ata_sas_port_start
+sata_scr_read
+sata_scr_write
+sata_scr_write_flush
+sata_link_debounce
+sata_link_resume
+sata_link_scr_lpm
+__sata_set_spd_needed
+sata_set_spd
+sata_link_hardreset
+ata_qc_complete_multiple
+ata_scsi_lpm_store
+ata_scsi_lpm_show
+ata_scsi_em_message_type_show
+ata_scsi_activity_show
+ata_scsi_activity_store
+__ata_change_queue_depth
+ata_scsi_change_queue_depth
+ata_sas_port_alloc
+ata_sas_async_probe
+ata_sas_sync_probe
+ata_sas_tport_add
+ata_sas_tport_delete
+ata_sas_port_destroy
+ata_sas_slave_configure
+ata_eh_analyze_ncq_error
+ata_sas_port_init
+ata_sas_queuecmd
+sata_async_notification
+ata_slave_link_init
+ata_ncq_prio_enable_show
+ata_ncq_prio_enable_store
+ata_sas_allocate_tag
+ata_sas_free_tag
+ata_sff_wait_ready
+ata_sff_check_ready
+ata_sff_qc_fill_rtf
+ata_sff_std_ports
+ata_bmdma_post_internal_cmd
+ata_pci_bmdma_clear_simplex
+ata_sff_check_status
+ata_bmdma_status
+ata_sff_wait_after_reset
+ata_sff_set_devctl
+ata_sff_freeze
+ata_devchk
+ata_bmdma_irq_clear
+ata_bmdma_start
+ata_sff_tf_read
+ata_sff_data_xfer
+ata_sff_data_xfer32
+ata_pio_sector
+ata_bmdma_qc_prep
+ata_bmdma_dumb_qc_prep
+ata_sff_queue_work
+ata_sff_queue_delayed_work
+ata_sff_queue_pio_task
+ata_sff_prereset
+ata_sff_dev_classify
+ata_sff_softreset
+ata_sff_postreset
+ata_sff_error_handler
+ata_pci_sff_init_host
+ata_bmdma_nodma
+ata_pci_sff_prepare_host
+ata_pci_sff_activate_host
+ata_bmdma_error_handler
+ata_bmdma_setup
+ata_sff_sync
+ata_sff_pause
+ata_sff_dev_select
+ata_sff_exec_command
+ata_pio_sectors
+ata_sff_altstatus
+ata_sff_dma_pause
+ata_bmdma_stop
+ata_sff_drain_fifo
+ata_bmdma_port_start.part.0
+ata_bmdma_port_start
+ata_bmdma_port_start32
+sata_sff_hardreset
+ata_pci_bmdma_init
+ata_pci_bmdma_prepare_host
+ata_pci_init_one
+ata_pci_sff_init_one
+ata_pci_bmdma_init_one
+ata_sff_busy_sleep
+ata_sff_irq_on
+ata_sff_thaw
+ata_hsm_qc_complete
+ata_dev_select.constprop.0
+ata_sff_qc_issue
+ata_bmdma_qc_issue
+ata_sff_tf_load
+ata_sff_hsm_move
+__ata_sff_port_intr
+ata_sff_port_intr
+ata_sff_interrupt
+ata_sff_lost_interrupt
+ata_bmdma_port_intr
+ata_bmdma_interrupt
+ata_sff_pio_task
+ata_sff_flush_pio_task
+ata_sff_port_init
+ata_sff_exit
+sata_pmp_read
+sata_pmp_read_gscr
+sata_pmp_handle_link_fail
+sata_pmp_detach
+sata_pmp_qc_defer_cmd_switch
+sata_pmp_write
+sata_pmp_configure
+sata_pmp_error_handler
+sata_pmp_scr_read
+sata_pmp_scr_write
+sata_pmp_set_lpm
+sata_pmp_attach
+ata_acpi_uevent
+ata_acpi_ap_uevent
+ata_acpi_dev_uevent
+ata_acpi_handle_hotplug
+ata_acpi_ap_notify_dock
+ata_acpi_dev_notify_dock
+ata_acpi_stm
+ata_acpi_gtm
+ata_acpi_gtm_xfermask
+ata_acpi_cbl_80wire
+ata_acpi_gtf_to_tf
+ata_acpi_run_tf
+ata_dev_acpi_handle.part.0
+ata_dev_get_GTF
+ata_dev_acpi_handle
+ata_acpi_bind_port
+ata_acpi_bind_dev
+ata_acpi_dissociate
+ata_acpi_on_suspend
+ata_acpi_on_resume
+ata_acpi_set_state
+ata_acpi_on_devcfg
+ata_acpi_on_disable
+zpodd_wake_dev
+zpodd_on_suspend
+zpodd_zpready
+zpodd_enable_run_wake
+zpodd_disable_run_wake
+zpodd_post_poweron
+zpodd_init
+zpodd_exit
+ata_timing_merge
+ata_timing_find_mode
+ata_timing_compute
+piix_sidpr_set_lpm
+piix_vmw_bmdma_status
+ich_pata_cable_detect
+piix_pci_device_resume
+piix_pci_device_suspend
+piix_remove_one
+piix_irq_check
+piix_port_start
+piix_sidpr_sel
+piix_sidpr_scr_write
+piix_sidpr_scr_read
+piix_set_timings
+do_pata_set_dmamode
+ich_set_dmamode
+piix_set_dmamode
+piix_set_piomode
+piix_pata_prereset
+piix_init_one
+sis_port_base
+sis_133_mode_filter
+sis_133_set_dmamode
+sis_set_fifo
+sis_133_set_piomode
+sis_100_set_piomode
+sis_old_set_piomode
+sis_66_cable_detect
+sis_100_set_dmamode
+sis_133_early_set_dmamode
+sis_133_cable_detect
+sis_old_set_dmamode
+sis_66_set_dmamode
+sis_fixup
+sis_reinit_one
+sis_pre_reset
+sis_init_one
+ata_generic_init_one
+generic_set_mode
+match_true
+__traceiter_spi_controller_idle
+__traceiter_spi_controller_busy
+__traceiter_spi_message_submit
+__traceiter_spi_message_start
+__traceiter_spi_message_done
+__traceiter_spi_transfer_start
+__traceiter_spi_transfer_stop
+spi_statistics_add_transfer_stats
+spi_drv_shutdown
+spi_dev_check
+spi_get_next_queued_message
+devm_spi_match_controller
+__spi_controller_match
+__spi_replace_transfers_release
+spi_delay_to_ns
+spi_get_device_id
+spi_uevent
+spi_match_device
+spi_statistics_transfers_split_maxsize_show
+spi_device_transfers_split_maxsize_show
+spi_controller_transfers_split_maxsize_show
+spi_statistics_transfer_bytes_histo16_show
+spi_device_transfer_bytes_histo16_show
+spi_controller_transfer_bytes_histo16_show
+spi_statistics_transfer_bytes_histo15_show
+spi_device_transfer_bytes_histo15_show
+spi_controller_transfer_bytes_histo15_show
+spi_statistics_transfer_bytes_histo14_show
+spi_device_transfer_bytes_histo14_show
+spi_controller_transfer_bytes_histo14_show
+spi_statistics_transfer_bytes_histo13_show
+spi_device_transfer_bytes_histo13_show
+spi_controller_transfer_bytes_histo13_show
+spi_statistics_transfer_bytes_histo12_show
+spi_device_transfer_bytes_histo12_show
+spi_controller_transfer_bytes_histo12_show
+spi_statistics_transfer_bytes_histo11_show
+spi_device_transfer_bytes_histo11_show
+spi_controller_transfer_bytes_histo11_show
+spi_statistics_transfer_bytes_histo10_show
+spi_device_transfer_bytes_histo10_show
+spi_controller_transfer_bytes_histo10_show
+spi_statistics_transfer_bytes_histo9_show
+spi_device_transfer_bytes_histo9_show
+spi_controller_transfer_bytes_histo9_show
+spi_statistics_transfer_bytes_histo8_show
+spi_device_transfer_bytes_histo8_show
+spi_controller_transfer_bytes_histo8_show
+spi_statistics_transfer_bytes_histo7_show
+spi_device_transfer_bytes_histo7_show
+spi_controller_transfer_bytes_histo7_show
+spi_statistics_transfer_bytes_histo6_show
+spi_device_transfer_bytes_histo6_show
+spi_controller_transfer_bytes_histo6_show
+spi_statistics_transfer_bytes_histo5_show
+spi_device_transfer_bytes_histo5_show
+spi_controller_transfer_bytes_histo5_show
+spi_statistics_transfer_bytes_histo4_show
+spi_device_transfer_bytes_histo4_show
+spi_controller_transfer_bytes_histo4_show
+spi_statistics_transfer_bytes_histo3_show
+spi_device_transfer_bytes_histo3_show
+spi_controller_transfer_bytes_histo3_show
+spi_statistics_transfer_bytes_histo2_show
+spi_device_transfer_bytes_histo2_show
+spi_controller_transfer_bytes_histo2_show
+spi_statistics_transfer_bytes_histo1_show
+spi_device_transfer_bytes_histo1_show
+spi_controller_transfer_bytes_histo1_show
+spi_statistics_transfer_bytes_histo0_show
+spi_device_transfer_bytes_histo0_show
+spi_controller_transfer_bytes_histo0_show
+spi_statistics_bytes_tx_show
+spi_device_bytes_tx_show
+spi_controller_bytes_tx_show
+spi_statistics_bytes_rx_show
+spi_device_bytes_rx_show
+spi_controller_bytes_rx_show
+spi_statistics_bytes_show
+spi_device_bytes_show
+spi_controller_bytes_show
+spi_statistics_spi_async_show
+spi_device_spi_async_show
+spi_controller_spi_async_show
+spi_statistics_spi_sync_immediate_show
+spi_device_spi_sync_immediate_show
+spi_controller_spi_sync_immediate_show
+spi_statistics_spi_sync_show
+spi_device_spi_sync_show
+spi_controller_spi_sync_show
+spi_statistics_timedout_show
+spi_device_timedout_show
+spi_controller_timedout_show
+spi_statistics_errors_show
+spi_device_errors_show
+spi_controller_errors_show
+spi_statistics_transfers_show
+spi_device_transfers_show
+spi_controller_transfers_show
+spi_statistics_messages_show
+spi_device_messages_show
+spi_controller_messages_show
+spi_controller_release
+spi_res_release
+spi_bus_lock
+driver_override_store
+spi_bus_unlock
+driver_override_show
+modalias_show
+__spi_register_driver
+spi_drv_remove
+spi_drv_probe
+spi_res_free
+spi_res_add
+spidev_release
+devm_spi_release_controller
+spi_acpi_controller_match
+spi_unregister_device
+__unregister
+spi_finalize_current_transfer
+spi_complete
+spi_start_queue
+__spi_validate_bits_per_word
+spi_set_cs_timing
+slave_show
+acpi_spi_add_resource
+spi_busnum_to_master
+spi_slave_abort
+spi_take_timestamp_pre
+spi_take_timestamp_post
+__spi_queued_transfer
+spi_queued_transfer
+spi_stop_queue
+spi_destroy_queue
+spi_unregister_controller
+devm_spi_unregister
+_spi_transfer_delay_ns.part.0
+spi_delay_exec
+spi_set_cs
+spi_controller_resume
+spi_idle_runtime_pm
+spi_controller_suspend
+spi_setup
+spi_add_device
+__spi_async
+spi_alloc_device
+spi_new_device
+spi_match_controller_to_boardinfo
+spi_register_controller
+devm_spi_register_controller
+slave_store
+acpi_register_spi_device
+acpi_spi_add_device
+acpi_spi_notify
+spi_res_alloc
+__spi_alloc_controller
+__devm_spi_alloc_controller
+spi_replace_transfers
+spi_split_transfers_maxsize
+__spi_validate
+spi_async_locked
+spi_async
+spi_register_board_info
+spi_map_buf
+spi_unmap_buf
+__spi_unmap_msg
+spi_finalize_current_message
+spi_transfer_one_message
+__spi_pump_messages
+spi_pump_messages
+__spi_sync
+spi_sync
+spi_write_then_read
+spi_sync_locked
+spi_flush_queue
+spi_mem_buswidth_is_valid
+spi_check_buswidth_req
+spi_mem_get_name
+spi_mem_remove
+spi_mem_shutdown
+spi_controller_dma_map_mem_op_data
+spi_mem_check_op
+spi_mem_dirmap_destroy
+devm_spi_mem_dirmap_release
+devm_spi_mem_dirmap_match
+devm_spi_mem_dirmap_destroy
+spi_mem_driver_register_with_owner
+spi_mem_probe
+spi_mem_driver_unregister
+spi_mem_access_start
+spi_mem_access_end
+spi_mem_default_supports_op
+spi_mem_internal_supports_op
+spi_mem_supports_op
+spi_mem_exec_op
+spi_controller_dma_unmap_mem_op_data
+spi_mem_dirmap_create
+devm_spi_mem_dirmap_create
+spi_mem_adjust_op_size
+spi_mem_no_dirmap_read
+spi_mem_dirmap_write
+spi_mem_dirmap_read
+always_on
+loopback_setup
+blackhole_netdev_setup
+loopback_dev_free
+loopback_xmit
+loopback_dev_init
+blackhole_netdev_xmit
+loopback_net_init
+dev_lstats_read
+loopback_get_stats64
+mdiobus_setup_mdiodev_from_board_info
+mdiobus_register_board_info
+mdiobus_devres_match
+devm_mdiobus_free
+devm_mdiobus_alloc_size
+__devm_mdiobus_register
+devm_mdiobus_unregister
+phy_ethtool_set_wol
+phy_ethtool_get_wol
+phy_restart_aneg
+phy_ethtool_nway_reset
+phy_queue_state_machine
+phy_mac_interrupt
+phy_start_machine
+phy_ethtool_get_strings
+phy_ethtool_get_sset_count
+phy_ethtool_get_stats
+phy_error
+phy_interrupt
+phy_abort_cable_test
+phy_start
+phy_get_eee_err
+phy_ethtool_set_eee
+phy_print_status
+phy_aneg_done
+phy_config_aneg
+mmd_eee_adv_to_linkmode
+phy_check_link_status
+phy_start_aneg
+phy_mii_ioctl
+phy_do_ioctl
+phy_do_ioctl_running
+phy_ethtool_ksettings_get
+phy_ethtool_get_link_ksettings
+phy_speed_up
+phy_ethtool_ksettings_set
+phy_ethtool_set_link_ksettings
+phy_speed_down
+phy_ethtool_get_eee
+phy_init_eee
+phy_start_cable_test
+phy_start_cable_test_tdr
+phy_supported_speeds
+phy_stop_machine
+phy_disable_interrupts
+phy_free_interrupt
+phy_request_interrupt
+phy_state_machine
+phy_stop
+gen10g_config_aneg
+genphy_c45_aneg_done
+genphy_c45_an_disable_aneg
+genphy_c45_restart_aneg
+genphy_c45_read_lpa
+genphy_c45_pma_read_abilities
+genphy_c45_read_link
+genphy_c45_an_config_aneg
+genphy_c45_pma_setup_forced
+genphy_c45_check_and_restart_aneg
+genphy_c45_read_mdix
+genphy_c45_config_aneg
+genphy_c45_read_pma
+genphy_c45_read_status
+phy_speed_to_str
+mmd_phy_indirect
+phy_set_max_speed
+phy_lookup_setting
+phy_check_downshift
+phy_modify_changed
+__phy_modify
+phy_modify
+__phy_read_page
+phy_save_page
+__phy_write_page
+phy_select_page
+phy_restore_page
+phy_read_paged
+phy_write_paged
+phy_modify_paged_changed
+phy_modify_paged
+phy_duplex_to_str
+phy_resolve_aneg_linkmode
+__phy_read_mmd
+phy_read_mmd
+__phy_write_mmd
+__phy_modify_mmd_changed
+__phy_modify_mmd
+phy_modify_mmd_changed
+phy_modify_mmd
+phy_write_mmd
+phy_resolve_aneg_pause
+phy_speeds
+of_set_phy_supported
+of_set_phy_eee_broken
+phy_speed_down_core
+genphy_read_mmd_unsupported
+genphy_write_mmd_unsupported
+phy_device_free
+phy_mdio_device_free
+phy_support_sym_pause
+phy_support_asym_pause
+phy_bus_match
+phy_sfp_attach
+phy_sfp_detach
+phy_loopback
+phy_scan_fixups
+phy_unregister_fixup
+phy_unregister_fixup_for_uid
+phy_unregister_fixup_for_id
+phy_device_release
+phy_has_fixups_show
+phy_interface_show
+phy_id_show
+phy_standalone_show
+phy_request_driver_module
+get_phy_c45_devs_in_pkg
+genphy_aneg_done
+genphy_update_link
+genphy_read_status_fixed
+genphy_read_abilities
+phy_device_register
+phy_init_hw
+mdio_bus_phy_restore
+phy_device_remove
+phy_mdio_device_remove
+phy_find_first
+phy_attached_info_irq
+phy_attached_print
+phy_attached_info
+phy_sfp_probe
+phy_driver_is_genphy
+phy_driver_is_genphy_10g
+phy_link_change
+phy_package_leave
+devm_phy_package_leave
+phy_suspend
+phy_detach
+phy_disconnect
+__phy_resume
+phy_resume
+mdio_bus_phy_resume
+genphy_config_eee_advert
+genphy_setup_forced
+genphy_restart_aneg
+genphy_suspend
+genphy_resume
+genphy_loopback
+genphy_c37_read_status
+phy_get_pause
+phy_driver_register
+phy_remove
+phy_driver_unregister
+phy_drivers_register
+phy_drivers_unregister
+phy_attach_direct
+phy_validate_pause
+phy_get_internal_delay
+phy_reset_after_clk_enable
+mdio_bus_phy_suspend
+genphy_check_and_restart_aneg
+__genphy_config_aneg
+genphy_c37_config_aneg
+genphy_soft_reset
+phy_connect_direct
+phy_connect
+phy_attach
+genphy_read_lpa
+genphy_read_status
+phy_register_fixup
+phy_register_fixup_for_uid
+phy_register_fixup_for_id
+phy_package_join
+devm_phy_package_join
+phy_device_create
+get_phy_device
+phy_set_sym_pause
+phy_set_asym_pause
+phy_advertise_supported
+phy_remove_link_mode
+phy_probe
+linkmode_set_pause
+linkmode_resolve_pause
+mdio_uevent
+__traceiter_mdio_access
+mdiobus_get_phy
+mdiobus_is_registered_device
+mdio_bus_match
+mdiobus_register_device
+mdiobus_unregister_device
+mdio_find_bus
+mdiobus_create_device
+mdiobus_scan
+mdio_bus_exit
+mdiobus_release
+__mdiobus_read
+mdiobus_read
+mdiobus_read_nested
+mdiobus_unregister
+mdiobus_free
+mdiobus_alloc_size
+mdio_bus_device_stat_field_show
+mdio_bus_stat_field_show
+__mdiobus_write
+__mdiobus_modify_changed
+mdiobus_modify
+mdiobus_write
+mdiobus_write_nested
+__mdiobus_register
+mdio_device_free
+mdio_device_release
+mdio_device_remove
+mdio_driver_unregister
+mdio_device_reset
+mdio_remove
+mdio_probe
+mdio_driver_register
+mdio_device_register
+mdio_device_create
+mdio_device_bus_match
+swphy_read_reg
+swphy_validate_state
+phy_led_trigger_no_link
+phy_led_trigger_change_speed
+phy_led_triggers_register
+phy_led_triggers_unregister
+unregister_mii_tstamp_controller
+register_mii_timestamper
+unregister_mii_timestamper
+register_mii_tstamp_controller
+sfp_quirk_2500basex
+sfp_get_module_info
+sfp_get_module_eeprom
+sfp_parse_port
+sfp_parse_support
+sfp_add_phy
+sfp_remove_phy
+sfp_link_up
+sfp_link_down
+sfp_module_remove
+sfp_module_start
+sfp_module_stop
+sfp_register_bus
+sfp_unregister_bus
+sfp_upstream_start
+sfp_upstream_stop
+sfp_bus_put.part.0
+sfp_bus_put
+sfp_unregister_socket
+sfp_match
+sfp_module_insert
+sfp_may_have_phy
+sfp_select_interface
+sfp_bus_del_upstream
+sfp_bus_get
+sfp_bus_find_fwnode
+sfp_register_socket
+sfp_bus_add_upstream
+bcm84881_aneg_done
+bcm84881_config_init
+bcm84881_probe
+bcm84881_get_features
+bcm84881_config_aneg
+bcm84881_read_status
+fixed_mdio_write
+fixed_phy_change_carrier
+fixed_phy_set_link_update
+fixed_phy_del
+fixed_phy_unregister
+fixed_phy_update
+fixed_mdio_read
+fixed_phy_add_gpiod.part.0
+__fixed_phy_register.part.0
+fixed_phy_register
+fixed_phy_register_with_gpiod
+fixed_phy_add
+tun_net_mclist
+tun_get_size
+tun_ptr_free
+tun_net_open
+tun_net_fix_features
+tun_set_headroom
+tun_validate
+tun_get_msglevel
+tun_set_msglevel
+tun_get_coalesce
+tun_set_coalesce
+tun_get_socket
+tun_get_tx_ring
+tun_get
+tun_get_link_ksettings
+tun_set_link_ksettings
+tun_get_iff
+tun_chr_show_fdinfo
+tun_get_drvinfo
+tun_chr_fasync
+tun_flow_delete
+tun_flow_flush
+tun_flow_update
+__tun_build_skb
+tun_chr_open
+tun_show_flags
+tun_fill_info
+__tun_set_ebpf
+tun_prog_free
+tun_net_close
+tun_detach_filter
+tun_set_ebpf
+tun_cleanup
+tun_napi_disable
+tun_napi_del
+tun_sock_write_space
+tun_show_group
+tun_xdp
+tun_free_netdev
+tun_net_get_stats64
+tun_net_change_carrier
+tun_show_owner
+tun_setup
+tun_select_queue
+tun_queue_purge
+tun_detach_all
+tun_net_uninit
+__tun_detach
+tun_chr_close
+tun_napi_poll
+tun_flow_cleanup
+tun_peek_len
+tun_xdp_xmit
+tun_xdp_act
+tun_build_skb
+tun_device_event
+tun_chr_poll
+tun_do_read
+tun_recvmsg
+tun_chr_read_iter
+tun_net_xmit
+tun_attach
+__tun_chr_ioctl
+tun_chr_compat_ioctl
+tun_chr_ioctl
+tun_get_user
+tun_sendmsg
+tun_chr_write_iter
+ppp_nl_get_size
+ppp_nl_fill_info
+ppp_poll
+ppp_nl_validate
+ppp_nl_get_link_net
+ppp_get_stats64
+ppp_setup
+ppp_channel_index
+ppp_unit_number
+ppp_dev_name
+ppp_ccp_closed
+ppp_destroy_interface
+ppp_nl_dellink
+ppp_exit_net
+ppp_net_ioctl
+ppp_dev_uninit
+ppp_init_net
+ppp_open
+get_filter
+ppp_read
+ppp_dev_configure
+ppp_nl_newlink
+ppp_dev_priv_destructor
+ppp_destroy_channel
+ppp_disconnect_channel
+ppp_unregister_channel
+ppp_dev_init
+ppp_release
+ppp_register_net_channel
+ppp_register_channel
+find_compressor
+ppp_set_compress
+ppp_unregister_compressor
+ppp_register_compressor
+ppp_ccp_peek.part.0
+ppp_receive_nonmp_frame
+ppp_receive_frame
+ppp_input
+ppp_input_error
+ppp_push
+__ppp_xmit_process
+__ppp_channel_push
+ppp_channel_push
+ppp_output_wakeup
+ppp_xmit_process
+ppp_start_xmit
+ppp_write
+ppp_ioctl
+ppp_compat_ioctl
+slhc_toss
+slhc_remember
+slhc_free
+slhc_uncompress
+slhc_compress
+slhc_init
+wl1251_get_platform_data
+xennet_get_sset_count
+xennet_change_mtu
+xennet_get_ethtool_stats
+xennet_disconnect_backend
+netfront_resume
+xennet_destroy_queues
+xennet_fix_features
+talk_to_netback_xdp
+xennet_tx_setup_grant
+xennet_make_txreqs
+xennet_alloc_rx_buffers
+show_rxbuf
+store_rxbuf
+netfront_probe
+xennet_get_stats64
+xennet_select_queue
+xennet_close
+xennet_get_strings
+xennet_move_rx_slot
+xennet_tx_buf_gc
+xennet_tx_interrupt
+xennet_start_xmit
+xennet_set_features
+xennet_xdp
+xennet_make_one_txreq
+xennet_remove
+xennet_xdp_xmit
+rx_refill_timeout
+xennet_rx_interrupt
+xennet_interrupt
+xennet_poll_controller
+xennet_open
+xennet_get_responses
+xennet_poll
+write_queue_xenstore_keys
+netback_changed
+vfio_noiommu_release
+vfio_noiommu_detach_group
+vfio_noiommu_attach_group
+vfio_iommu_group_put
+vfio_device_data
+vfio_external_group_match_file
+vfio_info_cap_shift
+vfio_set_irqs_validate_and_prepare
+vfio_fops_mmap
+vfio_fops_write
+vfio_fops_read
+vfio_device_fops_mmap
+vfio_device_fops_unl_ioctl
+vfio_device_fops_write
+vfio_device_fops_read
+vfio_group_pin_pages
+vfio_group_unpin_pages
+vfio_dma_rw
+vfio_unregister_iommu_driver
+vfio_group_unlock_and_free
+vfio_group_put
+vfio_device_put
+vfio_group_put_bg
+vfio_external_user_iommu_id
+vfio_info_cap_add
+vfio_info_add_capability
+vfio_group_set_kvm
+vfio_devnode
+vfio_noiommu_ioctl
+vfio_group_add_container_user
+vfio_ioctl_check_extension
+vfio_fops_unl_ioctl
+vfio_external_check_extension
+vfio_noiommu_open
+vfio_iommu_group_get
+__vfio_group_unset_container
+vfio_group_try_dissolve_container
+vfio_group_put_external_user
+vfio_group_fops_release
+vfio_device_fops_release
+vfio_fops_open
+vfio_register_iommu_driver
+vfio_fops_release
+vfio_device_get
+vfio_group_get_device
+vfio_dev_viable
+vfio_group_get_from_iommu
+vfio_group_get_from_dev
+vfio_device_get_from_dev
+vfio_group_get_external_user_from_dev
+vfio_pin_pages
+vfio_unpin_pages
+vfio_register_notifier
+vfio_unregister_notifier
+vfio_group_fops_open
+vfio_add_group_dev
+vfio_del_group_dev
+vfio_group_get_external_user
+vfio_iommu_group_notifier
+vfio_group_fops_unl_ioctl
+virqfd_ptable_queue_proc
+virqfd_inject
+virqfd_wakeup
+virqfd_shutdown
+vfio_virqfd_disable
+vfio_virqfd_enable
+vfio_update_pgsize_bitmap
+vfio_bus_type
+vfio_iommu_find_iommu_group
+vfio_iommu_type1_unregister_notifier
+vfio_iommu_type1_register_notifier
+vfio_iommu_resv_free
+vfio_iommu_iova_free
+vfio_iommu_iova_insert
+vfio_iommu_aper_resize
+vfio_iommu_resv_exclude
+vfio_iommu_iova_get_copy
+vfio_dma_populate_bitmap
+vfio_mdev_get_iommu_device
+vfio_mdev_detach_domain
+vfio_mdev_iommu_device
+vfio_mdev_attach_domain
+vfio_dma_bitmap_alloc
+vfio_iommu_type1_dma_rw
+update_user_bitmap
+is_invalid_reserved_pfn
+vaddr_get_pfn
+put_pfn
+vfio_sanity_check_pfn_list
+update_pinned_page_dirty_scope
+vfio_lock_acct.part.0
+vfio_unpin_page_external
+vfio_iommu_type1_unpin_pages
+vfio_unpin_pages_remote
+vfio_sync_unpin
+vfio_pin_pages_remote
+vfio_iommu_detach_group
+vfio_release_domain
+vfio_iommu_attach_group
+vfio_unmap_unpin
+vfio_remove_dma
+vfio_iommu_unmap_unpin_all
+vfio_iommu_type1_release
+vfio_iommu_type1_detach_group
+vfio_iommu_type1_open
+vfio_iommu_type1_pin_pages
+vfio_iommu_type1_ioctl
+vfio_iommu_type1_attach_group
+vfio_pci_reflck_put
+vfio_pci_count_devs
+vfio_pci_mmap_close
+vfio_pci_mmap_open
+vfio_pci_zap_and_vma_lock
+vfio_pci_aer_err_detected
+vfio_pci_bus_notifier
+vfio_pci_try_zap_and_vma_lock_cb
+vfio_pci_get_unused_devs
+vfio_pci_request
+vfio_pci_mmap_fault
+vfio_pci_validate_devs
+vfio_pci_fill_devs
+vfio_pci_rw
+vfio_pci_set_vga_decode
+vfio_pci_walk_wrapper
+vfio_pci_sriov_configure
+vfio_pci_mmap
+get_pf_vdev
+vfio_pci_vf_token_user_add
+vfio_pci_write
+vfio_pci_read
+vfio_pci_get_irq_count
+vfio_pci_reflck_find
+vfio_pci_match
+vfio_pci_set_power_state
+vfio_pci_remove
+vfio_pci_probe
+vfio_pci_disable
+vfio_pci_release
+vfio_pci_open
+vfio_pci_register_dev_region
+vfio_pci_zap_and_down_write_memory_lock
+vfio_pci_memory_lock_and_enable
+vfio_pci_ioctl
+vfio_pci_memory_unlock_and_restore
+vfio_msihandler
+vfio_msi_set_vector_signal
+vfio_msi_set_block
+vfio_pci_intx_unmask_handler
+vfio_send_intx_eventfd
+vfio_intx_set_signal
+vfio_intx_disable
+vfio_msi_disable
+vfio_intx_handler
+vfio_pci_set_ctx_trigger_single
+vfio_pci_set_req_trigger
+vfio_pci_set_err_trigger
+vfio_pci_set_intx_trigger
+vfio_pci_set_msi_trigger
+vfio_pci_intx_mask
+vfio_pci_set_intx_mask
+vfio_pci_intx_unmask
+vfio_pci_set_intx_unmask
+vfio_pci_set_irqs_ioctl
+vfio_pci_iowrite32
+vfio_pci_iowrite16
+vfio_pci_setup_barmap
+vfio_pci_iowrite8
+do_io_rw
+vfio_pci_ioeventfd_do_write
+vfio_pci_ioeventfd_thread
+vfio_pci_ioeventfd_handler
+vfio_pci_bar_rw
+vfio_pci_vga_rw
+vfio_pci_ioeventfd
+vfio_user_config_read
+vfio_raw_config_read
+vfio_virt_config_write
+vfio_virt_config_read
+vfio_default_config_read
+vfio_msi_config_read
+vfio_fill_vconfig_bytes
+vfio_direct_config_read
+vfio_user_config_write
+vfio_raw_config_write
+vfio_default_config_write
+vfio_msi_config_write
+vfio_vpd_config_write
+vfio_af_config_write
+vfio_exp_config_write
+vfio_basic_config_write
+vfio_pm_config_write
+vfio_basic_config_read
+alloc_perm_bits
+__vfio_pci_memory_enabled
+vfio_pci_uninit_perm_bits
+vfio_config_init
+vfio_config_free
+vfio_pci_config_rw
+vfio_pci_igd_release
+vfio_pci_igd_rw
+vfio_pci_igd_cfg_release
+vfio_pci_igd_cfg_rw
+vfio_pci_igd_init
+cdrom_dummy_generic_packet
+cdrom_check_events
+sanitize_format
+cdrom_multisession
+cdrom_read_tocentry
+init_cdrom_command
+cdrom_get_random_writable
+cdrom_get_disc_info
+cdrom_get_media_event
+cdrom_mode_sense
+mo_open_write
+cdrom_mrw_probe_pc
+cdrom_is_mrw
+cdrom_mode_select
+cdrom_read_block
+cdrom_switch_blocksize
+cdrom_count_tracks
+cdrom_load_unload
+mmc_ioctl_cdrom_play_msf
+mmc_ioctl_cdrom_play_blk
+mmc_ioctl_cdrom_start_stop
+mmc_ioctl_cdrom_pause_resume
+dvd_do_auth
+mmc_ioctl_dvd_auth
+check_for_audio_disc
+cdrom_release
+unregister_cdrom
+cdrom_ram_open_write
+mmc_ioctl_cdrom_volume
+mmc_ioctl_dvd_read_struct
+cdrom_read_mech_status.part.0
+cdrom_read_mech_status
+cdrom_number_of_slots
+cdrom_sysctl_handler
+register_cdrom
+cdrom_print_info.constprop.0
+cdrom_sysctl_info
+cdrom_get_track_info.constprop.0
+cdrom_get_last_written
+mmc_ioctl_cdrom_next_writable
+mmc_ioctl_cdrom_last_written
+cdrom_read_subchannel.constprop.0
+mmc_ioctl_cdrom_subchannel
+cdrom_mrw_set_lba_space.constprop.0
+cdrom_mrw_exit
+cdrom_open
+mmc_ioctl_cdrom_read_data
+cdrom_read_cdda_old
+mmc_ioctl_cdrom_read_audio
+cdrom_ioctl
+usb_ep_type_string
+usb_otg_state_string
+usb_speed_string
+usb_state_string
+usb_get_maximum_speed
+usb_get_dr_mode
+usb_decode_ctrl
+usb_led_activity
+usb_dev_prepare
+usb_find_interface
+usb_put_dev
+usb_put_intf
+usb_for_each_dev
+usb_dev_restore
+usb_dev_thaw
+usb_dev_resume
+usb_dev_poweroff
+usb_dev_freeze
+usb_dev_suspend
+usb_dev_complete
+usb_get_dev
+usb_get_intf
+usb_get_current_frame_number
+match_endpoint
+usb_find_common_endpoints
+usb_find_common_endpoints_reverse
+usb_ifnum_to_if
+usb_altnum_to_altsetting
+__usb_get_extra_descriptor
+usb_release_dev
+usb_devnode
+usb_dev_uevent
+usb_lock_device_for_reset
+usb_alloc_coherent
+usb_free_coherent
+usb_disabled
+__find_interface
+__each_dev
+usb_find_alt_setting
+usb_bus_notify
+usb_alloc_dev
+set_port_feature
+clear_hub_feature
+hub_release
+usb_hub_clear_tt_buffer
+hub_tt_work
+set_port_led
+usb_set_lpm_timeout
+usb_set_device_initiated_lpm
+usb_disable_link_state
+hub_pm_barrier_for_all_ports
+hub_ext_port_status
+hub_hub_status
+find_port_owner
+usb_hub_claim_port
+usb_hub_release_port
+recursively_mark_NOTATTACHED
+usb_set_device_state
+usb_wakeup_enabled_descendants
+usb_hub_find_child
+usb_ep0_reinit
+usb_queue_reset_device
+hub_resubmit_irq_urb
+hub_retry_irq_urb
+led_work
+usb_disable_remote_wakeup
+usb_disable_ltm
+usb_enable_ltm
+hub_port_warm_reset_required
+usb_enable_link_state
+usb_enable_lpm
+usb_unlocked_enable_lpm
+usb_disable_lpm
+usb_unlocked_disable_lpm
+kick_hub_wq.part.0
+hub_irq
+hub_ioctl
+usb_wakeup_notification
+descriptors_changed
+usb_hub_to_struct_hub
+usb_device_supports_lpm
+usb_clear_port_feature
+hub_port_disable
+hub_port_logical_disconnect
+hub_port_reset
+hub_port_init
+usb_reset_and_verify_device
+usb_reset_device
+hub_power_on
+hub_activate
+hub_post_reset
+hub_init_func3
+hub_init_func2
+hub_reset_resume
+hub_resume
+usb_kick_hub_wq
+usb_hub_set_port_power
+usb_remove_device
+usb_hub_release_all_ports
+usb_device_is_owned
+usb_disconnect
+hub_quiesce
+hub_pre_reset
+hub_suspend
+hub_disconnect
+usb_new_device
+usb_deauthorize_device
+usb_authorize_device
+usb_port_suspend
+usb_port_resume
+usb_remote_wakeup
+usb_port_disable
+hub_port_debounce
+hub_event
+usb_hub_init
+usb_hub_cleanup
+usb_hub_adjust_deviceremovable
+hub_probe
+usb_get_hub_port_acpi_handle
+usb_mon_register
+usb_hcd_check_unlink_urb
+usb_alloc_streams
+usb_free_streams
+usb_hcd_is_primary_hcd
+usb_hcd_irq
+usb_hcd_start_port_resume
+usb_hcd_end_port_resume
+usb_calc_bus_time
+usb_hcd_resume_root_hub
+usb_hc_died
+hcd_died_work
+hcd_resume_work
+usb_mon_deregister
+usb_deregister_bus
+usb_hcd_platform_shutdown
+usb_hcd_setup_local_mem
+hcd_alloc_coherent
+__usb_create_hcd
+usb_create_shared_hcd
+usb_create_hcd
+usb_put_hcd
+usb_get_hcd
+usb_hcd_unmap_urb_setup_for_dma
+usb_hcd_unmap_urb_for_dma
+unmap_urb_for_dma
+__usb_hcd_giveback_urb
+usb_hcd_giveback_urb
+usb_hcd_unlink_urb_from_ep
+usb_hcd_poll_rh_status
+rh_timer_func
+unlink1
+usb_hcd_link_urb_to_ep
+usb_giveback_urb_bh
+usb_remove_hcd
+usb_add_hcd
+usb_hcd_map_urb_for_dma
+usb_hcd_submit_urb
+usb_hcd_unlink_urb
+usb_hcd_flush_endpoint
+usb_hcd_alloc_bandwidth
+usb_hcd_disable_endpoint
+usb_hcd_reset_endpoint
+usb_hcd_synchronize_unlinks
+usb_hcd_get_frame_number
+hcd_bus_resume
+hcd_bus_suspend
+usb_hcd_find_raw_port_number
+usb_unpoison_urb
+usb_block_urb
+usb_anchor_suspend_wakeups
+usb_anchor_empty
+usb_pipe_type_check
+usb_urb_ep_type_check
+usb_unpoison_anchored_urbs
+usb_init_urb
+usb_alloc_urb
+urb_destroy
+usb_unlink_urb
+usb_wait_anchor_empty_timeout
+usb_submit_urb
+usb_anchor_resume_wakeups
+usb_kill_urb
+usb_poison_urb
+usb_get_urb.part.0
+usb_get_urb
+usb_anchor_urb
+__usb_unanchor_urb
+usb_unanchor_urb
+usb_get_from_anchor
+usb_scuttle_anchored_urbs
+usb_unlink_anchored_urbs
+usb_poison_anchored_urbs
+usb_free_urb
+usb_kill_anchored_urbs
+usb_api_blocking_completion
+sg_clean
+usb_start_wait_urb
+usb_control_msg
+usb_get_string
+usb_string_sub
+usb_get_status
+usb_bulk_msg
+usb_interrupt_msg
+usb_control_msg_send
+sg_complete
+usb_sg_cancel
+usb_get_descriptor
+cdc_parse_cdc_header
+usb_string
+usb_reset_endpoint
+usb_clear_halt
+remove_intf_ep_devs
+create_intf_ep_devs
+usb_if_uevent
+__usb_queue_reset_device
+usb_release_interface
+usb_sg_wait
+usb_driver_set_configuration
+usb_control_msg_recv
+usb_sg_init
+usb_cache_string
+usb_get_device_descriptor
+usb_set_isoch_delay
+usb_disable_endpoint
+usb_disable_device_endpoints
+usb_disable_interface
+usb_disable_device
+usb_enable_endpoint
+usb_enable_interface
+usb_set_interface
+usb_reset_configuration
+usb_set_configuration
+driver_set_config_work
+usb_deauthorize_interface
+usb_authorize_interface
+usb_enable_autosuspend
+usb_disable_autosuspend
+usb_autopm_get_interface
+usb_autopm_get_interface_async
+usb_show_dynids
+new_id_show
+usb_driver_claim_interface
+usb_register_device_driver
+autosuspend_check
+usb_deregister_device_driver
+usb_register_driver
+usb_autopm_get_interface_no_resume
+usb_autopm_put_interface
+usb_autopm_put_interface_async
+usb_uevent
+usb_resume_interface.isra.0
+usb_suspend_both
+usb_resume_both
+usb_unbind_device
+usb_store_new_id
+new_id_store
+remove_id_show
+usb_autopm_put_interface_no_suspend
+usb_deregister
+remove_id_store
+usb_match_device
+usb_device_match_id.part.0
+usb_match_one_id_intf
+usb_match_one_id.part.0
+usb_match_one_id
+usb_match_id.part.0
+usb_match_id
+usb_match_dynamic_id
+usb_device_match_id
+usb_driver_applicable
+__usb_bus_reprobe_drivers
+usb_device_match
+usb_autosuspend_device
+usb_autoresume_device
+usb_unbind_interface
+usb_driver_release_interface
+usb_forced_unbind_intf
+unbind_marked_interfaces
+usb_resume
+rebind_marked_interfaces
+usb_unbind_and_rebind_marked_interfaces
+usb_resume_complete
+usb_suspend
+usb_probe_device
+usb_probe_interface
+usb_runtime_suspend
+usb_runtime_resume
+usb_runtime_idle
+usb_enable_usb2_hardware_lpm
+usb_disable_usb2_hardware_lpm
+usb_release_interface_cache
+usb_destroy_configuration
+usb_get_configuration
+usb_release_bos_descriptor
+usb_get_bos_descriptor
+usb_devnode
+usb_open
+usb_deregister_dev
+usb_register_dev
+usb_major_init
+usb_major_cleanup
+hcd_buffer_create
+hcd_buffer_destroy
+hcd_buffer_alloc
+hcd_buffer_free
+devpath_show
+persist_show
+usb2_hardware_lpm_show
+usb3_hardware_lpm_u2_show
+usb3_hardware_lpm_u1_show
+bConfigurationValue_store
+authorized_store
+authorized_show
+urbnum_show
+dev_string_attrs_are_visible
+intf_assoc_attrs_are_visible
+removable_show
+avoid_reset_quirk_show
+quirks_show
+maxchild_show
+version_show
+devnum_show
+busnum_show
+tx_lanes_show
+rx_lanes_show
+speed_show
+bMaxPacketSize0_show
+bNumConfigurations_show
+bDeviceProtocol_show
+bDeviceSubClass_show
+bDeviceClass_show
+bcdDevice_show
+idProduct_show
+idVendor_show
+usb2_lpm_besl_show
+usb2_lpm_l1_timeout_show
+autosuspend_show
+interface_authorized_default_show
+iad_bFunctionProtocol_show
+iad_bFunctionSubClass_show
+iad_bFunctionClass_show
+iad_bInterfaceCount_show
+iad_bFirstInterface_show
+interface_authorized_show
+modalias_show
+bInterfaceProtocol_show
+bInterfaceSubClass_show
+bInterfaceClass_show
+bNumEndpoints_show
+bAlternateSetting_show
+bInterfaceNumber_show
+interface_show
+serial_show
+product_show
+manufacturer_show
+bMaxPower_show
+bmAttributes_show
+bConfigurationValue_show
+bNumInterfaces_show
+configuration_show
+supports_autosuspend_show
+remove_store
+avoid_reset_quirk_store
+persist_store
+authorized_default_store
+authorized_default_show
+read_descriptors
+usb2_lpm_besl_store
+usb2_lpm_l1_timeout_store
+active_duration_show
+connected_duration_show
+autosuspend_store
+usb2_hardware_lpm_store
+interface_authorized_default_store
+interface_authorized_store
+ltm_capable_show
+level_store
+level_show
+usb_remove_sysfs_dev_files
+usb_create_sysfs_dev_files
+usb_create_sysfs_intf_files
+usb_remove_sysfs_intf_files
+ep_device_release
+direction_show
+type_show
+wMaxPacketSize_show
+bInterval_show
+bmAttributes_show
+bEndpointAddress_show
+bLength_show
+interval_show
+usb_create_ep_devs
+usb_remove_ep_devs
+driver_probe
+driver_suspend
+driver_resume
+usbdev_vm_open
+async_getcompleted
+findintfep
+usbdev_poll
+destroy_async
+destroy_async_on_interface
+driver_disconnect
+releaseintf
+dec_usb_memory_use_count
+usbdev_vm_close
+reap_as
+get_urb32
+proc_getdriver
+usbdev_notify
+claimintf
+checkintf
+check_ctrlrecip
+snoop_urb_data
+proc_disconnect_claim
+check_reset_of_active_ep
+proc_forbid_suspend
+snoop_urb
+usbfs_increase_memory_usage
+usbdev_mmap
+do_proc_control
+async_completed
+usbdev_open
+free_async
+usbdev_release
+usbdev_read
+copy_urb_data_to_user
+processcompl
+processcompl_compat
+parse_usbdevfs_streams
+do_proc_bulk
+proc_ioctl
+proc_do_submiturb
+usbdev_ioctl
+usbfs_notify_suspend
+usbfs_notify_resume
+usb_devio_cleanup
+usb_register_notify
+usb_unregister_notify
+usb_notify_add_device
+usb_notify_remove_device
+usb_notify_add_bus
+usb_notify_remove_bus
+usb_generic_driver_disconnect
+usb_generic_driver_suspend
+usb_generic_driver_resume
+usb_generic_driver_match
+__check_for_non_generic_match
+usb_choose_configuration
+usb_generic_driver_probe
+usb_detect_static_quirks
+quirks_param_set
+usb_endpoint_is_ignored
+usb_detect_quirks
+usb_detect_interface_quirks
+usb_release_quirk_list
+usb_device_dump
+usb_device_read
+usb_phy_roothub_alloc
+usb_phy_roothub_init
+usb_phy_roothub_exit
+usb_phy_roothub_set_mode
+usb_phy_roothub_power_off
+usb_phy_roothub_suspend
+usb_phy_roothub_calibrate
+usb_phy_roothub_power_on
+usb_phy_roothub_resume
+usb3_lpm_permit_show
+usb_port_runtime_suspend
+usb_port_device_release
+usb_port_shutdown
+over_current_count_show
+quirks_show
+location_show
+connect_type_show
+quirks_store
+usb3_lpm_permit_store
+link_peers_report
+match_location
+usb_port_runtime_resume
+usb_hub_create_port_device
+usb_hub_remove_port_device
+hcd_pci_resume_noirq
+ehci_wait_for_companions
+ehci_remove
+for_each_companion
+usb_hcd_pci_probe
+usb_hcd_pci_remove
+usb_hcd_pci_shutdown
+resume_common
+hcd_pci_runtime_resume
+hcd_pci_restore
+hcd_pci_resume
+check_root_hub_suspended
+suspend_common
+hcd_pci_runtime_suspend
+hcd_pci_suspend
+hcd_pci_suspend_noirq
+non_ehci_add
+ehci_post_add
+ehci_pre_add
+usb_acpi_power_manageable
+usb_acpi_bus_match
+usb_acpi_set_power_state
+usb_acpi_get_companion_for_port
+usb_acpi_find_companion
+usb_acpi_register
+usb_acpi_unregister
+usb_remove_phy
+usb_phy_get_charger_current
+devm_usb_phy_match
+usb_phy_set_event
+usb_get_phy
+devm_usb_get_phy
+usb_phy_notify_charger_work
+__usb_phy_get_charger_type
+usb_add_phy
+usb_add_phy_dev
+usb_phy_set_charger_current
+usb_phy_set_charger_state
+devm_usb_get_phy_by_node
+devm_usb_get_phy_by_phandle
+usb_put_phy.part.0
+usb_put_phy
+devm_usb_phy_release
+devm_usb_phy_release2
+devm_usb_put_phy
+dwc2_iddig_filter_enabled.part.0
+dwc2_wait_for_mode
+dwc2_backup_global_registers
+dwc2_restore_global_registers
+dwc2_exit_partial_power_down
+dwc2_enter_partial_power_down
+dwc2_enter_hibernation
+dwc2_exit_hibernation
+dwc2_enable_acg
+dwc2_dump_host_registers
+dwc2_dump_global_registers
+dwc2_is_controller_alive
+dwc2_enable_global_interrupts
+dwc2_disable_global_interrupts
+dwc2_op_mode
+dwc2_force_mode
+dwc2_force_dr_mode
+dwc2_hw_is_otg
+dwc2_hw_is_host
+dwc2_hw_is_device
+dwc2_hsotg_wait_bit_set
+dwc2_hib_restore_common
+dwc2_hsotg_wait_bit_clear
+dwc2_core_reset
+dwc2_flush_tx_fifo
+dwc2_flush_rx_fifo
+dwc2_init_fs_ls_pclk_sel
+dwc2_phy_init
+dwc2_handle_common_intr
+__dwc2_disable_regulators
+__dwc2_lowlevel_hw_enable
+__dwc2_lowlevel_hw_disable
+dwc2_driver_shutdown
+dwc2_driver_remove
+dwc2_resume
+dwc2_suspend
+dwc2_lowlevel_hw_enable
+dwc2_lowlevel_hw_disable
+dwc2_check_core_version
+dwc2_driver_probe
+dwc2_ovr_avalid
+dwc2_ovr_bvalid
+dwc2_drd_role_sw_set
+dwc2_drd_init
+dwc2_drd_suspend
+dwc2_drd_resume
+dwc2_drd_exit
+dwc2_set_bcm_params
+dwc2_set_his_params
+dwc2_set_s3c6400_params
+dwc2_set_rk_params
+dwc2_set_ltq_params
+dwc2_set_amlogic_params
+dwc2_set_amlogic_g12a_params
+dwc2_set_amcc_params
+dwc2_set_stm32f4x9_fsotg_params
+dwc2_set_stm32f7_hsotg_params
+dwc2_set_stm32mp15_fsotg_params
+dwc2_set_stm32mp15_hsotg_params
+dwc2_set_param_tx_fifo_sizes
+dwc2_get_hwparams
+dwc2_init_params
+_dwc2_hcd_endpoint_reset
+dwc2_hcd_phy_reset_func
+dwc2_free_dma_aligned_buffer
+dwc2_unmap_urb_for_dma
+_dwc2_hcd_irq
+dwc2_hcd_rem_wakeup
+dwc2_reset_device
+dwc2_free_dev
+dwc2_set_pid_isoc
+dwc2_map_urb_for_dma
+_dwc2_hcd_hub_status_data
+_dwc2_hcd_endpoint_disable
+dwc2_hc_write_packet
+dwc2_disable_host_interrupts
+dwc2_hcd_reset_func
+dwc2_enable_common_interrupts
+dwc2_wakeup_detected
+dwc2_port_resume
+dwc2_assign_and_init_hc
+_dwc2_hcd_resume
+_dwc2_hcd_suspend
+_dwc2_hcd_hub_control
+dwc2_calc_frame_interval
+dwc2_read_packet
+dwc2_hc_halt
+_dwc2_hcd_urb_dequeue
+dwc2_hc_cleanup
+_dwc2_hcd_start
+dwc2_hcd_start_func
+dwc2_hc_start_transfer_ddma
+dwc2_hcd_start
+dwc2_hcd_connect
+dwc2_hcd_stop
+dwc2_core_init
+dwc2_conn_id_status_change
+dwc2_hcd_select_transactions
+dwc2_hcd_get_frame_number
+_dwc2_hcd_get_frame_number
+dwc2_hcd_get_future_frame_number
+dwc2_hc_set_even_odd_frame.part.0
+dwc2_hc_start_transfer
+dwc2_hc_continue_transfer
+dwc2_queue_transaction
+dwc2_hcd_queue_transactions
+_dwc2_hcd_clear_tt_buffer_complete
+_dwc2_hcd_urb_enqueue
+dwc2_hcd_is_b_host
+dwc2_hcd_dump_state
+dwc2_host_get_tt_info
+dwc2_host_put_tt_info
+dwc2_host_get_speed
+dwc2_host_complete
+dwc2_kill_urbs_in_qh_list
+dwc2_hcd_disconnect
+_dwc2_hcd_stop
+dwc2_qh_list_free
+dwc2_hcd_free
+dwc2_hcd_init
+dwc2_hcd_remove
+dwc2_backup_host_registers
+dwc2_restore_host_registers
+dwc2_host_enter_hibernation
+dwc2_host_exit_hibernation
+dwc2_host_can_poweroff_phy
+dwc2_hc_handle_tt_clear
+dwc2_get_actual_xfer_length
+dwc2_update_urb_state_abn
+dwc2_update_urb_state
+dwc2_update_isoc_urb_state
+dwc2_release_channel
+dwc2_halt_channel
+dwc2_complete_non_periodic_xfer.isra.0
+dwc2_complete_periodic_xfer
+dwc2_hc_frmovrun_intr
+dwc2_hc_stall_intr
+dwc2_hc_ack_intr
+dwc2_hc_babble_intr
+dwc2_hc_ahberr_intr
+dwc2_hcd_save_data_toggle
+dwc2_hc_xfercomp_intr
+dwc2_hc_nak_intr
+dwc2_hc_nyet_intr
+dwc2_hc_xacterr_intr
+dwc2_hc_n_intr
+dwc2_handle_hcd_intr
+dwc2_wait_timer_fn
+pmap_unschedule
+dwc2_hs_pmap_unschedule
+pmap_schedule
+dwc2_hs_pmap_schedule
+dwc2_pick_first_frame
+dwc2_get_ls_map.isra.0
+dwc2_ls_pmap_unschedule.isra.0
+dwc2_do_unreserve
+dwc2_unreserve_timer_fn
+dwc2_ls_pmap_schedule.isra.0
+dwc2_hcd_qh_free
+dwc2_hcd_qh_create
+dwc2_hcd_qh_add
+dwc2_hcd_qh_unlink
+dwc2_hcd_qh_deactivate
+dwc2_hcd_qtd_init
+dwc2_hcd_qtd_add
+dwc2_desc_list_free
+dwc2_update_frame_list
+dwc2_init_non_isoc_dma_desc
+dwc2_calc_starting_frame
+dwc2_release_channel_ddma
+dwc2_hcd_qh_init_ddma
+dwc2_hcd_qh_free_ddma
+dwc2_hcd_start_xfer_ddma
+dwc2_hcd_complete_xfer_ddma
+dr_mode_open
+hw_params_open
+params_open
+dr_mode_show
+hw_params_show
+params_show
+dwc2_debugfs_init
+dwc2_debugfs_exit
+sb800_prefetch
+usb_amd_dev_put
+usb_amd_quirk_pll
+usb_amd_quirk_pll_disable
+usb_amd_quirk_pll_enable
+usb_disable_xhci_ports
+uhci_reset_hc
+uhci_check_and_reset_hc
+usb_amd_pt_check_port
+handshake
+usb_amd_find_chipset_info
+usb_amd_hang_symptom_quirk
+usb_amd_prefetch_quirk
+usb_amd_quirk_pll_check
+mmio_resource_enabled.part.0
+usb_enable_intel_xhci_ports
+usb_asmedia_wait_write
+usb_asmedia_modifyflowcontrol
+usb_hcd_amd_remote_wakeup_quirk
+quirk_usb_early_handoff
+ehci_handshake
+ehci_disable_ASE
+ehci_disable_PSE
+ehci_get_resuming_ports
+ehci_port_handed_over
+ehci_port_power
+tt_available
+ehci_init_driver
+uframe_periodic_max_show
+qh_lines
+companion_show
+compute_tt_budget
+ehci_clear_tt_buffer
+ehci_urb_done
+qh_completions
+iso_sched_free
+ehci_enable_event
+ehci_hrtimer_func
+uframe_periodic_max_store
+debug_close
+debug_output
+fill_async_buffer
+ehci_hub_status_data
+persist_enabled_on_companion
+bandwidth_dbg.isra.0
+qh_refresh
+qtd_list_free.isra.0
+qtd_fill.isra.0
+qh_destroy
+ehci_mem_cleanup
+start_free_itds.part.0
+end_free_itds
+turn_on_io_watchdog
+ehci_poll_PSS.part.0
+ehci_poll_PSS
+disable_periodic.part.0
+enable_periodic.part.0
+qh_link_periodic
+ehci_poll_ASS.part.0
+ehci_poll_ASS
+qh_link_async
+ehci_clear_tt_buffer_complete
+start_iaa_cycle
+end_unlink_async
+end_iaa_cycle
+start_unlink_async
+ehci_iaa_watchdog
+unlink_empty_async
+dbg_port_buf.constprop.0
+dbg_command_buf.constprop.0
+dbg_status_buf.constprop.0
+fill_registers_buffer
+check_intr_schedule
+ehci_get_frame
+ehci_qtd_alloc
+qh_urb_transaction
+alloc_buffer
+debug_registers_open
+debug_periodic_open
+debug_bandwidth_open
+debug_async_open
+ehci_qh_alloc
+qh_append_tds
+ehci_reset
+ehci_run
+find_tt
+reserve_release_intr_bandwidth
+qh_schedule
+ehci_handle_intr_unlinks
+start_unlink_intr
+ehci_handle_start_intr_unlinks
+ehci_work.part.0
+ehci_work
+ehci_handle_controller_death
+ehci_urb_dequeue
+ehci_endpoint_reset
+reserve_release_iso_bandwidth
+ehci_endpoint_disable
+iso_stream_schedule
+iso_stream_find
+set_owner
+ehci_relinquish_port
+companion_store
+ehci_remove_device
+ehci_quiesce.part.0
+ehci_irq
+fill_bandwidth_buffer
+ehci_halt
+ehci_silence_controller
+ehci_shutdown
+ehci_stop
+ehci_adjust_port_wakeup_flags
+ehci_resume
+ehci_suspend
+ehci_bus_suspend
+ehci_urb_enqueue
+ehci_hub_control
+ehci_bus_resume
+ehci_setup
+fill_periodic_buffer
+ehci_pci_remove
+ehci_pci_probe
+ehci_pci_reinit
+ehci_pci_resume
+ehci_pci_setup
+quirk_poll_timer
+quirk_poll_init
+ehci_platform_power_off
+ehci_platform_power_on
+ehci_platform_reset
+ehci_platform_resume
+ehci_platform_suspend
+ehci_platform_remove
+ehci_platform_probe
+quirk_poll_work
+ohci_get_frame
+td_fill
+add_to_done_list
+ohci_init_driver
+td_done
+update_done_list
+td_free
+urb_free_priv
+ed_deschedule
+start_ed_unlink
+ed_schedule
+ohci_shutdown
+ohci_hub_control
+ohci_dump_intr_mask
+debug_close
+debug_output
+td_alloc
+ed_free
+maybe_print_eds
+ohci_dump_status
+show_list.isra.0
+fill_async_buffer
+ohci_dump_roothub.constprop.0
+fill_registers_buffer
+ohci_dump
+ohci_stop
+ohci_init
+ohci_setup
+fill_periodic_buffer
+alloc_buffer
+debug_registers_open
+debug_periodic_open
+debug_async_open
+finish_urb
+ohci_work.part.0
+io_watchdog_func
+ohci_endpoint_disable
+ohci_urb_dequeue
+ohci_rh_suspend
+ohci_bus_suspend
+ohci_run
+ohci_start
+ohci_restart
+ohci_rh_resume
+ohci_hub_status_data
+ohci_resume
+ohci_suspend
+ohci_bus_resume
+ohci_irq
+ohci_urb_enqueue
+ohci_pci_probe
+ohci_pci_reset
+ohci_quirk_amd700
+broken_suspend
+ohci_quirk_amd756
+ohci_quirk_nec_worker
+ohci_quirk_toshiba_scc
+ohci_quirk_ns
+ohci_quirk_qemu
+ohci_quirk_nec
+ohci_quirk_zfmicro
+ohci_quirk_opti
+ohci_platform_resume
+ohci_platform_suspend
+ohci_platform_power_off
+ohci_platform_power_on
+ohci_platform_remove
+ohci_platform_probe
+uhci_pci_probe
+uhci_show_sc
+uhci_fsbr_timeout
+finish_reset
+check_and_reset_hc
+uhci_hcd_get_frame_number
+uhci_debug_release
+uhci_activate_qh
+uhci_check_bandwidth
+uhci_reserve_bandwidth
+uhci_set_next_interrupt
+any_ports_active
+uhci_free_td
+uhci_free_qh
+lprintk
+uhci_free_urb_priv
+uhci_make_qh_idle
+uhci_alloc_td
+uhci_alloc_qh
+uhci_submit_common
+uhci_pci_configure_hc
+uhci_debug_read
+uhci_debug_lseek
+uhci_pci_check_and_reset_hc
+uhci_pci_reset_hc
+uhci_pci_init
+uhci_map_status
+uhci_get_current_frame_number.part.0
+uhci_hc_died
+uhci_shutdown
+uhci_unlink_qh
+uhci_urb_dequeue
+uhci_pci_resume_detect_interrupts_are_broken
+uhci_fixup_toggles.isra.0
+uhci_show_td.isra.0
+uhci_show_qh
+uhci_sprint_schedule
+uhci_debug_open
+uhci_urbp_wants_fsbr.part.0
+uhci_urb_enqueue
+uhci_pci_global_suspend_mode_is_broken
+uhci_finish_suspend
+uhci_check_ports
+uhci_hub_control
+uhci_giveback_urb
+uhci_scan_schedule.part.0
+suspend_rh
+uhci_irq
+uhci_stop
+uhci_rh_suspend
+uhci_hcd_endpoint_disable
+uhci_pci_resume
+uhci_pci_suspend
+uhci_start
+wakeup_rh
+uhci_rh_resume
+uhci_hub_status_data
+xhci_check_usb2_port_capability
+calculate_max_exit_latency
+xhci_update_device
+xhci_get_frame
+xhci_cleanup_msix
+xhci_get_timeout_no_hub_lpm
+xhci_calculate_u1_timeout
+xhci_calculate_u2_timeout
+xhci_set_cmd_ring_deq
+compliance_mode_recovery_timer_init
+xhci_init
+compliance_mode_recovery
+xhci_find_raw_port_number
+xhci_init_driver
+xhci_get_ss_bw_consumed
+xhci_drop_ep_from_interval_table
+xhci_add_ep_to_interval_table
+xhci_check_bw_drop_ep_streams
+xhci_check_args
+xhci_map_urb_for_dma
+xhci_count_num_new_endpoints.isra.0
+xhci_free_host_resources
+xhci_zero_in_ctx
+xhci_reset_bandwidth
+xhci_get_endpoint_index.part.0
+xhci_get_endpoint_flag
+xhci_clear_tt_buffer_complete
+xhci_endpoint_reset
+xhci_endpoint_disable
+xhci_urb_dequeue
+xhci_drop_endpoint
+xhci_add_endpoint
+xhci_handshake
+xhci_suspend
+xhci_zero_64b_regs
+xhci_quiesce
+xhci_halt
+xhci_start
+xhci_run
+xhci_reset
+xhci_shutdown
+xhci_resume
+xhci_gen_setup
+xhci_stop
+xhci_get_endpoint_index
+xhci_get_endpoint_address
+xhci_last_valid_endpoint
+xhci_update_tt_active_eps
+xhci_reserve_bandwidth
+xhci_configure_endpoint
+xhci_change_max_exit_latency
+xhci_disable_usb3_lpm_timeout
+xhci_enable_usb3_lpm_timeout
+xhci_set_usb2_hardware_lpm
+xhci_update_hub_device
+xhci_check_bandwidth
+xhci_free_streams
+xhci_alloc_streams
+xhci_urb_enqueue
+xhci_cleanup_stalled_ring
+xhci_free_device_endpoint_resources
+xhci_disable_slot
+xhci_alloc_dev
+xhci_discover_or_reset_device
+xhci_setup_device
+xhci_enable_device
+xhci_address_device
+xhci_free_dev
+xhci_remove_segment_mapping
+xhci_segment_free
+xhci_microframes_to_exponent
+xhci_parse_exponent_interval
+xhci_test_trb_in_td
+xhci_check_trb_in_td_math
+xhci_link_segments.part.0
+xhci_update_stream_segment_mapping
+xhci_free_tt_info
+xhci_ring_free.part.0
+xhci_free_container_ctx.part.0
+xhci_segment_alloc
+xhci_alloc_segments_for_ring
+xhci_create_rhub_port_array
+xhci_ring_free
+xhci_initialize_ring_info
+xhci_ring_alloc
+xhci_free_endpoint_ring
+xhci_ring_expansion
+xhci_alloc_container_ctx
+xhci_free_container_ctx
+xhci_get_input_control_ctx
+xhci_get_slot_ctx
+xhci_get_ep_ctx
+xhci_dma_to_transfer_ring
+xhci_stream_id_to_ring
+xhci_setup_streams_ep_input_ctx
+xhci_setup_no_streams_ep_input_ctx
+xhci_alloc_tt_info
+xhci_alloc_virt_device
+xhci_copy_ep0_dequeue_into_input_ctx
+xhci_setup_addressable_virt_dev
+xhci_endpoint_init
+xhci_endpoint_zero
+xhci_clear_endpoint_bw_info
+xhci_update_bw_info
+xhci_endpoint_copy
+xhci_slot_copy
+xhci_alloc_command
+xhci_alloc_command_with_ctx
+xhci_urb_free_priv
+xhci_free_command
+xhci_alloc_stream_info
+xhci_free_stream_info.part.0
+xhci_free_stream_info
+xhci_free_virt_device
+xhci_free_virt_devices_depth_first
+xhci_alloc_erst
+xhci_free_erst
+xhci_mem_cleanup
+xhci_mem_init
+xhci_intel_unregister_pdev
+xhci_ext_cap_init
+xhci_unmap_td_bounce_buffer
+xhci_giveback_urb_in_irq
+xhci_kill_ring_urbs
+xhci_td_cleanup
+xhci_update_erst_dequeue
+xhci_td_remainder
+prepare_ring
+prepare_transfer
+inc_enq
+xhci_get_hw_deq
+check_interval.isra.0
+xhci_ring_cmd_db.part.0
+xhci_handle_stopped_cmd_ring
+sum_trb_lengths.isra.0
+td_to_noop.constprop.0
+queue_command
+xhci_trb_virt_to_dma
+inc_deq
+xhci_ring_cmd_db
+xhci_ring_ep_doorbell
+ring_doorbell_for_active_rings
+xhci_ring_doorbell_for_active_rings
+xhci_triad_to_transfer_ring
+xhci_find_new_dequeue_state
+xhci_cleanup_command_queue
+xhci_hc_died
+xhci_stop_endpoint_command_watchdog
+xhci_handle_command_timeout
+trb_in_td
+xhci_is_vendor_info_code
+count_trbs
+xhci_queue_bulk_tx
+xhci_queue_intr_tx
+xhci_queue_ctrl_tx
+xhci_queue_isoc_tx_prepare
+xhci_queue_slot_control
+xhci_queue_address_device
+xhci_queue_vendor_command
+xhci_queue_reset_device
+xhci_queue_configure_endpoint
+xhci_queue_evaluate_context
+xhci_queue_stop_endpoint
+xhci_queue_new_dequeue_state
+handle_cmd_completion
+xhci_queue_reset_ep
+xhci_cleanup_halted_endpoint
+finish_td
+xhci_irq
+xhci_msi_irq
+xhci_set_port_power
+xhci_stop_device.constprop.0
+xhci_port_state_to_neutral
+xhci_find_slot_id_by_port
+xhci_ring_device
+xhci_get_rhub
+xhci_set_link_state
+xhci_test_and_clear_bit
+xhci_hub_control
+xhci_hub_status_data
+xhci_bus_suspend
+xhci_bus_resume
+xhci_get_resuming_ports
+xhci_dbg_trace
+xhci_get_slot_state
+__traceiter_xhci_dbg_address
+__traceiter_xhci_dbg_context_change
+__traceiter_xhci_dbg_quirks
+__traceiter_xhci_dbg_reset_ep
+__traceiter_xhci_dbg_cancel_urb
+__traceiter_xhci_dbg_init
+__traceiter_xhci_dbg_ring_expansion
+__traceiter_xhci_address_ctx
+__traceiter_xhci_handle_event
+__traceiter_xhci_handle_command
+__traceiter_xhci_handle_transfer
+__traceiter_xhci_queue_trb
+__traceiter_xhci_dbc_handle_event
+__traceiter_xhci_dbc_handle_transfer
+__traceiter_xhci_dbc_gadget_ep_queue
+__traceiter_xhci_free_virt_device
+__traceiter_xhci_alloc_virt_device
+__traceiter_xhci_setup_device
+__traceiter_xhci_setup_addressable_virt_device
+__traceiter_xhci_stop_device
+__traceiter_xhci_urb_enqueue
+__traceiter_xhci_urb_giveback
+__traceiter_xhci_urb_dequeue
+__traceiter_xhci_handle_cmd_stop_ep
+__traceiter_xhci_handle_cmd_set_deq_ep
+__traceiter_xhci_handle_cmd_reset_ep
+__traceiter_xhci_handle_cmd_config_ep
+__traceiter_xhci_add_endpoint
+__traceiter_xhci_alloc_dev
+__traceiter_xhci_free_dev
+__traceiter_xhci_handle_cmd_disable_slot
+__traceiter_xhci_discover_or_reset_device
+__traceiter_xhci_setup_device_slot
+__traceiter_xhci_handle_cmd_addr_dev
+__traceiter_xhci_handle_cmd_reset_dev
+__traceiter_xhci_handle_cmd_set_deq
+__traceiter_xhci_configure_endpoint
+__traceiter_xhci_address_ctrl_ctx
+__traceiter_xhci_configure_endpoint_ctrl_ctx
+__traceiter_xhci_ring_alloc
+__traceiter_xhci_ring_free
+__traceiter_xhci_ring_expansion
+__traceiter_xhci_inc_enq
+__traceiter_xhci_inc_deq
+__traceiter_xhci_handle_port_status
+__traceiter_xhci_get_port_status
+__traceiter_xhci_hub_status_data
+__traceiter_xhci_ring_ep_doorbell
+__traceiter_xhci_ring_host_doorbell
+__traceiter_xhci_dbc_alloc_request
+__traceiter_xhci_dbc_free_request
+__traceiter_xhci_dbc_queue_request
+__traceiter_xhci_dbc_giveback_request
+xhci_do_dbc_exit
+dbc_ring_free
+dbc_show
+xhci_dbc_giveback
+xhci_dbc_flush_endpoint_requests
+xhci_dbc_handle_events
+xhci_dbc_ring_alloc.constprop.0
+xhci_dbc_start
+xhci_dbc_stop
+dbc_store
+dbc_alloc_request
+dbc_free_request
+dbc_ep_queue
+xhci_dbc_init
+xhci_dbc_exit
+xhci_dbc_suspend
+xhci_dbc_resume
+dbc_tty_exit
+dbc_tty_write_room
+dbc_tty_chars_in_buffer
+xhci_dbc_free_requests
+dbc_start_tx
+dbc_write_complete
+dbc_tty_flush_chars
+xhci_dbc_alloc_requests
+dbc_tty_put_char
+dbc_tty_write
+dbc_tty_close
+dbc_tty_open
+dbc_tty_install
+xhci_dbc_tty_unregister_device
+xhci_dbc_tty_register_device
+dbc_start_rx
+dbc_port_activate
+dbc_rx_push
+dbc_tty_unthrottle
+dbc_read_complete
+xhci_dbc_tty_probe
+xhci_dbc_tty_remove
+xhci_ring_open
+xhci_stream_context_array_open
+xhci_stream_id_open
+xhci_context_open
+xhci_port_open
+xhci_ring_cycle_show
+xhci_stream_context_array_show
+xhci_stream_id_show
+xhci_device_name_show
+xhci_ring_trb_show
+xhci_portsc_show
+xhci_ring_dequeue_show
+xhci_ring_enqueue_show
+xhci_stream_id_write
+xhci_endpoint_context_show
+xhci_slot_context_show
+xhci_port_write
+xhci_debugfs_regset
+xhci_debugfs_create_ring_dir.isra.0
+xhci_debugfs_extcap_regset
+xhci_debugfs_create_endpoint
+xhci_debugfs_remove_endpoint
+xhci_debugfs_create_stream_files
+xhci_debugfs_create_slot
+xhci_debugfs_remove_slot
+xhci_debugfs_init
+xhci_debugfs_exit
+dbgp_wait_until_done
+dbgp_bulk_read
+dbgp_reset_prep
+kgdbdbgp_read_char
+kgdbdbgp_reader_thread
+dbgp_control_msg.constprop.0
+dbgp_bulk_write.constprop.0
+_dbgp_external_startup
+dbgp_external_startup
+early_dbgp_write.part.0
+early_dbgp_write
+kgdbdbgp_write_char
+handshake
+xdbc_reset_ring
+xdbc_mem_init
+xdbc_bulk_transfer
+xdbc_start
+xdbc_handle_events
+xdbc_scrub_function
+early_xdbc_write
+usb_role_switch_match
+usb_role_switch_find_by_fwnode
+usb_role_switch_is_parent
+usb_role_switch_release
+usb_role_switch_unregister
+usb_role_switch_uevent
+usb_role_switch_get_drvdata
+usb_role_switch_set_drvdata
+usb_role_switch_is_visible
+usb_role_switch_set_role.part.0
+usb_role_switch_set_role
+role_store
+usb_role_switch_get_role.part.0
+usb_role_switch_get_role
+role_show
+usb_role_switch_get
+fwnode_usb_role_switch_get
+usb_role_switch_put
+usb_role_switch_register
+serio_find_driver
+serio_release_port
+firmware_id_show
+serio_show_description
+serio_match_port
+serio_reconnect_driver
+serio_disconnect_driver
+serio_driver_remove
+serio_cleanup
+serio_suspend
+serio_shutdown
+serio_remove_pending_events
+serio_remove_duplicate_events
+serio_queue_event
+serio_rescan
+serio_reconnect
+serio_interrupt
+serio_resume
+__serio_register_port
+modalias_show
+extra_show
+id_show
+proto_show
+type_show
+description_show
+serio_set_bind_mode
+bind_mode_store
+serio_uevent
+serio_bus_match
+serio_show_bind_mode
+bind_mode_show
+__serio_register_driver
+serio_driver_probe
+serio_close
+serio_open
+serio_destroy_port
+serio_disconnect_port
+serio_unregister_driver
+serio_reconnect_subtree
+serio_handle_event
+drvctl_store
+serio_unregister_port
+serio_unregister_child_port
+i8042_install_filter
+i8042_remove_filter
+i8042_lock_chip
+i8042_unlock_chip
+i8042_wait_write
+i8042_kbd_bind_notifier
+i8042_set_reset
+i8042_kbd_write
+i8042_flush
+i8042_panic_blink
+i8042_interrupt
+i8042_pm_thaw
+i8042_free_irqs
+__i8042_command
+i8042_command
+i8042_dritek_enable
+i8042_aux_write
+i8042_set_mux_mode
+i8042_port_close
+i8042_controller_selftest
+i8042_controller_reset
+i8042_pm_reset
+i8042_shutdown
+i8042_pm_suspend
+i8042_remove
+i8042_enable_aux_port
+i8042_enable_mux_ports
+i8042_enable_kbd_port
+i8042_controller_resume
+i8042_pm_restore
+i8042_pm_resume
+i8042_pm_resume_noirq
+i8042_pnp_id_to_string.constprop.0
+i8042_start
+i8042_stop
+i8042_pnp_aux_probe
+i8042_pnp_kbd_probe
+ps2_begin_command
+ps2_end_command
+ps2_is_keyboard_id
+ps2_init
+ps2_handle_response
+ps2_handle_ack
+ps2_cmd_aborted
+ps2_do_sendbyte
+ps2_sendbyte
+ps2_drain
+__ps2_command
+ps2_command
+ps2_sliced_command
+input_to_handler
+input_scancode_to_scalar
+input_get_keycode
+input_proc_devices_poll
+devm_input_device_match
+input_enable_softrepeat
+input_handler_for_each_handle
+input_grab_device
+input_flush_device
+input_register_handle
+__input_release_device
+input_release_device
+input_unregister_handle
+input_close_device
+input_dev_toggle
+input_devnode
+input_dev_release
+input_print_modalias_bits
+input_print_modalias
+input_dev_show_modalias
+input_dev_show_id_version
+input_dev_show_id_product
+input_dev_show_id_vendor
+input_dev_show_id_bustype
+input_dev_show_uniq
+input_dev_show_phys
+input_dev_show_name
+devm_input_device_release
+input_set_timestamp
+input_get_timestamp
+input_unregister_handler
+input_get_new_minor
+input_free_minor
+input_proc_handlers_open
+input_proc_devices_open
+input_handlers_seq_next
+input_devices_seq_next
+input_handlers_seq_start
+input_devices_seq_start
+input_seq_stop
+input_open_device
+input_free_device
+input_handlers_seq_show
+input_fetch_keycode
+input_default_getkeycode
+input_default_setkeycode
+input_pass_values.part.0
+input_match_device_id
+input_attach_handler
+input_bits_to_string
+input_print_bitmap
+input_add_uevent_bm_var
+input_dev_uevent
+input_dev_show_cap_sw
+input_dev_show_cap_ff
+input_dev_show_cap_snd
+input_dev_show_cap_led
+input_dev_show_cap_msc
+input_dev_show_cap_abs
+input_dev_show_cap_rel
+input_dev_show_cap_key
+input_dev_show_cap_ev
+input_dev_show_properties
+input_seq_print_bitmap
+input_devices_seq_show
+input_register_handler
+input_allocate_device
+devm_input_allocate_device
+input_alloc_absinfo
+input_set_abs_params
+input_set_capability
+input_dev_release_keys
+input_reset_device
+__input_unregister_device
+devm_input_device_unregister
+input_unregister_device
+input_register_device
+input_dev_freeze
+input_dev_poweroff
+input_dev_resume
+input_dev_suspend
+input_repeat_key
+input_set_keycode
+input_handle_event
+input_event
+input_inject_event
+input_event_from_user
+input_event_to_user
+input_ff_effect_from_user
+input_mt_report_finger_count
+adjust_dual
+input_mt_get_slot_by_key
+input_mt_destroy_slots
+copy_abs
+input_mt_report_pointer_emulation
+__input_mt_drop_unused
+input_mt_drop_unused
+input_mt_sync_frame
+input_mt_assign_slots
+input_mt_report_slot_state
+input_mt_init_slots
+input_get_poll_interval
+input_poller_attrs_visible
+input_dev_poller_queue_work
+input_dev_poller_work
+input_dev_get_poll_min
+input_dev_get_poll_max
+input_dev_get_poll_interval
+input_dev_set_poll_interval
+input_set_max_poll_interval
+input_setup_polling
+input_set_poll_interval
+input_set_min_poll_interval
+input_dev_poller_finalize
+input_dev_poller_start
+input_dev_poller_stop
+input_ff_upload
+input_ff_event
+input_ff_destroy
+erase_effect
+input_ff_flush
+input_ff_erase
+input_ff_create
+mousedev_packet
+mousedev_fasync
+mousedev_free
+mousedev_poll
+mousedev_read
+mousedev_close_device
+mixdev_close_devices
+mousedev_open_device
+mixdev_open_devices
+mousedev_write
+mousedev_notify_readers
+mousedev_cleanup
+mousedev_create
+mousedev_destroy
+mousedev_disconnect
+mousedev_connect
+mousedev_release
+mousedev_open
+mousedev_event
+evdev_fasync
+__evdev_queue_syn_dropped
+evdev_handle_get_keycode
+evdev_handle_get_keycode_v2
+evdev_handle_set_keycode
+evdev_handle_set_keycode_v2
+evdev_free
+evdev_poll
+evdev_read
+evdev_cleanup
+evdev_disconnect
+evdev_connect
+evdev_open
+evdev_release
+evdev_pass_values.part.0
+evdev_events
+evdev_event
+bits_to_user
+evdev_handle_get_val
+str_to_user
+evdev_ioctl_handler
+evdev_ioctl_compat
+evdev_ioctl
+evdev_write
+atkbd_reset_state
+atkbd_attr_is_visible
+atkbd_set_repeat_rate
+atkbd_do_show_function_row_physmap
+atkbd_do_show_force_release
+atkbd_do_show_err_count
+atkbd_do_show_set
+atkbd_schedule_event_work
+atkbd_activate
+atkbd_set_force_release
+atkbd_select_set
+atkbd_do_show_softraw
+atkbd_do_show_softrepeat
+atkbd_do_show_scroll
+atkbd_do_show_extra
+atkbd_set_device_attrs
+atkbd_set_softraw
+atkbd_set_softrepeat
+atkbd_set_leds
+atkbd_event
+atkbd_event_work
+atkbd_probe
+atkbd_interrupt
+atkbd_apply_forced_release_keylist
+atkbd_oqo_01plus_scancode_fixup
+atkbd_set_keycode_table
+atkbd_set_set
+atkbd_set_scroll
+atkbd_set_extra
+atkbd_connect
+atkbd_cleanup
+atkbd_disconnect
+atkbd_attr_set_helper
+atkbd_do_set_softraw
+atkbd_do_set_softrepeat
+atkbd_do_set_set
+atkbd_do_set_scroll
+atkbd_do_set_force_release
+atkbd_do_set_extra
+atkbd_reconnect
+touchscreen_set_params
+touchscreen_apply_prop_to_x_y
+touchscreen_set_mt_pos
+touchscreen_report_pos
+touchscreen_parse_properties
+elants_i2c_send
+elants_i2c_sw_reset
+elants_i2c_read
+elants_i2c_power_on
+elants_i2c_power_off
+elants_i2c_execute_command
+elants_i2c_initialize
+elants_version_attribute_show
+show_calibration_count
+show_iap_mode
+elants_i2c_calibrate
+write_update_fw
+calibrate_store
+elants_i2c_event
+elants_i2c_irq
+elants_i2c_probe
+elants_i2c_resume
+elants_i2c_suspend
+uinput_dev_flush
+uinput_poll
+uinput_destroy_device
+uinput_release
+uinput_dev_event
+uinput_dev_set_autocenter
+uinput_dev_set_gain
+uinput_dev_playback
+uinput_ff_upload_to_user
+uinput_dev_setup
+uinput_ff_upload_from_user
+uinput_validate_absinfo.isra.0
+uinput_open
+uinput_request_alloc_id
+uinput_request_reserve_slot
+uinput_request_submit.part.0
+uinput_dev_upload_effect
+uinput_dev_erase_effect
+uinput_write
+uinput_read
+uinput_ioctl_handler
+uinput_compat_ioctl
+uinput_ioctl
+rtc_month_days
+rtc_year_days
+rtc_valid_tm
+rtc_tm_to_time64
+rtc_tm_to_ktime
+rtc_time64_to_tm
+rtc_ktime_to_tm
+rtc_set_ntp_time
+rtc_device_release
+devm_rtc_release_device
+rtc_resume.part.0
+rtc_resume
+rtc_suspend
+__rtc_register_device
+devm_rtc_allocate_device
+devm_rtc_device_register
+__traceiter_rtc_set_time
+__traceiter_rtc_read_time
+__traceiter_rtc_set_alarm
+__traceiter_rtc_read_alarm
+__traceiter_rtc_irq_set_freq
+__traceiter_rtc_irq_set_state
+__traceiter_rtc_alarm_irq_enable
+__traceiter_rtc_set_offset
+__traceiter_rtc_read_offset
+__traceiter_rtc_timer_enqueue
+__traceiter_rtc_timer_dequeue
+__traceiter_rtc_timer_fired
+rtc_add_offset
+__rtc_read_time
+rtc_read_time
+rtc_subtract_offset
+__rtc_set_alarm
+rtc_class_open
+rtc_class_close
+rtc_update_hrtimer
+rtc_valid_range
+rtc_read_alarm
+rtc_initialize_alarm
+rtc_update_irq
+rtc_alarm_disable
+rtc_timer_enqueue
+rtc_timer_remove
+rtc_alarm_irq_enable
+rtc_update_irq_enable
+rtc_set_time
+rtc_set_alarm
+__rtc_read_alarm
+rtc_handle_legacy_irq
+rtc_aie_update_irq
+rtc_uie_update_irq
+rtc_pie_update_irq
+rtc_irq_set_state
+rtc_irq_set_freq
+rtc_timer_do_work
+rtc_timer_init
+rtc_timer_start
+rtc_timer_cancel
+rtc_read_offset
+rtc_set_offset
+rtc_nvram_write
+rtc_nvram_read
+rtc_nvmem_register
+rtc_nvmem_unregister
+rtc_dev_open
+rtc_dev_poll
+rtc_dev_fasync
+rtc_dev_ioctl
+rtc_dev_release
+rtc_dev_compat_ioctl
+rtc_dev_read
+rtc_dev_prepare
+rtc_proc_show
+is_rtc_hctosys
+rtc_proc_add_device
+rtc_proc_del_device
+offset_store
+offset_show
+time_show
+date_show
+since_epoch_show
+wakealarm_show
+rtc_attr_is_visible
+range_show
+max_user_freq_show
+wakealarm_store
+max_user_freq_store
+name_show
+rtc_add_groups
+rtc_add_group
+hctosys_show
+rtc_get_dev_attribute_groups
+mc146818_get_time
+mc146818_set_time
+rtc_wake_off
+rtc_wake_on
+cmos_set_time
+cmos_read_time
+cmos_validate_alarm
+cmos_wake_setup.part.0
+cmos_checkintr
+cmos_irq_disable
+cmos_irq_enable.constprop.0
+cmos_alarm_irq_enable
+cmos_interrupt
+rtc_handler
+cmos_do_shutdown
+cmos_do_remove
+cmos_platform_remove
+cmos_pnp_remove
+cmos_nvram_read
+cmos_nvram_write
+cmos_procfs
+cmos_do_probe
+cmos_pnp_probe
+cmos_read_alarm
+cmos_suspend
+cmos_set_alarm
+cmos_aie_poweroff
+cmos_platform_shutdown
+cmos_pnp_shutdown
+cmos_resume
+i2c_register_board_info
+dummy_probe
+dummy_remove
+__traceiter_i2c_write
+__traceiter_i2c_read
+__traceiter_i2c_reply
+__traceiter_i2c_result
+i2c_verify_client
+i2c_device_shutdown
+i2c_verify_adapter
+i2c_cmd
+i2c_transfer_trace_reg
+i2c_transfer_trace_unreg
+i2c_generic_scl_recovery
+i2c_recover_bus
+i2c_device_remove
+i2c_client_dev_release
+i2c_put_dma_safe_msg_buf
+name_show
+i2c_check_mux_parents
+i2c_check_addr_busy
+i2c_clients_command
+i2c_adapter_dev_release
+i2c_handle_smbus_host_notify
+i2c_default_probe
+i2c_get_device_id
+i2c_probe_func_quick_read
+i2c_adapter_unlock_bus
+i2c_adapter_trylock_bus
+i2c_adapter_lock_bus
+i2c_host_notify_irq_map
+set_sda_gpio_value
+set_scl_gpio_value
+get_sda_gpio_value
+get_scl_gpio_value
+i2c_for_each_dev
+i2c_get_adapter
+__i2c_check_addr_busy.part.0
+__i2c_check_addr_busy
+i2c_match_id.part.0
+i2c_match_id
+i2c_device_match
+i2c_device_probe
+i2c_device_uevent
+modalias_show
+i2c_check_mux_children
+i2c_unregister_device.part.0
+i2c_unregister_device
+devm_i2c_release_dummy
+__unregister_dummy
+i2c_do_del_adapter
+__process_removed_adapter
+__process_removed_driver
+delete_device_store
+i2c_del_adapter
+__unregister_client
+i2c_parse_timing
+i2c_parse_fw_timings
+i2c_del_driver
+i2c_quirk_error
+i2c_put_adapter
+i2c_adapter_depth
+i2c_register_driver
+i2c_get_dma_safe_msg_buf
+__i2c_transfer
+i2c_transfer
+i2c_transfer_buffer_flags
+i2c_check_7bit_addr_validity_strict
+i2c_dev_irq_from_resources
+i2c_new_client_device
+i2c_new_dummy_device
+devm_i2c_new_dummy_device
+i2c_new_ancillary_device
+new_device_store
+i2c_detect
+__process_new_adapter
+__process_new_driver
+i2c_register_adapter
+i2c_add_adapter
+i2c_add_numbered_adapter
+i2c_new_scanned_device
+__traceiter_smbus_write
+__traceiter_smbus_read
+__traceiter_smbus_reply
+__traceiter_smbus_result
+i2c_smbus_msg_pec
+i2c_new_smbus_alert_device
+i2c_smbus_try_get_dmabuf
+i2c_smbus_xfer_emulated
+__i2c_smbus_xfer
+i2c_smbus_xfer
+i2c_smbus_read_byte
+i2c_smbus_write_byte
+i2c_smbus_read_byte_data
+i2c_smbus_write_byte_data
+i2c_smbus_read_word_data
+i2c_smbus_write_word_data
+i2c_smbus_read_block_data
+i2c_smbus_write_block_data
+i2c_smbus_read_i2c_block_data
+i2c_smbus_read_i2c_block_data_or_emulated
+i2c_smbus_write_i2c_block_data
+i2c_acpi_get_i2c_resource
+i2c_acpi_find_bus_speed
+i2c_acpi_do_lookup
+i2c_acpi_get_info
+i2c_acpi_lookup_speed
+i2c_acpi_fill_info
+i2c_acpi_find_adapter_by_handle
+i2c_acpi_new_device
+i2c_acpi_add_resource
+i2c_acpi_find_match_adapter
+i2c_acpi_notify.part.0
+i2c_acpi_add_device
+i2c_acpi_notify
+i2c_acpi_space_handler
+i2c_acpi_get_irq
+i2c_acpi_register_devices
+i2c_acpi_install_space_handler
+i2c_acpi_remove_space_handler
+i2cdev_dev_release
+i2cdev_release
+i2cdev_ioctl_smbus
+i2cdev_check_mux_parents
+i2cdev_check
+i2cdev_write
+i2cdev_check_mux_children
+i2cdev_open
+i2c_dev_get_by_minor
+name_show
+i2cdev_attach_adapter.part.0
+i2cdev_attach_adapter
+i2cdev_detach_adapter
+i2cdev_notifier_call
+i2cdev_read
+i2cdev_ioctl_rdwr
+i2cdev_ioctl
+compat_i2cdev_ioctl
+dw_reg_read
+dw_reg_write
+dw_reg_read_word
+dw_reg_write_word
+i2c_dw_validate_speed
+dw_reg_write_swab
+dw_reg_read_swab
+i2c_dw_acpi_params
+i2c_dw_acpi_configure
+i2c_dw_adjust_bus_speed
+i2c_dw_prepare_clk
+i2c_dw_scl_hcnt
+i2c_dw_scl_lcnt
+__i2c_dw_disable
+i2c_dw_clk_rate
+i2c_dw_acquire_lock
+i2c_dw_init_regmap
+i2c_dw_set_sda_hold
+i2c_dw_release_lock
+i2c_dw_wait_bus_not_busy
+i2c_dw_handle_tx_abort
+i2c_dw_set_fifo_size
+i2c_dw_func
+i2c_dw_disable
+i2c_dw_disable_int
+i2c_dw_configure_master
+i2c_dw_isr
+i2c_dw_probe_master
+i2c_dw_prepare_recovery
+i2c_dw_init_master
+i2c_dw_unprepare_recovery
+i2c_dw_xfer
+dw_i2c_plat_prepare
+i2c_dw_get_clk_rate_khz
+dw_i2c_plat_resume
+dw_i2c_plat_suspend
+dw_i2c_plat_pm_cleanup
+dw_i2c_plat_remove
+dw_i2c_plat_complete
+dw_i2c_plat_probe
+i2c_dw_probe_lock_support
+pps_cdev_poll
+pps_device_destruct
+pps_cdev_fasync
+pps_cdev_release
+pps_cdev_open
+pps_cdev_pps_fetch
+pps_lookup_dev
+pps_cdev_ioctl
+pps_cdev_compat_ioctl
+pps_register_cdev
+pps_unregister_cdev
+pps_unregister_source
+pps_echo_client_default
+pps_event
+pps_register_source
+path_show
+name_show
+echo_show
+mode_show
+clear_show
+assert_show
+scaled_ppm_to_ppb
+ptp_clock_getres
+ptp_clock_settime
+ptp_clock_gettime
+ptp_clock_index
+ptp_find_pin
+ptp_clock_release
+ptp_aux_kworker
+ptp_clock_adjtime
+ptp_cancel_worker_sync
+ptp_clock_unregister
+ptp_find_pin_unlocked
+ptp_schedule_worker
+ptp_clock_register
+ptp_clock_event
+ptp_disable_pinfunc
+ptp_set_pinfunc
+ptp_open
+ptp_ioctl
+ptp_poll
+ptp_read
+ptp_is_attribute_visible
+pps_enable_store
+period_store
+extts_enable_store
+pps_show
+n_pins_show
+n_per_out_show
+n_ext_ts_show
+n_alarm_show
+max_adj_show
+clock_name_show
+extts_fifo_show
+ptp_pin_name2index
+ptp_pin_store
+ptp_pin_show
+ptp_populate_pin_groups
+ptp_cleanup_pin_groups
+mt6323_pwrc_remove
+mt6323_pwrc_probe
+mt6323_do_pwroff
+restart_poweroff_remove
+restart_poweroff_do_poweroff
+restart_poweroff_probe
+power_supply_am_i_supplied
+power_supply_is_system_supplied
+power_supply_put
+power_supply_dev_release
+power_supply_powers
+power_supply_reg_notifier
+power_supply_unreg_notifier
+power_supply_get_by_name
+__power_supply_is_system_supplied
+power_supply_set_battery_charged
+power_supply_set_property
+power_supply_property_is_writeable
+power_supply_external_power_changed
+ps_set_cur_charge_cntl_limit
+power_supply_get_drvdata
+power_supply_changed
+power_supply_set_input_current_limit_from_supplier
+power_supply_match_device_by_name
+power_supply_put_battery_info
+power_supply_temp2resist_simple
+power_supply_ocv2cap_simple
+power_supply_unregister
+devm_power_supply_release
+power_supply_deferred_register_work
+power_supply_changed_work
+power_supply_batinfo_ocv2cap
+__power_supply_is_supplied_by
+__power_supply_am_i_supplied
+__power_supply_get_supplier_max_current
+__power_supply_changed_work
+power_supply_get_battery_info
+power_supply_get_property
+ps_get_max_charge_cntl_limit
+ps_get_cur_charge_cntl_limit
+power_supply_read_temp
+__power_supply_register
+power_supply_register
+power_supply_register_no_ws
+devm_power_supply_register
+devm_power_supply_register_no_ws
+power_supply_find_ocv2cap_table
+power_supply_attr_is_visible
+power_supply_store_property
+power_supply_show_property
+add_prop_uevent
+power_supply_init_attrs
+power_supply_uevent
+power_supply_update_leds
+power_supply_create_triggers
+power_supply_remove_triggers
+power_supply_hwmon_bitmap_free
+power_supply_hwmon_read_string
+power_supply_hwmon_to_property
+power_supply_hwmon_write
+power_supply_hwmon_read
+power_supply_hwmon_is_visible
+power_supply_add_hwmon_sysfs
+power_supply_remove_hwmon_sysfs
+cm_timer_func
+cm_suspend_noirq
+is_ext_pwr_online
+is_batt_present
+get_batt_uV
+charger_extcon_notifier
+charger_externally_control_show
+charger_state_show
+charger_name_show
+cm_get_battery_temperature
+charger_extcon_work
+is_charging
+is_polling_required
+_setup_polling
+charger_get_property
+cm_suspend_prepare
+check_charging_duration
+try_charger_enable
+_cm_monitor
+cm_monitor
+cm_monitor_poller
+charger_manager_probe
+cm_suspend_complete
+charger_manager_remove
+charger_externally_control_store
+__traceiter_hwmon_attr_show
+__traceiter_hwmon_attr_store
+__traceiter_hwmon_attr_show_string
+hwmon_dev_name_is_visible
+devm_hwmon_match
+hwmon_notify_event
+name_show
+hwmon_attr_show
+hwmon_attr_show_string
+hwmon_attr_store
+hwmon_free_attrs
+hwmon_dev_release
+hwmon_device_unregister
+devm_hwmon_release
+devm_hwmon_device_unregister
+__hwmon_device_register
+devm_hwmon_device_register_with_groups
+hwmon_device_register_with_info
+devm_hwmon_device_register_with_info
+hwmon_device_register_with_groups
+__traceiter_thermal_temperature
+__traceiter_cdev_update
+__traceiter_thermal_zone_trip
+__traceiter_thermal_power_devfreq_get_power
+__traceiter_thermal_power_devfreq_limit
+thermal_set_governor
+thermal_zone_unbind_cooling_device
+__unbind
+__find_governor.part.0
+thermal_zone_get_zone_by_name
+thermal_zone_device_set_polling
+handle_thermal_trip
+thermal_notify_framework
+thermal_release
+thermal_cooling_device_unregister
+thermal_cooling_device_release
+thermal_zone_device_unregister
+thermal_unregister_governor.part.0
+thermal_zone_device_update
+thermal_zone_device_set_mode
+thermal_zone_device_enable
+thermal_zone_device_disable
+thermal_zone_device_check
+thermal_pm_notify
+thermal_zone_bind_cooling_device
+__bind
+__thermal_cooling_device_register
+thermal_cooling_device_register
+thermal_of_cooling_device_register
+devm_thermal_of_cooling_device_register
+thermal_zone_device_register
+thermal_register_governor
+thermal_unregister_governor
+thermal_zone_device_set_policy
+thermal_build_list_of_policies
+thermal_zone_device_is_enabled
+power_actor_get_max_power
+power_actor_get_min_power
+power_actor_set_power
+thermal_zone_device_rebind_exception
+for_each_thermal_governor
+for_each_thermal_cooling_device
+for_each_thermal_zone
+thermal_zone_get_by_id
+thermal_zone_device_unbind_exception
+type_show
+cdev_type_show
+mode_store
+mode_show
+available_policies_show
+policy_store
+temp_show
+thermal_zone_passive_is_visible
+passive_store
+passive_show
+offset_show
+slope_show
+integral_cutoff_show
+k_d_show
+k_i_show
+k_pu_show
+k_po_show
+sustainable_power_show
+policy_show
+trip_point_hyst_show
+trip_point_temp_show
+trip_point_type_show
+cur_state_show
+max_state_show
+offset_store
+slope_store
+integral_cutoff_store
+k_d_store
+k_i_store
+k_pu_store
+k_po_store
+sustainable_power_store
+emul_temp_store
+trip_point_hyst_store
+trip_point_temp_store
+update_time_in_state
+reset_store
+trans_table_show
+total_trans_show
+time_in_state_ms_show
+thermal_zone_create_device_groups
+thermal_zone_destroy_device_groups
+thermal_cooling_device_stats_update
+cur_state_store
+thermal_cooling_device_setup_sysfs
+thermal_cooling_device_destroy_sysfs
+trip_point_show
+weight_show
+weight_store
+get_tz_trend
+thermal_zone_get_slope
+thermal_zone_get_offset
+get_thermal_instance
+thermal_zone_get_temp
+thermal_cdev_update
+thermal_zone_set_trips
+thermal_genl_event_tz
+thermal_genl_event_tz_trip_down
+thermal_genl_event_tz_trip_delete
+thermal_genl_event_tz_trip_add
+thermal_genl_event_cdev_state_update
+thermal_genl_event_cdev_delete
+thermal_genl_cmd_tz_get_gov
+thermal_genl_cmd_tz_get_trip
+thermal_genl_cmd_tz_get_temp
+thermal_genl_send_event
+thermal_genl_cmd_tz_get_id
+thermal_genl_cmd_cdev_get
+thermal_genl_cmd_dumpit
+thermal_genl_cmd_doit
+__thermal_genl_cmd_cdev_get
+__thermal_genl_cmd_tz_get_id
+thermal_genl_event_tz_create
+thermal_genl_event_gov_change
+thermal_genl_event_cdev_add
+thermal_genl_sampling_temp
+thermal_notify_tz_create
+thermal_notify_tz_delete
+thermal_notify_tz_enable
+thermal_notify_tz_disable
+thermal_notify_tz_trip_down
+thermal_notify_tz_trip_up
+thermal_notify_tz_trip_add
+thermal_notify_tz_trip_delete
+thermal_notify_tz_trip_change
+thermal_notify_cdev_state_update
+thermal_notify_cdev_add
+thermal_notify_cdev_delete
+thermal_notify_tz_gov_change
+temp_crit_show
+temp_input_show
+thermal_hwmon_lookup_by_type
+thermal_remove_hwmon_sysfs
+devm_thermal_hwmon_release
+thermal_add_hwmon_sysfs
+devm_thermal_add_hwmon_sysfs
+fair_share_throttle
+bang_bang_control
+thermal_zone_trip_update
+step_wise_throttle
+notify_user_space
+__traceiter_thermal_power_allocator
+__traceiter_thermal_power_allocator_pid
+estimate_pid_constants
+power_allocator_unbind
+power_allocator_throttle
+power_allocator_bind
+devfreq_cooling_get_max_state
+devfreq_cooling_get_cur_state
+get_voltage
+get_static_power
+devfreq_cooling_state2power
+devfreq_cooling_power2state
+devfreq_cooling_get_requested_power
+devfreq_cooling_set_cur_state
+devfreq_cooling_unregister
+of_devfreq_cooling_register_power
+of_devfreq_cooling_register
+devfreq_cooling_register
+watchdog_restart_notifier
+watchdog_set_restart_priority
+watchdog_reboot_notifier
+watchdog_unregister_device
+devm_watchdog_unregister_device
+__watchdog_register_device
+watchdog_register_device
+devm_watchdog_register_device
+watchdog_init_timeout
+pretimeout_available_governors_show
+watchdog_core_data_release
+pretimeout_governor_store
+pretimeout_governor_show
+nowayout_store
+nowayout_show
+wdt_is_visible
+watchdog_get_status
+bootstatus_show
+pretimeout_show
+timeout_show
+identity_show
+status_show
+timeleft_show
+watchdog_next_keepalive
+watchdog_timer_expired
+state_show
+__watchdog_ping
+watchdog_ping
+watchdog_write
+watchdog_ping_work
+watchdog_set_last_hw_keepalive
+watchdog_stop
+watchdog_release
+watchdog_cdev_unregister
+watchdog_start
+watchdog_open
+watchdog_ioctl
+watchdog_dev_register
+watchdog_dev_unregister
+watchdog_notify_pretimeout
+find_governor_by_name
+watchdog_register_governor
+watchdog_unregister_governor
+watchdog_pretimeout_available_governors_get
+watchdog_pretimeout_governor_get
+watchdog_pretimeout_governor_set
+watchdog_register_pretimeout
+watchdog_unregister_pretimeout
+pretimeout_noop
+super_90_allow_new_offset
+null_show
+no_op
+md_new_event
+uuid_show
+get_ro
+set_ro
+max_corrected_read_errors_show
+errors_show
+max_corrected_read_errors_store
+errors_store
+mismatch_cnt_show
+md_find_rdev_nr_rcu
+md_find_rdev_rcu
+cmd_match
+rdev_attr_show
+md_set_array_sectors
+md_getgeo
+md_check_events
+mdstat_poll
+md_finish_reshape
+update_raid_disks
+mddev_init
+fail_last_dev_show
+consistency_policy_show
+reshape_direction_show
+degraded_show
+suspend_hi_show
+suspend_lo_show
+min_sync_show
+sync_force_parallel_show
+sync_max_show
+sync_min_show
+last_sync_action_show
+action_show
+safe_delay_show
+ppl_size_show
+ppl_sector_show
+rdev_size_show
+new_offset_show
+offset_show
+state_show
+size_show
+chunk_size_show
+raid_disks_show
+layout_show
+consistency_policy_store
+sync_max_store
+sync_min_store
+ppl_size_store
+update_size
+strict_blocks_to_sectors
+ppl_sector_store
+recovery_start_store
+new_offset_store
+offset_store
+super_90_validate
+super_1_validate
+flush_rdev_wq
+sync_force_parallel_store
+md_wakeup_thread
+md_safemode_timeout
+md_start
+restart_array
+super_90_sync
+rdev_set_badblocks
+rdev_free
+ubb_store
+bb_store
+ubb_show
+bb_show
+mddev_delayed_delete
+rdev_delayed_delete
+lock_rdev
+find_pers
+md_free
+md_integrity_add_rdev
+md_integrity_register
+md_rdev_init
+md_end_io
+md_thread
+md_seq_open
+fail_last_dev_store
+bio_alloc_mddev
+md_bio_alloc_sync
+sync_page_io
+super_1_allow_new_offset
+md_check_no_bitmap
+rdev_need_serial
+rdev_init_serial.part.0
+rdev_uninit_serial
+mddev_suspend
+serialize_policy_show
+array_size_show
+reshape_position_show
+max_sync_show
+sync_completed_show
+sync_speed_show
+slot_show
+metadata_show
+mddev_resume
+md_error
+super_1_sync
+super_written
+md_done_sync
+rdev_clear_badblocks
+read_disk_sb.constprop.0
+super_1_load
+super_90_load
+md_register_thread
+md_start_sync
+recovery_start_show
+md_handle_request
+md_submit_flush_data
+md_submit_bio
+resync_start_show
+md_write_inc
+md_flush_request
+md_end_flush
+md_wait_for_blocked_rdev
+submit_flushes
+md_write_end
+mddev_init_writes_pending
+remove_and_add_spares
+slot_store
+md_rdev_clear
+md_import_device
+read_rdev
+unregister_md_cluster_operations
+register_md_cluster_operations
+mddev_put
+md_release
+md_seq_stop
+min_sync_store
+unregister_md_personality
+register_md_personality
+level_show
+md_seq_next
+md_unregister_thread
+mddev_detach
+__md_stop
+md_stop
+md_write_start
+max_sync_store
+mddev_unlock
+array_size_store
+reshape_direction_store
+reshape_position_store
+bitmap_store
+suspend_hi_store
+suspend_lo_store
+rdev_attr_store
+metadata_store
+resync_start_store
+chunk_size_store
+raid_disks_store
+layout_store
+rdev_size_store
+set_in_sync
+md_seq_start
+array_state_show
+md_seq_show
+md_do_sync
+mddev_find
+md_open
+md_alloc
+add_named_array
+md_probe
+md_attr_show
+md_attr_store
+mddev_create_serial_pool
+bind_rdev_to_array
+mddev_destroy_serial_pool
+serialize_policy_store
+unbind_rdev_from_array
+md_super_write
+md_super_wait
+super_1_rdev_size_change
+super_90_rdev_size_change
+md_update_sb.part.0
+md_update_sb
+size_store
+level_store
+md_reap_sync_thread
+action_store
+__md_stop_writes
+md_set_readonly
+md_stop_writes
+md_notify_reboot
+md_allow_write
+strict_strtoul_scaled
+safe_delay_store
+md_set_array_info
+md_setup_cluster
+md_cluster_stop
+md_autodetect_dev
+export_rdev
+new_dev_store
+md_kick_rdev_from_array
+do_md_stop
+add_bound_rdev
+state_store
+md_run
+do_md_run
+array_state_store
+md_check_recovery
+md_reload_sb
+md_add_new_disk
+md_ioctl
+md_compat_ioctl
+behind_writes_used_reset
+md_bitmap_wait_writes
+md_bitmap_set_pending
+md_bitmap_count_page
+end_bitmap_write
+read_page
+read_sb_page
+chunksize_show
+backlog_show
+space_show
+location_show
+can_clear_store
+metadata_store
+chunksize_store
+space_store
+timeout_store
+timeout_show
+md_bitmap_file_kick
+write_page
+md_bitmap_update_sb
+backlog_store
+metadata_show
+behind_writes_used_show
+can_clear_show
+md_bitmap_unplug
+free_buffers
+md_bitmap_file_unmap
+md_bitmap_free
+md_bitmap_file_set_bit
+md_bitmap_file_clear_bit
+md_bitmap_checkpage
+md_bitmap_get_counter
+md_bitmap_start_sync
+md_bitmap_end_sync.part.0
+md_bitmap_end_sync
+md_bitmap_close_sync.part.0
+md_bitmap_close_sync
+md_bitmap_cond_end_sync
+md_bitmap_sync_with_cluster
+md_bitmap_set_memory_bits
+md_bitmap_init_from_disk
+md_bitmap_load
+md_bitmap_endwrite
+md_bitmap_startwrite
+md_bitmap_resize
+md_bitmap_print_sb
+md_bitmap_write_all
+md_bitmap_daemon_work
+md_bitmap_dirty_bits
+md_bitmap_flush
+md_bitmap_wait_behind_writes
+md_bitmap_destroy
+md_bitmap_create
+get_bitmap_from_slot
+md_bitmap_copy_from_slot
+location_store
+md_bitmap_status
+dm_send_uevents
+dm_path_uevent
+dm_uevent_init
+dm_uevent_exit
+dm_get_reserved_bio_based_ios
+dm_device_name
+dm_put
+local_exit
+dm_bio_get_target_bio_nr
+dm_report_zones_cb
+dm_disk
+__dm_pr_register
+dm_noflush_suspending
+dm_post_suspending
+dm_start_time_ns_from_clone
+dm_dax_get_live_target
+dm_blk_getgeo
+dm_suspended
+max_io_len
+do_deferred_remove
+queue_io
+dm_queue_flush
+dm_internal_resume_fast
+dm_wq_work
+alloc_tio
+dec_pending
+unlock_fs
+__dm_resume
+dm_internal_resume
+dm_per_bio_data
+free_tio
+__map_bio
+dm_bio_from_per_bio_data
+dm_accept_partial_bio
+dm_get_queue_limits.part.0
+dm_get_queue_limits
+dm_set_target_max_io_len
+__send_duplicate_bios
+__send_empty_flush
+__split_and_process_non_flush
+dm_put_table_device
+dm_get_table_device
+dm_wait_for_completion
+__dm_suspend
+dm_internal_suspend_noflush
+dm_internal_suspend_fast
+dm_prepare_ioctl
+dm_dax_supported
+dm_pr_clear
+dm_pr_release
+dm_pr_reserve
+dm_pr_preempt
+dm_dax_zero_page_range
+dm_call_pr.constprop.0
+dm_pr_register
+dm_dax_direct_access
+dm_blk_ioctl
+dm_blk_report_zones
+dm_dax_copy_from_iter
+dm_dax_copy_to_iter
+dm_submit_bio
+dm_blk_close
+cleanup_mapped_device
+free_dev
+__dm_destroy
+dm_issue_global_event
+event_callback
+__dm_get_module_param
+dm_deleting_md
+dm_open_count
+dm_lock_for_deletion
+dm_cancel_deferred_remove
+dm_get_live_table
+dm_put_live_table
+dm_sync_table
+dm_get_geometry
+dm_set_geometry
+disable_discard
+clone_endio
+disable_write_same
+disable_write_zeroes
+dm_create
+dm_lock_md_type
+dm_unlock_md_type
+dm_set_md_type
+dm_get_md_type
+dm_get_immutable_target_type
+dm_setup_md_queue
+dm_get_mdptr
+dm_set_mdptr
+dm_get
+dm_blk_open
+dm_get_md
+dm_hold
+dm_destroy
+dm_destroy_immediate
+dm_swap_table
+dm_suspend
+dm_resume
+dm_kobject_uevent
+dm_next_uevent_seq
+dm_get_event_nr
+dm_wait_event
+dm_uevent_add
+dm_kobject
+dm_get_from_kobject
+dm_suspended_md
+dm_suspended_internally_md
+dm_test_deferred_remove_flag
+dm_alloc_md_mempools
+dm_free_md_mempools
+dm_vcalloc
+dm_shift_arg
+dm_table_set_type
+device_is_rq_stackable
+count_device
+device_is_zoned_model
+device_matches_zone_sectors
+device_flush_capable
+device_not_write_same_capable
+device_not_write_zeroes_capable
+dm_table_get_mode
+dm_table_get_md
+device_is_not_random
+device_is_nonrot
+device_not_nowait_capable
+device_not_discard_capable
+device_not_secure_erase_capable
+device_requires_stable_pages
+dm_table_supports_flush
+dm_table_all_devices_attribute
+dm_table_device_name
+dm_get_dev_t
+dm_read_arg_group
+device_supports_dax
+dm_table_get_integrity_disk
+dm_table_event
+validate_hardware_logical_block_alignment
+device_area_is_invalid
+dm_set_device_limits
+device_dax_synchronous
+device_dax_write_cache_enabled
+dm_consume_args
+dm_table_run_md_queue_async
+realloc_argv
+dm_put_device
+dm_get_device
+dm_read_arg
+dm_table_create
+dm_table_destroy
+dm_split_args
+dm_table_add_target
+dm_table_supports_dax
+dm_table_get_type
+dm_table_get_immutable_target_type
+dm_table_get_immutable_target
+dm_table_get_wildcard_target
+dm_table_bio_based
+dm_table_request_based
+dm_table_free_md_mempools
+dm_table_get_md_mempools
+dm_table_complete
+dm_table_event_callback
+dm_table_get_target
+dm_table_find_target
+dm_table_has_no_data_devices
+dm_calculate_queue_limits
+dm_table_set_restrictions
+dm_table_get_num_targets
+dm_table_get_devices
+dm_table_presuspend_targets
+dm_table_presuspend_undo_targets
+dm_table_postsuspend_targets
+dm_table_resume_targets
+io_err_dtr
+io_err_map
+io_err_clone_and_map_rq
+io_err_release_clone_rq
+io_err_dax_direct_access
+io_err_ctr
+dm_unregister_target
+dm_register_target
+get_target_type
+dm_get_target_type
+dm_put_target_type
+dm_target_iterate
+dm_target_exit
+linear_prepare_ioctl
+linear_iterate_devices
+linear_dax_zero_page_range
+linear_dax_copy_to_iter
+linear_dax_copy_from_iter
+linear_dax_direct_access
+linear_report_zones
+linear_status
+linear_map
+linear_dtr
+linear_ctr
+dm_linear_exit
+stripe_iterate_devices
+stripe_map_sector
+stripe_dax_zero_page_range
+stripe_map_range_sector
+stripe_dax_copy_to_iter
+stripe_dax_copy_from_iter
+stripe_dax_direct_access
+stripe_io_hints
+stripe_status
+stripe_end_io
+stripe_map
+stripe_dtr
+trigger_event
+stripe_ctr
+dm_stripe_exit
+check_name
+dev_arm_poll
+dm_poll
+dm_release
+__get_uuid_cell
+__get_name_cell
+dm_open
+list_version_get_needed
+list_version_get_info
+__list_versions
+get_target_version
+list_versions
+dm_get_inactive_table
+dm_get_live_or_inactive_table
+dm_copy_name_and_uuid
+__find_device_hash_cell
+find_device
+dev_set_geometry
+list_devices
+__dev_status
+target_message
+dev_status
+retrieve_status
+table_status
+table_deps
+table_load
+dev_wait
+dev_suspend
+dev_rename
+free_params
+ctl_ioctl
+dm_ctl_ioctl
+dm_compat_ctl_ioctl
+dm_hash_insert
+dev_create
+table_clear
+__hash_remove
+dm_hash_remove_all
+remove_all
+dev_remove
+dm_deferred_remove
+dm_interface_exit
+dm_io_client_destroy
+list_get_page
+list_next_page
+bio_get_page
+vm_next_page
+km_next_page
+km_get_page
+vm_get_page
+sync_io_complete
+dec_count
+endio
+bio_next_page
+dispatch_io
+sync_io
+dm_io
+dm_io_client_create
+dm_io_exit
+push
+dm_kcopyd_prepare_callback
+dispatch_job
+dm_kcopyd_do_callback
+complete_io
+segment_complete
+alloc_pl
+kcopyd_put_pages
+run_pages_job
+drop_pages
+run_complete_job
+process_jobs
+do_work
+client_free_pages.part.0
+dm_kcopyd_copy
+dm_kcopyd_zero
+dm_kcopyd_client_create
+dm_kcopyd_client_destroy
+run_io_job
+dm_kcopyd_exit
+dm_attr_use_blk_mq_show
+dm_attr_suspended_show
+dm_attr_store
+dm_attr_show
+dm_attr_uuid_show
+dm_attr_name_show
+dm_sysfs_init
+dm_sysfs_exit
+free_shared_memory
+dm_stat_free
+dm_stat_round
+dm_jiffies_to_msec64
+__dm_stat_init_temporary_percpu_totals
+__check_shared_memory
+__dm_stat_clear
+message_stats_print
+dm_kvzalloc
+dm_stats_init
+dm_stats_cleanup
+dm_stats_account_io
+dm_stats_message
+dm_statistics_exit
+dm_get_reserved_rq_based_ios
+dm_rq_bio_constructor
+dm_mq_init_request
+dm_mq_kick_requeue_list
+end_clone_request
+end_clone_bio
+rq_end_stats.part.0
+dm_requeue_original_request
+dm_softirq_done
+dm_mq_queue_rq
+dm_request_based
+dm_start_queue
+dm_stop_queue
+dm_attr_rq_based_seq_io_merge_deadline_show
+dm_attr_rq_based_seq_io_merge_deadline_store
+dm_mq_init_request_queue
+dm_mq_cleanup_mapped_device
+dm_kobject_release
+edac_get_owner
+mci_release
+edac_mc_free
+edac_has_mcs
+find_mci_by_dev
+edac_mc_find
+edac_mc_find_csrow_by_page
+edac_mc_add_mc_with_groups
+edac_mc_del_mc
+edac_mc_workq_function
+edac_raw_mc_handle_error
+edac_mc_handle_error
+edac_mc_alloc
+edac_dimm_info_location
+edac_align_ptr
+edac_mc_reset_delay_period
+edac_device_alloc_index
+edac_device_free_ctl_info
+edac_device_workq_function
+edac_device_del_device
+edac_device_handle_ce_count
+edac_device_handle_ue_count
+edac_device_add_device
+edac_device_alloc_ctl_info
+edac_device_reset_delay_period
+dimm_release
+dimmdev_location_show
+mci_reset_counters_store
+edac_set_poll_msec
+mci_sdram_scrub_rate_store
+mci_sdram_scrub_rate_show
+mci_ce_count_show
+mci_ue_count_show
+mci_ce_noinfo_show
+mci_ue_noinfo_show
+mci_seconds_show
+mci_size_mb_show
+mci_ctl_name_show
+dimmdev_ue_count_show
+dimmdev_ce_count_show
+dimmdev_edac_mode_show
+dimmdev_dev_type_show
+dimmdev_mem_type_show
+dimmdev_size_show
+mci_max_location_show
+dimmdev_label_store
+dimmdev_label_show
+mc_attr_release
+mci_attr_is_visible
+edac_mc_get_log_ue
+edac_mc_get_log_ce
+edac_mc_get_panic_on_ue
+edac_mc_get_poll_msec
+edac_remove_sysfs_mci_device
+edac_create_sysfs_mci_device
+edac_mc_sysfs_exit
+edac_get_sysfs_subsys
+edac_op_state_to_string
+edac_device_ctl_poll_msec_store
+edac_dev_ctl_info_show
+edac_dev_ctl_info_store
+edac_dev_instance_show
+edac_dev_instance_store
+edac_dev_block_show
+edac_dev_block_store
+edac_device_ctrl_instance_release
+edac_device_ctrl_block_release
+edac_device_ctl_log_ce_store
+edac_device_ctl_log_ue_store
+edac_device_ctl_panic_on_ue_store
+edac_device_ctl_poll_msec_show
+edac_device_ctl_log_ce_show
+edac_device_ctl_log_ue_show
+edac_device_ctl_panic_on_ue_show
+instance_ue_count_show
+instance_ce_count_show
+block_ue_count_show
+block_ce_count_show
+edac_device_ctrl_master_release
+edac_device_remove_main_sysfs_attributes
+edac_device_delete_block.isra.0
+edac_device_delete_instance
+edac_device_register_sysfs_main_kobj
+edac_device_unregister_sysfs_main_kobj
+edac_device_create_sysfs
+edac_device_remove_sysfs
+edac_queue_work
+edac_mod_work
+edac_stop_work
+edac_workqueue_setup
+edac_workqueue_teardown
+edac_pci_alloc_index
+edac_pci_free_ctl_info
+edac_pci_add_device
+edac_pci_del_device
+edac_pci_release_generic_ctl
+edac_pci_generic_check
+edac_pci_workq_function
+edac_pci_alloc_ctl_info
+edac_pci_create_generic_ctl
+edac_pci_release_main_kobj
+edac_pci_instance_release
+get_pci_parity_status
+instance_npe_count_show
+instance_pe_count_show
+edac_pci_instance_show
+edac_pci_instance_store
+edac_pci_dev_show
+edac_pci_dev_store
+edac_pci_int_show
+edac_pci_int_store
+edac_pci_main_kobj_teardown
+edac_pci_do_parity_check.part.0
+edac_pci_handle_pe
+edac_pci_handle_npe
+edac_pci_get_check_errors
+edac_pci_get_poll_msec
+edac_pci_create_sysfs
+edac_pci_remove_sysfs
+edac_pci_do_parity_check
+edac_pci_clear_parity_errors
+enumerate_dimms
+ghes_edac_report_mem_error
+ghes_edac_register
+ghes_edac_unregister
+eisa_bus_uevent
+eisa_driver_unregister
+eisa_show_modalias
+eisa_show_sig
+eisa_bus_match
+eisa_driver_register
+eisa_show_state
+virtual_eisa_release
+_set_opp_bw
+_set_opp_voltage
+_set_required_opp
+_set_required_opps
+_opp_kref_release
+dev_pm_opp_put
+_opp_detach_genpd
+dev_pm_opp_put_opp_table
+dev_pm_opp_put_supported_hw
+dev_pm_opp_put_prop_name
+dev_pm_opp_put_clkname
+dev_pm_opp_unregister_set_opp_helper
+dev_pm_opp_detach_genpd
+dev_pm_opp_put_regulators
+dev_pm_opp_get_voltage
+dev_pm_opp_get_level
+dev_pm_opp_is_turbo
+dev_pm_opp_get_freq
+_find_opp_table_unlocked
+_find_freq_ceil
+_find_opp_table
+dev_pm_opp_get_max_clock_latency
+dev_pm_opp_get_max_volt_latency
+dev_pm_opp_get_max_transition_latency
+dev_pm_opp_get_suspend_opp_freq
+dev_pm_opp_set_bw
+dev_pm_opp_remove
+dev_pm_opp_remove_all_dynamic
+dev_pm_opp_register_notifier
+dev_pm_opp_unregister_notifier
+dev_pm_opp_find_freq_exact
+dev_pm_opp_find_level_exact
+dev_pm_opp_find_freq_ceil
+dev_pm_opp_find_freq_floor
+dev_pm_opp_find_freq_ceil_by_volt
+dev_pm_opp_adjust_voltage
+_opp_set_availability
+dev_pm_opp_enable
+dev_pm_opp_disable
+_get_opp_count
+dev_pm_opp_get_opp_count
+dev_pm_opp_set_rate
+_add_opp_dev
+_opp_get_opp_table.isra.0
+dev_pm_opp_get_opp_table
+dev_pm_opp_set_supported_hw
+dev_pm_opp_set_prop_name
+dev_pm_opp_set_regulators
+dev_pm_opp_set_clkname
+dev_pm_opp_register_set_opp_helper
+dev_pm_opp_attach_genpd
+_get_opp_table_kref
+dev_pm_opp_get_opp_table_indexed
+_opp_free
+dev_pm_opp_get
+_opp_remove_all_static
+dev_pm_opp_remove_table
+_opp_allocate
+_opp_compare_key
+_opp_add
+_opp_add_v1
+dev_pm_opp_add
+dev_pm_opp_xlate_performance_state
+dev_pm_opp_set_sharing_cpus
+dev_pm_opp_free_cpufreq_table
+dev_pm_opp_init_cpufreq_table
+dev_pm_opp_get_sharing_cpus
+_dev_pm_opp_cpumask_remove_table
+dev_pm_opp_cpumask_remove_table
+bw_name_read
+opp_set_dev_name
+opp_list_debug_create_link
+opp_debug_remove_one
+opp_debug_create_one
+opp_debug_register
+opp_debug_unregister
+cpufreq_get_current_driver
+have_governor_per_policy
+get_governor_parent_kobj
+cpufreq_get_driver_data
+cpufreq_cpu_get_raw
+cpufreq_generic_init
+cpufreq_generic_get
+cpufreq_cpu_get
+cpufreq_cpu_put
+cpufreq_quick_get
+cpufreq_quick_get_max
+cpufreq_get_hw_max_freq
+show_scaling_driver
+cpufreq_show_cpus
+show_related_cpus
+show_affected_cpus
+show_scaling_available_governors
+show_scaling_max_freq
+show_scaling_min_freq
+show_cpuinfo_transition_latency
+show_cpuinfo_max_freq
+show_cpuinfo_min_freq
+cpufreq_get_policy
+show
+cpufreq_notifier_max
+cpufreq_notifier_min
+find_governor
+cpufreq_register_governor
+get_governor
+cpufreq_parse_policy
+cpufreq_boost_set_sw
+store_scaling_setspeed
+store_scaling_max_freq
+store_scaling_min_freq
+store
+cpufreq_sysfs_release
+add_cpu_dev_symlink
+cpufreq_boost_enabled
+cpufreq_disable_fast_switch
+show_boost
+cpufreq_exit_governor
+cpufreq_policy_transition_delay_us
+cpufreq_notify_transition
+cpufreq_freq_transition_end
+show_scaling_setspeed
+show_scaling_governor
+show_bios_limit
+cpufreq_register_notifier
+cpufreq_unregister_notifier
+create_boost_sysfs_file
+cpufreq_enable_boost_support
+cpufreq_policy_put_kobj
+cpufreq_policy_free
+remove_cpu_dev_symlink.isra.0
+cpufreq_register_driver
+cpufreq_enable_fast_switch
+get_cpu_idle_time
+cpufreq_unregister_driver
+cpufreq_driver_resolve_freq
+cpufreq_freq_transition_begin
+cpufreq_verify_current_freq
+__cpufreq_driver_target
+cpufreq_generic_suspend
+cpufreq_driver_target
+cpufreq_driver_fast_switch
+cpufreq_unregister_governor
+__cpufreq_get
+cpufreq_get
+show_cpuinfo_cur_freq
+cpufreq_supports_freq_invariance
+disable_cpufreq
+cpufreq_cpu_release
+cpufreq_cpu_acquire
+cpufreq_cpu_acquire
+show_scaling_cur_freq
+cpufreq_driver_test_flags
+cpufreq_driver_test_flags
+cpufreq_init_governor
+cpufreq_start_governor
+cpufreq_resume
+cpufreq_stop_governor
+cpufreq_set_policy
+refresh_frequency_limits
+cpufreq_update_policy
+cpufreq_update_limits
+handle_update
+store_scaling_governor
+cpufreq_suspend
+cpufreq_offline
+cpuhp_cpufreq_offline
+cpufreq_remove_dev
+cpufreq_online
+cpuhp_cpufreq_online
+cpufreq_add_dev
+cpufreq_boost_trigger_state
+store_boost
+policy_has_boost_freq
+cpufreq_table_index_unsorted
+show_available_freqs
+scaling_available_frequencies_show
+scaling_boost_frequencies_show
+cpufreq_frequency_table_get_index
+cpufreq_frequency_table_verify
+cpufreq_generic_frequency_table_verify
+cpufreq_frequency_table_cpuinfo
+cpufreq_table_validate_and_sort
+store_reset
+show_time_in_state
+show_trans_table
+show_total_trans
+cpufreq_stats_free_table
+cpufreq_stats_create_table
+cpufreq_stats_record_transition
+cpufreq_gov_performance_limits
+cpufreq_fallback_governor
+cpufreq_gov_powersave_limits
+cpufreq_set
+cpufreq_userspace_policy_limits
+cpufreq_userspace_policy_stop
+show_speed
+cpufreq_userspace_policy_exit
+cpufreq_userspace_policy_start
+cpufreq_userspace_policy_init
+od_free
+od_start
+od_exit
+od_dbs_update
+store_powersave_bias
+store_up_threshold
+store_io_is_busy
+store_ignore_nice_load
+show_io_is_busy
+show_powersave_bias
+show_ignore_nice_load
+show_sampling_down_factor
+show_up_threshold
+show_sampling_rate
+store_sampling_down_factor
+od_set_powersave_bias
+od_register_powersave_bias_handler
+od_unregister_powersave_bias_handler
+od_alloc
+od_init
+generic_powersave_bias_target
+cs_free
+cs_start
+cs_exit
+cs_dbs_update
+store_freq_step
+store_down_threshold
+store_up_threshold
+store_sampling_down_factor
+show_freq_step
+show_ignore_nice_load
+show_down_threshold
+show_up_threshold
+show_sampling_down_factor
+show_sampling_rate
+store_ignore_nice_load
+cs_alloc
+cs_init
+dbs_irq_work
+store_sampling_rate
+dbs_work_handler
+gov_update_cpu_data
+free_policy_dbs_info
+cpufreq_dbs_governor_exit
+cpufreq_dbs_governor_start
+cpufreq_dbs_governor_stop
+cpufreq_dbs_governor_limits
+dbs_update_util_handler
+cpufreq_dbs_governor_init
+dbs_update
+governor_show
+governor_store
+gov_attr_set_get
+gov_attr_set_init
+gov_attr_set_put
+boost_set_msr
+boost_set_msr_each
+cpu_freq_read_intel
+cpu_freq_write_intel
+cpu_freq_read_amd
+cpu_freq_write_amd
+cpufreq_boost_down_prep
+sw_any_bug_found
+extract_freq
+do_drv_read
+do_drv_write
+acpi_cpufreq_fast_switch
+acpi_cpufreq_resume
+set_boost
+store_cpb
+show_freqdomain_cpus
+acpi_cpufreq_cpu_ready
+acpi_cpufreq_cpu_exit
+get_cur_val
+acpi_cpufreq_target
+get_cur_freq_on_cpu
+cpu_freq_write_io
+cpu_freq_read_io
+cpufreq_boost_online
+show_cpb
+acpi_cpufreq_cpu_init
+pending_bit_stuck
+powernowk8_get
+powernowk8_target
+print_basics
+count_off_vst
+query_current_values_with_pending_wait
+query_values_on_cpu
+write_new_vid
+write_new_fid
+powernowk8_cpu_init_on_cpu
+powernow_k8_acpi_pst_values.part.0
+powernowk8_init
+powernowk8_target_fn
+powernowk8_cpu_exit
+powernowk8_cpu_init
+check_supported_cpu
+pcc_cpufreq_cpu_exit
+pcc_cpufreq_verify
+pcc_cpufreq_cpu_init
+pcc_cpufreq_target
+pcc_get_freq
+extract_clock
+get_cur_freq
+centrino_cpu_exit
+centrino_target
+centrino_cpu_init
+atom_get_min_pstate
+atom_get_max_pstate
+atom_get_turbo_pstate
+core_get_min_pstate
+core_get_max_pstate_physical
+knl_get_aperf_mperf_shift
+airmont_get_scaling
+silvermont_get_scaling
+core_get_max_pstate
+knl_get_turbo_pstate
+core_get_turbo_pstate
+intel_pstate_set_epb
+intel_pstste_sched_itmt_work_fn
+intel_pstate_update_policies
+show_energy_performance_available_preferences
+show_energy_efficiency
+show_min_perf_pct
+show_max_perf_pct
+show_status
+store_hwp_dynamic_boost
+intel_pstate_suspend
+intel_pstate_cpu_exit
+atom_get_vid
+min_perf_pct_min
+intel_pstate_get_hwp_max
+intel_cpufreq_cpu_exit
+intel_pstate_get_epp
+intel_pstate_hwp_enable
+intel_pstate_hwp_reenable
+show_base_frequency
+show_energy_performance_preference
+show_num_pstates
+update_qos_request
+store_min_perf_pct
+store_max_perf_pct
+atom_get_val
+core_get_val
+intel_pstate_update_perf_limits
+intel_pstate_exit_perf_limits
+show_hwp_dynamic_boost
+intel_pstate_clear_update_util_hook
+intel_pstate_stop_cpu
+intel_pstate_driver_cleanup
+intel_pstate_init_acpi_perf_limits
+intel_pstate_cpu_online
+intel_pstate_register_driver
+store_status
+store_energy_performance_preference
+show_turbo_pct
+intel_pstate_set_pstate
+intel_pstate_cpu_offline
+set_power_ctl_ee_state
+intel_pstate_resume
+store_energy_efficiency
+intel_pstate_verify_cpu_policy
+intel_pstate_verify_policy
+intel_cpufreq_verify_policy
+show_no_turbo
+intel_pstate_update_util
+intel_pstate_update_limits
+store_no_turbo
+intel_cpufreq_update_pstate
+intel_cpufreq_fast_switch
+intel_cpufreq_target
+__intel_pstate_cpu_init
+intel_pstate_cpu_init
+intel_cpufreq_cpu_init
+intel_pstate_set_policy
+cpuidle_resume_and_unlock
+__cpuidle_unregister_device
+cpuidle_enable_device
+cpuidle_register_device
+cpuidle_disable_device
+cpuidle_disabled
+disable_cpuidle
+cpuidle_not_available
+cpuidle_play_dead
+cpuidle_use_deepest_state
+cpuidle_find_deepest_state
+cpuidle_enter_s2idle
+cpuidle_enter_state
+cpuidle_select
+cpuidle_enter
+cpuidle_reflect
+cpuidle_poll_time
+cpuidle_install_idle_handler
+cpuidle_uninstall_idle_handler
+cpuidle_pause_and_lock
+cpuidle_unregister_device.part.0
+cpuidle_unregister_device
+cpuidle_unregister
+cpuidle_register
+cpuidle_pause
+cpuidle_resume
+cpuidle_get_driver
+cpuidle_setup_broadcast_timer
+cpuidle_get_cpu_driver
+cpuidle_unregister_driver
+cpuidle_register_driver
+cpuidle_driver_state_disabled
+cpuidle_switch_governor.part.0
+cpuidle_find_governor
+cpuidle_switch_governor
+cpuidle_register_governor
+cpuidle_governor_latency_req
+show_current_governor
+cpuidle_state_sysfs_release
+cpuidle_sysfs_release
+cpuidle_state_show
+cpuidle_state_store
+show_state_default_status
+show_state_below
+show_state_above
+show_state_disable
+show_state_rejected
+show_state_usage
+show_state_power_usage
+show_state_s2idle_time
+show_state_s2idle_usage
+cpuidle_store
+cpuidle_show
+store_current_governor
+show_available_governors
+store_state_disable
+show_state_desc
+show_current_driver
+show_state_time
+show_state_name
+show_state_exit_latency
+show_state_target_residency
+cpuidle_add_interface
+cpuidle_remove_interface
+cpuidle_add_device_sysfs
+cpuidle_remove_device_sysfs
+cpuidle_add_sysfs
+cpuidle_remove_sysfs
+ladder_enable_device
+ladder_reflect
+ladder_select_state
+menu_reflect
+menu_enable_device
+menu_select
+teo_reflect
+teo_select
+teo_enable_device
+haltpoll_enable_device
+haltpoll_select
+haltpoll_reflect
+cpuidle_poll_state_init
+__traceiter_mmc_request_start
+__traceiter_mmc_request_done
+mmc_cqe_post_req
+mmc_can_erase
+mmc_can_discard
+mmc_card_is_blockaddr
+mmc_erase_group_aligned
+mmc_mrq_pr_debug
+mmc_is_req_done
+mmc_mrq_prep
+mmc_wait_done
+mmc_set_data_timeout
+mmc_mmc_erase_timeout
+__mmc_claim_host
+mmc_get_card
+mmc_release_host
+mmc_put_card
+mmc_can_secure_erase_trim
+mmc_cqe_start_req
+mmc_request_done
+mmc_do_calc_max_discard
+mmc_calc_max_discard
+mmc_can_trim
+mmc_command_done
+mmc_cqe_request_done
+__mmc_start_request
+mmc_start_request
+mmc_wait_for_req_done
+mmc_wait_for_req
+mmc_wait_for_cmd
+mmc_cqe_recovery
+mmc_set_blocklen
+mmc_do_erase
+mmc_erase
+mmc_sw_reset
+mmc_hw_reset
+mmc_set_chip_select
+mmc_set_clock
+mmc_execute_tuning
+mmc_set_bus_mode
+mmc_set_bus_width
+mmc_set_initial_state
+mmc_vddrange_to_ocrmask
+mmc_of_find_child_device
+mmc_set_signal_voltage
+mmc_set_initial_signal_voltage
+mmc_host_set_uhs_voltage
+mmc_set_timing
+mmc_set_driver_type
+mmc_select_drive_strength
+mmc_power_up
+mmc_power_off
+mmc_power_cycle
+mmc_select_voltage
+mmc_set_uhs_voltage
+mmc_attach_bus
+mmc_detach_bus
+_mmc_detect_change
+mmc_detect_change
+mmc_pm_notify
+mmc_init_erase
+mmc_can_sanitize
+_mmc_detect_card_removed
+mmc_detect_card_removed
+mmc_rescan
+mmc_start_host
+mmc_stop_host
+mmc_register_pm_notifier
+mmc_unregister_pm_notifier
+mmc_bus_match
+mmc_bus_probe
+mmc_bus_remove
+mmc_runtime_suspend
+mmc_runtime_resume
+mmc_bus_shutdown
+mmc_bus_resume
+mmc_bus_suspend
+mmc_bus_uevent
+mmc_register_driver
+mmc_unregister_driver
+mmc_release_card
+type_show
+mmc_register_bus
+mmc_unregister_bus
+mmc_alloc_card
+mmc_add_card
+mmc_remove_card
+mmc_retune_timer_stop
+mmc_of_parse_voltage
+mmc_free_host
+mmc_retune_timer
+mmc_host_classdev_release
+mmc_of_parse
+mmc_add_host
+mmc_remove_host
+mmc_retune_release.part.0
+mmc_retune_release
+mmc_retune_pause
+mmc_alloc_host
+mmc_retune_unpause
+mmc_register_host_class
+mmc_unregister_host_class
+mmc_retune_enable
+mmc_retune_disable
+mmc_retune_hold
+mmc_retune
+mmc_name_show
+mmc_set_bus_speed
+mmc_select_hs400
+mmc_remove
+mmc_alive
+mmc_resume
+mmc_dsr_show
+mmc_rca_show
+mmc_ocr_show
+mmc_rel_sectors_show
+mmc_raw_rpmb_size_mult_show
+mmc_enhanced_area_size_show
+mmc_enhanced_area_offset_show
+mmc_serial_show
+mmc_life_time_show
+mmc_pre_eol_info_show
+mmc_rev_show
+mmc_prv_show
+mmc_oemid_show
+mmc_manfid_show
+mmc_hwrev_show
+mmc_preferred_erase_size_show
+mmc_erase_size_show
+mmc_date_show
+mmc_csd_show
+mmc_cid_show
+mmc_part_add
+mmc_select_driver_type
+mmc_select_bus_width
+_mmc_suspend
+mmc_detect
+mmc_cmdq_en_show
+mmc_enhanced_rpmb_supported_show
+mmc_ffu_capable_show
+mmc_fwrev_show
+mmc_runtime_suspend
+mmc_suspend
+mmc_init_card
+_mmc_hw_reset
+_mmc_resume
+mmc_runtime_resume
+mmc_shutdown
+mmc_hs200_to_hs400
+mmc_hs400_to_hs200
+mmc_attach_mmc
+mmc_abort_tuning
+mmc_send_cxd_data
+__mmc_send_status
+mmc_send_status
+_mmc_select_card
+mmc_send_cxd_native
+mmc_send_bus_test
+mmc_switch_status_error.part.0
+__mmc_poll_for_busy
+mmc_send_tuning
+mmc_get_ext_csd.part.0
+mmc_get_ext_csd
+mmc_select_card
+mmc_deselect_cards
+mmc_set_dsr
+mmc_go_idle
+mmc_send_op_cond
+mmc_set_relative_addr
+mmc_send_csd
+mmc_send_cid
+mmc_spi_read_ocr
+mmc_spi_set_crc
+mmc_switch_status
+mmc_poll_for_busy
+__mmc_switch
+mmc_switch
+mmc_flush_cache
+mmc_cmdq_switch
+mmc_cmdq_enable
+mmc_cmdq_disable
+mmc_sanitize
+mmc_run_bkops
+mmc_bus_test
+mmc_can_ext_csd
+mmc_name_show
+sd_std_is_visible
+mmc_dsr_show
+mmc_rca_show
+mmc_ocr_show
+mmc_serial_show
+mmc_oemid_show
+mmc_manfid_show
+mmc_hwrev_show
+mmc_fwrev_show
+mmc_preferred_erase_size_show
+mmc_erase_size_show
+mmc_date_show
+mmc_ssr_show
+mmc_scr_show
+mmc_csd_show
+mmc_cid_show
+info4_show
+info3_show
+info2_show
+info1_show
+mmc_revision_show
+mmc_device_show
+mmc_vendor_show
+sd_get_host_max_current
+mmc_sd_remove
+mmc_sd_alive
+mmc_sd_resume
+_mmc_sd_suspend
+mmc_sd_detect
+mmc_read_switch
+mmc_sd_init_uhs_card.part.0
+mmc_sd_runtime_suspend
+mmc_sd_suspend
+mmc_sd_switch_hs.part.0
+mmc_decode_cid
+mmc_sd_switch_hs
+mmc_sd_get_cid
+mmc_sd_get_csd
+mmc_sd_setup_card
+mmc_sd_init_card
+mmc_sd_hw_reset
+mmc_sd_runtime_resume
+mmc_sd_get_max_clock
+mmc_attach_sd
+mmc_app_cmd
+mmc_wait_for_app_cmd
+mmc_app_set_bus_width
+mmc_send_app_op_cond
+mmc_send_if_cond
+mmc_send_relative_addr
+mmc_app_send_scr
+mmc_sd_switch
+mmc_app_sd_status
+mmc_sdio_pre_init
+mmc_sdio_pre_suspend
+mmc_sdio_alive
+sdio_disable_wide
+mmc_rca_show
+mmc_ocr_show
+info4_show
+info3_show
+info2_show
+info1_show
+mmc_revision_show
+mmc_device_show
+mmc_vendor_show
+mmc_sdio_remove
+mmc_sdio_runtime_suspend
+mmc_sdio_suspend
+sdio_enable_4bit_bus
+mmc_sdio_switch_hs
+mmc_sdio_detect
+mmc_sdio_init_card
+mmc_sdio_reinit_card
+mmc_sdio_sw_reset
+mmc_sdio_hw_reset
+mmc_sdio_runtime_resume
+mmc_sdio_resume
+mmc_attach_sdio
+mmc_io_rw_direct_host
+mmc_send_io_op_cond
+mmc_io_rw_direct
+mmc_io_rw_extended
+sdio_reset
+sdio_match_device
+sdio_bus_match
+sdio_bus_probe
+sdio_bus_uevent
+modalias_show
+info4_show
+info3_show
+info2_show
+info1_show
+revision_show
+device_show
+vendor_show
+class_show
+sdio_register_driver
+sdio_unregister_driver
+sdio_release_func
+sdio_bus_remove
+sdio_register_bus
+sdio_unregister_bus
+sdio_alloc_func
+sdio_add_func
+sdio_remove_func
+cistpl_manfid
+cistpl_funce_common
+cis_tpl_parse
+cistpl_funce
+sdio_read_cis
+cistpl_funce_func
+cistpl_vers_1
+sdio_read_common_cis
+sdio_free_common_cis
+sdio_read_func_cis
+sdio_free_func_cis
+sdio_get_host_pm_caps
+sdio_set_host_pm_flags
+sdio_retune_crc_disable
+sdio_retune_crc_enable
+sdio_retune_hold_now
+sdio_claim_host
+sdio_release_host
+sdio_set_block_size
+sdio_readb
+sdio_writeb_readb
+sdio_f0_readb
+sdio_enable_func
+sdio_disable_func
+sdio_align_size
+sdio_io_rw_ext_helper
+sdio_memcpy_fromio
+sdio_memcpy_toio
+sdio_readsb
+sdio_writesb
+sdio_readw
+sdio_readl
+sdio_writew
+sdio_writel
+sdio_retune_release
+sdio_writeb
+sdio_f0_writeb
+sdio_single_irq_set
+sdio_signal_irq
+sdio_claim_irq
+sdio_release_irq
+process_sdio_pending_irqs
+sdio_irq_thread
+sdio_irq_work
+mmc_can_gpio_cd
+mmc_can_gpio_ro
+mmc_gpio_get_ro
+mmc_gpio_get_cd
+mmc_gpiod_request_cd_irq
+mmc_gpio_cd_irqt
+mmc_gpio_set_cd_isr
+mmc_gpiod_request_cd
+mmc_gpiod_request_ro
+mmc_gpio_set_cd_wake
+mmc_gpio_alloc
+mmc_regulator_set_voltage_if_supported
+mmc_regulator_set_vqmmc
+mmc_regulator_get_supply
+mmc_regulator_set_ocr
+mmc_clock_fops_open
+mmc_clock_opt_get
+mmc_clock_opt_set
+mmc_ios_open
+mmc_ios_show
+mmc_add_host_debugfs
+mmc_remove_host_debugfs
+mmc_add_card_debugfs
+mmc_remove_card_debugfs
+led_set_brightness_sync
+led_update_brightness
+led_sysfs_disable
+led_sysfs_enable
+led_init_core
+led_stop_software_blink
+set_brightness_delayed
+led_compose_name
+led_set_brightness_nopm
+led_set_brightness_nosleep
+led_timer_function
+led_blink_setup
+led_blink_set
+led_blink_set_oneshot
+led_set_brightness
+led_get_default_pattern
+of_led_get
+devm_of_led_get
+devm_led_classdev_match
+led_classdev_notify_brightness_hw_changed
+led_classdev_resume
+led_resume
+led_classdev_suspend
+led_suspend
+led_put
+brightness_hw_changed_show
+max_brightness_show
+brightness_show
+led_classdev_unregister
+devm_led_classdev_release
+brightness_store
+devm_led_classdev_unregister
+led_classdev_register_ext
+devm_led_classdev_register_ext
+led_trigger_snprintf
+led_trigger_format
+led_trigger_read
+led_trigger_set
+led_trigger_remove
+led_trigger_write
+led_trigger_set_default
+led_trigger_unregister
+led_trigger_unregister_simple
+devm_led_trigger_release
+led_trigger_rename_static
+led_trigger_event
+led_trigger_register
+devm_led_trigger_register
+led_trigger_blink_oneshot
+led_trigger_register_simple
+led_trigger_blink
+ledtrig_disk_activity
+ledtrig_mtd_activity
+ledtrig_cpu
+ledtrig_prepare_down_cpu
+ledtrig_online_cpu
+ledtrig_cpu_syscore_shutdown
+ledtrig_cpu_syscore_resume
+ledtrig_cpu_syscore_suspend
+led_panic_blink
+led_trigger_panic_notifier
+dmi_get_system_info
+dmi_decode_table
+dmi_walk
+dmi_memdev_name
+dmi_memdev_size
+dmi_memdev_type
+dmi_memdev_handle
+raw_table_read
+dmi_find_device
+dmi_match
+dmi_matches
+dmi_check_system
+dmi_first_match
+dmi_name_in_vendors
+dmi_get_date
+dmi_get_bios_year
+dmi_name_in_serial
+edd_release
+edd_has_mbr_signature
+edd_has_edd_info
+edd_attr_show
+edd_has_legacy_max_cylinder
+edd_has_legacy_max_head
+edd_has_legacy_sectors_per_track
+edd_has_default_cylinders
+edd_has_default_heads
+edd_has_default_sectors_per_track
+edd_has_edd30
+edd_show_mbr_signature
+edd_show_default_sectors_per_track
+edd_show_default_heads
+edd_show_default_cylinders
+edd_show_legacy_sectors_per_track
+edd_show_legacy_max_head
+edd_show_legacy_max_cylinder
+edd_show_sectors
+edd_show_info_flags
+edd_show_extensions
+edd_show_version
+edd_show_host_bus
+edd_show_interface
+edd_show_raw_data
+sys_dmi_field_show
+get_modalias
+dmi_dev_uevent
+sys_dmi_modalias_show
+memmap_attr_show
+type_show
+end_show
+start_show
+start_show
+fw_platform_size_show
+systab_show
+update_efi_random_seed
+efi_mem_reserve_iomem
+efi_runtime_disabled
+__efi_soft_reserve_enabled
+efi_mem_desc_lookup
+efi_mem_attributes
+efi_mem_type
+efi_status_to_err
+validate_boot_order
+validate_uint16
+validate_ascii_string
+efivars_kobject
+efivar_supports_writes
+efivar_variable_is_removable
+efivar_entry_iter_begin
+efivar_entry_add
+efivar_entry_remove
+efivar_entry_iter_end
+efivars_unregister
+__efivar_entry_delete
+efivar_entry_size
+__efivar_entry_get
+efivar_entry_get
+efivar_entry_set_safe
+efivar_entry_find
+efivar_entry_set
+efivar_validate
+efivar_entry_set_get_size
+validate_device_path.part.0
+validate_device_path
+__efivar_entry_iter.part.0
+__efivar_entry_iter
+validate_load_option
+efivar_entry_iter
+efivars_register
+efivar_entry_delete
+efivar_init
+efi_power_off
+efi_reboot
+efi_reboot
+efi_capsule_supported
+capsule_reboot_notify
+efi_capsule_update
+efi_capsule_pending
+copy_out_compat
+efivar_release
+efivar_show_raw
+efivar_data_read
+efivar_attr_read
+efivar_size_read
+efivar_attr_store
+efivar_attr_show
+efivars_sysfs_exit
+efivar_sysfs_destroy
+efivar_delete
+efivar_create_sysfs_entry
+efivar_guid_read
+efivar_create
+efivars_sysfs_init
+efivars_sysfs_callback
+efivar_store_raw
+fw_resource_version_show
+fw_resource_count_max_show
+fw_resource_count_show
+last_attempt_status_show
+last_attempt_version_show
+capsule_flags_show
+lowest_supported_fw_version_show
+fw_version_show
+fw_type_show
+fw_class_show
+esre_attr_show
+esre_release
+esrt_attr_is_visible
+cper_severity_str
+cper_mem_err_type_str
+cper_estatus_check_header
+cper_estatus_check
+cper_dimm_err_location.constprop.0
+cper_mem_err_location.constprop.0
+cper_next_record_id
+cper_print_bits
+cper_estatus_print
+cper_mem_err_pack
+cper_mem_err_unpack
+map_attr_show
+attribute_show
+num_pages_show
+virt_addr_show
+phys_addr_show
+type_show
+map_release
+efi_get_runtime_map_size
+efi_get_runtime_map_desc_size
+efi_runtime_map_copy
+virt_efi_query_capsule_caps
+virt_efi_update_capsule
+virt_efi_query_variable_info
+virt_efi_get_next_high_mono_count
+virt_efi_set_variable
+virt_efi_get_next_variable
+virt_efi_get_variable
+virt_efi_set_wakeup_time
+virt_efi_get_wakeup_time
+virt_efi_set_time
+virt_efi_get_time
+efi_call_virt_save_flags
+efi_call_virt_check_flags
+efi_call_rts
+virt_efi_query_variable_info_nonblocking
+virt_efi_reset_system
+virt_efi_set_variable_nonblocking
+efi_native_runtime_setup
+raw_table_read
+efi_get_embedded_fw
+efi_mokvar_sysfs_read
+efi_mokvar_entry_next
+efi_mokvar_entry_find
+efi_earlycon_scroll_up
+efi_earlycon_write
+cper_print_proc_ia
+acpi_pm_read
+acpi_pm_check_graylist
+acpi_pm_check_blacklist
+acpi_pm_read_verified
+acpi_pm_read_slow
+pit_shutdown
+pit_set_oneshot
+pit_next_event
+pit_set_periodic
+numachip2_timer_read
+numachip2_set_next_event
+numachip_timer_interrupt
+hv_get_tsc_page
+hv_cs_enable
+hv_stimer0_isr
+hv_stimer_init
+hv_ce_shutdown
+hv_stimer_cleanup
+hv_stimer_legacy_cleanup
+hv_stimer_legacy_init
+hv_stimer_free
+hv_stimer_global_cleanup
+hv_stimer_alloc
+hv_ce_set_next_event
+suspend_hv_clock_tsc
+hv_ce_set_oneshot
+resume_hv_clock_tsc
+ts_dmi_notifier_call
+itmt_legacy_work_fn
+itmt_legacy_cpu_online
+pmc_core_ltr_ignore_show
+pmc_core_dev_state_open
+pmc_core_dev_state_get
+quirk_xtal_ignore
+pmc_core_slps0_display
+pmc_core_ppfear_show
+pmc_core_remove
+pmc_core_substate_res_show
+pmc_core_substate_l_sts_regs_open
+pmc_core_substate_sts_regs_open
+pmc_core_substate_res_open
+pmc_core_slps0_dbg_open
+pmc_core_mphy_pg_open
+pmc_core_pll_open
+pmc_core_pkgc_open
+pmc_core_ltr_open
+pmc_core_ltr_ignore_open
+pmc_core_ppfear_open
+pmc_core_send_msg
+pmc_core_mphy_pg_show
+pmc_core_pll_show
+pmc_core_pkgc_show
+pmc_core_ltr_show
+pmc_core_ltr_ignore_write
+pmc_core_suspend
+pmc_core_slps0_dbg_latch
+pmc_core_slps0_dbg_show
+pmc_core_probe
+pmc_core_lpm_display
+pmc_core_substate_l_sts_regs_show
+pmc_core_substate_sts_regs_show
+pmc_core_resume
+intel_pmc_core_release
+intel_scu_ipc_dev_get
+devm_intel_scu_ipc_dev_get
+intel_scu_ipc_check_status
+intel_scu_ipc_dev_simple_command
+intel_scu_ipc_dev_command_with_size
+ioc
+intel_scu_ipc_release
+intel_scu_ipc_unregister
+devm_intel_scu_ipc_unregister
+devm_intel_scu_ipc_dev_release
+pwr_reg_rdwr.constprop.0
+intel_scu_ipc_dev_update
+intel_scu_ipc_dev_writev
+intel_scu_ipc_dev_readv
+intel_scu_ipc_dev_iowrite8
+intel_scu_ipc_dev_ioread8
+__intel_scu_ipc_register
+__devm_intel_scu_ipc_register
+intel_scu_ipc_dev_put
+intel_mid_scu_setup
+intel_scu_pci_probe
+pmc_sleep_tmr_open
+pmc_pss_state_open
+pmc_dev_state_open
+pmc_sleep_tmr_show
+pmc_pss_state_show
+pmc_dev_state_print
+pmc_dev_state_show
+pmc_atom_read
+pmc_atom_write
+cros_ec_prepare_tx
+cros_ec_check_result
+cros_ec_get_host_event
+send_command
+cros_ec_host_command_proto_query
+cros_ec_get_host_command_version_mask
+cros_ec_query_all
+cros_ec_cmd_xfer_status
+cros_ec_get_sensor_count
+cros_ec_check_features
+cros_ec_get_next_event
+__traceiter_cros_ec_request_start
+__traceiter_cros_ec_request_done
+mbox_chan_received_data
+mbox_client_peek_data
+of_mbox_index_xlate
+devm_mbox_controller_match
+msg_submit
+mbox_request_channel_byname
+mbox_free_channel
+tx_tick
+mbox_flush
+txdone_hrtimer
+mbox_send_message
+mbox_controller_register
+devm_mbox_controller_register
+devm_mbox_controller_unregister
+mbox_chan_txdone
+mbox_client_txdone
+mbox_request_channel
+mbox_controller_unregister.part.0
+mbox_controller_unregister
+__devm_mbox_controller_unregister
+parse_pcc_subspace
+pcc_mbox_free_channel
+pcc_mbox_request_channel
+write_register
+read_register
+pcc_mbox_irq
+pcc_send_data
+of_hwspin_lock_get_id
+of_hwspin_lock_get_id_byname
+hwspin_lock_unregister_single
+devm_hwspin_lock_device_match
+devm_hwspin_lock_match
+hwspin_lock_register
+hwspin_lock_unregister
+devm_hwspin_lock_unreg
+devm_hwspin_lock_register
+__hwspin_lock_request
+hwspin_lock_request
+hwspin_lock_request_specific
+devm_hwspin_lock_request
+devm_hwspin_lock_request_specific
+hwspin_lock_free
+devm_hwspin_lock_release
+devm_hwspin_lock_unregister
+devm_hwspin_lock_free
+hwspin_lock_get_id
+__hwspin_trylock
+__hwspin_lock_timeout
+__hwspin_unlock
+rproc_get_by_phandle
+rproc_rvdev_release
+rproc_add_carveout
+rproc_add_subdev
+rproc_remove_subdev
+rproc_da_to_va
+rproc_of_parse_firmware
+rproc_prepare_subdevices
+rproc_start_subdevices
+rproc_get_by_child
+rproc_check_carveout_da
+rproc_release_carveout
+rproc_stop
+rproc_start
+rproc_free
+devm_rproc_free
+rproc_vdev_do_stop
+rproc_vdev_do_start
+rproc_disable_iommu
+rproc_type_release
+rproc_put
+rproc_panic_handler
+rproc_enable_iommu
+rproc_va_to_pa
+rproc_alloc_registered_carveouts
+rproc_report_crash
+rproc_handle_resources.constprop.0
+rproc_alloc.part.0
+rproc_alloc
+devm_rproc_alloc
+rproc_of_resm_mem_entry_init
+rproc_mem_entry_init
+rproc_handle_trace
+rproc_handle_devmem
+rproc_alloc_carveout
+rproc_find_carveout_by_name
+rproc_handle_carveout
+rproc_alloc_vring
+rproc_free_vring
+rproc_handle_vdev
+rproc_vdev_release
+rproc_resource_cleanup
+rproc_shutdown
+rproc_del
+devm_rproc_remove
+rproc_boot
+rproc_auto_boot_callback
+rproc_add
+devm_rproc_add
+rproc_trigger_recovery
+rproc_crash_handler_work
+rproc_coredump_set_elf_info
+rproc_coredump_free
+rproc_copy_segment
+rproc_coredump_read
+rproc_coredump_add_custom_segment
+rproc_coredump_add_segment
+rproc_coredump_cleanup
+rproc_coredump
+rproc_coredump_read
+rproc_name_read
+rproc_trace_read
+rproc_coredump_write
+rproc_carveouts_open
+rproc_rsc_table_open
+rproc_carveouts_show
+rproc_rsc_table_show
+rproc_crash_write
+rproc_recovery_write
+rproc_recovery_read
+rproc_remove_trace_file
+rproc_create_trace_file
+rproc_delete_debug_dir
+rproc_create_debug_dir
+name_show
+state_show
+coredump_show
+coredump_store
+state_store
+firmware_store
+recovery_store
+firmware_show
+recovery_show
+rproc_virtio_get_status
+rproc_virtio_get_features
+rproc_virtio_notify
+rproc_vq_interrupt
+__rproc_virtio_del_vqs
+rproc_virtio_del_vqs
+rproc_virtio_set
+rproc_virtio_get
+rproc_virtio_find_vqs
+rproc_virtio_reset
+rproc_virtio_set_status
+rproc_virtio_finalize_features
+rproc_virtio_dev_release
+rproc_add_virtio_dev
+rproc_remove_virtio_dev
+rproc_elf_get_boot_addr
+rproc_elf_sanity_check
+rproc_elf_load_segments
+find_table
+rproc_elf_find_loaded_rsc_table
+rproc_elf_load_rsc_table
+rproc_cdev_write
+rproc_device_ioctl
+rproc_cdev_release
+rproc_char_device_add
+rproc_char_device_remove
+devfreq_get_devfreq_by_node
+devfreq_get_devfreq_by_phandle
+__traceiter_devfreq_monitor
+devfreq_update_status
+get_freq_range
+devfreq_set_target
+update_devfreq
+qos_notifier_call
+qos_max_notifier_call
+qos_min_notifier_call
+devm_devfreq_dev_match
+devfreq_monitor
+devfreq_monitor_stop
+devfreq_dev_release
+find_available_min_freq
+find_available_max_freq
+devfreq_notifier_call
+devfreq_remove_device
+devm_devfreq_dev_release
+devfreq_summary_open
+devfreq_summary_show
+timer_store
+polling_interval_store
+timer_show
+max_freq_show
+min_freq_show
+polling_interval_show
+target_freq_show
+cur_freq_show
+governor_show
+name_show
+trans_stat_store
+max_freq_store
+min_freq_store
+available_frequencies_show
+available_governors_show
+devfreq_register_opp_notifier
+devm_devfreq_register_opp_notifier
+devfreq_unregister_opp_notifier
+devm_devfreq_opp_release
+devfreq_register_notifier
+devm_devfreq_register_notifier
+devfreq_unregister_notifier
+devm_devfreq_notifier_release
+devfreq_monitor_resume
+devfreq_monitor_suspend
+devfreq_update_interval
+trans_stat_show
+devfreq_suspend_device
+devfreq_resume_device
+devfreq_monitor_start
+devfreq_recommended_opp
+find_devfreq_governor
+devfreq_add_governor
+devfreq_remove_governor
+try_then_request_governor
+governor_store
+devm_devfreq_remove_device
+devm_devfreq_unregister_opp_notifier
+devm_devfreq_unregister_notifier
+devfreq_add_device
+devm_devfreq_add_device
+devfreq_suspend
+devfreq_resume
+devfreq_event_release_edev
+devfreq_event_enable_edev
+devfreq_event_get_edev_by_phandle
+devfreq_event_disable_edev
+devfreq_event_get_edev_count
+devm_devfreq_event_match
+devfreq_event_remove_edev
+devm_devfreq_event_release
+enable_count_show
+name_show
+devm_devfreq_event_remove_edev
+devfreq_event_is_enabled.part.0
+devfreq_event_is_enabled
+devfreq_event_set_event
+devfreq_event_get_event
+devfreq_event_reset_event
+devfreq_event_add_edev
+devm_devfreq_event_add_edev
+devfreq_simple_ondemand_handler
+devfreq_simple_ondemand_func
+devfreq_performance_func
+devfreq_performance_handler
+devfreq_powersave_func
+devfreq_powersave_handler
+store_freq
+devfreq_userspace_func
+show_freq
+devfreq_userspace_handler
+update_devfreq_passive
+devfreq_passive_notifier_call
+devfreq_passive_get_target_freq
+devfreq_passive_event_handler
+extcon_dev_release
+extcon_find_edev_by_node
+extcon_get_edev_by_phandle
+extcon_get_edev_name
+name_show
+state_show
+cable_name_show
+extcon_register_notifier_all
+extcon_unregister_notifier_all
+extcon_dev_free
+extcon_set_property_capability
+extcon_get_state.part.0
+extcon_get_state
+cable_state_show
+extcon_sync.part.0
+extcon_sync
+extcon_set_state.part.0
+extcon_set_state
+extcon_set_state_sync
+is_extcon_property_capability.isra.0
+extcon_set_property
+extcon_set_property_sync
+extcon_get_property_capability
+extcon_get_property
+extcon_get_extcon_dev
+extcon_register_notifier
+extcon_unregister_notifier
+create_extcon_class.part.0
+extcon_dev_unregister
+extcon_dev_register
+dummy_sysfs_dev_release
+extcon_dev_allocate
+devm_extcon_dev_release
+devm_extcon_dev_allocate
+devm_extcon_dev_match
+devm_extcon_dev_register
+devm_extcon_dev_unreg
+devm_extcon_register_notifier
+devm_extcon_dev_notifier_unreg
+devm_extcon_register_notifier_all
+devm_extcon_dev_notifier_all_unreg
+devm_extcon_dev_free
+devm_extcon_dev_unregister
+devm_extcon_unregister_notifier
+devm_extcon_unregister_notifier_all
+vme_check_window
+vme_dev_release
+vme_init_bridge
+vme_unregister_error_handler
+vme_register_error_handler
+vme_bus_match
+vme_bus_probe
+vme_bus_remove
+vme_irq_handler
+vme_irq_generate
+vme_lm_count
+vme_slot_num
+vme_bus_num
+vme_slave_request
+vme_dma_list_exec
+vme_irq_request
+vme_irq_free
+vme_lm_request
+vme_slave_free
+vme_dma_pattern_attribute
+vme_dma_pci_attribute
+vme_dma_vme_attribute
+vme_dma_free_attribute
+vme_lm_free
+vme_master_mmap
+vme_new_dma_list
+vme_dma_list_add
+vme_dma_list_free
+vme_dma_free
+vme_bus_error_handler
+vme_register_bridge
+vme_unregister_bridge
+vme_unregister_driver
+find_bridge
+vme_alloc_consistent
+vme_free_consistent
+vme_slave_set
+vme_slave_get
+vme_master_set
+vme_master_rmw
+vme_lm_set
+vme_lm_get
+vme_lm_attach
+vme_lm_detach
+vme_master_get
+vme_get_size
+vme_master_read
+vme_master_write
+vme_register_driver
+vme_master_free
+vme_master_request
+max_power_range_uw_show
+power_uw_show
+energy_uj_show
+max_energy_range_uj_show
+name_show
+energy_uj_store
+powercap_unregister_zone
+show_constraint_min_time_window_us
+show_constraint_max_time_window_us
+show_constraint_min_power_uw
+show_constraint_max_power_uw
+store_constraint_time_window_us
+show_constraint_time_window_us
+store_constraint_power_limit_uw
+show_constraint_power_limit_uw
+show_constraint_name
+powercap_release
+enabled_store
+enabled_show
+powercap_unregister_control_type
+powercap_register_control_type
+powercap_register_zone
+idle_inject_should_run
+idle_inject_wakeup
+idle_inject_timer_fn
+idle_inject_setup
+idle_inject_fn
+idle_inject_set_duration
+idle_inject_get_duration
+idle_inject_set_latency
+idle_inject_start
+idle_inject_stop
+idle_inject_register
+idle_inject_unregister
+__traceiter_extlog_mem_event
+__traceiter_mc_event
+__traceiter_arm_event
+__traceiter_non_standard_event
+__traceiter_aer_event
+__traceiter_memory_failure_event
+log_non_standard_event
+log_arm_hw_error
+ras_userspace_consumers
+trace_show
+trace_release
+trace_open
+u64_get
+action_threshold_set
+cec_mod_work
+decay_interval_set
+action_threshold_ops_open
+decay_interval_ops_open
+del_elem.constprop.0
+do_spring_cleaning.constprop.0
+cec_work_fn
+cec_notifier
+nvmem_register_notifier
+nvmem_unregister_notifier
+devm_nvmem_unregister
+nvmem_add_cell_table
+nvmem_add_cell_lookups
+nvmem_del_cell_table
+nvmem_del_cell_lookups
+nvmem_dev_name
+nvmem_device_read
+bin_attr_nvmem_read
+devm_nvmem_match
+devm_nvmem_device_match
+devm_nvmem_cell_match
+nvmem_reg_write
+nvmem_device_write
+bin_attr_nvmem_write
+type_show
+nvmem_release
+nvmem_cell_info_to_nvmem_cell_nodup
+nvmem_cell_add
+nvmem_cell_drop
+nvmem_device_remove_all_cells
+nvmem_device_release
+__nvmem_cell_read
+nvmem_device_cell_read
+nvmem_bin_attr_get_umode
+nvmem_bin_attr_is_visible
+devm_nvmem_device_put
+devm_nvmem_cell_put
+__nvmem_device_put
+nvmem_device_put
+devm_nvmem_device_release
+nvmem_cell_put
+devm_nvmem_cell_release
+__nvmem_device_get
+nvmem_device_find
+nvmem_device_get
+devm_nvmem_device_get
+nvmem_cell_get_from_lookup
+nvmem_cell_get
+devm_nvmem_cell_get
+nvmem_unregister
+devm_nvmem_release
+nvmem_register
+devm_nvmem_register
+nvmem_cell_read
+nvmem_cell_read_common
+nvmem_cell_read_u8
+nvmem_cell_read_u16
+nvmem_cell_read_u32
+nvmem_cell_read_u64
+nvmem_cell_write
+nvmem_device_cell_write
+__traceiter_icc_set_bw
+__traceiter_icc_set_bw_end
+icc_std_aggregate
+icc_get_name
+of_icc_get_by_index
+of_icc_get
+of_icc_xlate_onecell
+icc_node_add
+icc_node_del
+devm_of_icc_get
+icc_node_destroy
+icc_nodes_remove
+icc_provider_add
+icc_graph_open
+icc_summary_open
+icc_graph_show
+aggregate_requests
+apply_constraints
+icc_set_bw
+__icc_enable
+icc_enable
+icc_disable
+icc_put
+devm_icc_release
+icc_summary_show
+icc_set_tag
+icc_provider_del
+icc_link_destroy
+icc_sync_state
+icc_get
+icc_node_create_nolock.part.0
+icc_link_create
+of_icc_get_from_provider
+icc_node_create
+icc_bulk_put
+of_icc_bulk_get
+icc_bulk_set_bw
+icc_bulk_disable
+icc_bulk_enable
+netdev_devres_match
+devm_free_netdev
+devm_alloc_etherdev_mqs
+devm_register_netdev
+devm_unregister_netdev
+sockfs_security_xattr_set
+sock_show_fdinfo
+sock_from_file
+__sock_tx_timestamp
+sock_mmap
+kernel_bind
+kernel_listen
+kernel_connect
+kernel_getsockname
+kernel_getpeername
+kernel_sock_shutdown
+sock_splice_read
+sock_fasync
+__sock_release
+sock_close
+sock_release
+sock_alloc_file
+compat_ifr_data_ioctl
+brioctl_set
+vlan_ioctl_set
+dlci_ioctl_set
+sock_poll
+sockfd_lookup
+sock_alloc
+sockfs_xattr_get
+sockfs_listxattr
+move_addr_to_user
+kernel_sendmsg_locked
+__sock_recv_timestamp
+sock_create_lite
+sock_wake_async
+sockfd_lookup_light
+kernel_accept
+sockfs_init_fs_context
+sockfs_dname
+sock_free_inode
+sock_alloc_inode
+init_once
+kernel_sendpage_locked
+sock_do_ioctl
+sock_ioctl
+__sock_create
+sock_create
+sock_create_kern
+kernel_sock_ip_overhead
+sockfs_setattr
+__sock_recv_ts_and_drops
+get_net_ns
+sock_register
+kernel_sendpage
+sock_sendpage
+compat_sock_ioctl
+__sock_recv_wifi_status
+move_addr_to_kernel.part.0
+sock_unregister
+sock_recvmsg
+sock_read_iter
+kernel_recvmsg
+____sys_recvmsg
+sock_sendmsg
+sock_write_iter
+kernel_sendmsg
+____sys_sendmsg
+move_addr_to_kernel
+__sys_socket
+__x64_sys_socket
+__ia32_sys_socket
+__sys_socketpair
+__x64_sys_socketpair
+__ia32_sys_socketpair
+__sys_bind
+__x64_sys_bind
+__ia32_sys_bind
+__sys_listen
+__x64_sys_listen
+__ia32_sys_listen
+__sys_accept4_file
+__sys_accept4
+__x64_sys_accept4
+__ia32_sys_accept4
+__x64_sys_accept
+__ia32_sys_accept
+__sys_connect_file
+__sys_connect
+__x64_sys_connect
+__ia32_sys_connect
+__sys_getsockname
+__x64_sys_getsockname
+__ia32_sys_getsockname
+__sys_getpeername
+__x64_sys_getpeername
+__ia32_sys_getpeername
+__sys_sendto
+__x64_sys_sendto
+__ia32_sys_sendto
+__x64_sys_send
+__ia32_sys_send
+__sys_recvfrom
+__x64_sys_recvfrom
+__ia32_sys_recvfrom
+__x64_sys_recv
+__ia32_sys_recv
+__sys_setsockopt
+__x64_sys_setsockopt
+__ia32_sys_setsockopt
+__sys_getsockopt
+__x64_sys_getsockopt
+__ia32_sys_getsockopt
+__sys_shutdown
+__x64_sys_shutdown
+__ia32_sys_shutdown
+__copy_msghdr_from_user
+copy_msghdr_from_user
+sendmsg_copy_msghdr
+___sys_sendmsg
+__sys_sendmsg_sock
+__sys_sendmsg
+__x64_sys_sendmsg
+__ia32_sys_sendmsg
+__sys_sendmmsg
+__x64_sys_sendmmsg
+__ia32_sys_sendmmsg
+recvmsg_copy_msghdr
+___sys_recvmsg
+do_recvmmsg
+__sys_recvmsg_sock
+__sys_recvmsg
+__x64_sys_recvmsg
+__ia32_sys_recvmsg
+__sys_recvmmsg
+__x64_sys_recvmmsg
+__ia32_sys_recvmmsg
+__x64_sys_recvmmsg_time32
+__ia32_sys_recvmmsg_time32
+__ia32_sys_socketcall
+__x64_sys_socketcall
+sock_is_registered
+socket_seq_show
+sock_no_bind
+sock_no_connect
+sock_no_socketpair
+sock_no_accept
+sock_no_ioctl
+sock_no_listen
+sock_no_sendmsg
+sock_no_recvmsg
+sock_no_mmap
+sock_def_destruct
+sock_get_timeout
+sock_i_uid
+sock_i_ino
+sock_ofree
+sk_set_peek_off
+sock_common_getsockopt
+sock_common_recvmsg
+sock_common_setsockopt
+sock_bind_add
+sk_ns_capable
+sk_capable
+sk_net_capable
+sk_set_memalloc
+__sock_cmsg_send
+sock_cmsg_send
+sock_prot_inuse_add
+__sk_dst_check
+sock_bindtoindex_locked
+sk_setup_caps
+sk_dst_check
+sock_disable_timestamp
+sock_pfree
+sock_kzfree_s
+skb_page_frag_refill
+sock_no_sendpage
+sock_no_sendpage_locked
+sock_init_data
+sock_def_wakeup
+__lock_sock
+sock_recv_errqueue
+sock_prot_inuse_get
+sock_inuse_get
+sock_inuse_exit_net
+sock_inuse_init_net
+proto_seq_stop
+proto_exit_net
+proto_init_net
+proto_seq_next
+proto_seq_start
+sk_busy_loop_end
+sk_prot_alloc
+__sk_mem_raise_allocated
+__sk_mem_schedule
+__sk_backlog_rcv
+sk_mc_loop
+sock_def_write_space
+proto_register
+sock_load_diag_module
+proto_seq_show
+sock_no_sendmsg_locked
+sock_no_getname
+sk_stop_timer_sync
+skb_orphan_partial
+sock_no_shutdown
+sk_page_frag_refill
+proto_unregister
+sk_send_sigurg
+sock_def_readable
+sock_def_error_report
+sk_stop_timer
+sock_kfree_s
+__sock_queue_rcv_skb
+sock_queue_rcv_skb
+__sk_mem_reduce_allocated
+__sk_mem_reclaim
+sk_clear_memalloc
+sock_rfree
+skb_set_owner_w
+sock_wmalloc
+sock_alloc_send_pskb
+sock_alloc_send_skb
+lock_sock_nested
+sk_reset_timer
+lock_sock_fast
+__sk_destruct
+sk_alloc
+sock_set_timeout
+sock_kmalloc
+sk_destruct
+__sk_free
+sk_free
+__sk_receive_skb
+sk_free_unlock_clone
+sk_clone_lock
+sock_efree
+sk_common_release
+sock_wfree
+__sock_wfree
+sock_omalloc
+__release_sock
+release_sock
+sock_bindtoindex
+sock_set_reuseaddr
+sock_set_reuseport
+sock_no_linger
+sock_set_priority
+sock_set_sndtimeo
+sock_set_keepalive
+sock_set_rcvbuf
+sock_set_mark
+sk_wait_data
+__sk_flush_backlog
+__receive_sock
+sock_enable_timestamp
+__sock_set_timestamps.part.0
+sock_enable_timestamps
+sock_setsockopt
+sock_gettstamp
+sk_get_meminfo
+sock_getsockopt
+reqsk_queue_alloc
+reqsk_fastopen_remove
+skb_queue_head
+skb_append
+skb_queue_tail
+skb_dequeue
+skb_dequeue_tail
+skb_unlink
+skb_coalesce_rx_frag
+skb_headers_offset_update
+skb_zerocopy_headlen
+skb_prepare_seq_read
+skb_abort_seq_read
+skb_ts_finish
+skb_find_text
+sock_rmem_free
+sock_dequeue_err_skb
+skb_add_rx_frag
+skb_trim
+skb_seq_read
+skb_ts_get_next_block
+skb_partial_csum_set
+skb_gso_transport_seglen
+skb_gso_validate_network_len
+skb_gso_validate_mac_len
+__build_skb_around
+build_skb_around
+napi_alloc_frag
+netdev_alloc_frag
+skb_free_head
+skb_dump
+skb_store_bits
+mm_unaccount_pinned_pages
+skb_zerocopy_iter_dgram
+skb_panic
+skb_push
+skb_send_sock_locked
+__skb_checksum
+skb_checksum
+skb_mod_eth_type
+skb_copy_and_csum_bits
+__skb_checksum_complete_head
+__skb_checksum_complete
+warn_crc32c_csum_combine
+warn_crc32c_csum_update
+__skb_warn_lro_forwarding
+__kmalloc_reserve.isra.0
+__alloc_skb
+skb_put
+pskb_put
+sock_queue_err_skb
+skb_may_tx_timestamp.part.0
+__splice_segment.part.0
+__skb_to_sgvec
+skb_to_sgvec
+skb_to_sgvec_nomark
+skb_append_pagefrags
+skb_copy_and_csum_dev
+skb_clone_fraglist
+__skb_splice_bits
+skb_splice_bits
+skb_pull
+skb_pull_rcsum
+kfree_skbmem
+__skb_ext_put
+skb_scrub_packet
+__skb_ext_del
+skb_copy_bits
+skb_try_coalesce
+sock_spd_release
+__copy_skb_header
+__skb_clone
+skb_copy_header
+skb_copy
+skb_copy_expand
+alloc_skb_for_msg
+mm_account_pinned_pages
+__build_skb
+build_skb
+__netdev_alloc_skb
+__napi_alloc_skb
+skb_release_head_state
+skb_release_all
+__kfree_skb
+kfree_skb
+kfree_skb_list
+sock_zerocopy_alloc
+sock_zerocopy_realloc
+skb_queue_purge
+__skb_complete_tx_timestamp
+skb_complete_tx_timestamp
+skb_complete_wifi_ack
+alloc_skb_with_frags
+consume_skb
+sock_zerocopy_callback
+sock_zerocopy_put
+sock_zerocopy_put_abort
+skb_tx_error
+skb_release_data
+skb_copy_ubufs
+pskb_expand_head
+skb_prepare_for_shift
+skb_eth_push
+skb_mpls_push
+skb_vlan_push
+skb_zerocopy_clone
+skb_split
+skb_clone
+skb_clone_sk
+__skb_tstamp_tx
+skb_tstamp_tx
+skb_zerocopy
+__pskb_copy_fclone
+skb_realloc_headroom
+pskb_carve
+__pskb_pull_tail
+__skb_pad
+skb_cow_data
+skb_maybe_pull_tail
+skb_checksum_setup_ip
+skb_checksum_setup
+skb_ensure_writable
+__skb_vlan_pop
+skb_vlan_pop
+skb_mpls_pop
+skb_mpls_update_lse
+skb_eth_pop
+skb_mpls_dec_ttl
+skb_vlan_untag
+napi_consume_skb
+skb_morph
+skb_segment_list
+kfree_skb_partial
+__consume_stateless_skb
+__kfree_skb_flush
+__kfree_skb_defer
+skb_rbtree_purge
+skb_shift
+skb_gro_receive_list
+skb_gro_receive
+skb_condense
+___pskb_trim
+skb_zerocopy_iter_stream
+pskb_trim_rcsum_slow
+skb_checksum_trimmed
+pskb_extract
+skb_segment
+__skb_ext_alloc
+skb_ext_add
+__skb_ext_set
+receiver_wake_function
+__skb_wait_for_more_packets
+simple_copy_to_iter
+__skb_datagram_iter
+skb_copy_and_hash_datagram_iter
+skb_copy_datagram_iter
+skb_copy_datagram_from_iter
+skb_copy_and_csum_datagram_msg
+__sk_queue_drop_skb
+__skb_free_datagram_locked
+datagram_poll
+skb_free_datagram
+skb_kill_datagram
+__zerocopy_sg_from_iter
+zerocopy_sg_from_iter
+__skb_try_recv_from_queue
+__skb_try_recv_datagram
+__skb_recv_datagram
+skb_recv_datagram
+sk_stream_error
+sk_stream_wait_connect
+sk_stream_wait_close
+sk_stream_wait_memory
+sk_stream_kill_queues
+sk_stream_write_space
+__scm_destroy
+put_cmsg
+put_cmsg_scm_timestamping64
+put_cmsg_scm_timestamping
+scm_detach_fds
+__scm_send
+scm_fp_dup
+__gnet_stats_copy_queue_cpu
+__gnet_stats_copy_queue
+__gnet_stats_copy_basic
+gnet_stats_copy_app
+gnet_stats_copy_queue
+gnet_stats_copy_rate_est
+gnet_stats_start_copy_compat
+gnet_stats_start_copy
+gnet_stats_finish_copy
+___gnet_stats_copy_basic
+gnet_stats_copy_basic
+gnet_stats_copy_basic_hw
+gen_kill_estimator
+gen_estimator_active
+est_fetch_counters
+est_timer
+gen_estimator_read
+gen_new_estimator
+gen_replace_estimator
+net_eq_idr
+peernet2id
+net_ns_barrier
+ops_exit_list
+net_defaults_init_net
+netns_owner
+net_ns_net_exit
+net_ns_net_init
+rtnl_net_fill
+rtnl_net_notifyid
+rtnl_net_dumpid_one
+ops_free_list.part.0
+unregister_pernet_operations
+unregister_pernet_subsys
+unregister_pernet_device
+net_ns_get_ownership
+__put_net
+get_net_ns_by_fd
+peernet2id_alloc
+net_drop_ns.part.0
+cleanup_net
+rtnl_valid_dump_net_req
+netns_put
+netns_install
+netns_get
+rtnl_net_dumpid
+get_net_ns_by_pid
+rtnl_net_newid
+net_alloc_generic
+ops_init
+setup_net
+register_pernet_operations
+register_pernet_subsys
+register_pernet_device
+__net_gen_cookie
+peernet_has_id
+get_net_ns_by_id
+rtnl_net_getid
+net_drop_ns
+copy_net_ns
+secure_tcp_seq
+secure_ipv4_port_ephemeral
+secure_dccp_sequence_number
+secure_dccpv6_sequence_number
+secure_tcpv6_ts_off
+secure_tcpv6_seq
+secure_ipv6_port_ephemeral
+secure_tcp_ts_off
+make_flow_keys_digest
+skb_flow_dissector_init
+skb_flow_dissect_tunnel_info
+flow_hash_from_keys
+__get_hash_from_flowi6
+flow_get_u32_src
+flow_get_u32_dst
+skb_flow_dissect_meta
+skb_flow_dissect_ct
+skb_flow_dissect_hash
+skb_flow_get_icmp_tci
+__skb_flow_get_ports
+flow_dissector_bpf_prog_attach_check
+bpf_flow_dissect
+__skb_flow_dissect
+__skb_get_hash_symmetric
+__skb_get_hash
+skb_get_hash_perturb
+__skb_get_poff
+skb_get_poff
+sysctl_core_net_init
+set_default_qdisc
+flow_limit_table_len_sysctl
+rps_sock_flow_sysctl
+proc_dointvec_minmax_bpf_restricted
+proc_dolongvec_minmax_bpf_restricted
+proc_dointvec_minmax_bpf_enable
+proc_do_rss_key
+sysctl_core_net_exit
+proc_do_dev_weight
+flow_limit_cpu_sysctl
+netdev_cmd_to_name
+netif_get_num_default_rss_queues
+passthru_features_check
+dev_pick_tx_zero
+netdev_increment_features
+dev_nit_active
+dev_get_iflink
+__dev_get_by_index
+dev_get_by_index_rcu
+call_netdevice_unregister_notifiers
+call_netdevice_register_net_notifiers
+netdev_bind_sb_channel_queue
+netdev_set_sb_channel
+skb_gro_reset_offset
+gro_find_receive_by_type
+gro_find_complete_by_type
+____netdev_has_upper_dev
+netdev_adjacent_get_private
+netdev_lower_get_next_private
+netdev_lower_get_next
+netdev_walk_all_lower_dev
+netdev_next_lower_dev_rcu
+netdev_walk_all_lower_dev_rcu
+__netdev_adjacent_dev_set
+netdev_get_xmit_slave
+netdev_lower_dev_get_private
+__dev_set_mtu
+dev_set_group
+dev_get_phys_port_id
+dev_new_index
+netif_tx_stop_all_queues
+netdev_set_default_ethtool_ops
+dev_change_carrier
+dev_change_proto_down
+dev_get_flags
+dev_get_by_napi_id
+netdev_upper_get_next_dev_rcu
+netdev_walk_all_upper_dev_rcu
+netdev_has_upper_dev_all_rcu
+netdev_lower_get_next_private_rcu
+init_dummy_netdev
+netdev_stats_to_stats64
+dev_get_stats
+netdev_boot_setup_check
+netdev_name_node_lookup_rcu
+dev_get_by_name_rcu
+netdev_name_node_alloc
+napi_schedule_prep
+netdev_lower_get_first_private_rcu
+__netdev_name_node_alt_destroy
+bpf_xdp_link_dealloc
+dev_fill_metadata_dst
+dev_get_by_name
+dev_get_by_index
+dev_getfirstbyhwtype
+rps_may_expire_flow
+dev_getbyhwaddr_rcu
+dev_set_alias
+remove_xps_queue
+bpf_xdp_link_fill_link_info
+register_netdevice_notifier
+unregister_netdevice_notifier
+__register_netdevice_notifier_net
+register_netdevice_notifier_net
+register_netdevice_notifier_dev_net
+net_inc_ingress_queue
+net_inc_egress_queue
+net_dec_ingress_queue
+net_dec_egress_queue
+netstamp_clear
+__get_xps_queue_idx
+netdev_pick_tx
+__napi_schedule_irqoff
+rps_trigger_softirq
+skb_warn_bad_offload
+skb_checksum_help
+dev_pick_tx_cpu_id
+gro_pull_from_frag0
+napi_skb_free_stolen_head
+napi_reuse_skb
+napi_get_frags
+napi_disable
+netdev_adjacent_sysfs_add
+netdev_adjacent_sysfs_del
+__netdev_adjacent_dev_insert
+dev_get_phys_port_name
+dev_get_port_parent_id
+netdev_port_same_parent_id
+dev_change_proto_down_generic
+dev_change_proto_down_reason
+bpf_xdp_link_show_fdinfo
+netif_stacked_transfer_operstate
+netdev_refcnt_read
+dev_fetch_sw_netstats
+synchronize_net
+net_rps_send_ipi
+__netdev_next_upper_dev
+__netdev_walk_all_upper_dev
+__netdev_next_lower_dev
+__netdev_upper_depth
+__netdev_update_upper_level
+__netdev_lower_depth
+__netdev_update_lower_level
+netdev_master_upper_dev_get_rcu
+__dev_getfirstbyhwtype
+__dev_get_by_flags
+netdev_is_rx_handler_busy
+netdev_rx_handler_register
+netdev_has_upper_dev
+netdev_has_any_upper_dev
+netdev_master_upper_dev_get
+__netdev_has_upper_dev
+unlist_netdevice
+call_netdevice_notifiers_info
+call_netdevice_notifiers
+netdev_features_change
+netdev_notify_peers
+netdev_bonding_info_change
+dev_pre_changeaddr_notify
+netdev_lower_state_changed
+__dev_close_many
+dev_close_many
+get_rps_cpu
+netif_set_real_num_rx_queues
+netdev_rx_handler_unregister
+is_skb_forwardable
+netif_device_detach
+dev_valid_name
+netdev_exit
+__unregister_netdevice_notifier_net
+unregister_netdevice_notifier_net
+unregister_netdevice_notifier_dev_net
+net_enable_timestamp
+net_disable_timestamp
+napi_watchdog
+netdev_rx_csum_fault
+__skb_gro_checksum_complete
+dev_xdp_install
+dev_xdp_attach
+netdev_state_change
+dev_set_mac_address
+dev_close.part.0
+dev_close
+skb_crc32c_csum_help.part.0
+skb_csum_hwoffload_help
+__netdev_adjacent_dev_remove.constprop.0
+__netdev_adjacent_dev_unlink_neighbour
+__netdev_walk_all_lower_dev.constprop.0
+__netdev_upper_dev_unlink
+netdev_upper_dev_unlink
+netdev_adjacent_change_commit
+netdev_adjacent_change_abort
+__netdev_upper_dev_link
+netdev_upper_dev_link
+netdev_master_upper_dev_link
+netdev_adjacent_change_prepare
+__dev_forward_skb
+netdev_txq_to_tc
+bpf_xdp_link_update
+bpf_xdp_link_release
+bpf_xdp_link_detach
+clean_xps_maps
+netif_reset_xps_queues
+netdev_unbind_sb_channel
+netdev_unbind_all_sb_channels
+netdev_reset_tc
+netdev_set_num_tc
+netdev_set_tc_queue
+netif_set_real_num_tx_queues
+netdev_name_node_add
+list_netdevice
+netdev_name_node_lookup
+__dev_get_by_name
+netdev_name_node_alt_create
+netdev_name_node_alt_destroy
+dev_alloc_name_ns
+dev_alloc_name
+dev_get_valid_name
+dev_change_net_namespace
+default_device_exit
+dev_queue_xmit_nit
+__napi_schedule
+__dev_kfree_skb_irq
+__dev_kfree_skb_any
+dev_remove_offload
+__netif_schedule
+netif_schedule_queue
+netif_tx_wake_queue
+netif_device_attach
+dev_add_pack
+dev_add_offload
+__dev_remove_pack
+dev_remove_pack
+__netif_napi_del
+free_netdev
+alloc_netdev_mqs
+rollback_registered_many
+rollback_registered
+unregister_netdevice_queue
+unregister_netdev
+unregister_netdevice_many
+default_device_exit_batch
+flush_backlog
+net_tx_action
+netif_napi_add
+enqueue_to_backlog
+netif_rx_internal
+dev_forward_skb
+netif_rx
+netif_rx_ni
+dev_loopback_xmit
+netif_rx_any_context
+dev_cpu_dead
+__netif_set_xps_queue
+netif_set_xps_queue
+netdev_create_hash
+netdev_init
+netdev_boot_base
+netdev_get_name
+dev_get_alias
+skb_crc32c_csum_help
+skb_network_protocol
+skb_mac_gso_segment
+__skb_gso_segment
+netif_skb_features
+validate_xmit_skb
+validate_xmit_skb_list
+__dev_direct_xmit
+dev_hard_start_xmit
+netdev_core_pick_tx
+__dev_queue_xmit
+dev_queue_xmit
+dev_queue_xmit_accel
+generic_xdp_tx
+do_xdp_generic.part.0
+do_xdp_generic
+__netif_receive_skb_core
+__netif_receive_skb_one_core
+netif_receive_skb_core
+__netif_receive_skb
+netif_receive_skb
+process_backlog
+__netif_receive_skb_list_core
+netif_receive_skb_list_internal
+netif_receive_skb_list
+gro_normal_one
+napi_gro_complete.constprop.0
+dev_gro_receive
+napi_gro_receive
+napi_gro_frags
+napi_gro_flush
+napi_complete_done
+busy_poll_stop
+napi_busy_loop
+net_rx_action
+netdev_adjacent_rename_links
+dev_change_name
+__dev_notify_flags
+__dev_set_promiscuity
+__dev_set_rx_mode
+dev_set_rx_mode
+__dev_open
+dev_open
+dev_set_promiscuity
+__dev_set_allmulti
+dev_set_allmulti
+__dev_change_flags
+dev_change_flags
+dev_validate_mtu
+dev_set_mtu_ext
+dev_set_mtu
+dev_change_tx_queue_len
+dev_xdp_prog_id
+bpf_xdp_link_attach
+dev_change_xdp_fd
+__netdev_update_features
+netdev_update_features
+dev_disable_lro
+generic_xdp_install
+netdev_change_features
+register_netdevice
+register_netdev
+netdev_run_todo
+dev_ingress_queue_create
+netdev_freemem
+netdev_drivername
+__hw_addr_init
+dev_uc_init
+dev_mc_init
+__hw_addr_create_ex
+__hw_addr_flush
+dev_addr_flush
+dev_uc_flush
+dev_mc_flush
+dev_uc_add_excl
+dev_mc_add_excl
+__hw_addr_add_ex
+dev_addr_init
+dev_uc_add
+__hw_addr_sync_one
+__dev_mc_add
+dev_mc_add
+dev_mc_add_global
+__hw_addr_del_entry
+__hw_addr_del_ex
+dev_uc_del
+__dev_mc_del
+dev_mc_del
+dev_mc_del_global
+dev_addr_del
+__hw_addr_sync_dev
+__hw_addr_ref_sync_dev
+__hw_addr_ref_unsync_dev
+__hw_addr_unsync_dev
+__hw_addr_unsync_one
+__hw_addr_sync
+__hw_addr_unsync
+dev_mc_unsync
+__hw_addr_sync_multiple
+dev_addr_add
+dev_uc_sync
+dev_uc_sync_multiple
+dev_mc_sync
+dev_mc_sync_multiple
+dev_uc_unsync
+dst_discard_out
+__dst_destroy_metrics_generic
+dst_dev_put
+__metadata_dst_init
+metadata_dst_alloc
+metadata_dst_free
+metadata_dst_alloc_percpu
+metadata_dst_free_percpu
+dst_md_discard_out
+dst_md_discard
+dst_release
+dst_release_immediate
+dst_destroy
+dst_destroy_rcu
+dst_init
+dst_alloc
+dst_cow_metrics_generic
+register_netevent_notifier
+unregister_netevent_notifier
+call_netevent_notifiers
+neigh_stat_seq_stop
+neigh_blackhole
+pneigh_get_first
+pneigh_get_next
+neigh_get_first
+neigh_get_next
+neigh_seq_start
+pneigh_queue_purge
+neigh_for_each
+neigh_seq_stop
+__pneigh_lookup_1
+__pneigh_lookup
+neigh_probe
+neigh_direct_output
+neigh_stat_seq_next
+neigh_stat_seq_start
+neigh_stat_seq_show
+neigh_sysctl_register
+neigh_sysctl_unregister
+neigh_rand_reach_time.part.0
+neigh_rand_reach_time
+pneigh_lookup
+neigh_connected_output
+neigh_seq_next
+neigh_parms_release
+neigh_master_filtered.part.0
+pneigh_fill_info.constprop.0
+neigh_lookup_nodev
+neigh_parms_alloc
+neigh_rcu_free_parms
+neigh_valid_get_req.constprop.0
+neigh_valid_dump_req
+neigh_proxy_process
+neigh_invalidate
+pneigh_enqueue
+neigh_add_timer
+__neigh_set_probe_once
+neigh_lookup
+neigh_proc_update
+neigh_proc_dointvec
+neigh_proc_dointvec_jiffies
+neigh_proc_dointvec_ms_jiffies
+neigh_proc_base_reachable_time
+neigh_proc_dointvec_unres_qlen
+neigh_proc_dointvec_zero_intmax
+neigh_proc_dointvec_userhz_jiffies
+neightbl_fill_parms
+neightbl_fill_info.constprop.0
+neightbl_set
+neigh_fill_info
+__neigh_notify
+neigh_app_ns
+neigh_dump_info
+neightbl_dump_info
+neigh_del_timer.part.0
+neigh_destroy
+neigh_cleanup_and_release
+__neigh_for_each_release
+neigh_periodic_work
+neigh_get
+neigh_flush_dev
+neigh_changeaddr
+__neigh_ifdown
+neigh_carrier_down
+neigh_ifdown
+neigh_table_clear
+__neigh_event_send
+neigh_resolve_output
+neigh_timer_handler
+__neigh_update
+neigh_update
+neigh_hash_free_rcu
+neigh_hash_alloc
+neigh_table_init
+neigh_remove_one
+___neigh_create
+__neigh_create
+neigh_event_ns
+neigh_xmit
+neigh_add
+pneigh_delete
+neigh_delete
+rtnl_lock
+rtnl_lock_killable
+rtnl_unlock
+rtnl_trylock
+rtnl_is_locked
+refcount_dec_and_rtnl_lock
+rtnl_af_register
+rtnl_kfree_skbs
+rtnl_link_ops_get
+__rtnl_link_register
+rtnl_link_register
+__rtnl_link_unregister
+rtnl_delete_link
+rtnl_af_unregister
+rtnl_unicast
+rtnl_notify
+rtnl_set_sk_err
+rtnl_put_cacheinfo
+rtnl_nla_parse_ifla
+rtnl_configure_link
+set_operstate
+rtnl_create_link
+if_nlmsg_size
+rtnl_bridge_notify
+rtnl_dump_all
+rtnl_fill_link_ifmap
+rtnl_phys_port_id_fill
+rtnl_phys_switch_id_fill
+rtnl_fill_stats
+rtnl_xdp_prog_hw
+rtnl_xdp_prog_drv
+ndo_dflt_fdb_add
+ndo_dflt_fdb_del
+rtnetlink_net_exit
+rtnetlink_rcv
+rtnetlink_net_init
+rtnl_xdp_prog_skb
+rtnl_ensure_unique_netns
+fdb_vid_parse
+rtnl_valid_stats_req
+rtnl_unregister_all
+rtnl_xdp_report_one
+brport_nla_put_flag.part.0
+do_set_master
+rtnetlink_bind
+rtnl_dev_get.constprop.0
+rtnl_register_internal
+rtnl_register_module
+validate_linkmsg
+rtnl_bridge_dellink
+rtnl_bridge_setlink
+rtnl_unregister
+rtnl_link_get_net
+valid_fdb_dump_strict
+rtnl_calcit
+rtnetlink_rcv_msg
+rtnl_linkprop
+rtnl_dellinkprop
+rtnl_newlinkprop
+rtnl_link_get_net_capable.constprop.0
+valid_fdb_dump_legacy
+rtnl_get_net_ns_capable
+rtnl_fdb_get
+valid_bridge_getlink_req
+rtnl_bridge_getlink
+rtnl_dellink
+do_setlink
+rtnl_setlink
+nla_put_ifalias
+rtnetlink_put_metrics
+nlmsg_populate_fdb_fill.constprop.0
+rtnl_fdb_notify
+rtnl_fdb_add
+rtnl_fdb_del
+nlmsg_populate_fdb
+ndo_dflt_fdb_dump
+rtnl_fdb_dump
+rtnl_fill_statsinfo.isra.0.constprop.0
+rtnl_stats_dump
+rtnl_stats_get
+ndo_dflt_bridge_getlink
+rtnl_fill_vfinfo
+rtnl_fill_vf
+rtnl_fill_ifinfo
+rtnl_getlink
+rtnl_dump_ifinfo
+__rtnl_unlock
+rtnl_link_unregister
+__rtnl_newlink
+rtnl_newlink
+rtnl_register
+rtnetlink_send
+rtmsg_ifinfo_build_skb
+rtmsg_ifinfo_event.part.0
+rtnetlink_event
+rtmsg_ifinfo_send
+rtmsg_ifinfo
+rtmsg_ifinfo_newnet
+net_ratelimit
+in_aton
+inet_proto_csum_replace16
+inet_proto_csum_replace4
+inet_proto_csum_replace_by_diff
+inet_addr_is_any
+in4_pton
+in6_pton
+inet6_pton
+inet4_pton
+inet_pton_with_scope
+rfc2863_policy
+linkwatch_urgent_event
+linkwatch_do_dev
+linkwatch_schedule_work
+linkwatch_fire_event
+__linkwatch_run_queue
+linkwatch_event
+linkwatch_init_dev
+linkwatch_forget_dev
+linkwatch_run_queue
+bpf_csum_level
+bpf_noop_prologue
+bpf_dispatcher_xdp_func
+bpf_csum_update
+bpf_msg_apply_bytes
+bpf_msg_cork_bytes
+bpf_sock_ops_reserve_hdr_opt
+bpf_skc_to_tcp_timewait_sock
+bpf_skc_to_tcp_request_sock
+bpf_set_hash_invalid
+convert_bpf_ld_abs
+bpf_sock_ops_get_syn
+bpf_gen_ld_abs
+bpf_get_route_realm
+bpf_sock_convert_ctx_access
+bpf_convert_shinfo_access
+bpf_convert_ctx_access
+xdp_convert_ctx_access
+sock_ops_convert_ctx_access
+sk_skb_convert_ctx_access
+sk_msg_convert_ctx_access
+flow_dissector_convert_ctx_access
+sk_reuseport_convert_ctx_access
+sk_lookup_convert_ctx_access
+bpf_redirect
+bpf_redirect_peer
+bpf_skb_change_type
+bpf_xdp_adjust_meta
+bpf_xdp_redirect
+sock_addr_convert_ctx_access
+bpf_skb_get_xfrm_state
+bpf_skb_load_bytes_relative
+bpf_redirect_neigh
+bpf_xdp_copy
+bpf_fib_set_fwd_params
+bpf_skb_cgroup_id
+bpf_skb_ancestor_cgroup_id
+bpf_sk_lookup_assign
+sk_filter_trim_cap
+bpf_skb_get_pay_offset
+bpf_skb_get_nlattr_nest
+bpf_skb_load_helper_8
+bpf_skb_load_helper_8_no_cache
+bpf_skb_load_helper_16
+bpf_skb_load_helper_16_no_cache
+bpf_skb_load_helper_32
+bpf_skb_load_helper_32_no_cache
+bpf_prog_store_orig_filter
+sk_skb_pull_data
+bpf_csum_diff
+bpf_get_cgroup_classid_curr
+bpf_get_cgroup_classid
+bpf_get_hash_recalc
+bpf_skb_grow_rcsum
+bpf_xdp_adjust_head
+bpf_skb_net_hdr_push
+xdp_do_flush
+bpf_xdp_redirect_map
+bpf_skb_event_output
+bpf_xdp_event_output
+bpf_skb_set_tunnel_key
+bpf_get_socket_cookie
+bpf_get_socket_cookie_sock_addr
+bpf_get_socket_cookie_sock
+bpf_get_socket_cookie_sock_ops
+bpf_get_netns_cookie_sock_addr
+_bpf_setsockopt
+bpf_sock_addr_setsockopt
+bpf_sock_ops_setsockopt
+bpf_bind
+bpf_push_seg6_encap
+bpf_lwt_xmit_push_encap
+bpf_lwt_seg6_store_bytes
+bpf_update_srh_state
+sock_addr_is_valid_access
+bpf_tcp_gen_syncookie
+bpf_search_tcp_opt
+sock_filter_func_proto
+sk_reuseport_func_proto
+bpf_sk_base_func_proto
+sk_filter_func_proto
+cg_skb_func_proto
+xdp_func_proto
+lwt_out_func_proto
+lwt_in_func_proto
+lwt_seg6local_func_proto
+sock_addr_func_proto
+sock_ops_func_proto
+sk_skb_func_proto
+sk_msg_func_proto
+flow_dissector_func_proto
+sk_lookup_func_proto
+bpf_get_skb_set_tunnel_proto
+tc_cls_act_func_proto
+lwt_xmit_func_proto
+bpf_xdp_adjust_tail
+bpf_sock_ops_store_hdr_opt
+bpf_unclone_prologue.part.0
+tc_cls_act_prologue
+sk_skb_prologue
+flow_dissector_is_valid_access
+__bpf_prog_release
+sk_filter_release_rcu
+bpf_prog_destroy
+bpf_skb_is_valid_access.isra.0
+tc_cls_act_is_valid_access
+sk_filter_is_valid_access
+sk_skb_is_valid_access
+__is_valid_xdp_access.part.0
+sock_ops_is_valid_access
+sk_msg_is_valid_access
+sk_reuseport_is_valid_access
+sk_lookup_is_valid_access
+tc_cls_act_convert_ctx_access
+xdp_is_valid_access
+bpf_warn_invalid_xdp_action
+sk_lookup
+bpf_set_hash
+bpf_tcp_check_syncookie
+sk_reuseport_load_bytes_relative
+bpf_sock_ops_load_hdr_opt
+bpf_skb_get_nlattr
+bpf_lwt_in_push_encap
+bpf_lwt_seg6_action
+bpf_get_listener_sock
+bpf_skb_get_tunnel_key
+bpf_get_netns_cookie_sock
+lwt_is_valid_access
+_bpf_getsockopt
+bpf_sock_addr_getsockopt
+bpf_sock_ops_getsockopt
+cg_skb_is_valid_access
+sk_filter_release
+sk_skb_change_head
+bpf_sk_cgroup_id
+bpf_skb_set_tunnel_opt
+bpf_skb_copy
+sk_skb_adjust_room
+bpf_skb_pull_data
+bpf_skb_change_tail
+bpf_sk_release
+bpf_skb_get_tunnel_opt
+bpf_sk_fullsock
+bpf_skb_load_bytes
+sk_reuseport_load_bytes
+bpf_tcp_sock
+bpf_sock_ops_cb_flags_set
+bpf_flow_dissector_load_bytes
+bpf_skb_ecn_set_ce
+bpf_skb_cgroup_classid
+bpf_skc_to_tcp_sock
+bpf_sk_assign
+bpf_l3_csum_replace
+__bpf_skc_lookup
+bpf_xdp_skc_lookup_tcp
+bpf_sock_addr_skc_lookup_tcp
+bpf_sk_lookup
+bpf_sk_lookup_tcp
+bpf_sk_lookup_udp
+__bpf_sk_lookup.constprop.0
+bpf_sock_addr_sk_lookup_udp
+bpf_sock_addr_sk_lookup_tcp
+bpf_xdp_sk_lookup_tcp
+bpf_xdp_sk_lookup_udp
+bpf_skc_lookup_tcp
+bpf_skb_under_cgroup
+bpf_skc_to_tcp6_sock
+bpf_skb_net_hdr_pop
+bpf_skb_change_proto
+bpf_sk_ancestor_cgroup_id
+bpf_skc_to_udp6_sock
+copy_bpf_fprog_from_user
+bpf_get_socket_uid
+bpf_l4_csum_replace
+bpf_skb_store_bytes
+bpf_lwt_seg6_adjust_srh
+bpf_skb_vlan_pop
+bpf_skb_change_head
+bpf_skb_vlan_push
+bpf_skb_adjust_room
+sk_select_reuseport
+sk_skb_change_tail
+__bpf_redirect
+bpf_clone_redirect
+xdp_do_redirect
+bpf_ipv6_fib_lookup
+bpf_ipv4_fib_lookup
+bpf_xdp_fib_lookup
+bpf_skb_fib_lookup
+bpf_msg_pull_data
+bpf_msg_push_data
+bpf_msg_pop_data
+bpf_convert_filter
+bpf_prepare_filter
+bpf_prog_create
+bpf_prog_create_from_user
+__get_filter
+sk_filter_uncharge
+__sk_attach_prog
+sk_attach_filter
+sk_detach_filter
+sk_filter_charge
+sk_reuseport_attach_filter
+sk_attach_bpf
+sk_reuseport_attach_bpf
+sk_reuseport_prog_free
+skb_do_redirect
+bpf_clear_redirect_map
+xdp_do_generic_redirect
+bpf_tcp_sock_is_valid_access
+bpf_tcp_sock_convert_ctx_access
+bpf_xdp_sock_is_valid_access
+bpf_xdp_sock_convert_ctx_access
+bpf_helper_changes_pkt_data
+bpf_sock_is_valid_access
+bpf_sock_common_is_valid_access
+sock_filter_is_valid_access
+sk_get_filter
+bpf_run_sk_reuseport
+bpf_prog_change_xdp
+sock_diag_put_meminfo
+sock_diag_put_filterinfo
+sock_diag_register_inet_compat
+sock_diag_unregister_inet_compat
+sock_diag_register
+sock_diag_broadcast_destroy_work
+sock_diag_destroy
+diag_net_exit
+sock_diag_rcv
+diag_net_init
+sock_diag_unregister
+sock_diag_bind
+sock_diag_rcv_msg
+__sock_gen_cookie
+sock_diag_check_cookie
+sock_diag_save_cookie
+sock_diag_broadcast_destroy
+register_gifconf
+dev_ifsioc
+dev_load
+dev_ifconf
+dev_ioctl
+tso_count_descs
+tso_build_data
+tso_build_hdr
+tso_start
+reuseport_free_rcu
+reuseport_detach_sock
+reuseport_select_sock
+reuseport_detach_prog
+reuseport_alloc
+reuseport_attach_prog
+reuseport_add_sock
+call_fib_notifier
+call_fib_notifiers
+unregister_fib_notifier
+fib_notifier_net_init
+fib_seq_sum
+register_fib_notifier
+fib_notifier_ops_register
+fib_notifier_ops_unregister
+fib_notifier_net_exit
+xdp_warn
+xdp_mem_id_hashfn
+xdp_mem_id_cmp
+xdp_rxq_info_unused
+xdp_rxq_info_is_reg
+__xdp_mem_allocator_rcu_free
+xdp_attachment_setup
+xdp_convert_zc_to_xdp_frame
+xdp_rxq_info_reg_mem_model
+xdp_rxq_info_unreg_mem_model
+xdp_rxq_info_unreg
+xdp_rxq_info_reg
+__xdp_release_frame
+__xdp_return
+xdp_return_frame
+xdp_return_frame_rx_napi
+mem_xa_remove
+mem_allocator_disconnect
+xdp_return_buff
+flow_rule_match_meta
+flow_rule_match_basic
+flow_rule_match_control
+flow_rule_match_eth_addrs
+flow_rule_match_vlan
+flow_rule_match_cvlan
+flow_rule_match_ipv4_addrs
+flow_rule_match_ipv6_addrs
+flow_rule_match_ip
+flow_rule_match_ports
+flow_rule_match_tcp
+flow_rule_match_icmp
+flow_rule_match_mpls
+flow_rule_match_enc_control
+flow_rule_match_enc_ipv4_addrs
+flow_rule_match_enc_ipv6_addrs
+flow_rule_match_enc_ip
+flow_rule_match_enc_ports
+flow_rule_match_enc_keyid
+flow_rule_match_enc_opts
+flow_rule_match_ct
+flow_block_cb_lookup
+flow_block_cb_priv
+flow_block_cb_incref
+flow_block_cb_decref
+flow_block_cb_is_busy
+flow_action_cookie_destroy
+flow_block_cb_free
+flow_indr_dev_setup_offload
+flow_action_cookie_create
+flow_indr_dev_unregister
+flow_indr_dev_register
+flow_block_cb_alloc
+flow_indr_block_cb_alloc
+flow_block_cb_setup_simple
+flow_rule_alloc
+net_initial_ns
+change_proto_down
+change_flags
+change_mtu
+ifalias_show
+iflink_show
+change_group
+rps_dev_flow_table_release
+carrier_down_count_show
+carrier_up_count_show
+carrier_changes_show
+carrier_show
+testing_show
+dormant_show
+change_carrier
+net_namespace
+net_get_ownership
+net_netlink_ns
+change_gro_flush_timeout
+change_napi_defer_hard_irqs
+rx_queue_attr_show
+rx_queue_attr_store
+rx_queue_namespace
+rx_queue_get_ownership
+netdev_queue_attr_show
+netdev_queue_attr_store
+netdev_queue_namespace
+netdev_queue_get_ownership
+format_napi_defer_hard_irqs
+format_gro_flush_timeout
+format_tx_queue_len
+format_flags
+format_mtu
+format_link_mode
+format_addr_len
+format_addr_assign_type
+format_name_assign_type
+format_ifindex
+format_dev_port
+format_dev_id
+format_type
+format_group
+bql_show_inflight
+bql_show_limit_min
+bql_show_limit_max
+bql_show_limit
+tx_maxrate_show
+tx_timeout_show
+net_current_may_mount
+operstate_show
+broadcast_show
+address_show
+show_rps_dev_flow_table_cnt
+netdev_queue_release
+rx_queue_release
+bql_set_hold_time
+bql_show_hold_time
+bql_set
+bql_set_limit_min
+bql_set_limit_max
+bql_set_limit
+netdev_class_create_file_ns
+netdev_class_remove_file_ns
+format_proto_down
+netdev_show.isra.0
+dev_id_show
+dev_port_show
+addr_assign_type_show
+addr_len_show
+ifindex_show
+type_show
+link_mode_show
+mtu_show
+flags_show
+tx_queue_len_show
+gro_flush_timeout_show
+napi_defer_hard_irqs_show
+group_show
+proto_down_show
+name_assign_type_show
+get_netdev_queue_index.part.0
+tx_maxrate_store
+xps_rxqs_store
+traffic_class_show
+xps_cpus_store
+netdev_release
+netdev_uevent
+netstat_show.isra.0
+rx_nohandler_show
+tx_compressed_show
+rx_compressed_show
+tx_window_errors_show
+tx_heartbeat_errors_show
+tx_fifo_errors_show
+tx_carrier_errors_show
+tx_aborted_errors_show
+rx_missed_errors_show
+rx_fifo_errors_show
+rx_frame_errors_show
+rx_crc_errors_show
+rx_over_errors_show
+rx_length_errors_show
+collisions_show
+multicast_show
+tx_dropped_show
+rx_dropped_show
+tx_errors_show
+rx_errors_show
+tx_bytes_show
+rx_bytes_show
+tx_packets_show
+rx_packets_show
+net_grab_current_ns
+store_rps_dev_flow_table_cnt
+store_rps_map
+duplex_show.part.0
+speed_show
+phys_switch_id_show
+phys_port_name_show
+phys_port_id_show
+ifalias_store
+duplex_show
+netdev_store.isra.0
+proto_down_store
+flags_store
+mtu_store
+carrier_store
+group_store
+napi_defer_hard_irqs_store
+gro_flush_timeout_store
+tx_queue_len_store
+show_rps_map
+xps_rxqs_show
+xps_cpus_show
+net_rx_queue_update_kobjects
+netdev_queue_update_kobjects
+netdev_unregister_kobject
+netdev_register_kobject
+netdev_change_owner
+__page_pool_alloc_pages_slow
+page_pool_release_page
+page_pool_create
+page_pool_update_nid
+page_pool_release
+page_pool_destroy
+page_pool_release_retry
+page_pool_refill_alloc_cache
+page_pool_alloc_pages
+page_pool_put_page
+page_pool_use_xdp_mem
+softnet_seq_stop
+dev_seq_stop
+dev_seq_start
+ptype_get_idx
+ptype_seq_start
+dev_mc_net_exit
+dev_mc_net_init
+softnet_seq_show
+dev_proc_net_exit
+dev_proc_net_init
+ptype_seq_show
+dev_seq_printf_stats
+dev_seq_show
+softnet_get_online
+softnet_seq_start
+softnet_seq_next
+ptype_seq_next
+dev_mc_seq_show
+ptype_seq_stop
+dev_seq_next
+sk_psock_strp_read_done
+sk_psock_verdict_data_ready
+sk_psock_destroy
+sk_psock_write_space
+sk_psock_skb_redirect
+sk_psock_strp_data_ready
+sk_psock_skb_ingress_enqueue
+sk_msg_alloc
+sk_psock_init
+sk_msg_return
+sk_msg_memcopy_from_iter
+sk_msg_zerocopy_from_iter
+sk_msg_clone
+sk_psock_skb_ingress_self
+sk_psock_verdict_apply
+sk_msg_return_zero
+sk_psock_backlog
+sk_psock_verdict_recv
+sk_msg_free_elem
+__sk_msg_free
+sk_msg_free_nocharge
+sk_msg_free
+__sk_msg_free_partial
+sk_msg_free_partial
+sk_msg_trim
+sk_psock_strp_parse
+sk_psock_tls_strp_read
+sk_psock_msg_verdict
+sk_psock_strp_read
+sk_msg_free_partial_nocharge
+sk_psock_link_pop
+__sk_psock_purge_ingress_msg
+sk_psock_destroy_deferred
+sk_psock_init_strp
+sk_psock_start_verdict
+sk_psock_start_strp
+sk_psock_stop_strp
+sk_psock_drop
+sk_psock_stop_verdict
+zap_completion_queue
+netpoll_poll_enable
+refill_skbs
+netpoll_parse_ip_addr
+rcu_cleanup_netpoll_info
+netpoll_print_options
+netpoll_parse_options
+netpoll_poll_dev
+netpoll_start_xmit
+netpoll_poll_disable
+__netpoll_cleanup
+netpoll_cleanup
+__netpoll_free
+__netpoll_setup
+netpoll_setup
+netpoll_send_skb
+netpoll_send_udp
+queue_process
+fib_rules_net_init
+fib_rules_register
+lookup_rules_ops
+fib_rules_dump
+attach_rules
+fib_rules_seq_read
+fib_rules_event
+fib_rules_net_exit
+fib_rule_matchall
+fib_rules_lookup
+fib_nl2rule
+fib_rules_unregister
+fib_nl_fill_rule
+notify_rule_change
+fib_nl_newrule
+fib_nl_delrule
+dump_rules
+fib_nl_dumprule
+fib_default_rule_add
+__traceiter_kfree_skb
+__traceiter_consume_skb
+__traceiter_skb_copy_datagram_iovec
+__traceiter_net_dev_start_xmit
+__traceiter_net_dev_xmit
+__traceiter_net_dev_xmit_timeout
+__traceiter_net_dev_queue
+__traceiter_netif_receive_skb
+__traceiter_netif_rx
+__traceiter_napi_gro_frags_entry
+__traceiter_napi_gro_receive_entry
+__traceiter_netif_receive_skb_entry
+__traceiter_netif_receive_skb_list_entry
+__traceiter_netif_rx_entry
+__traceiter_netif_rx_ni_entry
+__traceiter_napi_gro_frags_exit
+__traceiter_napi_gro_receive_exit
+__traceiter_netif_receive_skb_exit
+__traceiter_netif_rx_exit
+__traceiter_netif_rx_ni_exit
+__traceiter_netif_receive_skb_list_exit
+__traceiter_napi_poll
+__traceiter_sock_rcvqueue_full
+__traceiter_sock_exceed_buf_limit
+__traceiter_inet_sock_set_state
+__traceiter_udp_fail_queue_rcv_skb
+__traceiter_tcp_retransmit_skb
+__traceiter_tcp_send_reset
+__traceiter_tcp_receive_reset
+__traceiter_tcp_destroy_sock
+__traceiter_tcp_rcv_space_adjust
+__traceiter_tcp_retransmit_synack
+__traceiter_tcp_probe
+__traceiter_fib_table_lookup
+__traceiter_qdisc_dequeue
+__traceiter_qdisc_reset
+__traceiter_qdisc_destroy
+__traceiter_qdisc_create
+__traceiter_br_fdb_add
+__traceiter_br_fdb_external_learn_add
+__traceiter_fdb_delete
+__traceiter_br_fdb_update
+__traceiter_page_pool_release
+__traceiter_page_pool_state_release
+__traceiter_page_pool_state_hold
+__traceiter_page_pool_update_nid
+__traceiter_neigh_create
+__traceiter_neigh_update
+__traceiter_neigh_update_done
+__traceiter_neigh_timer_handler
+__traceiter_neigh_event_send_done
+__traceiter_neigh_event_send_dead
+__traceiter_neigh_cleanup_and_release
+net_dm_packet_trace_napi_poll_hit
+net_dm_nl_pre_doit
+net_dm_nl_post_doit
+net_dm_hw_metadata_free
+sched_send_work
+net_dm_packet_trace_kfree_skb_hit
+reset_per_cpu_data
+net_dm_hw_reset_per_cpu_data
+net_dm_trace_off_set
+net_dm_cmd_config
+__net_dm_cpu_data_fini.part.0
+net_dm_hw_trap_summary_probe
+trace_drop_common.isra.0
+trace_kfree_skb_hit
+trace_napi_poll_hit
+exit_net_drop_monitor
+net_dm_hw_trap_packet_probe
+dropmon_net_event
+net_dm_cmd_trace
+send_dm_alert
+net_dm_cmd_config_get
+net_dm_hw_summary_work
+net_dm_packet_report_in_port_put
+net_dm_hw_packet_work
+net_dm_packet_work
+net_dm_cmd_stats_get
+skb_defer_rx_timestamp
+skb_clone_tx_timestamp
+ptp_parse_header
+ptp_classify_raw
+read_prioidx
+netprio_device_event
+read_priomap
+update_netprio
+cgrp_css_free
+netprio_set_prio
+write_priomap
+cgrp_css_online
+cgrp_css_alloc
+net_prio_attach
+cgrp_css_free
+task_cls_state
+cgrp_css_online
+read_classid
+update_classid_sock
+cgrp_css_alloc
+update_classid_task
+write_classid
+cgrp_attach
+lwtunnel_encap_add_ops
+lwtunnel_encap_del_ops
+lwtunnel_build_state
+lwtunnel_get_encap_size
+lwtstate_free
+lwtunnel_fill_encap
+lwtunnel_output
+lwtunnel_xmit
+lwtunnel_input
+lwtunnel_cmp_encap
+lwtunnel_valid_encap_type
+lwtunnel_valid_encap_type_attr
+lwtunnel_state_alloc
+bpf_encap_nlsize
+handle_gso_type
+bpf_lwt_prog_cmp
+bpf_lwt_prog_destroy
+bpf_destroy_state
+bpf_encap_cmp
+run_lwt_bpf.constprop.0
+bpf_output
+bpf_input
+bpf_parse_prog
+bpf_build_state
+bpf_fill_lwt_prog.part.0
+bpf_fill_encap_info
+bpf_lwt_xmit_reroute
+bpf_xmit
+bpf_lwt_push_ip_encap
+sock_map_release_progs
+sock_map_get_next_key
+sock_map_redirect_allowed
+sock_map_init_seq_private
+sock_hash_seq_start
+sock_hash_seq_next
+sock_hash_init_seq_private
+bpf_msg_redirect_map
+sock_map_seq_next
+sock_map_seq_start
+sock_map_init_proto
+sock_hash_lookup_elem_raw
+sock_hash_free_elem
+sock_map_seq_show
+sock_map_seq_stop
+sock_hash_seq_show
+sock_hash_seq_stop
+sock_map_iter_detach_target
+sock_map_iter_attach_target
+sock_map_sk_state_allowed.part.0
+sock_map_lookup_sys
+sock_hash_alloc
+sock_map_psock_get_checked
+sock_map_alloc
+bpf_sk_redirect_map
+sock_hash_release_progs
+sock_map_unref
+__sock_map_delete
+sock_map_delete_elem
+sock_map_remove_links
+sock_map_close
+sock_map_free
+sock_hash_free
+sock_map_link_no_progs
+sock_map_lookup
+sock_map_link
+sock_hash_update_common
+bpf_sock_hash_update
+sock_map_update_common
+bpf_sock_map_update
+sock_map_update_elem
+__sock_hash_lookup_elem
+bpf_sk_redirect_hash
+bpf_msg_redirect_hash
+sock_hash_lookup
+sock_hash_lookup_sys
+sock_hash_delete_elem
+sock_hash_get_next_key
+sock_map_update_elem_sys
+sock_map_prog_update
+sock_map_get_from_fd
+sock_map_prog_detach
+sock_map_unhash
+dst_cache_init
+dst_cache_destroy
+dst_cache_set_ip6
+dst_cache_per_cpu_get
+dst_cache_get
+dst_cache_get_ip4
+dst_cache_get_ip6
+dst_cache_set_ip4
+devlink_net
+__traceiter_devlink_hwmsg
+__traceiter_devlink_hwerr
+__traceiter_devlink_health_report
+__traceiter_devlink_health_recover_aborted
+__traceiter_devlink_health_reporter_state_update
+__traceiter_devlink_trap_report
+devlink_nl_cmd_port_unsplit_doit
+devlink_nl_cmd_eswitch_set_doit
+devlink_dpipe_entry_ctx_close
+devlink_resource_find
+devlink_is_reload_failed
+devlink_health_reporter_priv
+devlink_health_reporter_recovery_done
+devlink_trap_ctx_priv
+devlink_net_set
+devlink_nl_cmd_sb_occ_max_clear_doit
+devlink_nl_cmd_sb_occ_snapshot_doit
+devlink_nl_cmd_sb_tc_pool_bind_set_doit
+devlink_nl_cmd_sb_port_pool_set_doit
+devlink_nl_cmd_sb_pool_set_doit
+devlink_nl_cmd_port_split_doit
+devlink_nl_cmd_trap_policer_set_doit
+devlink_nl_cmd_flash_update
+devlink_nl_post_doit
+devlink_reload_enable
+devlink_reload_disable
+devlink_dpipe_headers_register
+devlink_dpipe_headers_unregister
+devlink_resource_size_get
+devlink_resource_occ_get_register
+devlink_resource_occ_get_unregister
+devlink_dpipe_send_and_alloc_skb
+devlink_trap_group_item_lookup
+devlink_trap_item_lookup
+devlink_trap_item_get_from_info
+devlink_get_from_attrs
+devlink_nl_pre_doit
+devlink_port_region_get_by_name
+devlink_region_get_by_name
+devlink_param_find_by_name
+devlink_fmsg_free
+devlink_dpipe_entry_clear
+devlink_sb_unregister
+devlink_resources_unregister
+__devlink_snapshot_id_decrement
+devlink_region_snapshot_id_put
+devlink_nl_cmd_resource_set
+devlink_free
+devlink_port_type_warn
+devlink_param_value_str_fill
+devlink_resources_validate
+__devlink_param_driverinit_value_get
+devlink_param_driverinit_value_get
+devlink_port_param_driverinit_value_get
+devlink_port_attrs_set
+devlink_port_attrs_pci_pf_set
+devlink_port_attrs_pci_vf_set
+__devlink_trap_action_set
+devlink_nl_cmd_trap_set_doit
+devlink_nl_cmd_trap_group_set_doit
+__devlink_health_reporter_find_by_name.isra.0
+devlink_dpipe_table_find.isra.0
+devlink_dpipe_table_resource_set
+devlink_dpipe_table_unregister
+devlink_nl_cmd_dpipe_table_counters_set
+devlink_dpipe_table_counter_enabled
+devlink_dpipe_value_put
+devlink_nl_cmd_dpipe_entries_get
+devlink_alloc
+devlink_health_reporter_put
+devlink_health_reporter_destroy
+devlink_port_health_reporter_destroy
+devlink_region_snapshot_id_get
+devlink_trap_report
+devlink_health_reporter_get_from_attrs
+devlink_nl_cmd_health_reporter_test_doit
+devlink_nl_cmd_health_reporter_set_doit
+devlink_nl_cmd_health_reporter_dump_clear_doit
+devlink_fmsg_obj_nest_start
+devlink_fmsg_nest_end
+devlink_fmsg_obj_nest_end
+devlink_fmsg_pair_nest_end
+devlink_fmsg_bool_pair_put.part.0
+devlink_fmsg_arr_pair_nest_end
+devlink_fmsg_binary_pair_nest_end
+devlink_fmsg_pair_nest_start
+devlink_sb_register
+__devlink_health_reporter_create
+devlink_port_health_reporter_create
+devlink_health_reporter_create
+devlink_fmsg_arr_pair_nest_start
+devlink_fmsg_binary_pair_nest_start
+devlink_resource_register
+devlink_dpipe_table_register
+devlink_health_do_dump
+devlink_info_driver_name_put
+devlink_info_serial_number_put
+devlink_info_board_serial_number_put
+devlink_nl_put_handle
+devlink_dpipe_entry_ctx_prepare
+devlink_nl_info_fill.constprop.0
+devlink_nl_cmd_info_get_doit
+devlink_nl_cmd_info_get_dumpit
+devlink_nl_cmd_eswitch_get_doit
+devlink_nl_sb_port_pool_fill.constprop.0
+devlink_nl_cmd_sb_port_pool_get_doit
+devlink_nl_cmd_sb_port_pool_get_dumpit
+devlink_info_version_put
+devlink_info_version_fixed_put
+devlink_info_version_stored_put
+devlink_info_version_running_put
+devlink_resource_put
+devlink_nl_cmd_resource_dump
+devlink_nl_sb_fill.constprop.0
+devlink_nl_cmd_sb_get_doit
+devlink_nl_cmd_sb_get_dumpit
+devlink_nl_health_reporter_fill
+devlink_nl_cmd_health_reporter_get_dumpit
+devlink_nl_cmd_health_reporter_get_doit
+devlink_recover_notify.constprop.0
+devlink_health_reporter_state_update
+devlink_health_reporter_recover
+devlink_nl_cmd_health_reporter_recover_doit
+devlink_health_report
+devlink_nl_trap_policer_fill
+devlink_nl_cmd_trap_policer_get_dumpit
+devlink_nl_cmd_trap_policer_get_doit
+devlink_trap_policer_notify
+devlink_trap_policer_unregister
+devlink_trap_policers_register
+devlink_trap_policers_unregister
+devlink_nl_region_notify_build
+devlink_nl_region_notify
+devlink_region_snapshot_del
+devlink_nl_cmd_region_del
+__devlink_region_snapshot_create
+devlink_region_snapshot_create
+devlink_region_create
+devlink_port_region_create
+devlink_region_destroy
+devlink_nl_cmd_region_new
+devlink_nl_cmd_dpipe_headers_get
+devlink_nl_port_fill
+devlink_nl_cmd_port_get_dumpit
+devlink_nl_cmd_port_get_doit
+devlink_port_notify
+devlink_nl_cmd_port_set_doit
+devlink_port_register
+devlink_port_unregister
+__devlink_port_type_set
+devlink_port_type_ib_set
+devlink_port_type_clear
+devlink_port_type_eth_set
+devlink_nl_region_fill.constprop.0
+devlink_nl_cmd_region_get_doit
+devlink_nl_cmd_region_get_dumpit
+devlink_dpipe_match_put
+devlink_dpipe_action_put
+devlink_dpipe_entry_ctx_append
+devlink_fmsg_put_value
+devlink_fmsg_bool_put
+devlink_fmsg_bool_pair_put
+devlink_fmsg_u8_put
+devlink_fmsg_u8_pair_put
+devlink_fmsg_u32_put
+devlink_fmsg_u32_pair_put
+devlink_fmsg_u64_put
+devlink_fmsg_u64_pair_put
+devlink_fmsg_string_put
+devlink_fmsg_string_pair_put
+devlink_fmsg_binary_put
+devlink_fmsg_binary_pair_put
+__devlink_flash_update_notify
+devlink_flash_update_begin_notify
+devlink_flash_update_end_notify
+devlink_flash_update_status_notify
+devlink_flash_update_timeout_notify
+devlink_nl_sb_pool_fill.constprop.0
+devlink_nl_cmd_sb_pool_get_doit
+devlink_nl_cmd_sb_pool_get_dumpit
+devlink_trap_stats_put
+devlink_nl_trap_group_fill
+devlink_nl_cmd_trap_group_get_dumpit
+devlink_nl_cmd_trap_group_get_doit
+devlink_trap_group_notify
+devlink_trap_group_unregister
+devlink_trap_groups_register
+devlink_trap_groups_unregister
+devlink_nl_sb_tc_pool_bind_fill.constprop.0
+devlink_nl_cmd_sb_tc_pool_bind_get_doit
+devlink_nl_cmd_sb_tc_pool_bind_get_dumpit
+devlink_nl_cmd_region_read_dumpit
+devlink_fmsg_prepare_skb
+devlink_nl_cmd_health_reporter_dump_get_dumpit
+devlink_nl_cmd_health_reporter_diagnose_doit
+devlink_nl_trap_fill
+devlink_nl_cmd_trap_get_dumpit
+devlink_nl_cmd_trap_get_doit
+devlink_trap_notify
+devlink_trap_unregister
+devlink_traps_register
+devlink_traps_unregister
+devlink_reload_stats_put
+devlink_nl_fill
+devlink_nl_cmd_get_dumpit
+devlink_notify
+__devlink_reload_stats_update
+devlink_remote_reload_actions_performed
+devlink_register
+devlink_unregister
+devlink_nl_cmd_get_doit
+devlink_nl_param_fill
+devlink_nl_cmd_port_param_get_dumpit
+devlink_nl_cmd_param_get_dumpit
+devlink_param_notify
+__devlink_nl_cmd_param_set_doit
+devlink_nl_cmd_port_param_set_doit
+devlink_nl_cmd_param_set_doit
+devlink_param_unregister_one
+devlink_port_params_unregister
+__devlink_params_register
+devlink_params_register
+devlink_port_params_register
+devlink_params_unregister
+__devlink_param_driverinit_value_set
+devlink_param_driverinit_value_set
+devlink_port_param_driverinit_value_set
+devlink_param_value_changed
+devlink_port_param_value_changed
+devlink_reload
+devlink_nl_cmd_reload
+devlink_pernet_pre_exit
+devlink_params_publish
+devlink_params_unpublish
+devlink_nl_cmd_port_param_get_doit
+devlink_nl_cmd_param_get_doit
+devlink_dpipe_table_put
+devlink_nl_cmd_dpipe_table_get
+devlink_compat_running_version
+devlink_compat_flash_update
+devlink_compat_phys_port_name_get
+devlink_compat_switch_id_get
+gro_cell_poll
+gro_cells_receive
+gro_cells_init
+gro_cells_destroy
+notsupp_get_next_key
+sk_storage_uncharge
+sk_storage_ptr
+sk_storage_charge
+bpf_iter_init_sk_storage_map
+bpf_sk_storage_map_seq_find_next
+bpf_sk_storage_map_seq_next
+bpf_sk_storage_map_seq_start
+sk_storage_delete
+bpf_fd_sk_storage_delete_elem
+bpf_fd_sk_storage_update_elem
+bpf_fd_sk_storage_lookup_elem
+sk_storage_map_free
+sk_storage_map_alloc
+__bpf_sk_storage_map_seq_show
+bpf_sk_storage_map_seq_show
+bpf_sk_storage_map_seq_stop
+bpf_iter_detach_map
+bpf_iter_attach_map
+bpf_sk_storage_diag_free.part.0
+bpf_sk_storage_diag_free
+bpf_sk_storage_diag_alloc
+bpf_sk_storage_get
+bpf_sk_storage_delete
+diag_get
+bpf_sk_storage_diag_put
+bpf_sk_storage_free
+bpf_sk_storage_clone
+__ia32_compat_sys_sendmsg
+__x32_compat_sys_sendmsg
+__ia32_compat_sys_sendmmsg
+__x32_compat_sys_sendmmsg
+__ia32_compat_sys_recvmsg
+__x32_compat_sys_recvmsg
+__ia32_compat_sys_recv
+__x32_compat_sys_recv
+__ia32_compat_sys_recvfrom
+__x32_compat_sys_recvfrom
+__ia32_compat_sys_recvmmsg_time64
+__x32_compat_sys_recvmmsg_time64
+__ia32_compat_sys_recvmmsg_time32
+__x32_compat_sys_recvmmsg_time32
+__ia32_compat_sys_socketcall
+__x32_compat_sys_socketcall
+__get_compat_msghdr
+get_compat_msghdr
+cmsghdr_from_user_compat_to_kern
+put_cmsg_compat
+scm_detach_fds_compat
+eth_header_parse_protocol
+eth_validate_addr
+eth_prepare_mac_addr_change
+eth_header_cache_update
+eth_header_parse
+eth_header_cache
+eth_commit_mac_addr_change
+eth_mac_addr
+ether_setup
+eth_header
+alloc_etherdev_mqs
+sysfs_format_mac
+eth_gro_complete
+nvmem_get_mac_address
+eth_gro_receive
+eth_type_trans
+eth_get_headlen
+arch_get_platform_mac_address
+eth_platform_get_mac_address
+alloc_fcdev
+fc_header
+fc_setup
+fddi_type_trans
+alloc_fddidev
+fddi_header
+fddi_setup
+noop_dequeue
+mini_qdisc_rcu_func
+noop_enqueue
+noqueue_init
+dev_graft_qdisc
+mini_qdisc_pair_block_init
+mini_qdisc_pair_init
+pfifo_fast_peek
+pfifo_fast_dequeue
+dev_trans_start
+__netdev_watchdog_up
+netif_carrier_on
+pfifo_fast_dump
+__skb_array_destroy_skb
+pfifo_fast_destroy
+qdisc_reset
+qdisc_destroy
+qdisc_put_unlocked
+psched_ratecfg_precompute
+mini_qdisc_pair_swap
+netif_carrier_off
+dev_reset_queue.constprop.0
+pfifo_fast_init
+qdisc_put
+pfifo_fast_reset
+pfifo_fast_change_tx_queue_len
+pfifo_fast_enqueue
+dev_watchdog
+sch_direct_xmit
+__qdisc_run
+qdisc_alloc
+qdisc_create_dflt
+attach_one_default_qdisc.constprop.0
+dev_activate
+qdisc_free
+qdisc_free_cb
+dev_deactivate_many
+dev_deactivate
+dev_qdisc_change_tx_queue_len
+dev_init_scheduler
+dev_shutdown
+mq_offload
+mq_find
+mq_select_queue
+mq_leaf
+mq_dump_class
+mq_walk
+mq_attach
+mq_destroy
+mq_dump_class_stats
+mq_graft
+mq_init
+mq_dump
+unregister_qdisc
+qdisc_leaf
+qdisc_class_hash_insert
+qdisc_class_hash_remove
+qdisc_offload_dump_helper
+check_loop
+check_loop_fn
+tc_bind_tclass
+register_qdisc
+qdisc_match_from_root
+qdisc_lookup_default
+__qdisc_calculate_pkt_len
+qdisc_warn_nonwc
+qdisc_watchdog_init_clockid
+qdisc_watchdog_init
+qdisc_watchdog
+qdisc_watchdog_cancel
+qdisc_class_hash_destroy
+qdisc_class_hash_alloc
+qdisc_class_hash_init
+tc_dump_tclass_qdisc
+qdisc_get_stab
+tc_bind_class_walker
+qdisc_lookup_ops
+psched_net_exit
+psched_net_init
+psched_show
+qdisc_offload_graft_helper
+tc_dump_tclass_root
+tc_dump_tclass
+qdisc_get_rtab
+qdisc_put_rtab
+qdisc_put_stab.part.0
+qdisc_put_stab
+qdisc_watchdog_schedule_range_ns
+qdisc_hash_del
+qdisc_hash_add.part.0
+qdisc_hash_add
+tc_fill_tclass
+qdisc_class_dump
+tclass_notify.constprop.0
+tcf_node_bind
+tc_fill_qdisc
+tc_dump_qdisc_root
+tc_dump_qdisc
+qdisc_notify
+notify_and_destroy
+qdisc_graft
+qdisc_class_hash_grow
+qdisc_get_default
+qdisc_set_default
+qdisc_lookup
+qdisc_tree_reduce_backlog
+tc_ctl_tclass
+tc_get_qdisc
+qdisc_create
+tc_modify_qdisc
+qdisc_lookup_rcu
+blackhole_dequeue
+blackhole_enqueue
+tcf_chain_head_change_dflt
+tcf_exts_num_actions
+register_tcf_proto_ops
+unregister_tcf_proto_ops
+tcf_queue_work
+__tcf_get_next_chain
+tcf_chain0_head_change
+tcf_qevent_dump
+tcf_net_init
+tcf_chain0_head_change_cb_del
+tcf_block_owner_del
+tcf_tunnel_encap_put_tunnel
+tcf_exts_destroy
+tcf_exts_change
+tcf_exts_validate
+tcf_exts_dump
+tcf_exts_dump_stats
+tc_setup_cb_call
+tc_cleanup_flow_action
+__tcf_proto_lookup_ops
+tcf_net_exit
+__tcf_qdisc_cl_find
+tcf_qevent_handle
+tcf_proto_check_kind
+tcf_proto_lookup_ops
+tcf_proto_is_unlocked.part.0
+tcf_block_owner_netif_keep_dst
+tcf_block_netif_keep_dst
+__tcf_qdisc_find.part.0
+tcf_gate_entry_destructor
+tcf_chain_create
+tcf_qevent_validate_change
+tcf_proto_signal_destroying
+tcf_block_refcnt_get
+tc_setup_flow_action
+tc_cls_offload_cnt_reset
+tc_setup_cb_destroy
+tcf_chain_tp_find
+tc_cls_offload_cnt_update
+tc_setup_cb_reoffload
+tc_setup_cb_add
+tc_setup_cb_replace
+__tcf_block_find
+tcf_classify
+tc_chain_fill_node
+tc_chain_notify
+__tcf_chain_get
+tcf_chain_get_by_act
+__tcf_chain_put
+tcf_chain_put_by_act
+tcf_get_next_chain
+tcf_proto_destroy
+tcf_proto_put
+tcf_chain_flush
+tcf_chain_tp_delete_empty
+tcf_fill_node
+tfilter_notify
+tcf_node_dump
+__tcf_get_next_proto
+tcf_get_next_proto
+tcf_block_playback_offloads
+tcf_block_unbind
+tc_block_indr_cleanup
+tcf_block_setup
+tcf_block_offload_cmd
+tcf_block_offload_unbind
+tcf_chain_dump
+tcf_exts_terse_dump
+tcf_classify_ingress
+__tcf_block_put
+tcf_block_get_ext
+tcf_block_get
+tcf_qevent_init
+tc_dump_chain
+tcf_block_release
+tc_get_tfilter
+tc_ctl_chain
+tc_del_tfilter
+tc_new_tfilter
+tc_dump_tfilter
+tcf_block_put_ext.part.0
+tcf_block_put_ext
+tcf_block_put
+tcf_qevent_destroy
+tcf_action_set_ctrlact
+tcf_free_cookie_rcu
+tcf_action_cleanup
+tcf_idr_cleanup
+tcf_unregister_action
+tcf_action_fill_size
+find_dump_kind
+tc_lookup_action_n
+tc_lookup_action
+tcf_action_update_stats
+tcf_action_check_ctrlact
+__tcf_action_put
+tcf_action_put_many
+__tcf_idr_release
+tcf_register_action
+tcf_action_exec
+tcf_idr_check_alloc
+tcf_idr_create
+tcf_idr_create_from_flags
+tcf_idrinfo_destroy
+tcf_idr_search
+tc_dump_action
+tca_action_flush
+tcf_action_destroy
+tcf_action_dump_old
+tcf_action_init_1
+tcf_action_init
+tcf_action_copy_stats
+tcf_action_dump_terse
+tcf_action_dump_1
+tcf_generic_walker
+tcf_action_dump
+tca_get_fill.constprop.0
+tca_action_gd
+tcf_action_add
+tc_ctl_action
+fifo_destroy
+fifo_hd_dump
+pfifo_tail_enqueue
+fifo_set_limit
+fifo_create_dflt
+__fifo_init.isra.0
+fifo_init
+fifo_hd_init
+fifo_dump
+bfifo_enqueue
+pfifo_enqueue
+tcf_em_unregister
+tcf_em_register
+tcf_em_tree_destroy
+tcf_em_tree_dump
+__tcf_em_tree_match
+tcf_em_lookup
+tcf_em_tree_validate
+netlink_ioctl
+netlink_sock_destruct_work
+netlink_overrun
+netlink_update_listeners
+netlink_update_subscriptions
+netlink_strict_get_check
+netlink_skb_set_owner_r
+netlink_add_tap
+netlink_remove_tap
+__netlink_ns_capable
+netlink_ns_capable
+netlink_capable
+netlink_net_capable
+netlink_set_err
+netlink_update_socket_mc
+netlink_undo_bind
+netlink_skb_destructor
+netlink_trim
+netlink_compare_arg_init
+__nlmsg_put
+netlink_data_ready
+netlink_kernel_release
+netlink_tap_init_net
+__netlink_create
+netlink_register_notifier
+netlink_unregister_notifier
+netlink_net_exit
+netlink_net_init
+__netlink_seq_next
+netlink_seq_next
+netlink_sock_destruct
+netlink_seq_show
+netlink_getsockopt
+netlink_has_listeners
+netlink_seq_stop
+netlink_deliver_tap
+__netlink_sendskb
+deferred_put_nlk_sk
+netlink_seq_start
+netlink_dump_done
+netlink_dump
+netlink_recvmsg
+netlink_getname
+netlink_create
+netlink_broadcast_filtered
+netlink_broadcast
+netlink_lookup
+__netlink_dump_start
+netlink_insert
+netlink_autobind
+netlink_connect
+netlink_table_grab
+netlink_table_ungrab
+__netlink_kernel_create
+netlink_realloc_groups
+netlink_setsockopt
+netlink_bind
+netlink_release
+netlink_getsockbyfilp
+netlink_attachskb
+netlink_unicast
+netlink_sendmsg
+netlink_ack
+netlink_rcv_skb
+nlmsg_notify
+netlink_sendskb
+netlink_detachskb
+__netlink_change_ngroups
+netlink_change_ngroups
+__netlink_clear_multicast_users
+genl_lock
+genl_unlock
+genl_op_from_full
+genl_lock_dumpit
+ctrl_dumppolicy_done
+genl_op_from_small
+genl_get_cmd
+genl_family_find_byname
+genlmsg_put
+ctrl_dumppolicy_prep
+genl_pernet_exit
+genl_rcv
+genl_family_rcv_msg_dumpit
+genl_parallel_done
+genl_lock_done
+genl_pernet_init
+genlmsg_multicast_allns
+genl_notify
+genl_get_cmd_by_index
+ctrl_dumppolicy_start
+ctrl_dumppolicy
+ctrl_fill_info
+ctrl_dumpfamily
+ctrl_build_family_msg
+ctrl_getfamily
+genl_ctrl_event
+genl_register_family
+genl_unregister_family
+genl_family_rcv_msg_attrs_parse.isra.0
+genl_start
+genl_family_rcv_msg_doit
+genl_rcv_msg
+add_policy
+netlink_policy_dump_get_policy_idx
+__netlink_policy_dump_write_attr
+netlink_policy_dump_add_policy
+netlink_policy_dump_loop
+netlink_policy_dump_attr_size_estimate
+netlink_policy_dump_write_attr
+netlink_policy_dump_write
+netlink_policy_dump_free
+__traceiter_bpf_test_finish
+bpf_modify_return_test
+__bpf_prog_test_run_raw_tp
+bpf_test_run
+bpf_test_init
+bpf_ctx_finish
+bpf_test_finish
+bpf_ctx_init
+bpf_fentry_test1
+bpf_fentry_test2
+bpf_fentry_test3
+bpf_fentry_test4
+bpf_fentry_test5
+bpf_fentry_test6
+bpf_fentry_test7
+bpf_fentry_test8
+bpf_prog_test_run_tracing
+bpf_prog_test_run_raw_tp
+bpf_prog_test_run_skb
+bpf_prog_test_run_xdp
+bpf_prog_test_run_flow_dissector
+ethtool_op_get_link
+ethtool_op_get_ts_info
+__ethtool_get_sset_count
+__ethtool_get_flags
+ethtool_intersect_link_masks
+ethtool_set_coalesce_supported
+netdev_rss_key_fill
+__ethtool_set_flags
+ethtool_set_coalesce
+ethtool_get_value
+ethtool_set_rxnfc
+ethtool_get_coalesce
+ethtool_get_channels
+ethtool_get_drvinfo
+ethtool_rx_flow_rule_destroy
+ethtool_get_any_eeprom
+ethtool_flash_device
+ethtool_set_channels
+__ethtool_get_module_info
+__ethtool_get_module_eeprom
+load_link_ksettings_from_user
+ethtool_get_per_queue_coalesce
+__ethtool_get_link_ksettings
+ethtool_set_settings
+ethtool_set_link_ksettings
+ethtool_get_feature_mask
+store_link_ksettings_for_user.constprop.0
+ethtool_get_link_ksettings
+ethtool_convert_link_mode_to_legacy_u32
+ethtool_get_settings
+ethtool_convert_legacy_u32_to_link_mode
+ethtool_rx_flow_rule_create
+ethtool_copy_validate_indir
+ethtool_get_rxfh
+ethtool_set_rxfh
+ethtool_set_per_queue_coalesce
+ethtool_set_per_queue
+ethtool_set_rxfh_indir
+ethtool_get_rxfh_indir
+ethtool_get_sset_info
+ethtool_get_rxnfc
+ethtool_virtdev_validate_cmd
+ethtool_virtdev_set_link_ksettings
+dev_ethtool
+ethtool_set_ethtool_phy_ops
+convert_legacy_settings_to_link_ksettings
+__ethtool_get_link
+ethtool_get_max_rxfh_channel
+ethtool_check_ops
+__ethtool_get_ts_info
+ethnl_default_done
+ethnl_init_reply_data
+ethtool_notify
+ethnl_netdev_event
+ethnl_fill_reply_header.part.0
+ethnl_default_dumpit
+ethnl_default_notify
+ethnl_parse_header_dev_get
+ethnl_default_parse
+ethnl_default_start
+ethnl_fill_reply_header
+ethnl_reply_init
+ethnl_default_doit
+ethnl_dump_put
+ethnl_bcastmsg_put
+ethnl_multicast
+ethnl_bitmap32_clear
+ethnl_compact_sanity_checks
+ethnl_parse_bit
+ethnl_update_bitset32.part.0
+ethnl_bitset32_size
+ethnl_put_bitset32
+ethnl_bitset_is_compact
+ethnl_update_bitset32
+ethnl_parse_bitset
+ethnl_bitset_size
+ethnl_put_bitset
+ethnl_update_bitset
+strset_cleanup_data
+strset_include
+strset_reply_size
+strset_parse_request
+strset_prepare_data
+strset_fill_reply
+linkinfo_reply_size
+linkinfo_fill_reply
+linkinfo_prepare_data
+ethnl_set_linkinfo
+linkmodes_prepare_data
+linkmodes_fill_reply
+linkmodes_reply_size
+ethnl_set_linkmodes
+linkstate_prepare_data
+linkstate_reply_size
+linkstate_fill_reply
+debug_prepare_data
+debug_fill_reply
+debug_reply_size
+ethnl_set_debug
+wol_prepare_data
+wol_reply_size
+wol_fill_reply
+ethnl_set_wol
+features_fill_reply
+features_reply_size
+features_prepare_data
+ethnl_set_features
+privflags_cleanup_data
+privflags_fill_reply
+privflags_reply_size
+ethnl_get_priv_flags_info
+privflags_prepare_data
+ethnl_set_privflags
+rings_reply_size
+rings_prepare_data
+rings_fill_reply
+ethnl_set_rings
+channels_reply_size
+channels_prepare_data
+channels_fill_reply
+ethnl_set_channels
+coalesce_reply_size
+coalesce_put_u32
+coalesce_prepare_data
+coalesce_fill_reply
+ethnl_set_coalesce
+pause_prepare_data
+pause_reply_size
+pause_fill_reply
+ethnl_set_pause
+eee_prepare_data
+eee_fill_reply
+eee_reply_size
+ethnl_set_eee
+tsinfo_fill_reply
+tsinfo_reply_size
+tsinfo_prepare_data
+ethnl_cable_test_finished
+ethnl_cable_test_started
+ethnl_cable_test_alloc
+ethnl_cable_test_free
+ethnl_cable_test_pulse
+ethnl_cable_test_step
+ethnl_cable_test_amplitude
+ethnl_cable_test_result
+ethnl_cable_test_fault_length
+ethnl_act_cable_test
+ethnl_act_cable_test_tdr
+ethnl_tunnel_info_fill_reply
+ethnl_tunnel_info_doit
+ethnl_tunnel_info_start
+ethnl_tunnel_info_dumpit
+accept_all
+nf_hook_entry_head
+hooks_validate
+allocate_hook_entries_size
+nf_hook_entries_grow
+__nf_hook_entries_try_shrink
+__nf_hook_entries_free
+nf_hook_slow
+nf_hook_slow_list
+nf_ct_get_tuple_skb
+netfilter_net_exit
+netfilter_net_init
+nf_hook_entries_free.part.0
+nf_hook_entries_delete_raw
+__nf_register_net_hook
+__nf_unregister_net_hook
+nf_hook_entries_insert_raw
+nf_ct_attach
+nf_conntrack_destroy
+nf_unregister_net_hook
+nf_unregister_net_hooks
+nf_register_net_hook
+nf_register_net_hooks
+seq_stop
+seq_next
+nf_log_net_exit
+seq_show
+seq_start
+nf_log_set
+nf_log_unset
+nf_log_register
+__find_logger
+nf_log_bind_pf
+nf_log_net_init
+nf_log_unregister
+nf_log_packet
+nf_log_trace
+nf_log_buf_open
+nf_log_buf_add
+nf_log_proc_dostring
+nf_logger_request_module
+nf_logger_put
+nf_logger_find_get
+nf_log_buf_close
+nf_log_unbind_pf
+nf_unregister_queue_handler
+nf_register_queue_handler
+nf_queue_nf_hook_drop
+nf_queue_entry_release_refs
+nf_queue_entry_free
+nf_queue_entry_get_refs
+nf_queue
+nf_reinject
+nf_unregister_sockopt
+nf_register_sockopt
+nf_sockopt_find.constprop.0
+nf_getsockopt
+nf_setsockopt
+nf_route
+nf_ip_checksum
+nf_ip6_checksum
+nf_checksum
+nf_checksum_partial
+nf_reroute
+ipv4_cow_metrics
+rt_cache_seq_stop
+ipv4_blackhole_dst_check
+ipv4_rt_blackhole_update_pmtu
+ipv4_rt_blackhole_redirect
+ipv4_rt_blackhole_cow_metrics
+rt_cache_seq_start
+rt_cache_seq_next
+ipv4_dst_check
+ipv4_blackhole_mtu
+ip_idents_reserve
+__ip_select_ident
+rt_cpu_seq_next
+rt_cpu_seq_start
+fnhe_flush_routes
+ipv4_sysctl_rtcache_flush
+rt_dst_alloc
+rt_dst_clone
+ip_handle_martian_source
+ip_rt_bug
+ip_error
+rt_fill_info
+ipv4_inetpeer_exit
+ipv4_inetpeer_init
+rt_genid_init
+sysctl_route_net_init
+ip_rt_do_proc_exit
+ip_rt_do_proc_init
+rt_cpu_seq_open
+rt_cache_seq_open
+rt_cpu_seq_show
+fill_route_from_fnhe
+ipv4_mtu
+ipv4_default_advmss
+ipv4_negative_advice
+sysctl_route_net_exit
+rt_cache_seq_show
+rt_cpu_seq_stop
+__build_flow_key.constprop.0
+ipv4_link_failure
+ip_multipath_l3_keys
+rt_acct_proc_show
+find_exception
+update_or_create_fnhe
+ipv4_confirm_neigh
+__ip_rt_update_pmtu
+ip_rt_update_pmtu
+ipv4_neigh_lookup
+__ip_do_redirect
+ip_do_redirect
+rt_cache_flush
+ip_rt_send_redirect
+ip_rt_get_source
+ip_mtu_from_fib_result
+rt_add_uncached_list
+rt_cache_route
+rt_set_nexthop.constprop.0
+rt_del_uncached_list
+ipv4_dst_destroy
+rt_flush_dev
+ip_mc_validate_source
+fib_multipath_hash
+ip_route_input_slow
+ip_route_use_hint
+ip_route_input_rcu
+ip_route_input_noref
+ip_route_output_key_hash_rcu
+ip_route_output_key_hash
+ipv4_update_pmtu
+__ipv4_sk_update_pmtu
+ipv4_redirect
+ipv4_sk_redirect
+ip_route_output_flow
+ipv4_sk_update_pmtu
+ip_route_output_tunnel
+inet_rtm_getroute
+ipv4_blackhole_route
+fib_dump_info_fnhe
+ip_rt_multicast_event
+inetpeer_free_rcu
+inet_peer_base_init
+inet_peer_xrlim_allow
+inet_putpeer
+inetpeer_invalidate_tree
+lookup
+inet_getpeer
+inet_add_offload
+inet_add_protocol
+inet_del_protocol
+inet_del_offload
+ip_sublist_rcv_finish
+ip_rcv_finish_core.isra.0
+ip_rcv_finish
+ip_rcv_core
+ip_sublist_rcv
+ip_call_ra_chain
+ip_protocol_deliver_rcu
+ip_local_deliver_finish
+ip_local_deliver
+ip_rcv
+ip_list_rcv
+ipv4_frags_pre_exit_net
+ipv4_frags_exit_net
+ipv4_frags_init_net
+ip4_obj_cmpfn
+ip4_frag_free
+ip4_frag_init
+ip4_obj_hashfn
+ip_defrag
+ip_check_defrag
+ip_expire
+ip4_key_hashfn
+ip_forward_finish
+ip_forward
+__ip_options_compile
+ip_options_compile
+ip_options_rcv_srr
+ip_options_build
+__ip_options_echo
+ip_options_fragment
+ip_options_undo
+ip_options_get
+ip_forward_options
+ip_send_check
+ip_fraglist_init
+ip_frag_init
+ip_copy_addrs
+ip_mc_finish_output
+ip_reply_glue_bits
+ip_generic_getfrag
+ip_setup_cork
+__ip_flush_pending_frames.isra.0
+ip_finish_output2
+ip_copy_metadata
+ip_fraglist_prepare
+ip_frag_next
+ip_do_fragment
+ip_fragment.constprop.0
+__ip_finish_output
+ip_finish_output
+__ip_append_data
+ip_append_data.part.0
+__ip_local_out
+ip_local_out
+ip_build_and_send_pkt
+__ip_queue_xmit
+ip_queue_xmit
+ip_mc_output
+ip_output
+ip_append_data
+ip_append_page
+__ip_make_skb
+ip_send_skb
+ip_push_pending_frames
+ip_flush_pending_frames
+ip_make_skb
+ip_send_unicast_reply
+ip_sock_set_freebind
+ip_sock_set_recverr
+ip_sock_set_mtu_discover
+ip_sock_set_pktinfo
+__ip_sock_set_tos
+ip_sock_set_tos
+compat_ip_get_mcast_msfilter
+ip_get_mcast_msfilter
+do_ip_getsockopt
+ip_getsockopt
+ip_cmsg_recv_offset
+ip_ra_destroy_rcu
+compat_ip_mcast_join_leave
+ip_mcast_join_leave
+copy_group_source_from_sockptr
+do_mcast_group_source
+set_mcast_msfilter
+ip_cmsg_send
+ip_ra_control
+ip_setsockopt
+ip_icmp_error
+ip_local_error
+ip_recv_error
+ipv4_pktinfo_prepare
+inet_hashinfo_init
+init_hashinfo_lhash2
+inet_hashinfo2_init_mod
+inet_ehash_locks_alloc
+sock_gen_put
+sock_edemux
+inet_ehashfn
+__inet_lookup_established
+inet_lhash2_lookup
+inet_put_port
+__inet_lookup_listener
+inet_lhash2_bucket_sk
+inet_unhash
+__inet_check_established
+inet_bind_bucket_create
+__inet_inherit_port
+inet_bind_bucket_destroy
+inet_bind_hash
+inet_ehash_insert
+inet_ehash_nolisten
+__inet_hash
+inet_hash
+__inet_hash_connect
+inet_hash_connect
+inet_twsk_alloc
+__inet_twsk_schedule
+inet_twsk_hashdance
+inet_twsk_bind_unhash
+inet_twsk_free
+inet_twsk_put
+inet_twsk_kill
+tw_timer_handler
+inet_twsk_deschedule_put
+inet_twsk_purge
+inet_csk_delete_keepalive_timer
+inet_csk_reset_keepalive_timer
+inet_csk_reqsk_queue_hash_add
+ipv6_rcv_saddr_equal
+inet_rtx_syn_ack
+inet_csk_addr2sockaddr
+inet_get_local_port_range
+inet_csk_init_xmit_timers
+inet_csk_clear_xmit_timers
+inet_csk_route_req
+inet_csk_route_child_sock
+inet_csk_clone_lock
+inet_csk_listen_start
+inet_csk_rebuild_route
+inet_csk_update_pmtu
+inet_rcv_saddr_equal
+inet_csk_bind_conflict
+inet_csk_destroy_sock
+inet_child_forget
+inet_csk_prepare_forced_close
+inet_csk_listen_stop
+inet_csk_reqsk_queue_add
+inet_csk_reqsk_queue_drop
+inet_csk_reqsk_queue_drop_and_put
+reqsk_timer_handler
+inet_csk_complete_hashdance
+inet_csk_accept
+inet_rcv_saddr_any
+inet_csk_update_fastreuse
+inet_csk_get_port
+tcp_mmap
+tcp_get_info_chrono_stats
+tcp_init_sock
+tcp_splice_data_recv
+tcp_sock_set_syncnt
+tcp_sock_set_user_timeout
+tcp_sock_set_keepintvl
+tcp_sock_set_keepcnt
+skb_entail
+tcp_set_rcvlowat
+tcp_recv_timestamp
+tcp_zerocopy_vm_insert_batch
+tcp_enter_memory_pressure
+tcp_leave_memory_pressure
+tcp_ioctl
+tcp_inq_hint
+__tcp_sock_set_cork.part.0
+tcp_sock_set_cork
+tcp_get_info
+tcp_get_md5sig_pool
+tcp_set_state
+tcp_shutdown
+tcp_tx_timestamp
+tcp_remove_empty_skb.part.0
+tcp_alloc_md5sig_pool
+__tcp_sock_set_nodelay.part.0
+tcp_sock_set_nodelay
+tcp_peek_len
+tcp_poll
+tcp_md5_hash_skb_data
+tcp_md5_hash_key
+tcp_done
+tcp_recv_skb
+tcp_push
+sk_stream_alloc_skb
+tcp_send_mss
+do_tcp_sendpages
+tcp_sendpage_locked
+tcp_sendpage
+tcp_sendmsg_locked
+tcp_sendmsg
+tcp_free_fastopen_req
+tcp_cleanup_rbuf
+tcp_read_sock
+tcp_splice_read
+tcp_recvmsg
+__tcp_sock_set_quickack.part.0
+tcp_sock_set_quickack
+do_tcp_getsockopt.isra.0
+tcp_getsockopt
+tcp_check_oom
+tcp_close
+tcp_write_queue_purge
+tcp_disconnect
+tcp_abort
+tcp_sock_set_keepidle_locked
+tcp_sock_set_keepidle
+tcp_setsockopt
+tcp_get_timestamping_opt_stats
+clean_acked_data_flush
+tcp_initialize_rcv_mss
+tcp_enter_cwr
+tcp_parse_md5sig_option
+clean_acked_data_enable
+clean_acked_data_disable
+tcp_incr_quickack
+tcp_enter_quickack_mode
+__tcp_ecn_check_ce
+tcp_update_pacing_rate
+tcp_newly_delivered
+tcp_reset_check
+tcp_sndbuf_expand
+tcp_undo_cwnd_reduction
+tcp_syn_flood_action
+tcp_drop
+tcp_match_skb_to_sack
+tcp_urg
+tcp_sacktag_one
+tcp_parse_fastopen_option
+tcp_parse_options
+tcp_dsack_extend
+tcp_add_reno_sack.part.0
+tcp_collapse_one
+tcp_any_retrans_done.part.0
+tcp_try_keep_open
+tcp_try_undo_recovery
+tcp_get_syncookie_mss
+tcp_rcv_spurious_retrans.part.0
+tcp_send_dupack
+tcp_send_challenge_ack.isra.0
+tcp_ack_tstamp
+tcp_identify_packet_loss
+tcp_xmit_recovery.part.0
+tcp_sack_compress_send_ack
+__tcp_ack_snd_check
+inet_reqsk_alloc
+tcp_force_fast_retransmit
+tcp_check_sack_reordering
+tcp_try_undo_loss
+tcp_shifted_skb
+tcp_sacktag_walk
+tcp_sacktag_write_queue
+tcp_prune_ofo_queue
+tcp_try_coalesce
+tcp_queue_rcv
+tcp_ooo_try_coalesce
+tcp_conn_request
+tcp_process_tlp_ack
+tcp_check_space
+tcp_grow_window
+tcp_event_data_recv
+tcp_ack_update_rtt
+tcp_rcv_space_adjust
+tcp_init_cwnd
+tcp_mark_skb_lost
+tcp_simple_retransmit
+tcp_mark_head_lost
+tcp_skb_shift
+tcp_clear_retrans
+tcp_enter_loss
+tcp_cwnd_reduction
+tcp_enter_recovery
+tcp_fastretrans_alert
+tcp_synack_rtt_meas
+tcp_rearm_rto
+tcp_ack
+tcp_rcv_synrecv_state_fastopen
+tcp_oow_rate_limited
+tcp_reset
+tcp_validate_incoming
+tcp_fin
+tcp_data_ready
+tcp_rbtree_insert
+tcp_collapse
+tcp_try_rmem_schedule
+tcp_send_rcvq
+tcp_data_queue
+tcp_rcv_established
+tcp_init_transfer
+tcp_finish_connect
+tcp_rcv_state_process
+tcp_set_skb_tso_segs
+tcp_init_tso_segs
+tcp_update_skb_after_send
+tcp_tso_segs
+tcp_select_initial_window
+tcp_fragment_tstamp
+tcp_small_queue_check
+tcp_adjust_pcount
+tcp_mss_to_mtu
+tcp_mtup_init
+__pskb_trim_head
+bpf_skops_hdr_opt_len
+bpf_skops_write_hdr_opt
+tcp_event_new_data_sent
+tcp_options_write
+tcp_rtx_synack.part.0
+tcp_rtx_synack
+tcp_wfree
+tcp_established_options
+tcp_make_synack
+tcp_pacing_check.part.0
+tcp_schedule_loss_probe.part.0
+tcp_sync_mss
+tcp_mstamp_refresh
+tcp_cwnd_restart
+tcp_fragment
+tcp_trim_head
+tcp_mtu_to_mss
+tcp_current_mss
+tcp_chrono_start
+tcp_chrono_stop
+tcp_schedule_loss_probe
+__tcp_select_window
+__tcp_transmit_skb
+tcp_connect
+tcp_xmit_probe_skb
+__tcp_send_ack.part.0
+__tcp_send_ack
+tcp_skb_collapse_tstamp
+tcp_write_xmit
+__tcp_push_pending_frames
+tcp_push_one
+__tcp_retransmit_skb
+tcp_send_loss_probe
+tcp_retransmit_skb
+tcp_xmit_retransmit_queue
+tcp_tsq_write
+tcp_release_cb
+tcp_tsq_handler
+tcp_tasklet_func
+tcp_pace_kick
+sk_forced_mem_schedule
+tcp_send_fin
+tcp_send_active_reset
+tcp_send_synack
+tcp_send_delayed_ack
+tcp_send_ack
+tcp_send_window_probe
+tcp_write_wakeup
+tcp_send_probe0
+tcp_syn_ack_timeout
+tcp_write_err
+tcp_out_of_resources
+tcp_model_timeout.isra.0
+tcp_set_keepalive
+tcp_keepalive_timer
+tcp_compressed_ack_kick
+retransmits_timed_out.part.0
+tcp_delack_timer_handler
+tcp_delack_timer
+tcp_retransmit_timer
+tcp_write_timer_handler
+tcp_write_timer
+tcp_init_xmit_timers
+tcp_v4_init_seq
+tcp_v4_init_ts_off
+tcp_v4_reqsk_destructor
+tcp_md5_do_lookup_exact
+tcp_v4_restore_cb
+tcp_v4_fill_cb
+tcp_md5_do_del
+tcp_v4_md5_hash_headers
+tcp_v4_md5_hash_skb
+tcp_v4_md5_hash_hdr
+tcp_v4_route_req
+tcp_v4_init_req
+tcp_filter
+established_get_first
+established_get_next
+tcp4_proc_exit_net
+tcp4_proc_init_net
+tcp4_seq_show
+tcp_v4_init_sock
+tcp_sk_exit_batch
+tcp_sk_exit
+tcp_sk_init
+bpf_iter_fini_tcp
+bpf_iter_init_tcp
+bpf_iter_tcp_seq_show
+tcp_v4_mtu_reduced
+tcp_md5_do_add
+tcp_v4_conn_request
+tcp_v4_pre_connect
+tcp_v4_connect
+tcp_ld_RTO_revert.part.0
+tcp_ld_RTO_revert
+tcp_v4_parse_md5_keys
+__tcp_md5_do_lookup
+tcp_v4_send_ack
+tcp_v4_destroy_sock
+tcp_v4_md5_lookup
+tcp_v4_reqsk_send_ack
+inet_sk_rx_dst_set
+tcp_v4_inbound_md5_hash
+tcp_req_err
+tcp_twsk_unique
+listening_get_next
+tcp_get_idx
+tcp_seq_start
+tcp_seq_next
+tcp_v4_send_reset
+tcp_v4_do_rcv
+tcp_seq_stop
+bpf_iter_tcp_seq_stop
+tcp_add_backlog
+tcp_v4_syn_recv_sock
+tcp_v4_err
+__tcp_v4_send_check
+tcp_v4_send_check
+tcp_v4_send_synack
+tcp_v4_get_syncookie
+tcp_v4_early_demux
+tcp_v4_rcv
+tcp4_proc_exit
+tcp_time_wait
+tcp_ca_openreq_child
+tcp_twsk_destructor
+tcp_openreq_init_rwin
+tcp_child_process
+tcp_create_openreq_child
+tcp_check_req
+tcp_timewait_state_process
+tcp_slow_start
+tcp_reno_ssthresh
+tcp_reno_undo_cwnd
+tcp_ca_get_name_by_key
+tcp_cong_avoid_ai
+tcp_reno_cong_avoid
+tcp_ca_find_autoload.isra.0
+tcp_ca_get_key_by_name
+tcp_register_congestion_control
+tcp_unregister_congestion_control
+tcp_ca_find
+tcp_ca_find_key
+tcp_assign_congestion_control
+tcp_init_congestion_control
+tcp_cleanup_congestion_control
+tcp_set_default_congestion_control
+tcp_get_available_congestion_control
+tcp_get_default_congestion_control
+tcp_get_allowed_congestion_control
+tcp_set_allowed_congestion_control
+tcp_set_congestion_control
+__tcp_get_metrics
+tcpm_suck_dst
+tcpm_check_stamp
+tcp_get_metrics
+tcp_metrics_flush_all
+tcp_net_metrics_exit_batch
+__parse_nl_addr
+tcp_metrics_nl_cmd_del
+tcp_net_metrics_init
+tcp_metrics_fill_info
+tcp_metrics_nl_cmd_get
+tcp_metrics_nl_dump
+tcp_update_metrics
+tcp_init_metrics
+tcp_peer_is_proven
+tcp_fastopen_cache_get
+tcp_fastopen_cache_set
+tcp_fastopen_ctx_free
+__tcp_fastopen_cookie_gen_cipher
+tcp_fastopen_destroy_cipher
+tcp_fastopen_ctx_destroy
+tcp_fastopen_reset_cipher
+tcp_fastopen_init_key_once
+tcp_fastopen_get_cipher
+tcp_fastopen_add_skb
+tcp_try_fastopen
+tcp_fastopen_active_disable
+tcp_fastopen_active_should_disable
+tcp_fastopen_cookie_check
+tcp_fastopen_defer_connect
+tcp_fastopen_active_disable_ofo_check
+tcp_fastopen_active_detect_blackhole
+tcp_rate_check_app_limited
+tcp_rate_skb_sent
+tcp_rate_skb_delivered
+tcp_rate_gen
+tcp_rack_detect_loss
+tcp_rack_skb_timeout
+tcp_rack_mark_lost
+tcp_rack_advance
+tcp_rack_reo_timeout
+tcp_rack_update_reo_wnd
+tcp_newreno_mark_lost
+tcp_register_ulp
+tcp_unregister_ulp
+tcp_get_available_ulp
+tcp_update_ulp
+tcp_cleanup_ulp
+tcp_set_ulp
+tcp_gro_complete
+tcp4_gro_complete
+tcp_gso_segment
+tcp4_gso_segment
+tcp_gro_receive
+tcp4_gro_receive
+ip4_datagram_release_cb
+__ip4_datagram_connect
+ip4_datagram_connect
+raw_rcv_skb
+__raw_v4_lookup
+raw_sysctl_init
+raw_abort
+raw_bind
+raw_recvmsg
+raw_destroy
+raw_getfrag
+compat_raw_ioctl
+raw_close
+raw_get_first
+raw_get_next
+raw_seq_next
+raw_seq_start
+raw_seq_stop
+raw_exit_net
+raw_init_net
+raw_seq_show
+raw_sk_init
+raw_ioctl
+raw_setsockopt
+raw_unhash_sk
+raw_hash_sk
+raw_getsockopt
+raw_sendmsg
+raw_icmp_error
+raw_rcv
+raw_local_deliver
+udp_cmsg_send
+udp_init_sock
+udp_sysctl_init
+udp_lib_lport_inuse
+udp_flow_hashrnd
+udp_encap_enable
+udp_flush_pending_frames
+udp4_hwcsum
+udp_set_csum
+udp_send_skb
+udp_push_pending_frames
+__udp_disconnect
+udp_sendmsg
+udp_disconnect
+udp_abort
+udp_sendpage
+udp_lib_getsockopt
+udp_getsockopt
+udp_get_first
+udp_get_next
+udp_get_idx
+udp_seq_start
+udp_seq_next
+udp_seq_stop
+udp4_seq_show
+udp4_proc_exit_net
+udp4_proc_init_net
+bpf_iter_fini_udp
+bpf_iter_init_udp
+bpf_iter_udp_seq_show
+bpf_iter_udp_seq_stop
+udp_sk_rx_dst_set
+udp_pre_connect
+udp_destroy_sock
+__first_packet_length
+skb_consume_udp
+udp_lib_setsockopt
+udp_setsockopt
+udp_ehashfn
+udp4_lib_lookup2
+udp_lib_lport_inuse2
+udp_lib_unhash
+udp_lib_rehash
+udp_v4_rehash
+__udp4_lib_lookup
+udp4_lib_lookup_skb
+udp4_lib_lookup
+udp_rmem_release
+udp_skb_destructor
+udp_destruct_sock
+__skb_recv_udp
+udp_recvmsg
+first_packet_length
+udp_ioctl
+udp_poll
+__udp_enqueue_schedule_skb
+udp_queue_rcv_one_skb
+udp_queue_rcv_skb
+udp_unicast_rcv_skb
+udp_lib_get_port
+udp_v4_get_port
+__udp4_lib_err
+udp_err
+__udp4_lib_rcv
+udp_v4_early_demux
+udp_rcv
+udp4_proc_exit
+udplite_err
+udplite_rcv
+udplite4_proc_exit_net
+udplite4_proc_init_net
+udp_gro_complete
+udp4_gro_complete
+skb_udp_tunnel_segment
+__udp_gso_segment
+udp4_ufo_fragment
+udp_gro_receive
+udp4_gro_receive
+arp_key_eq
+arp_hash
+arp_is_multicast
+arp_error_report
+arp_ignore
+arp_create
+arp_xmit_finish
+arp_netdev_event
+arp_net_exit
+arp_net_init
+arp_seq_show
+arp_seq_start
+arp_xmit
+arp_send_dst.part.0
+arp_solicit
+arp_send
+arp_req_delete
+arp_req_set
+arp_process
+parp_redo
+arp_rcv
+arp_mc_map
+arp_constructor
+arp_ioctl
+arp_ifdown
+icmp_discard
+icmp_push_reply
+icmp_glue_bits
+icmp_sk_exit
+icmp_sk_init
+icmpv4_xrlim_allow
+icmp_timestamp.part.0
+icmp_route_lookup.constprop.0
+ip_icmp_error_rfc4884
+icmp_socket_deliver
+icmp_redirect
+icmp_unreach
+icmp_global_allow
+icmpv4_global_allow
+__icmp_send
+icmp_ndo_send
+icmp_reply.constprop.0
+icmp_echo.part.0
+icmp_echo
+icmp_timestamp
+icmp_out_count
+icmp_rcv
+icmp_err
+inet_get_link_af_size
+confirm_addr_indev
+in_dev_finish_destroy
+inetdev_by_index
+inet_netconf_fill_devconf
+inet_select_addr
+register_inetaddr_notifier
+register_inetaddr_validator_notifier
+unregister_inetaddr_notifier
+unregister_inetaddr_validator_notifier
+inet_fill_link_af
+ipv4_doint_and_flush
+inet_gifconf
+inet_hash_remove
+inet_netconf_dump_devconf
+ip_mc_autojoin_config
+inet_validate_link_af
+inet_confirm_addr
+inet_abc_len.part.0
+in_dev_rcu_put
+set_ifa_lifetime
+inet_rcu_free_ifa
+inet_valid_dump_ifaddr_req
+inet_netconf_get_devconf
+inet_set_link_af
+inet_fill_ifaddr
+rtmsg_ifa
+__inet_del_ifa
+inet_rtm_deladdr
+check_lifetime
+__inet_insert_ifa
+in_dev_dump_addr
+inet_dump_ifaddr
+inet_rtm_newaddr
+inet_lookup_ifaddr_rcu
+__ip_dev_find
+inet_addr_onlink
+inet_ifa_byprefix
+devinet_ioctl
+inet_netconf_notify_devconf
+__devinet_sysctl_unregister
+devinet_sysctl_unregister
+devinet_exit_net
+__devinet_sysctl_register
+devinet_sysctl_register
+inetdev_init
+inetdev_event
+devinet_init_net
+devinet_conf_proc
+devinet_sysctl_forward
+snmp_get_cpu_field
+inet_register_protosw
+inet_shutdown
+inet_release
+inet_getname
+inet_autobind
+inet_dgram_connect
+__inet_stream_connect
+inet_stream_connect
+inet_compat_routing_ioctl
+inet_compat_ioctl
+inet_ioctl
+inet_gro_receive
+ipip_gro_receive
+inet_gro_complete
+ipip_gro_complete
+inet_ctl_sock_create
+snmp_fold_field
+inet_init_net
+ipv4_mib_exit_net
+inet_accept
+inet_unregister_protosw
+inet_create
+inet_listen
+inet_sk_rebuild_header
+ipv4_mib_init_net
+inet_current_timestamp
+inet_send_prepare
+inet_sendmsg
+inet_sendpage
+inet_sock_destruct
+inet_recvmsg
+inet_sk_set_state
+inet_gso_segment
+ipip_gso_segment
+__inet_bind
+inet_bind
+inet_sk_state_store
+inet_recv_error
+unsolicited_report_interval
+is_in
+sf_markstate
+igmp_mc_seq_next
+igmp_mcf_get_next
+igmp_mcf_seq_next
+ip_mc_clear_src
+kfree_pmc
+sf_setstate
+igmpv3_clear_zeros
+igmp_mcf_seq_stop
+igmp_mc_seq_stop
+ip_mc_del1_src
+igmpv3_sendpack
+ip_mc_find_dev
+igmp_net_exit
+igmp_net_init
+igmp_mcf_seq_show
+igmp_mc_seq_show
+igmpv3_newpack
+add_grhead
+add_grec
+igmpv3_send_report
+igmp_send_report
+igmp_netdev_event
+igmpv3_del_delrec
+ip_mc_validate_checksum
+igmp_mc_seq_start
+igmpv3_clear_delrec
+igmp_gq_timer_expire
+igmp_stop_timer
+igmp_mcf_seq_start
+ip_mc_check_igmp
+ip_ma_put
+igmp_ifc_start_timer
+igmp_ifc_event
+ip_mc_add_src
+ip_mc_del_src
+ip_mc_leave_src
+igmp_ifc_timer_expire
+igmp_start_timer
+igmp_timer_expire
+igmp_group_added
+____ip_mc_inc_group
+__ip_mc_inc_group
+ip_mc_inc_group
+__ip_mc_join_group
+ip_mc_join_group
+__igmp_group_dropped
+__ip_mc_dec_group
+ip_mc_leave_group
+igmp_rcv
+ip_mc_unmap
+ip_mc_remap
+ip_mc_down
+ip_mc_init_dev
+ip_mc_up
+ip_mc_destroy_dev
+ip_mc_join_group_ssm
+ip_mc_source
+ip_mc_msfilter
+ip_mc_msfget
+ip_mc_gsfget
+ip_mc_sf_allow
+ip_mc_drop_socket
+ip_check_mc_rcu
+ip_fib_net_exit
+fib_net_exit
+ip_valid_fib_dump_req
+fib_net_init
+fib_info_nh_uses_dev
+__fib_validate_source
+fib_get_table
+fib_new_table
+fib_magic
+inet_addr_type_table
+inet_addr_type
+inet_dev_addr_type
+inet_addr_type_dev_table
+inet_dump_fib
+nl_fib_lookup
+nl_fib_input
+fib_unmerge
+fib_flush
+fib_disable_ip
+fib_compute_spec_dst
+fib_validate_source
+ip_rt_ioctl
+fib_gw_from_via
+rtm_to_fib_config
+inet_rtm_delroute
+inet_rtm_newroute
+fib_add_ifaddr
+fib_netdev_event
+fib_modify_prefix_metric
+fib_del_ifaddr
+fib_inetaddr_event
+fib_check_nh_v6_gw
+rt_fibinfo_free
+free_fib_info
+fib_nexthop_info
+fib_add_nexthop
+rt_fibinfo_free_cpus.part.0
+fib_nh_common_release
+fib_nh_common_init
+fib_check_nh_v4_gw
+free_fib_info_rcu
+fib_detect_death
+fib_rebalance
+fib_info_hash_free
+fib_info_hash_alloc
+fib_nh_release
+fib_release_info
+ip_fib_check_default
+fib_nh_init
+fib_get_nhs
+fib_nh_match
+fib_metrics_match
+fib_check_nh
+fib_info_update_nhc_saddr
+fib_result_prefsrc
+fib_create_info
+fib_dump_info
+rtmsg_fib
+fib_sync_down_addr
+fib_nhc_update_mtu
+fib_sync_mtu
+fib_sync_down_dev
+fib_sync_up
+fib_select_multipath
+fib_select_path
+fib_trie_seq_stop
+__alias_free_mem
+fib_find_alias
+fib_find_node
+update_children
+update_suffix
+node_pull_suffix
+leaf_walk_rcu
+fib_route_seq_next
+fib_route_seq_start
+fib_alias_hw_flags_set
+fib_trie_get_next
+fib_trie_seq_next
+fib_trie_seq_start
+put_child
+tnode_free
+call_fib_entry_notifiers
+fib_notify_alias_delete
+__trie_free_rcu
+fib_table_print
+fib_triestat_seq_show
+fib_valid_key_len
+__node_free_rcu
+fib_trie_seq_show
+tnode_new
+resize
+fib_insert_alias
+fib_remove_alias
+replace
+fib_route_seq_stop
+fib_route_seq_show
+fib_table_insert
+fib_lookup_good_nhc
+fib_table_lookup
+fib_table_delete
+fib_table_flush_external
+fib_table_flush
+fib_info_notify_update
+fib_notify
+fib_free_table
+fib_table_dump
+fib_trie_table
+fib_trie_unmerge
+fib_proc_init
+fib_proc_exit
+fib4_dump
+fib4_seq_read
+call_fib4_notifier
+call_fib4_notifiers
+fib4_notifier_init
+fib4_notifier_exit
+inet_frags_init
+fqdir_exit
+inet_frag_rbtree_purge
+inet_frag_destroy
+inet_frag_destroy_rcu
+inet_frag_pull_head
+inet_frag_reasm_finish
+inet_frag_reasm_prepare
+inet_frags_free_cb
+fqdir_init
+inet_frag_queue_insert
+inet_frags_fini
+fqdir_work_fn
+inet_frag_kill
+inet_frag_find
+ping_seq_stop
+ping_get_first
+ping_get_next
+ping_get_idx
+ping_seq_start
+ping_v4_seq_start
+ping_seq_next
+ping_v4_proc_exit_net
+ping_v4_proc_init_net
+ping_v4_seq_show
+ping_hash
+ping_init_sock
+ping_close
+ping_getfrag
+ping_common_sendmsg
+ping_v4_sendmsg
+ping_queue_rcv_skb
+ping_unhash
+ping_get_port
+ping_lookup
+ping_rcv
+ping_recvmsg
+ping_err
+ping_bind
+ping_proc_exit
+ip_tunnel_parse_protocol
+ip_tun_cmp_encap
+ip_tun_destroy_state
+iptunnel_xmit
+ip_tunnel_get_stats64
+ip_tunnel_need_metadata
+ip_tunnel_unneed_metadata
+ip_tun_opts_nlsize
+ip_tun_encap_nlsize
+ip6_tun_encap_nlsize
+iptunnel_metadata_reply
+iptunnel_handle_offloads
+ip_tun_parse_opts.part.0
+ip6_tun_build_state
+ip_tun_build_state
+skb_tunnel_check_pmtu
+__iptunnel_pull_header
+ip_tun_fill_encap_opts.constprop.0
+ip_tun_fill_encap_info
+ip6_tun_fill_encap_info
+gre_gro_complete
+gre_gso_segment
+gre_gro_receive
+ip_fib_metrics_init
+rtm_getroute_parse_ip_proto
+register_nexthop_notifier
+unregister_nexthop_notifier
+nexthop_find_by_id
+nh_group_rebalance
+nh_create_ipv6
+__nexthop_replace_notify
+nh_fill_node
+nexthop_notify
+nh_create_ipv4
+fib6_check_nexthop
+nexthop_check_scope
+nexthop_for_each_fib6_nh
+rtm_to_nh_config
+fib6_check_nh_list
+nh_valid_dump_req.constprop.0
+rtm_dump_nexthop
+nh_valid_get_del_req
+rtm_get_nexthop
+nexthop_select_path
+nexthop_alloc
+nexthop_free_rcu
+nexthop_net_init
+remove_nexthop
+__remove_nexthop
+rtm_del_nexthop
+nexthop_flush_dev
+nh_netdev_event
+nexthop_net_exit
+fib_check_nexthop
+fib_check_nh_list
+rtm_new_nexthop
+bpfilter_umh_cleanup
+bpfilter_mbox_request
+bpfilter_ip_set_sockopt
+bpfilter_ip_get_sockopt
+ipv4_sysctl_exit_net
+proc_tfo_blackhole_detect_timeout
+ipv4_privileged_ports
+proc_fib_multipath_hash_policy
+ipv4_fwd_update_priority
+sscanf_key
+proc_tcp_fastopen_key
+proc_allowed_congestion_control
+proc_tcp_available_congestion_control
+proc_tcp_congestion_control
+proc_configure_early_demux
+ipv4_ping_group_range
+proc_tcp_available_ulp
+ipv4_local_port_range
+proc_tcp_early_demux
+proc_udp_early_demux
+ipv4_sysctl_init_net
+ip_proc_exit_net
+ip_proc_init_net
+netstat_seq_show
+sockstat_seq_show
+icmpmsg_put_line.part.0
+icmpmsg_put
+snmp_seq_show_ipstats.isra.0
+snmp_seq_show_tcp_udp.isra.0
+snmp_seq_show
+fib4_rule_nlmsg_payload
+fib4_rule_compare
+__fib_lookup
+fib4_rule_match
+fib4_rule_flush_cache
+fib4_rule_fill
+fib4_rule_delete
+fib4_rule_default
+fib4_rule_action
+fib4_rule_suppress
+fib4_rule_configure
+fib4_rules_dump
+fib4_rules_seq_read
+fib4_rules_init
+fib4_rules_exit
+ipmr_rule_match
+ipmr_rule_configure
+ipmr_rule_compare
+reg_vif_get_iflink
+ipmr_vif_seq_stop
+ipmr_new_table_set
+ipmr_mr_table_iter
+ipmr_rule_action
+ipmr_rule_fill
+reg_vif_setup
+ipmr_rule_default
+ipmr_fib_lookup
+ipmr_rt_fib_lookup
+ipmr_update_thresholds
+ipmr_cache_free_rcu
+ipmr_destroy_unres
+ipmr_vif_seq_show
+ipmr_mfc_seq_show
+ipmr_vif_seq_start
+ipmr_dump
+ipmr_rules_dump
+ipmr_rtm_dumproute
+ipmr_seq_read
+ipmr_new_table
+__pim_rcv.constprop.0
+ipmr_mfc_seq_start
+pim_rcv
+ipmr_init_vif_indev
+vif_add
+vif_delete
+ipmr_device_event
+ipmr_cache_report
+reg_vif_xmit
+ipmr_queue_xmit
+ip_mr_forward
+ipmr_rtm_dumplink
+ipmr_fill_mroute
+mroute_netlink_event
+ipmr_expire_process
+ipmr_cache_unresolved
+_ipmr_fill_mroute
+ipmr_rtm_getroute
+mroute_clean_tables
+mrtsock_destruct
+ipmr_free_table
+ipmr_rules_exit
+ipmr_net_exit
+ipmr_net_init
+ipmr_mfc_delete
+ipmr_mfc_add
+ipmr_rtm_route
+ip_mroute_setsockopt
+ip_mroute_getsockopt
+ipmr_ioctl
+ipmr_compat_ioctl
+ip_mr_input
+pim_rcv_v1
+ipmr_get_route
+mr_vif_seq_idx
+mr_vif_seq_next
+vif_device_init
+mr_mfc_seq_idx
+mr_mfc_seq_next
+mr_fill_mroute
+mr_table_dump
+mr_rtm_dumproute
+mr_dump
+mr_table_alloc
+mr_mfc_find_any_parent
+mr_mfc_find_any
+mr_mfc_find_parent
+cookie_hash
+__cookie_v4_init_sequence
+__cookie_v4_check
+cookie_timestamp_decode
+cookie_ecn_ok
+tcp_get_cookie_sock
+cookie_tcp_reqsk_alloc
+cookie_init_timestamp
+cookie_v4_init_sequence
+cookie_v4_check
+nf_ip_route
+ip_route_me_harder
+bictcp_recalc_ssthresh
+bictcp_acked
+bictcp_cong_avoid
+bictcp_state
+bictcp_init
+bictcp_cwnd_event
+tcp_bpf_stream_read
+tcp_bpf_push
+__tcp_bpf_recvmsg
+tcp_bpf_sendmsg_redir
+tcp_bpf_send_verdict
+tcp_bpf_sendpage
+tcp_bpf_sendmsg
+tcp_bpf_recvmsg
+tcp_bpf_get_proto
+tcp_bpf_clone
+udp_bpf_get_proto
+cipso_v4_delopt
+cipso_v4_map_lvl_valid.part.0
+cipso_v4_map_lvl_hton.part.0
+cipso_v4_map_lvl_ntoh.part.0
+cipso_v4_genopt.part.0.constprop.0
+cipso_v4_cache_entry_free
+cipso_v4_cache_invalidate
+cipso_v4_cache_add
+cipso_v4_doi_add
+cipso_v4_doi_free
+cipso_v4_doi_free_rcu
+cipso_v4_doi_remove
+cipso_v4_doi_getdef
+cipso_v4_doi_putdef
+cipso_v4_doi_walk
+cipso_v4_optptr
+cipso_v4_validate
+cipso_v4_error
+cipso_v4_sock_setattr
+cipso_v4_req_setattr
+cipso_v4_sock_delattr
+cipso_v4_req_delattr
+cipso_v4_getattr
+cipso_v4_sock_getattr
+cipso_v4_skbuff_setattr
+cipso_v4_skbuff_delattr
+xfrm4_dst_ifdown
+xfrm4_update_pmtu
+xfrm4_redirect
+xfrm4_net_exit
+xfrm4_net_init
+xfrm4_fill_dst
+__xfrm4_dst_lookup
+xfrm4_get_saddr
+xfrm4_dst_lookup
+xfrm4_dst_destroy
+xfrm4_rcv_encap_finish2
+xfrm4_rcv
+xfrm4_transport_finish
+xfrm4_udp_encap_rcv
+__xfrm4_output
+xfrm4_output
+xfrm4_local_error
+xfrm4_rcv_cb
+xfrm4_esp_err
+xfrm4_ah_err
+xfrm4_ipcomp_err
+xfrm4_rcv_encap
+xfrm4_protocol_register
+xfrm4_protocol_deregister
+xfrm4_ah_rcv.part.0
+xfrm4_ipcomp_rcv
+xfrm4_ah_rcv
+xfrm4_esp_rcv
+bpf_tcp_send_ack
+bpf_tcp_ca_unreg
+bpf_tcp_ca_reg
+bpf_tcp_ca_init
+bpf_tcp_ca_btf_struct_access
+bpf_tcp_ca_get_func_proto
+bpf_tcp_ca_check_member
+bpf_tcp_ca_init_member
+bpf_tcp_ca_is_valid_access
+xfrm_link_failure
+xfrm_policy_walk_done
+xfrm_default_advmss
+xfrm_spd_getinfo
+xfrm_gen_index
+xfrm_pol_bin_cmp
+xfrm_policy_walk
+xfrm_policy_walk_init
+__xfrm_policy_unlink
+xfrm_dst_ifdown
+xfrm_neigh_lookup
+xfrm_confirm_neigh
+xfrm_pol_bin_key
+xfrm_pol_bin_obj
+xfrm_policy_insert_list
+__xfrm_dst_lookup
+xfrm_negative_advice
+xfrm_policy_destroy_rcu
+xfrm_policy_hash_rebuild
+xfrm_policy_inexact_gc_tree
+xfrm_policy_unregister_afinfo
+xfrm_if_unregister_cb
+xfrm_audit_common_policyinfo
+xfrm_audit_policy_delete
+xfrm_mtu
+xfrm_pol_inexact_addr_use_any_list
+__get_hash_thresh
+xfrm_policy_addr_delta
+xfrm_policy_lookup_inexact_addr
+xfrm_policy_find_inexact_candidates
+xfrm_policy_inexact_list_reinsert
+xfrm_policy_destroy
+xfrm_expand_policies.constprop.0
+__xfrm_policy_bysel_ctx.constprop.0
+xfrm_policy_inexact_insert_node.constprop.0
+xfrm_policy_inexact_alloc_chain
+xfrm_dst_check
+xfrm_policy_alloc
+xfrm_tmpl_resolve
+xfrm_audit_policy_add
+xfrm_hash_resize
+xfrm_if_register_cb
+xfrm_policy_register_afinfo
+xfrm_policy_inexact_alloc_bin
+__xfrm_policy_link
+xfrm_resolve_and_create_bundle
+xfrm_policy_kill
+xfrm_policy_delete
+xdst_queue_output
+xfrm_policy_requeue
+__xfrm_decode_session
+xfrm_policy_timer
+policy_hash_bysel
+xfrm_policy_byid
+__xfrm_policy_inexact_prune_bin
+xfrm_policy_inexact_insert
+xfrm_policy_insert
+xfrm_policy_bysel_ctx
+__xfrm_policy_inexact_flush
+xfrm_policy_flush
+xfrm_hash_rebuild
+xfrm_policy_fini
+xfrm_net_exit
+xfrm_net_init
+xfrm_selector_match
+xfrm_sk_policy_lookup
+xfrm_policy_match
+xfrm_policy_lookup_bytype.constprop.0
+xfrm_lookup_with_ifid
+xfrm_lookup
+xfrm_policy_queue_process
+xfrm_lookup_route
+__xfrm_route_forward
+__xfrm_policy_check
+xfrm_sk_policy_insert
+__xfrm_sk_clone_policy
+xfrm_get_acqseq
+verify_spi_info
+xfrm_state_afinfo_get_rcu
+xfrm_register_translator
+xfrm_state_free
+xfrm_unregister_translator
+xfrm_register_km
+xfrm_unregister_km
+xfrm_sad_getinfo
+xfrm_state_walk_init
+xfrm_state_register_afinfo
+km_policy_notify
+km_policy_expired
+km_state_notify
+km_state_expired
+km_query
+km_new_mapping
+km_report
+xfrm_state_alloc
+xfrm_state_unregister_afinfo
+xfrm_state_walk_done
+xfrm_put_translator
+___xfrm_state_destroy
+xfrm_state_gc_task
+xfrm_register_type
+xfrm_unregister_type
+xfrm_register_type_offload
+xfrm_unregister_type_offload
+xfrm_get_translator
+xfrm_flush_gc
+__xfrm_init_state
+xfrm_init_state
+xfrm_audit_helper_sainfo
+xfrm_state_mtu
+__xfrm_state_destroy
+xfrm_hash_grow_check
+xfrm_state_look_at
+xfrm_state_check_expire
+xfrm_audit_helper_pktinfo
+xfrm_audit_state_icvfail
+xfrm_user_policy
+xfrm_replay_timer_handler
+xfrm_state_walk
+xfrm_audit_state_notfound_simple
+xfrm_audit_state_delete
+xfrm_audit_state_add
+xfrm_audit_state_notfound
+xfrm_audit_state_replay_overflow
+xfrm_audit_state_replay
+xfrm_state_lookup_byspi
+__xfrm_state_delete
+xfrm_state_delete
+xfrm_state_delete_tunnel
+xfrm_state_flush
+xfrm_dev_state_flush
+xfrm_timer_handler
+__xfrm_find_acq_byseq
+xfrm_find_acq_byseq
+xfrm_hash_resize
+__xfrm_state_lookup
+xfrm_state_lookup
+__xfrm_state_lookup_byaddr
+xfrm_state_lookup_byaddr
+xfrm_stateonly_find
+__xfrm_state_bump_genids
+xfrm_alloc_spi
+__find_acq_core
+xfrm_find_acq
+__xfrm_state_insert
+xfrm_state_insert
+xfrm_state_add
+xfrm_state_update
+xfrm_state_find
+xfrm_state_get_afinfo
+xfrm_state_init
+xfrm_state_fini
+xfrm_hash_alloc
+xfrm_hash_free
+xfrm_trans_reinject
+xfrm_rcv_cb
+xfrm_trans_queue_net
+xfrm_trans_queue
+xfrm_input_register_afinfo
+xfrm_input_unregister_afinfo
+secpath_set
+xfrm_parse_spi
+xfrm_input
+xfrm_input_resume
+xfrm_local_error
+xfrm_inner_extract_output
+xfrm_outer_mode_output
+pktgen_xfrm_outer_mode_output
+xfrm_output_resume
+xfrm_output2
+xfrm_output_gso.isra.0
+xfrm_output
+xfrm_sysctl_init
+xfrm_sysctl_fini
+xfrm_init_replay
+xfrm_replay_seqhi
+xfrm_replay_notify
+xfrm_replay_notify_bmp
+xfrm_replay_notify_esn
+xfrm_replay_check
+xfrm_replay_check_bmp
+xfrm_replay_check_esn
+xfrm_replay_recheck_esn
+xfrm_replay_advance
+xfrm_replay_advance_bmp
+xfrm_replay_overflow_offload_esn
+xfrm_replay_advance_esn
+xfrm_replay_overflow_offload
+xfrm_replay_overflow_offload_bmp
+xfrm_dev_state_add
+xfrm_dev_offload_ok
+xfrm_dev_event
+__xfrm_mode_tunnel_prep
+__xfrm_transport_prep.isra.0
+__xfrm_mode_beet_prep
+xfrm_outer_mode_prep
+xfrm_dev_resume
+validate_xmit_xfrm
+xfrm_dev_backlog
+xfrm_statistics_seq_show
+xfrm_proc_init
+xfrm_proc_fini
+espintcp_queue_out
+tcp_is_ulp_esp
+espintcp_destruct
+espintcp_write_space
+espintcp_data_ready
+espintcp_parse
+espintcp_poll
+espintcp_close
+espintcp_recvmsg
+build_protos
+espintcp_rcv
+espintcp_push_msgs
+espintcp_sendmsg
+espintcp_push_skb
+espintcp_release
+espintcp_tx_work
+espintcp_init_sk
+unix_state_double_lock
+unix_outq_len
+unix_next_socket
+unix_seq_next
+unix_net_exit
+unix_net_init
+unix_show_fdinfo
+unix_set_peek_off
+unix_copy_addr
+unix_stream_read_actor
+unix_mkname
+__unix_find_socket_byname
+unix_dgram_peer_wake_relay
+unix_stream_splice_actor
+unix_seq_start
+unix_dgram_disconnected
+unix_sock_destructor
+unix_poll
+unix_write_space
+__unix_insert_socket
+unix_seq_stop
+unix_peer_get
+unix_scm_to_skb
+unix_dgram_peer_wake_disconnect
+unix_dgram_peer_wake_me
+init_peercred
+unix_socketpair
+unix_inq_len
+unix_ioctl
+unix_compat_ioctl
+unix_getname
+unix_wait_for_peer
+unix_listen
+unix_state_double_unlock
+unix_seq_show
+maybe_init_creds
+maybe_add_creds
+unix_shutdown
+unix_create1
+unix_create
+unix_accept
+unix_release_sock
+unix_release
+unix_dgram_poll
+unix_autobind
+unix_find_other
+unix_dgram_connect
+unix_bind
+unix_stream_sendmsg
+unix_dgram_recvmsg
+unix_seqpacket_recvmsg
+unix_stream_sendpage
+unix_stream_read_generic
+unix_stream_splice_read
+unix_stream_recvmsg
+unix_stream_connect
+unix_dgram_sendmsg
+unix_seqpacket_sendmsg
+dec_inflight
+inc_inflight
+inc_inflight_move_tail
+scan_inflight
+scan_children
+unix_gc
+wait_for_unix_gc
+unix_sysctl_register
+unix_sysctl_unregister
+unix_get_socket
+unix_inflight
+unix_attach_fds
+unix_notinflight
+unix_detach_fds
+unix_destruct_scm
+ipv6_mod_enabled
+inet6_release
+inet6_compat_ioctl
+inet6_ioctl
+inet6_sendmsg
+inet6_recvmsg
+inet6_register_protosw
+ipv6_route_input
+ipv6_cleanup_mibs
+inet6_net_exit
+inet6_unregister_protosw
+inet6_create
+inet6_net_init
+inet6_destroy_sock
+ipv6_opt_accepted
+inet6_sk_rebuild_header
+inet6_getname
+__inet6_bind
+inet6_bind
+ac6_get_next
+ac6_seq_next
+ac6_seq_start
+ac6_seq_stop
+ac6_seq_show
+aca_free_rcu
+aca_put
+ipv6_del_acaddr_hash
+__ipv6_dev_ac_inc
+ipv6_sock_ac_join
+__ipv6_dev_ac_dec
+ipv6_sock_ac_drop
+__ipv6_sock_ac_close
+ipv6_sock_ac_close
+ipv6_ac_destroy_dev
+ipv6_chk_acast_addr
+ipv6_chk_acast_addr_src
+ac6_proc_init
+ac6_proc_exit
+ipv6_anycast_cleanup
+ip6_frag_init
+ip6_cork_release
+__ip6_flush_pending_frames
+ip6_dst_lookup_tunnel
+ip6_autoflowlabel.part.0
+ip6_finish_output2
+ip6_flush_pending_frames
+ip6_fraglist_init
+ip6_copy_metadata
+ip6_fraglist_prepare
+ip6_frag_next
+ip6_setup_cork
+ip6_xmit
+ip6_dst_lookup_tail
+ip6_dst_lookup
+ip6_dst_lookup_flow
+ip6_sk_dst_lookup_flow
+__ip6_append_data
+ip6_append_data
+ip6_autoflowlabel
+ip6_forward
+ip6_fragment
+__ip6_finish_output
+ip6_finish_output
+ip6_output
+__ip6_make_skb
+ip6_send_skb
+ip6_push_pending_frames
+ip6_make_skb
+ip6_sublist_rcv_finish
+ip6_rcv_finish_core.isra.0
+ip6_rcv_finish
+ip6_rcv_core
+ip6_sublist_rcv
+ipv6_rcv
+ipv6_list_rcv
+ip6_protocol_deliver_rcu
+ip6_input_finish
+ip6_input
+ip6_mc_input
+put_cacheinfo
+inet6_get_link_af_size
+if6_seq_start
+if6_seq_next
+__ipv6_isatap_ifid
+if6_seq_stop
+ipv6_generate_eui64
+addrconf_prefix_route
+addrconf_add_mroute
+addrconf_leave_anycast
+addrconf_sysctl_mtu
+if6_proc_net_exit
+if6_proc_net_init
+if6_seq_show
+extract_addr
+ipv6_generate_stable_address
+ipv6_mc_config
+inet6_fill_ifla6_attrs
+inet6_fill_link_af
+check_stable_privacy
+inet6_validate_link_af
+addrconf_join_solict.part.0
+addrconf_leave_solict.part.0
+inet6_set_link_af.part.0
+ipv6_get_saddr_eval
+addrconf_get_prefix_route
+__ipv6_dev_get_saddr
+ipv6_dev_get_saddr
+ipv6_chk_custom_prefix
+ipv6_chk_prefix
+__ipv6_chk_addr_and_flags
+ipv6_chk_addr_and_flags
+ipv6_chk_addr
+ipv6_dev_find
+addrconf_del_dad_work
+inet6_valid_dump_ifaddr_req
+cleanup_prefix_route
+addrconf_join_anycast
+modify_prefix_route
+addrconf_disable_policy_idev
+check_cleanup_prefix_route
+addrconf_sysctl_stable_secret
+inet6_fill_ifinfo
+inet6_dump_ifinfo
+addrconf_sysctl_disable_policy
+addrconf_mod_rs_timer
+inet6_fill_ifaddr
+__ipv6_ifa_notify
+ipv6_ifa_notify
+inet6_netconf_fill_devconf
+inet6_netconf_dump_devconf
+inet6_netconf_get_devconf
+in6_dump_addrs
+inet6_dump_addr
+inet6_dump_ifacaddr
+inet6_dump_ifmcaddr
+inet6_dump_ifaddr
+ipv6_add_addr
+inet6_netconf_notify_devconf
+__addrconf_sysctl_unregister
+addrconf_sysctl_unregister
+addrconf_exit_net
+__addrconf_sysctl_register
+addrconf_sysctl_register
+ipv6_add_dev
+ipv6_find_idev
+addrconf_add_dev
+addrconf_init_net
+addrconf_sysctl_ignore_routes_with_linkdown
+addrconf_sysctl_proxy_ndp
+dev_forward_change
+addrconf_sysctl_forward
+inet6_ifa_finish_destroy
+add_addr
+addrconf_ifdown
+addrconf_mod_dad_work
+addrconf_dad_kick
+addrconf_dad_run
+addrconf_dad_start
+addrconf_add_linklocal
+addrconf_addr_gen
+addrconf_dev_config
+addrconf_sysctl_addr_gen_mode
+ipv6_del_addr
+ipv6_create_tempaddr
+addrconf_dad_stop
+addrconf_verify_rtnl
+addrconf_verify_work
+manage_tempaddrs
+inet6_addr_del
+inet6_rtm_deladdr
+inet6_addr_add
+__ipv6_get_lladdr
+ipv6_get_lladdr
+addrconf_rs_timer
+addrconf_dad_completed
+addrconf_dad_work
+ipv6_get_ifaddr
+inet6_rtm_getaddr
+addrconf_prefix_rcv_add_addr
+inet6_rtm_newaddr
+addrconf_dad_failure
+addrconf_join_solict
+addrconf_leave_solict
+addrconf_prefix_rcv
+addrconf_set_dstaddr
+addrconf_add_ifaddr
+addrconf_del_ifaddr
+if6_proc_exit
+ipv6_chk_home_addr
+ipv6_chk_rpl_srh_loop
+inet6_ifinfo_notify
+addrconf_notify
+dev_disable_change
+addrconf_sysctl_disable
+inet6_set_link_af
+addrconf_cleanup
+ip6addrlbl_fill.constprop.0
+ip6addrlbl_dump
+__ipv6_addr_label
+ip6addrlbl_get
+ip6addrlbl_net_exit
+ip6addrlbl_add
+ip6addrlbl_net_init
+ip6addrlbl_newdel
+ipv6_addr_label
+ipv6_addr_label_cleanup
+ip6_rt_blackhole_update_pmtu
+ip6_rt_blackhole_redirect
+__traceiter_fib6_table_lookup
+ip6_blackhole_mtu
+fib6_nh_find_match
+ip6_default_advmss
+fib6_info_nh_uses_dev
+rt6_info_init
+ip6_dst_alloc
+rt6_upper_bound_set
+ip6_mtu
+fib6_backtrack
+ip6_pkt_drop
+ip6_pkt_discard
+ip6_pkt_discard_out
+ip6_pkt_prohibit
+ip6_pkt_prohibit_out
+ip6_route_lookup
+rt6_lookup
+ip6_route_input_lookup
+ip6_route_redirect
+__ip6_ins_rt
+rt6_probe_deferred
+ip6_rt_get_dev_rcu
+rt6_nlmsg_size
+rt6_nh_nlmsg_size
+ipv6_sysctl_rtcache_flush
+ip6_dst_gc
+ip6_route_net_exit_late
+ip6_route_net_init_late
+rt6_stats_seq_show
+ipv6_inetpeer_exit
+ipv6_inetpeer_init
+ip6_route_net_exit
+ip6_route_net_init
+rt6_check_expired
+fib6_remove_prefsrc
+__rt6_nh_dev_match
+inet6_rtm_delroute.part.0
+rt6_multipath_rebalance.part.0
+fib6_ifdown
+fib6_ifup
+ip6_dst_check
+ip6_multipath_l3_keys
+fib6_nh_mtu_change
+rt6_mtu_change_route
+rtm_to_fib6_config
+rt6_score_route
+rt6_do_update_pmtu
+ip6_route_output_flags_noref
+ip6_route_output_flags
+ip6_hold_safe
+ip6_dst_ifdown
+ip6_rt_copy_init
+__ip6_del_rt
+rt6_exception_hash
+__rt6_find_exception_rcu
+rt6_find_cached_rt
+ip6_redirect_nh_match
+fib6_nh_redirect_match
+__rt6_find_exception_spinlock
+rt6_remove_exception.part.0
+fib6_nh_flush_exceptions
+rt6_nh_flush_exceptions
+fib6_nh_age_exceptions
+rt6_nh_age_exceptions
+fib6_nh_remove_exception
+rt6_remove_exception_rt
+ip6_del_cached_rt
+fib6_nh_del_cached_rt
+ip6_link_failure
+ip6_negative_advice
+rt6_nh_remove_exception_rt
+fib6_clean_tohost
+rt6_insert_exception
+ip6_confirm_neigh
+ip6_route_dev_notify
+rt6_get_route_info
+ip6_create_rt_rcu
+__ip6_route_redirect
+find_match
+rt6_nh_find_match
+ip6_rt_cache_alloc
+__ip6_rt_update_pmtu
+ip6_update_pmtu
+ip6_sk_update_pmtu
+ip6_rt_update_pmtu
+rt6_do_redirect
+ip6_redirect
+ip6_sk_redirect
+__find_rr_leaf
+rt6_fill_node
+ip6_route_del
+ip6_route_multipath_del
+inet6_rtm_delroute
+rt6_nh_dump_exceptions
+inet6_rtm_getroute
+rt6_uncached_list_add
+rt6_uncached_list_del
+ip6_dst_destroy
+ip6_neigh_lookup
+ip6_dst_neigh_lookup
+ip6_ins_rt
+rt6_flush_exceptions
+rt6_age_exceptions
+fib6_table_lookup
+rt6_multipath_hash
+fib6_select_path
+ip6_pol_route_lookup
+ip6_pol_route
+ip6_pol_route_input
+ip6_pol_route_output
+ip6_nh_lookup_table
+ip6_route_check_nh
+ip6_route_input
+ip6_blackhole_route
+ip6_sk_dst_store_flow
+ip6_redirect_no_header
+ip6_mtu_from_fib6
+icmp6_dst_alloc
+fib6_nh_init
+ip6_route_info_create
+fib6_nh_release
+ip6_route_add
+rt6_add_route_info
+ip6_del_rt
+rt6_get_dflt_router
+rt6_route_rcv
+rt6_add_dflt_router
+rt6_purge_dflt_routers
+ipv6_route_ioctl
+addrconf_f6i_alloc
+rt6_remove_prefsrc
+rt6_clean_tohost
+rt6_multipath_rebalance
+rt6_sync_up
+rt6_sync_down_dev
+rt6_disable_ip
+rt6_mtu_change
+rt6_dump_route
+inet6_rt_notify
+ip6_route_mpath_notify
+ip6_route_multipath_add
+inet6_rtm_newroute
+fib6_rt_update
+ipv6_route_sysctl_init
+ip6_route_cleanup
+node_free_rcu
+fib6_walker_unlink
+ipv6_route_yield
+fib6_walk_continue
+fib6_walk
+fib6_clean_tree
+fib6_dump_table
+fib6_dump_end
+fib6_dump_done
+fib6_get_table
+__fib6_clean_all
+fib6_flush_trees
+fib6_node_dump
+node_alloc
+fib6_age
+fib6_dump_node
+fib6_net_exit
+ipv6_route_seq_setup_walk
+ipv6_route_seq_next
+ipv6_route_seq_start
+ipv6_route_seq_show
+fib6_find_prefix.isra.0.part.0
+ipv6_route_seq_stop
+fib6_node_lookup_1
+fib6_locate_1
+fib6_new_table
+fib6_net_init
+fib6_info_destroy_rcu
+inet6_dump_fib
+__fib6_drop_pcpu_from.isra.0
+fib6_nh_drop_pcpu_from
+fib6_purge_rt
+fib6_repair_tree.isra.0.part.0
+fib6_add_1.isra.0
+fib6_update_sernum
+fib6_info_alloc
+fib6_tables_seq_read
+call_fib6_entry_notifiers
+call_fib6_multipath_entry_notifiers
+call_fib6_entry_notifiers_replace
+fib6_tables_dump
+fib6_metric_set
+fib6_force_start_gc
+fib6_update_sernum_upto_root
+fib6_update_sernum_stub
+fib6_add
+fib6_node_lookup
+fib6_locate
+fib6_del
+fib6_clean_node
+fib6_clean_all
+fib6_clean_all_skip_notify
+fib6_run_gc
+fib6_gc_timer_cb
+fib6_gc_cleanup
+compat_ipv6_get_msfilter
+ipv6_get_msfilter
+do_ipv6_getsockopt.isra.0.constprop.0
+ipv6_getsockopt
+compat_ipv6_mcast_join_leave
+ipv6_mcast_join_leave
+compat_ipv6_set_mcast_msfilter
+copy_group_source_from_sockptr
+do_ipv6_mcast_group_source
+ip6_ra_control
+ipv6_update_options
+do_ipv6_setsockopt.isra.0
+ipv6_setsockopt
+ndisc_key_eq
+ndisc_hash
+ndisc_is_multicast
+ndisc_error_report
+pndisc_destructor
+pndisc_constructor
+__ndisc_fill_addr_option
+ndisc_net_exit
+ndisc_next_option.part.0
+ndisc_mc_map
+ndisc_allow_add
+ndisc_alloc_skb
+ndisc_net_init
+ndisc_send_skb
+ndisc_constructor
+ndisc_ifinfo_sysctl_change
+ndisc_parse_options
+ndisc_redirect_rcv
+ndisc_send_na
+ndisc_send_unsol_na
+ndisc_netdev_event
+ndisc_send_ns
+ndisc_solicit
+ndisc_send_rs
+ndisc_update
+ndisc_recv_ns
+pndisc_redo
+ndisc_recv_na
+ndisc_recv_rs
+ndisc_router_discovery
+ndisc_send_redirect
+ndisc_rcv
+ndisc_late_cleanup
+ndisc_cleanup
+udpv6_encap_enable
+udp_v6_flush_pending_frames
+udpv6_destroy_sock
+udpv6_setsockopt
+udpv6_getsockopt
+udp6_seq_show
+udpv6_pre_connect
+udp6_ehashfn
+udp6_lib_lookup2
+udpv6_recvmsg
+udp_v6_send_skb
+udp_v6_push_pending_frames
+udpv6_sendmsg
+udpv6_queue_rcv_one_skb
+udpv6_queue_rcv_skb
+udp6_unicast_rcv_skb
+udp_v6_rehash
+udp_v6_get_port
+udp_v6_early_demux
+__udp6_lib_lookup
+udp6_lib_lookup_skb
+udp6_lib_lookup
+__udp6_lib_err
+__udp6_lib_rcv
+udpv6_rcv
+udp6_proc_init
+udp6_proc_exit
+udpv6_exit
+udplitev6_err
+udplitev6_rcv
+udplite6_proc_exit_net
+udplite6_proc_init_net
+udplitev6_exit
+udplite6_proc_exit
+rawv6_mh_filter_register
+rawv6_mh_filter_unregister
+rawv6_init_sk
+__raw_v6_lookup
+raw6_getfrag
+compat_rawv6_ioctl
+raw6_destroy
+rawv6_close
+raw6_exit_net
+raw6_init_net
+raw6_seq_show
+rawv6_getsockopt
+rawv6_ioctl
+rawv6_bind
+rawv6_recvmsg
+rawv6_setsockopt
+rawv6_sendmsg
+raw6_icmp_error
+rawv6_rcv
+raw6_local_deliver
+raw6_proc_exit
+rawv6_exit
+icmpv6_getfrag
+icmpv6_sk_exit
+icmpv6_sk_init
+icmpv6_err_convert
+icmpv6_mask_allow.part.0
+icmpv6_xrlim_allow
+icmpv6_err
+icmpv6_route_lookup
+icmpv6_push_pending_frames
+icmp6_send
+ip6_err_gen_icmpv6_unreach
+icmpv6_echo_reply
+icmpv6_param_prob
+icmpv6_notify
+icmpv6_rcv
+icmpv6_flow_init
+icmpv6_cleanup
+ipv6_icmp_sysctl_init
+is_in
+sf_markstate
+igmp6_mcf_get_next
+igmp6_mcf_seq_next
+igmp6_mc_get_next
+igmp6_mc_seq_next
+igmp6_mc_seq_start
+igmp6_mcf_seq_stop
+igmp6_mc_seq_stop
+sf_setstate
+ip6_mc_clear_src
+mld_clear_zeros
+ip6_mc_find_dev_rcu
+igmp6_net_exit
+igmp6_mcf_seq_show
+igmp6_mc_seq_show
+mld_in_v1_mode
+ipv6_mc_reset
+ip6_mc_del1_src
+mld_sendpack
+mld_clear_delrec
+ip6_mc_hdr.constprop.0
+mld_newpack
+add_grhead
+add_grec
+mld_send_report
+mld_send_initial_cr.part.0
+igmp6_send
+igmp6_net_init
+mld_gq_stop_timer
+mld_ifc_stop_timer
+igmp6_mcf_seq_start
+mld_gq_timer_expire
+ma_put
+igmp6_timer_handler
+mld_del_delrec
+mld_ifc_start_timer
+mld_ifc_event
+ip6_mc_add_src
+ip6_mc_del_src
+ip6_mc_leave_src
+mld_ifc_timer_expire
+mld_dad_start_timer
+mld_dad_timer_expire
+igmp6_group_queried
+igmp6_join_group
+igmp6_group_added
+ipv6_mc_netdev_event
+igmp6_group_dropped
+__ipv6_dev_mc_inc
+ipv6_dev_mc_inc
+__ipv6_sock_mc_join
+ipv6_sock_mc_join
+ipv6_sock_mc_join_ssm
+ip6_mc_msfget
+inet6_mc_check
+__ipv6_dev_mc_dec
+ipv6_sock_mc_drop
+ip6_mc_source
+ip6_mc_msfilter
+__ipv6_sock_mc_close
+ipv6_sock_mc_close
+ipv6_dev_mc_dec
+ipv6_chk_mcast_addr
+igmp6_event_query
+igmp6_event_report
+ipv6_mc_dad_complete
+ipv6_mc_unmap
+ipv6_mc_down
+ipv6_mc_up
+ipv6_mc_remap
+ipv6_mc_init_dev
+ipv6_mc_destroy_dev
+igmp6_cleanup
+igmp6_late_cleanup
+ipv6_frags_pre_exit_net
+ipv6_frags_exit_net
+ipv6_frags_init_net
+ip6_frag_expire
+ipv6_frag_rcv
+ipv6_frag_exit
+tcp_v6_route_req
+tcp_v6_restore_cb
+tcp_v6_reqsk_destructor
+tcp_v6_fill_cb
+tcp_v6_md5_hash_headers
+tcp_v6_md5_hash_skb
+tcp_v6_send_response
+tcp_v6_init_ts_off
+tcp_v6_init_seq
+tcp6_seq_show
+tcp_v6_destroy_sock
+tcp_v6_init_sock
+tcpv6_net_exit_batch
+tcpv6_net_exit
+tcpv6_net_init
+tcp_v6_mtu_reduced
+inet6_sk_rx_dst_set
+tcp_v6_conn_request
+tcp_v6_pre_connect
+tcp_v6_parse_md5_keys
+tcp_v6_early_demux
+tcp_v6_md5_lookup
+tcp_v6_reqsk_send_ack
+tcp_v6_inbound_md5_hash
+tcp_v6_connect
+tcp_v6_send_check
+tcp_v6_init_req
+tcp_v6_send_synack
+tcp_v6_send_reset
+tcp_v6_do_rcv
+tcp_v6_err
+tcp_v6_syn_recv_sock
+tcp_v6_rcv
+tcp_v6_get_syncookie
+tcp6_proc_init
+tcp6_proc_exit
+tcpv6_exit
+dummy_ipv6_recv_error
+dummy_ip6_datagram_recv_ctl
+dummy_icmpv6_err_convert
+dummy_ipv6_icmp_error
+dummy_ipv6_chk_addr
+ping_v6_seq_start
+ping_v6_proc_exit_net
+ping_v6_proc_init_net
+ping_v6_seq_show
+ping_v6_sendmsg
+pingv6_exit
+fl6_update_dst
+ip6_parse_tlv
+ipv6_hop_ra
+ipv6_renew_option
+ipv6_push_exthdr
+ipv6_push_frag_opts
+ipv6_hop_calipso
+ipv6_hop_jumbo
+ipv6_dup_options
+ipv6_dest_hao
+ipv6_fixup_options
+ipv6_destopt_rcv
+ipv6_rthdr_rcv
+ipv6_exthdrs_exit
+ipv6_parse_hopopts
+ipv6_push_nfrag_opts
+ipv6_renew_options
+ip6_datagram_send_ctl
+ip6_datagram_dst_update
+ip6_datagram_release_cb
+__ip6_datagram_connect
+ip6_datagram_connect
+ip6_datagram_connect_v6_only
+ipv6_icmp_error
+ipv6_local_error
+ipv6_local_rxpmtu
+ipv6_recv_rxpmtu
+ip6_datagram_recv_common_ctl
+ip6_datagram_recv_specific_ctl
+ipv6_recv_error
+ip6_datagram_recv_ctl
+__ip6_dgram_sock_seq_show
+ip6fl_seq_stop
+fl6_merge_options
+ip6fl_get_next
+ip6fl_seq_start
+ip6fl_seq_next
+fl_release
+fl_free
+fl_free_rcu
+fl_lookup
+fl6_renew
+ip6_flowlabel_net_exit
+ip6_flowlabel_proc_init
+ip6fl_seq_show
+ip6_fl_gc
+fl_create
+__fl6_sock_lookup
+fl6_free_socklist
+ipv6_flowlabel_opt_get
+ipv6_flowlabel_opt
+ip6_flowlabel_init
+ip6_flowlabel_cleanup
+inet6_csk_addr2sockaddr
+inet6_csk_route_req
+inet6_csk_route_socket
+inet6_csk_xmit
+inet6_csk_update_pmtu
+udp6_gro_complete
+udp6_ufo_fragment
+udp6_gro_receive
+udpv6_offload_init
+udpv6_offload_exit
+seg6_net_exit
+seg6_genl_get_tunsrc
+seg6_genl_set_tunsrc
+seg6_genl_dumphmac_done
+seg6_genl_dumphmac_start
+seg6_genl_dumphmac
+seg6_genl_sethmac
+seg6_net_init
+seg6_validate_srh
+seg6_exit
+fib6_dump
+fib6_seq_read
+call_fib6_notifier
+call_fib6_notifiers
+fib6_notifier_init
+fib6_notifier_exit
+ipv6_rpl_addr_decompress
+ipv6_rpl_addr_compress
+ipv6_rpl_srh_size
+ipv6_rpl_srh_decompress
+ipv6_rpl_srh_compress
+ipv6_sysctl_net_exit
+proc_rt6_multipath_hash_policy
+ipv6_sysctl_net_init
+ipv6_sysctl_register
+ipv6_sysctl_unregister
+ip6mr_rule_match
+ip6mr_rule_configure
+ip6mr_rule_compare
+ip6mr_vif_seq_stop
+reg_vif_get_iflink
+ip6mr_dump
+ip6mr_rules_dump
+ip6mr_new_table_set
+ip6mr_mr_table_iter
+ip6mr_rule_action
+ip6mr_rule_fill
+ip6mr_hash_cmp
+reg_vif_setup
+ip6mr_rule_default
+ip6mr_fill_mroute
+_ip6mr_fill_mroute
+ip6mr_fib_lookup
+mroute6_is_socket
+pim6_rcv
+mr6_netlink_event
+ip6mr_destroy_unres
+ip6mr_vif_seq_show
+ipmr_mfc_seq_show
+ip6mr_vif_seq_start
+ipmr_do_expire_process
+ip6mr_cache_find
+ip6mr_update_thresholds
+ip6mr_cache_find_any
+ip6mr_rtm_dumproute
+ip6mr_seq_read
+ip6mr_new_table
+ipmr_mfc_seq_start
+ipmr_expire_process
+ip6mr_cache_report
+reg_vif_xmit
+ip6mr_cache_unresolved
+mif6_delete
+ip6mr_device_event
+ip6mr_forward2
+ip6_mr_forward
+mroute_clean_tables
+ip6mr_free_table
+ip6mr_rules_exit
+ip6mr_net_exit
+ip6mr_net_init
+ip6mr_mfc_delete
+ip6mr_mfc_add
+ip6_mr_cleanup
+ip6mr_sk_done
+ip6_mroute_setsockopt
+ip6_mroute_getsockopt
+ip6mr_ioctl
+ip6mr_compat_ioctl
+ip6_mr_input
+ip6mr_get_route
+xfrm6_update_pmtu
+xfrm6_redirect
+xfrm6_net_exit
+xfrm6_net_init
+xfrm6_dst_lookup
+xfrm6_get_saddr
+xfrm6_dst_ifdown
+xfrm6_fill_dst
+xfrm6_dst_destroy
+xfrm6_fini
+xfrm6_state_fini
+xfrm6_transport_finish2
+xfrm6_rcv_spi
+xfrm6_rcv_tnl
+xfrm6_rcv
+xfrm6_input_addr
+xfrm6_transport_finish
+xfrm6_udp_encap_rcv
+xfrm6_find_1stfragopt
+__xfrm6_output_finish
+xfrm6_local_rxpmtu
+__xfrm6_output
+xfrm6_local_error
+xfrm6_output
+xfrm6_rcv_cb
+xfrm6_esp_err
+xfrm6_ah_err
+xfrm6_ipcomp_err
+xfrm6_rcv_encap
+xfrm6_protocol_register
+xfrm6_protocol_deregister
+xfrm6_ah_rcv.part.0
+xfrm6_ipcomp_rcv
+xfrm6_ah_rcv
+xfrm6_esp_rcv
+xfrm6_protocol_fini
+__nf_ip6_route
+ip6_route_me_harder
+br_ip6_fragment
+nf_ip6_reroute
+ipv6_netfilter_fini
+fib6_rule_nlmsg_payload
+fib6_rule_suppress
+fib6_rules_net_exit
+fib6_rules_net_init
+fib6_rule_fill
+fib6_rule_compare
+fib6_rule_configure
+fib6_rule_default
+fib6_rule_delete
+fib6_rule_match
+fib6_rule_saddr.part.0
+fib6_rule_action
+fib6_rules_dump
+fib6_rules_seq_read
+fib6_lookup
+fib6_rule_lookup
+fib6_rules_cleanup
+snmp6_seq_show_icmpv6msg
+ipv6_proc_exit_net
+ipv6_proc_init_net
+sockstat6_seq_show
+snmp6_seq_show_item.part.0
+snmp6_seq_show_item
+snmp6_seq_show_item64.isra.0.constprop.0
+snmp6_seq_show
+snmp6_dev_seq_show
+snmp6_register_dev
+snmp6_unregister_dev
+ipv6_misc_proc_exit
+cookie_hash
+__cookie_v6_init_sequence
+__cookie_v6_check
+cookie_v6_init_sequence
+cookie_v6_check
+calipso_tlv_len
+calipso_opt_find
+calipso_doi_free
+calipso_doi_free_rcu
+calipso_skbuff_optptr
+calipso_doi_walk
+calipso_pad_write
+calipso_genopt
+calipso_skbuff_setattr
+calipso_skbuff_delattr
+calipso_doi_getdef
+calipso_cache_entry_free
+calipso_cache_add
+calipso_cache_invalidate
+calipso_opt_update
+calipso_doi_putdef
+calipso_doi_add
+calipso_opt_getattr
+calipso_sock_getattr
+calipso_doi_remove
+calipso_opt_insert
+calipso_req_setattr
+calipso_sock_setattr
+calipso_opt_del
+calipso_req_delattr
+calipso_sock_delattr
+calipso_validate
+calipso_exit
+seg6_encap_nlsize
+seg6_encap_cmp
+seg6_destroy_state
+seg6_build_state
+seg6_fill_encap_info
+seg6_do_srh_inline
+seg6_do_srh_encap
+seg6_do_srh
+seg6_input
+seg6_output
+seg6_iptunnel_exit
+parse_nla_table
+cmp_nla_table
+parse_nla_iif
+cmp_nla_iif
+parse_nla_oif
+cmp_nla_oif
+seg6_local_get_encap_size
+seg6_lookup_any_nexthop
+seg6_local_cmp_encap
+cmp_nla_bpf
+put_nla_oif
+put_nla_iif
+put_nla_table
+seg6_local_fill_encap
+parse_nla_srh
+cmp_nla_nh4
+cmp_nla_nh6
+cmp_nla_srh
+parse_nla_nh4
+parse_nla_nh6
+put_nla_nh6
+put_nla_nh4
+put_nla_srh
+seg6_local_input
+seg6_local_destroy_state
+seg6_local_build_state
+parse_nla_bpf
+put_nla_bpf
+get_srh
+get_and_validate_srh
+input_action_end_b6_encap
+input_action_end_b6
+input_action_end_t
+input_action_end_x
+input_action_end
+decap_and_validate
+input_action_end_dt6
+input_action_end_dx4
+input_action_end_dx6
+input_action_end_dx2
+seg6_lookup_nexthop
+seg6_bpf_has_valid_srh
+input_action_end_bpf
+seg6_local_exit
+seg6_hmac_cmpfn
+seg6_free_hi
+seg6_hmac_net_init
+seg6_hmac_exit
+seg6_hmac_net_exit
+seg6_hmac_compute
+seg6_hmac_info_lookup
+seg6_hmac_info_del
+seg6_hmac_validate_skb
+seg6_push_hmac
+seg6_hmac_info_add
+eafnosupport_ipv6_dst_lookup_flow
+eafnosupport_ipv6_route_input
+eafnosupport_fib6_get_table
+eafnosupport_fib6_table_lookup
+eafnosupport_fib6_lookup
+eafnosupport_fib6_select_path
+eafnosupport_ip6_mtu_from_fib6
+eafnosupport_ip6_del_rt
+eafnosupport_ipv6_fragment
+register_inet6addr_notifier
+unregister_inet6addr_notifier
+inet6addr_notifier_call_chain
+register_inet6addr_validator_notifier
+unregister_inet6addr_validator_notifier
+inet6addr_validator_notifier_call_chain
+eafnosupport_fib6_nh_init
+in6_dev_finish_destroy
+in6_dev_finish_destroy_rcu
+__ipv6_addr_type
+ipv6_ext_hdr
+ipv6_find_tlv
+ipv6_skip_exthdr
+ipv6_find_hdr
+udp6_set_csum
+udp6_csum_init
+icmpv6_ndo_send
+ip6_find_1stfragopt
+ip6_dst_hoplimit
+__ip6_local_out
+ip6_local_out
+__ipv6_select_ident
+ipv6_proxy_select_ident
+ipv6_select_ident
+inet6_add_protocol
+inet6_add_offload
+inet6_del_protocol
+inet6_del_offload
+ipv6_gro_complete
+ip6ip6_gro_complete
+sit_gro_complete
+ip4ip6_gro_complete
+ip4ip6_gro_receive
+ip4ip6_gso_segment
+ipv6_gso_pull_exthdrs
+ipv6_gro_receive
+sit_ip6ip6_gro_receive
+ipv6_gso_segment
+ip6ip6_gso_segment
+sit_gso_segment
+tcp6_gro_complete
+tcp6_gro_receive
+tcp6_gso_segment
+inet6_hash_connect
+inet6_hash
+inet6_ehashfn
+__inet6_lookup_established
+__inet6_check_established
+inet6_lhash2_lookup
+inet6_lookup_listener
+inet6_lookup
+ipv6_mc_check_icmpv6
+ipv6_mc_check_mld
+packet_seq_stop
+packet_seq_next
+match_fanout_group
+packet_mm_open
+packet_mm_close
+packet_net_init
+packet_seq_show
+packet_seq_start
+packet_sock_destruct
+prb_retire_current_block
+prb_open_block
+prb_dispatch_next_block
+prb_fill_curr_block
+tpacket_get_timestamp
+packet_getname_spkt
+packet_getname
+packet_read_pending
+free_pg_vec
+packet_direct_xmit
+packet_getsockopt
+packet_net_exit
+packet_ioctl
+packet_dev_mc
+__packet_get_status.part.0
+__packet_set_status
+tpacket_destruct_skb
+packet_parse_headers
+packet_lookup_frame
+__packet_rcv_has_room
+packet_poll
+fanout_demux_rollover
+packet_rcv_fanout
+packet_mmap
+packet_rcv_spkt
+__fanout_set_data_bpf
+__fanout_link
+__register_prot_hook
+packet_create
+packet_recvmsg
+packet_sendmsg_spkt
+prb_retire_rx_blk_timer_expired
+__unregister_prot_hook
+packet_do_bind
+packet_bind_spkt
+packet_bind
+packet_notifier
+packet_sendmsg
+packet_rcv
+packet_set_ring
+packet_release
+tpacket_rcv
+packet_setsockopt
+default_read_sock_done
+strp_msg_timeout
+strp_stop
+strp_read_sock
+__strp_unpause
+strp_work
+strp_unpause
+strp_check_rcv
+strp_init
+strp_sock_unlock
+strp_sock_lock
+strp_done
+strp_abort_strp
+strp_data_ready
+__strp_recv
+strp_process
+strp_recv
+vlan_dev_real_dev
+vlan_dev_vlan_id
+vlan_dev_vlan_proto
+vlan_info_rcu_free
+vlan_gro_complete
+vlan_uses_dev
+vlan_kill_rx_filter_info
+vlan_filter_drop_vids
+vlan_vid_del
+vlan_vids_del_by_dev
+vlan_gro_receive
+vlan_add_rx_filter_info
+vlan_filter_push_vids
+vlan_vid_add
+vlan_vids_add_by_dev
+vlan_for_each
+__vlan_find_dev_deep_rcu
+vlan_do_receive
+wext_pernet_exit
+wext_pernet_init
+wireless_nlevent_flush
+wext_netdev_notifier_call
+wireless_nlevent_process
+iwe_stream_add_event
+iwe_stream_add_point
+iwe_stream_add_value
+wext_permission_check
+wireless_process_ioctl
+rtnetlink_ifinfo_prep
+wireless_send_event
+ioctl_standard_iw_point
+ioctl_standard_call
+compat_standard_call
+get_wireless_stats
+iw_handler_get_iwstats
+call_commit_handler
+wext_handle_ioctl
+compat_wext_handle_ioctl
+wireless_dev_seq_stop
+wireless_dev_seq_next
+wireless_dev_seq_start
+wireless_dev_seq_show
+wext_proc_init
+wext_proc_exit
+iw_handler_get_thrspy
+iw_handler_get_spy
+iw_handler_set_thrspy
+iw_handler_set_spy
+iw_send_thrspy_event
+wireless_spy_update
+get_priv_descr_and_size
+ioctl_private_iw_point
+iw_handler_get_private
+ioctl_private_call
+compat_private_call
+netlbl_audit_start_common
+netlbl_audit_start
+netlbl_bitmap_walk
+netlbl_bitmap_setbit
+_netlbl_catmap_getnode
+netlbl_catmap_setbit
+netlbl_catmap_walk
+netlbl_cfg_map_del
+netlbl_cfg_unlbl_map_add
+netlbl_cfg_unlbl_static_add
+netlbl_cfg_unlbl_static_del
+netlbl_cfg_cipsov4_add
+netlbl_cfg_cipsov4_del
+netlbl_cfg_cipsov4_map_add
+netlbl_cfg_calipso_add
+netlbl_cfg_calipso_del
+netlbl_cfg_calipso_map_add
+netlbl_catmap_walkrng
+netlbl_catmap_getlong
+netlbl_catmap_setlong
+netlbl_catmap_setrng
+netlbl_enabled
+netlbl_sock_setattr
+netlbl_sock_delattr
+netlbl_sock_getattr
+netlbl_conn_setattr
+netlbl_req_delattr
+netlbl_req_setattr
+netlbl_skbuff_setattr
+netlbl_skbuff_getattr
+netlbl_skbuff_err
+netlbl_cache_invalidate
+netlbl_cache_add
+netlbl_domhsh_free_entry
+netlbl_domhsh_hash
+netlbl_domhsh_search
+netlbl_domhsh_audit_add
+netlbl_domhsh_search_def
+netlbl_domhsh_add
+netlbl_domhsh_add_default
+netlbl_domhsh_remove_entry
+netlbl_domhsh_remove_af4
+netlbl_domhsh_remove_af6
+netlbl_domhsh_remove
+netlbl_domhsh_remove_default
+netlbl_domhsh_getentry
+netlbl_domhsh_getentry_af4
+netlbl_domhsh_getentry_af6
+netlbl_domhsh_walk
+netlbl_af4list_search
+netlbl_af4list_search_exact
+netlbl_af6list_search
+netlbl_af6list_search_exact
+netlbl_af4list_add
+netlbl_af6list_add
+netlbl_af4list_remove_entry
+netlbl_af4list_remove
+netlbl_af6list_remove_entry
+netlbl_af6list_remove
+netlbl_af4list_audit_addr
+netlbl_af6list_audit_addr
+netlbl_mgmt_version
+netlbl_mgmt_removedef
+netlbl_mgmt_listall
+netlbl_mgmt_remove
+netlbl_mgmt_listentry
+netlbl_mgmt_listall_cb
+netlbl_mgmt_listdef
+netlbl_mgmt_add_common
+netlbl_mgmt_adddef
+netlbl_mgmt_add
+netlbl_mgmt_protocols_cb
+netlbl_mgmt_protocols
+netlbl_unlabel_acceptflg_set
+netlbl_unlhsh_search_iface
+netlbl_unlabel_addrinfo_get
+netlbl_unlhsh_free_iface
+netlbl_unlabel_list
+netlbl_unlabel_accept
+netlbl_unlabel_staticlist_gen
+netlbl_unlabel_staticlistdef
+netlbl_unlabel_staticlist
+netlbl_unlhsh_netdev_handler
+netlbl_unlhsh_add
+netlbl_unlabel_staticadddef
+netlbl_unlabel_staticadd
+netlbl_unlhsh_remove
+netlbl_unlabel_staticremovedef
+netlbl_unlabel_staticremove
+netlbl_unlabel_getattr
+netlbl_cipsov4_listall
+netlbl_cipsov4_listall_cb
+netlbl_cipsov4_list
+netlbl_cipsov4_remove
+netlbl_cipsov4_remove_cb
+netlbl_cipsov4_add_common
+netlbl_cipsov4_add
+netlbl_calipso_ops_register
+netlbl_calipso_listall_cb
+netlbl_calipso_remove
+netlbl_calipso_list
+netlbl_calipso_listall
+netlbl_calipso_remove_cb
+netlbl_calipso_add
+calipso_doi_add
+calipso_doi_free
+calipso_doi_remove
+calipso_doi_getdef
+calipso_doi_putdef
+calipso_doi_walk
+calipso_sock_getattr
+calipso_sock_setattr
+calipso_sock_delattr
+calipso_req_setattr
+calipso_req_delattr
+calipso_optptr
+calipso_getattr
+calipso_skbuff_setattr
+calipso_skbuff_delattr
+calipso_cache_invalidate
+calipso_cache_add
+rfkill_release
+name_show
+rfkill_get_led_trigger_name
+rfkill_blocked
+rfkill_fop_poll
+rfkill_global_led_trigger_worker
+rfkill_suspend
+hard_show
+soft_show
+state_show
+index_show
+type_show
+rfkill_poll
+rfkill_destroy
+rfkill_fop_read
+persistent_show
+rfkill_fop_release
+rfkill_fop_ioctl
+rfkill_update_global_state.part.0
+rfkill_find_type
+rfkill_set_led_trigger_name
+rfkill_pause_polling
+rfkill_dev_uevent
+rfkill_init_sw_state
+rfkill_led_trigger_event
+rfkill_led_trigger_activate
+rfkill_set_hw_state
+rfkill_set_sw_state
+rfkill_set_states
+rfkill_resume_polling
+rfkill_alloc
+rfkill_send_events
+rfkill_unregister
+rfkill_event
+rfkill_set_block
+__rfkill_switch_all
+rfkill_fop_write
+soft_store
+state_store
+rfkill_sync_work
+rfkill_resume
+rfkill_uevent_work
+rfkill_register
+rfkill_fop_open
+rfkill_switch_all
+rfkill_epo
+rfkill_restore_states
+rfkill_remove_epo_lock
+rfkill_is_epo_lock_active
+rfkill_get_global_sw_state
+rfkill_schedule_ratelimited
+rfkill_schedule_global_op
+rfkill_disconnect
+rfkill_schedule_toggle.part.0
+rfkill_connect
+rfkill_event
+rfkill_op_handler
+rfkill_start
+dcb_app_lookup
+dcb_getapp
+dcbnl_cee_pg_fill
+dcbnl_setdcbx
+dcbnl_getdcbx
+dcbnl_setpfcstate
+dcbnl_getpfcstate
+dcbnl_setstate
+dcbnl_getstate
+dcb_ieee_getapp_default_prio_mask
+dcbnl_getperm_hwaddr
+dcb_ieee_getapp_prio_dscp_mask_map
+dcb_ieee_getapp_dscp_prio_mask_map
+dcb_app_add
+dcb_setapp
+dcb_ieee_setapp
+dcb_ieee_delapp
+dcb_ieee_getapp_mask
+dcbnl_setfeatcfg
+dcbnl_bcn_setcfg
+dcbnl_setnumtcs
+dcbnl_setpfccfg
+dcbnl_newmsg
+__dcbnl_pg_setcfg.isra.0
+dcbnl_pgrx_setcfg
+dcbnl_pgtx_setcfg
+dcb_doit
+dcbnl_build_peer_app
+dcbnl_cee_fill
+dcbnl_cee_get
+dcbnl_ieee_fill
+dcbnl_ieee_get
+dcbnl_notify
+dcbnl_ieee_notify
+dcbnl_cee_notify
+dcbnl_setall
+dcbnl_ieee_del
+dcbnl_ieee_set
+dcbnl_setapp
+dcbnl_getapp
+dcbnl_bcn_getcfg
+dcbnl_getpfccfg
+__dcbnl_pg_getcfg.isra.0
+dcbnl_pgrx_getcfg
+dcbnl_pgtx_getcfg
+dcbnl_getfeatcfg
+dcbnl_getcap
+dcbnl_getnumtcs
+register_dcbevent_notifier
+unregister_dcbevent_notifier
+call_dcbevent_notifiers
+unregister_net_sysctl_table
+sysctl_net_exit
+sysctl_net_init
+register_net_sysctl
+net_ctl_header_lookup
+is_seen
+net_ctl_set_ownership
+net_ctl_permissions
+dns_resolver_match_preparse
+dns_resolver_read
+dns_resolver_cmp
+dns_resolver_free_preparse
+dns_resolver_preparse
+dns_resolver_describe
+dns_query
+register_switchdev_notifier
+unregister_switchdev_notifier
+call_switchdev_notifiers
+register_switchdev_blocking_notifier
+unregister_switchdev_blocking_notifier
+call_switchdev_blocking_notifiers
+__switchdev_handle_port_obj_add
+switchdev_handle_port_obj_add
+__switchdev_handle_port_obj_del
+switchdev_handle_port_obj_del
+__switchdev_handle_port_attr_set
+switchdev_handle_port_attr_set
+switchdev_deferred_process
+switchdev_deferred_process_work
+switchdev_port_obj_notify
+switchdev_port_obj_del_deferred
+switchdev_port_obj_add_now
+switchdev_port_obj_add_deferred
+switchdev_obj_size.part.0
+switchdev_port_attr_notify.constprop.0
+switchdev_port_attr_set_now
+switchdev_port_attr_set_deferred
+switchdev_deferred_enqueue.constprop.0
+switchdev_port_attr_set
+switchdev_port_obj_del
+switchdev_port_obj_add
+l3mdev_master_upper_ifindex_by_index_rcu
+l3mdev_link_scope_lookup
+l3mdev_master_ifindex_rcu
+l3mdev_update_flow
+l3mdev_fib_table_rcu
+l3mdev_fib_table_by_index
+l3mdev_ifindex_lookup_by_table_id
+l3mdev_table_lookup_register
+l3mdev_table_lookup_unregister
+l3mdev_fib_rule_match
+ncsi_cmd_build_header
+ncsi_cmd_handler_oem
+ncsi_cmd_handler_default
+ncsi_cmd_handler_rc
+ncsi_cmd_handler_dc
+ncsi_cmd_handler_sp
+ncsi_cmd_handler_snfc
+ncsi_cmd_handler_ev
+ncsi_cmd_handler_egmf
+ncsi_cmd_handler_ebf
+ncsi_cmd_handler_ae
+ncsi_cmd_handler_sl
+ncsi_cmd_handler_svf
+ncsi_cmd_handler_sma
+ncsi_calculate_checksum
+ncsi_xmit_cmd
+ncsi_rsp_handler_pldm
+ncsi_rsp_handler_gps
+ncsi_rsp_handler_snfc
+ncsi_rsp_handler_dgmf
+ncsi_rsp_handler_dbf
+ncsi_rsp_handler_dv
+ncsi_rsp_handler_dcnt
+ncsi_rsp_handler_ecnt
+ncsi_rsp_handler_rc
+ncsi_rsp_handler_ec
+ncsi_rsp_handler_dp
+ncsi_rsp_handler_gpuuid
+ncsi_rsp_handler_oem_bcm
+ncsi_rsp_handler_oem_mlx
+ncsi_rsp_handler_oem
+ncsi_rsp_handler_gnpts
+ncsi_rsp_handler_gns
+ncsi_rsp_handler_gcps
+ncsi_rsp_handler_gvi
+ncsi_rsp_handler_egmf
+ncsi_rsp_handler_ebf
+ncsi_rsp_handler_ev
+ncsi_rsp_handler_gls
+ncsi_rsp_handler_sl
+ncsi_rsp_handler_ae
+ncsi_rsp_handler_sp
+ncsi_rsp_handler_cis
+ncsi_validate_rsp_pkt
+ncsi_rsp_handler_dc
+ncsi_rsp_handler_svf
+ncsi_rsp_handler_gp
+ncsi_rsp_handler_sma
+ncsi_rsp_handler_gc
+ncsi_rcv_rsp
+ncsi_aen_handler_hncdsc
+ncsi_aen_handler_cr
+ncsi_aen_handler_lsc
+ncsi_aen_handler
+ncsi_report_link
+ncsi_oem_gma_handler_mlx
+ncsi_channel_is_tx
+ncsi_oem_smaf_mlx.constprop.0
+ncsi_register_dev
+ncsi_oem_gma_handler_bcm
+ncsi_channel_has_link
+ncsi_channel_is_last
+ncsi_start_channel_monitor
+ncsi_stop_channel_monitor
+ncsi_kick_channels
+ncsi_stop_dev
+ncsi_find_channel
+ncsi_add_channel
+ncsi_find_package
+ncsi_add_package
+ncsi_remove_package
+ncsi_unregister_dev
+ncsi_find_package_and_channel
+ncsi_alloc_request
+ncsi_free_request
+ncsi_request_timeout
+ncsi_find_dev
+ncsi_update_tx_channel
+ncsi_reset_dev
+ncsi_suspend_channel
+ncsi_process_next_channel
+ncsi_configure_channel
+ncsi_channel_monitor
+ncsi_choose_active_channel
+ncsi_vlan_rx_add_vid
+ncsi_vlan_rx_kill_vid
+ncsi_dev_work
+ncsi_start_dev
+ndp_from_ifindex
+ncsi_clear_interface_nl
+ncsi_set_package_mask_nl
+ncsi_set_interface_nl
+ncsi_set_channel_mask_nl
+ncsi_write_package_info
+ncsi_pkg_info_all_nl
+ncsi_pkg_info_nl
+ncsi_send_netlink_rsp
+ncsi_send_netlink_timeout
+ncsi_send_netlink_err
+ncsi_send_cmd_nl
+xsk_set_rx_need_wakeup
+xsk_clear_rx_need_wakeup
+xsk_tx_completed
+xsk_set_tx_need_wakeup
+xsk_clear_tx_need_wakeup
+xsk_tx_release
+xsk_wakeup
+xsk_flush
+xsk_unbind_dev
+xsk_notifier
+xsk_net_init
+xsk_destruct_skb
+xsk_init_queue
+xsk_uses_need_wakeup
+xsk_getsockopt
+xsk_bind
+xsk_net_exit
+xsk_get_pool_from_qid
+xsk_destruct
+__xsk_sendmsg
+xsk_sendmsg
+xsk_poll
+__xsk_rcv_zc
+xsk_rcv.part.0
+xsk_release
+xsk_create
+xsk_mmap
+xsk_tx_peek_desc
+xsk_setsockopt
+xsk_clear_pool_at_qid
+xsk_reg_pool_at_qid
+xp_release
+xsk_generic_rcv
+__xsk_map_redirect
+__xsk_map_flush
+xdp_umem_unpin_pages
+xdp_umem_unaccount_pages
+xdp_umem_release
+xdp_umem_release_deferred
+xdp_get_umem
+xdp_put_umem
+xdp_umem_create
+xskq_create
+xskq_destroy
+xsk_map_lookup_elem_sys_only
+xsk_map_free
+xsk_map_get_next_key
+xsk_map_meta_equal
+xsk_map_gen_lookup
+xsk_map_lookup_elem
+xsk_map_sock_delete
+xsk_map_delete_elem
+xsk_map_alloc
+xsk_map_update_elem
+xsk_map_inc
+xsk_map_put
+xsk_map_try_sock_delete
+xp_set_rxq_info
+xp_can_alloc
+xp_free
+__xp_dma_unmap
+xp_dma_sync_for_device_slow
+xp_dma_sync_for_cpu_slow
+xp_raw_get_data
+xp_raw_get_dma
+xp_init_dma_info
+xp_alloc
+xp_disable_drv_zc
+__xp_assign_dev
+xp_destroy.part.0
+xp_dma_unmap
+xp_dma_map
+xp_add_xsk
+xp_del_xsk
+xp_destroy
+xp_create_and_assign_umem
+xp_assign_dev
+xp_assign_dev_shared
+xp_clear_dev
+xp_release_deferred
+xp_get_pool
+xp_put_pool
+mptcp_sync_mss
+mptcp_disconnect
+mptcp_hash
+mptcp_unhash
+__mptcp_flush_join_list
+mptcp_drop
+mptcp_nospace
+mptcp_subflow_active
+mptcp_poll
+mptcp_reset_timer
+mptcp_getsockopt
+__mptcp_init_sock
+mptcp_init_sock
+__mptcp_nmpc_socket
+mptcp_get_port
+mptcp_setsockopt
+mptcp_try_coalesce
+mptcp_ofo_queue
+mptcp_memory_free
+mptcp_check_for_eof
+mptcp_page_frag_refill
+mptcp_pending_data_fin
+mptcp_is_writeable.part.0
+dfrag_clear
+mptcp_copy_inaddrs
+mptcp_bind
+mptcp_listen
+mptcp_sendmsg_frag.isra.0
+mptcp_clean_una
+mptcp_subflow_get_send
+mptcp_sendmsg
+mptcp_check_data_fin
+__mptcp_move_skbs_from_subflow
+move_skbs_to_msk
+__mptcp_move_skbs
+mptcp_stream_connect
+mptcp_recvmsg
+mptcp_stream_accept
+mptcp_retransmit_handler
+mptcp_release_cb
+mptcp_retransmit_timer
+mptcp_accept
+mptcp_data_ready
+mptcp_data_acked
+mptcp_subflow_eof
+__mptcp_close_ssk
+mptcp_worker
+mptcp_subflow_shutdown
+mptcp_shutdown
+mptcp_close
+mptcp_sk_clone
+mptcp_rcv_space_init
+mptcp_destroy_common
+mptcp_destroy
+mptcp_v6_destroy
+mptcp_finish_connect
+mptcp_finish_join
+mptcp_sock_destruct
+mptcp_info2sockaddr
+subflow_v4_conn_request
+subflow_v6_conn_request
+warn_bad_map
+subflow_create_ctx
+subflow_ulp_init
+subflow_ulp_clone
+mptcp_can_accept_new_subflow
+subflow_init_req
+subflow_v6_init_req
+subflow_v4_init_req
+mptcp_subflow_init_cookie_req
+subflow_write_space
+subflow_ulp_release
+subflow_req_destructor
+subflow_drop_ctx
+subflow_syn_recv_sock
+mptcp_subflow_reset
+subflow_finish_connect
+mptcp_subflow_fully_established
+mptcp_subflow_data_available
+subflow_state_change
+subflow_data_ready
+mptcp_space
+mptcpv6_handle_mapped
+mptcp_subflow_create_socket
+__mptcp_subflow_connect
+add_addr_generate_hmac
+add_addr6_generate_hmac
+mptcp_get_options
+mptcp_syn_options
+mptcp_established_options
+mptcp_synack_options
+mptcp_update_rcv_data_fin
+mptcp_incoming_options
+mptcp_write_options
+__token_bucket_busy
+mptcp_token_iter_next
+mptcp_token_get_sock
+mptcp_token_new_request
+mptcp_token_new_connect
+mptcp_token_accept
+mptcp_token_exists
+mptcp_token_destroy_request
+mptcp_token_destroy
+mptcp_crypto_key_sha
+mptcp_crypto_hmac_sha
+mptcp_net_exit
+mptcp_net_init
+mptcp_is_enabled
+mptcp_pm_schedule_work
+mptcp_pm_announce_addr
+mptcp_pm_remove_addr
+mptcp_pm_remove_subflow
+mptcp_pm_new_connection
+mptcp_pm_allow_new_subflow
+mptcp_pm_fully_established
+mptcp_pm_connection_closed
+mptcp_pm_subflow_established
+mptcp_pm_subflow_closed
+mptcp_pm_add_addr_received
+mptcp_pm_rm_addr_received
+mptcp_pm_add_addr_signal
+mptcp_pm_rm_addr_signal
+mptcp_pm_get_local_id
+mptcp_pm_data_init
+subflow_get_info_size
+subflow_get_info
+mptcp_diag_subflow_init
+mptcp_mib_alloc
+mptcp_seq_show
+pm_nl_init_net
+mptcp_nl_cmd_get_limits
+mptcp_nl_fill_addr
+mptcp_pm_parse_addr
+mptcp_nl_cmd_get_addr
+__flush_addrs
+mptcp_nl_cmd_flush_addrs
+pm_nl_exit_net
+addresses_equal
+lookup_subflow_by_saddr
+mptcp_pm_nl_append_new_local_addr
+mptcp_nl_cmd_add_addr
+check_work_pending.part.0
+mptcp_pm_create_subflow_or_signal_addr
+mptcp_pm_add_timer
+mptcp_nl_cmd_set_limits
+mptcp_nl_cmd_dump_addrs
+mptcp_pm_del_add_timer
+remove_anno_list_by_saddr
+mptcp_nl_cmd_del_addr
+mptcp_pm_free_anno_list
+mptcp_pm_nl_fully_established
+mptcp_pm_nl_subflow_established
+mptcp_pm_nl_add_addr_received
+mptcp_pm_nl_rm_addr_received
+mptcp_pm_nl_rm_subflow_received
+mptcp_pm_nl_get_local_id
+mptcp_pm_nl_data_init
+subflow_init_req_cookie_join_save
+mptcp_token_join_cookie_init_state
+__connect
+__disconnect
+irq_bypass_register_producer
+irq_bypass_unregister_producer
+irq_bypass_register_consumer
+irq_bypass_unregister_consumer
+pcibios_align_resource
+pcibios_allocate_rom_resources
+pcibios_allocate_bus_resources
+pcibios_allocate_resources
+pcibios_retrieve_fw_addr
+pci_mmcfg_read
+pci_mmcfg_write
+pci_mmcfg_arch_map
+pci_mmcfg_arch_unmap
+pci_conf1_write
+pci_conf2_write
+pci_conf1_read
+pci_conf2_read
+is_acpi_reserved
+pci_mmcfg_for_each_region
+find_mboard_resource
+list_add_sorted
+check_mcfg_resource
+pci_mmconfig_alloc
+pci_mmconfig_lookup
+pci_mmconfig_insert
+pci_mmconfig_delete
+xen_pcifront_enable_irq
+xen_msi_domain_free_irqs
+xen_msi_domain_alloc_irqs
+xen_teardown_msi_irqs
+xen_pv_teardown_msi_irqs
+xen_initdom_restore_msi_irqs
+xen_hvm_setup_msi_irqs
+xen_register_pirq
+acpi_register_gsi_xen_hvm
+acpi_register_gsi_xen
+xen_setup_msi_irqs
+xen_find_device_domain_owner
+xen_initdom_setup_msi_irqs
+xen_unregister_device_domain_owner
+xen_register_device_domain_owner
+pci_invalid_bar
+pci_fixup_latency
+pci_fixup_i450gx
+pci_early_fixup_cyrix_5530
+pci_fixup_nforce2
+pci_fixup_piix4_acpi
+pci_fixup_transparent_bridge
+pci_siemens_interrupt_controller
+quirk_no_aersid
+quirk_intel_th_dnv
+sb600_hpet_quirk
+pci_fixup_via_northbridge_bug
+pcie_rootport_aspm_quirk
+quirk_pcie_aspm_write
+quirk_pcie_aspm_read
+pci_fixup_video
+quirk_apple_mbp_poweroff
+sb600_disable_hpet_bar
+pci_fixup_msi_k8t_onboard_sound
+twinhead_reserve_killing_zone
+pci_pre_fixup_toshiba_ohci1394
+pci_post_fixup_toshiba_ohci1394
+pci_amd_enable_64bit_bar
+pci_acpi_root_prepare_resources
+pci_acpi_root_release_info
+pci_acpi_root_init_info
+pci_acpi_scan_root
+pcibios_root_bridge_prepare
+pcibios_scan_specific_bus
+pirq_serverworks_get
+pirq_serverworks_set
+pirq_pico_get
+pirq_pico_set
+pirq_get_info
+read_config_nybble
+pirq_amd756_get
+pirq_cyrix_get
+pirq_opti_get
+pirq_via_get
+pirq_sis_get
+pirq_piix_get
+write_config_nybble
+pirq_cyrix_set
+pirq_opti_set
+pirq_via_set
+pirq_sis_set
+pirq_piix_set
+pirq_vlsi_set
+pirq_vlsi_get
+pirq_via586_set
+pirq_via586_get
+pirq_ite_set
+pirq_ite_get
+pirq_ali_set
+pirq_ali_get
+pirq_amd756_set
+pirq_disable_irq
+elcr_set_level_irq
+pcibios_lookup_irq
+pirq_enable_irq
+pcibios_penalize_isa_irq
+mp_should_keep_irq
+pci_mmcfg_read_numachip
+pci_mmcfg_write_numachip
+raw_pci_read
+pci_read
+raw_pci_write
+pci_write
+pcibios_fixup_bus
+pcibios_add_bus
+pcibios_remove_bus
+pcibios_scan_root
+pcibios_assign_all_busses
+pcibios_add_device
+pcibios_enable_device
+pcibios_disable_device
+pcibios_release_device
+pci_ext_cfg_avail
+pci_real_dma_dev
+read_pci_config
+read_pci_config_byte
+read_pci_config_16
+write_pci_config
+write_pci_config_byte
+write_pci_config_16
+early_pci_allowed
+x86_pci_root_bus_node
+x86_pci_root_bus_resources
+update_res
+amd_bus_cpu_online
+resume_play_dead
+bsp_pm_callback
+pm_check_save_msr
+msr_build_context.constprop.0
+msr_initialize_bdw
+msr_save_cpuid_features
+save_processor_state
+hibernate_resume_nonboot_cpu_disable
+alloc_pgt_page
+swsusp_arch_resume
+get_e820_md5
+pfn_is_nosave
+arch_hibernation_header_save
+arch_hibernation_header_restore
+relocate_restore_code
+arch_resume_nosmt
+fb_is_primary_device
+run_init_process
+try_to_run_init_process
+check_msr.part.0
+uncore_free_pcibus_map
+uncore_type_exit
+uncore_pci_exit
+xen_p2m_elem_type.part.0
+show_regs_if_on_stack.constprop.0
+show_trace_log_lvl
+show_stack_regs
+dump_kernel_offset
+xfeature_is_supervisor
+xfeature_is_aligned
+__xstate_dump_leaves.part.0
+default_deferred_error_interrupt
+default_threshold_interrupt
+unexpected_thermal_interrupt
+mtrr_check.part.0
+rdt_get_cache_alloc_cfg
+native_machine_restart
+__inquire_remote_apic
+__sysvec_spurious_apic_interrupt
+io_apic_print_entries
+uv_undefined
+_hpet_print_config
+pv_tlb_flush_supported
+jailhouse_no_restart
+enable_gart_translations
+gart_resume
+sync_global_pgds
+mark_rodata_ro
+show_ldttss
+pti_user_pagetable_walk_pte
+uv_init_hubless_pch_io
+uv_register_nmi_notifier
+__warn_printk
+panic
+abort
+pr_cont_work
+dump_cpu_task
+sched_numa_warn.part.0
+thaw_kernel_threads
+freeze_kernel_threads
+suspend_test.part.0
+hibernation_debug_sleep
+load_image_and_restore
+saveable_page
+count_data_pages
+alloc_image_page
+preallocate_image_pages.constprop.0
+hibernate_preallocate_memory
+swsusp_save
+printk
+devkmsg_emit.constprop.0
+printk_deferred
+noirqdebug_setup
+rcu_check_gp_kthread_starvation
+rcu_dump_cpu_stacks
+print_cpu_stall_info
+adjust_jiffies_till_sched_qs.part.0
+rcu_fwd_progress_check
+klp_force_transition
+swiotlb_print_info
+print_modules
+locate_mem_hole_callback.cold
+arch_kexec_apply_relocations
+dump_kprobe
+kgdb_initial_breakpoint
+oom_killer_enable
+pcpu_dump_alloc_info
+kmalloc_fix_flags
+pageset_init
+slab_bug
+slab_err
+restore_bytes.constprop.0
+print_trailer
+object_err
+mem_cgroup_print_oom_group
+mem_fmt.constprop.0
+me_unknown
+usercopy_abort
+fscrypt_msg
+fsverity_msg
+jbd2_journal_destroy_caches
+fat_msg
+__fat_fs_error
+do_sysfs_unregistration
+ecryptfs_free_kmem_caches
+process_request_key_err
+fuse_sysfs_cleanup
+fuse_fs_cleanup
+trusted_shash_release
+lsm_append.constprop.0
+destroy_buffers
+add_rules.constprop.0
+jent_panic
+disk_unlock_native_capacity
+_ldm_printk
+early_dump_pci_device
+pci_release_resource
+dpc_process_rp_pio_error
+acpi_send_edr_status
+quirk_enable_clear_retrain_link
+pci_fixup_no_d0_pme
+pci_fixup_no_pme
+quirk_via_ioapic
+quirk_ati_exploding_mce
+quirk_pcie_pxh
+quirk_al_msi_disable
+quirk_xio2000a
+quirk_disable_aspm_l0s
+quirk_disable_aspm_l0s_l1
+quirk_plx_ntb_dma_alias
+suspend_nvs_save
+suspend_nvs_restore
+acpi_power_off
+erst_get_erange.constprop.0
+xenbus_reset_wait_for_backend.part.0
+bind_virq_for_mce
+free_acpi_perf_data
+push_pxx_to_hypervisor
+push_cxx_to_hypervisor
+upload_pm_data
+xen_upload_processor_pm_data
+sysrq_handle_loglevel
+k_lowercase
+hpet_acpi_add.part.0
+tpm_tis_probe_irq_single
+vga_switcheroo_enable
+dev_vprintk_emit
+dev_printk_emit
+__dev_printk
+dev_printk
+_dev_emerg
+_dev_alert
+_dev_crit
+_dev_err
+_dev_warn
+_dev_notice
+_dev_info
+handle_remove
+dax_fs_exit
+ata_print_version
+cdrom_sysctl_register
+cdrom_mrw_bgformat.constprop.0
+usb_root_hub_lost_power
+i8042_pnp_exit
+input_proc_exit
+elants_i2c_validate_remark_id
+hwmon_device_register
+is_mddev_idle
+md_autostart_arrays
+free_acpi_perf_data
+edd_dev_is_type
+add_sysfs_fw_map_entry
+firmware_map_add_entry
+cper_estatus_print_section
+cper_get_err_type
+pmc_power_off
+pcc_mbox_probe
+rproc_iommu_fault
+vme_dma_request
+__netdev_printk
+netdev_printk
+netdev_emerg
+netdev_alert
+netdev_crit
+netdev_err
+netdev_warn
+netdev_notice
+netdev_info
+netdev_rx_csum_fault.part.0
+rfkill_global_led_trigger_unregister
+pcibios_resource_survey_bus
+pci_fixup_i450nx
+pci_fixup_amd_ehci_pme
+pci_fixup_amd_fch_xhci_pme
+pci_fixup_umc_ide
+rest_init
+kernel_init
+xen_chk_extra_mem
+free_p2m_page
+alloc_p2m_page
+xen_build_mfn_list_list
+get_trap_addr
+jump_label_transform
+text_poke_queue
+text_poke_bp
+__static_call_transform
+check_enable_amd_mmconf_dmi
+adjust_range_page_size_mask
+alloc_low_pages
+init_memory_mapping
+free_initmem
+spp_getpage
+vmemmap_free
+arch_remove_memory
+_cpu_down
+__irq_alloc_descs
+create_proc_profile
+profile_init
+free_area_init_core_hotplug
+build_all_zonelists
+memmap_init_zone_device
+sparse_index_alloc
+__earlyonly_bootmem_alloc
+hotadd_new_pgdat
+try_remove_memory
+__add_pages
+remove_pfn_range_from_zone
+move_pfn_range_to_zone
+online_pages
+add_memory_resource
+__add_memory
+offline_pages
+mem_cgroup_css_alloc
+acpi_os_map_iomem
+acpi_os_map_memory
+acpi_os_unmap_iomem
+acpi_os_unmap_memory
+vclkdev_alloc
+clkdev_alloc
+store_online
+xen_swiotlb_init
+dmar_validate_one_drhd
+devtmpfsd
+get_nid_for_pfn
+efi_mem_reserve_persistent
+efi_earlycon_unmap
+efi_earlycon_map
+is_mmconf_reserved
+pci_mmcfg_check_reserved
+schedule
+yield
+_cond_resched
+yield_to
+schedule_idle
+schedule_preempt_disabled
+preempt_schedule_irq
+io_schedule_timeout
+io_schedule
+__wait_on_bit
+out_of_line_wait_on_bit
+out_of_line_wait_on_bit_timeout
+__wait_on_bit_lock
+out_of_line_wait_on_bit_lock
+bit_wait_io_timeout
+bit_wait_io
+bit_wait
+bit_wait_timeout
+wait_for_completion
+wait_for_completion_io_timeout
+wait_for_completion_killable_timeout
+wait_for_completion_timeout
+wait_for_completion_interruptible_timeout
+wait_for_completion_killable
+wait_for_completion_interruptible
+wait_for_completion_io
+__ww_mutex_die.isra.0
+__ww_mutex_check_waiters
+mutex_trylock
+__mutex_unlock_slowpath.isra.0
+mutex_unlock
+ww_mutex_unlock
+__ww_mutex_lock.isra.0
+__ww_mutex_lock_slowpath
+ww_mutex_lock
+__ww_mutex_lock_interruptible_slowpath
+ww_mutex_lock_interruptible
+__mutex_lock.isra.0
+__mutex_lock_slowpath
+mutex_lock
+mutex_lock_io
+__mutex_lock_interruptible_slowpath
+mutex_lock_interruptible
+__mutex_lock_killable_slowpath
+mutex_lock_killable
+__up
+__down
+__down_killable
+__down_timeout
+__down_interruptible
+down_write
+down_write_killable
+rwsem_down_read_slowpath
+down_read
+down_read_killable
+rt_mutex_unlock
+rt_mutex_trylock
+__rt_mutex_slowlock
+rt_mutex_slowlock
+rt_mutex_lock
+rt_mutex_lock_interruptible
+rt_mutex_futex_trylock
+__rt_mutex_futex_trylock
+__rt_mutex_futex_unlock
+rt_mutex_futex_unlock
+console_conditional_schedule
+usleep_range
+schedule_timeout
+schedule_timeout_interruptible
+schedule_timeout_killable
+schedule_timeout_uninterruptible
+schedule_timeout_idle
+do_nanosleep
+hrtimer_nanosleep_restart
+schedule_hrtimeout_range_clock
+schedule_hrtimeout_range
+schedule_hrtimeout
+alarm_timer_nsleep_restart
+ldsem_down_read
+ldsem_down_write
+default_idle
+mwait_idle
+acpi_processor_ffh_cstate_enter
+cpu_idle_poll
+default_idle_call
+intel_idle_s2idle
+intel_idle
+acpi_idle_do_entry
+poll_idle
+_raw_spin_unlock_irqrestore
+_raw_read_unlock_irqrestore
+_raw_spin_lock_bh
+_raw_spin_unlock_bh
+_raw_read_unlock_bh
+_raw_spin_trylock
+_raw_read_trylock
+_raw_write_trylock
+_raw_spin_trylock_bh
+_raw_write_unlock_irqrestore
+_raw_write_unlock_bh
+_raw_write_lock
+_raw_write_lock_bh
+_raw_read_lock
+_raw_write_lock_irqsave
+_raw_read_lock_bh
+_raw_write_lock_irq
+_raw_read_lock_irq
+_raw_spin_lock_irqsave
+_raw_read_lock_irqsave
+_raw_spin_lock
+_raw_spin_lock_irq
+__do_softirq
+video_set_bqc_offset [video]
+video_disable_backlight_sysfs_if [video]
+video_set_device_id_scheme [video]
+video_enable_only_lcd [video]
+video_hw_changes_brightness [video]
+acpi_video_handles_brightness_key_presses [video]
+video_get_max_state [video]
+video_set_report_key_events [video]
+acpi_video_bqc_value_to_level [video]
+acpi_video_cmp_level [video]
+acpi_video_device_bind [video]
+acpi_video_device_lcd_query_levels [video]
+acpi_video_device_EDID [video]
+acpi_video_get_edid [video]
+acpi_video_bus_put_devices [video]
+acpi_video_bus_match [video]
+acpi_video_device_lcd_get_level_current [video]
+video_get_cur_state [video]
+acpi_video_get_brightness [video]
+acpi_video_register [video]
+acpi_video_unregister [video]
+acpi_video_device_enumerate [video]
+acpi_video_bus_notify [video]
+acpi_video_device_lcd_set_level [video]
+video_set_cur_state [video]
+acpi_video_switch_brightness [video]
+acpi_video_set_brightness [video]
+acpi_video_resume [video]
+brightness_switch_event [video]
+acpi_video_device_notify [video]
+acpi_video_bus_unregister_backlight [video]
+acpi_video_bus_DOS.constprop.0 [video]
+acpi_video_bus_stop_devices [video]
+acpi_video_bus_remove [video]
+acpi_video_get_levels [video]
+acpi_video_bus_add [video]
+acpi_video_unregister_backlight [video]
+video_detect_force_vendor [video]
+video_detect_force_video [video]
+video_detect_force_native [video]
+video_detect_force_none [video]
+acpi_video_get_backlight_type [video]
+acpi_video_backlight_notify_work [video]
+acpi_video_set_dmi_backlight_type [video]
+acpi_video_backlight_notify [video]
+find_video [video]
+set_required_buffer_size [wmi]
+find_guid [wmi]
+wmi_has_guid [wmi]
+wmi_get_acpi_device_uid [wmi]
+wmi_get_event_data [wmi]
+wmidev_evaluate_method [wmi]
+wmi_evaluate_method [wmi]
+wmi_set_block [wmi]
+wmi_notify_debug [wmi]
+wmi_dev_release [wmi]
+wmi_method_enable [wmi]
+__wmi_driver_register [wmi]
+wmi_dev_remove [wmi]
+wmi_char_open [wmi]
+wmi_dev_match [wmi]
+wmi_char_read [wmi]
+wmi_dev_uevent [wmi]
+expensive_show [wmi]
+instance_count_show [wmi]
+guid_show [wmi]
+modalias_show [wmi]
+object_id_show [wmi]
+notify_id_show [wmi]
+wmi_driver_unregister [wmi]
+acpi_wmi_ec_space_handler [wmi]
+acpi_wmi_remove [wmi]
+get_subobj_info [wmi]
+__query_block [wmi]
+wmi_query_block [wmi]
+wmidev_block_query [wmi]
+wmi_remove_notify_handler [wmi]
+setable_show [wmi]
+acpi_wmi_notify_handler [wmi]
+wmi_dev_probe [wmi]
+wmi_install_notify_handler [wmi]
+acpi_wmi_probe [wmi]
+wmi_ioctl [wmi]
+vmd_irq_set_affinity [vmd]
+vmd_get_hwirq [vmd]
+vmd_compose_msi_msg [vmd]
+vmd_set_desc [vmd]
+vmd_pci_write [vmd]
+vmd_pci_read [vmd]
+vmd_irq [vmd]
+vmd_resume [vmd]
+vmd_suspend [vmd]
+vmd_remove_irq_domain [vmd]
+vmd_remove [vmd]
+vmd_msi_free [vmd]
+vmd_irq_disable [vmd]
+vmd_irq_enable [vmd]
+vmd_msi_prepare [vmd]
+vmd_get_phys_offsets.constprop.0 [vmd]
+vmd_msi_init [vmd]
+vmd_probe [vmd]
+renesas_xhci_pci_exit [xhci_pci_renesas]
+renesas_fw_download_image [xhci_pci_renesas]
+renesas_check_rom [xhci_pci_renesas]
+renesas_fw_check_running [xhci_pci_renesas]
+renesas_xhci_check_request_fw [xhci_pci_renesas]
+rtl8366rb_config_init [realtek]
+rtl8211c_config_init [realtek]
+rtl8211f_ack_interrupt [realtek]
+rtl822x_get_features [realtek]
+rtlgen_resume [realtek]
+rtl8211f_config_intr [realtek]
+rtl8201_config_intr [realtek]
+rtl822x_config_aneg [realtek]
+rtl821x_write_page [realtek]
+rtlgen_write_mmd [realtek]
+rtl822x_write_mmd [realtek]
+rtl821x_read_page [realtek]
+rtl821x_ack_interrupt [realtek]
+rtl8201_ack_interrupt [realtek]
+rtlgen_supports_2_5gbps [realtek]
+rtl8211b_resume [realtek]
+rtl8211b_suspend [realtek]
+rtl8211f_config_init [realtek]
+rtl8211e_config_init [realtek]
+rtlgen_read_mmd [realtek]
+rtl822x_read_mmd [realtek]
+rtl8211e_config_intr [realtek]
+rtl8211b_config_intr [realtek]
+rtl8226_match_phy_device [realtek]
+rtlgen_match_phy_device [realtek]
+rtlgen_get_speed.part.0 [realtek]
+rtlgen_read_status [realtek]
+rtl822x_read_status [realtek]
+rtl8211_config_aneg [realtek]
+ahci_start_engine [libahci]
+ahci_freeze [libahci]
+ahci_scr_read [libahci]
+ahci_scr_write [libahci]
+ahci_start_fis_rx [libahci]
+ahci_reset_em [libahci]
+ahci_activity_store [libahci]
+ahci_fill_cmd_slot [libahci]
+ahci_check_ready [libahci]
+ahci_bad_pmp_check_ready [libahci]
+ahci_show_host_version [libahci]
+ahci_show_host_cap2 [libahci]
+ahci_show_host_caps [libahci]
+ahci_activity_show [libahci]
+ahci_show_port_cmd [libahci]
+ahci_show_em_supported [libahci]
+ahci_store_em_buffer [libahci]
+ahci_transmit_led_message [libahci]
+ahci_read_em_buffer [libahci]
+ahci_led_store [libahci]
+ahci_led_show [libahci]
+ahci_thaw [libahci]
+ahci_kick_engine [libahci]
+ahci_post_internal_cmd [libahci]
+ahci_print_info [libahci]
+ahci_set_aggressive_devslp [libahci]
+ahci_set_lpm [libahci]
+ahci_stop_engine [libahci]
+ahci_postreset [libahci]
+ahci_qc_prep [libahci]
+ahci_dev_classify [libahci]
+ahci_sw_activity_blink [libahci]
+ahci_error_handler [libahci]
+ahci_set_em_messages [libahci]
+ahci_disable_fbs [libahci]
+ahci_pmp_detach [libahci]
+ahci_enable_fbs [libahci]
+ahci_pmp_attach [libahci]
+ahci_port_resume [libahci]
+ahci_qc_fill_rtf [libahci]
+ahci_pmp_qc_defer [libahci]
+ahci_handle_port_interrupt [libahci]
+ahci_handle_port_intr [libahci]
+ahci_single_level_irq_intr [libahci]
+ahci_qc_issue [libahci]
+ahci_port_start [libahci]
+ahci_dev_config [libahci]
+ahci_enable_ahci [libahci]
+ahci_save_initial_config [libahci]
+ahci_reset_controller [libahci]
+ahci_host_activate [libahci]
+ahci_exec_polled_cmd.constprop.0 [libahci]
+ahci_do_softreset [libahci]
+ahci_softreset [libahci]
+ahci_pmp_retry_softreset [libahci]
+ahci_deinit_port.constprop.0 [libahci]
+ahci_init_controller [libahci]
+ahci_port_stop [libahci]
+ahci_port_suspend [libahci]
+ahci_do_hardreset [libahci]
+ahci_hardreset [libahci]
+ahci_multi_irqs_intr_hard [libahci]
+i2c_handle_smbus_alert [i2c_smbus]
+smbalert_remove [i2c_smbus]
+smbus_alert [i2c_smbus]
+smbalert_work [i2c_smbus]
+smbus_do_alert [i2c_smbus]
+smbalert_probe [i2c_smbus]
+i2c_register_spd [i2c_smbus]
+xhci_pci_remove [xhci_pci]
+xhci_ssic_port_unused_quirk [xhci_pci]
+xhci_pme_quirk [xhci_pci]
+xhci_pci_shutdown [xhci_pci]
+xhci_pci_resume [xhci_pci]
+xhci_pci_suspend [xhci_pci]
+xhci_pci_quirks [xhci_pci]
+xhci_pci_setup [xhci_pci]
+xhci_pci_probe [xhci_pci]
+nvme_error_status [nvme_core]
+__traceiter_nvme_setup_cmd [nvme_core]
+__traceiter_nvme_complete_rq [nvme_core]
+__traceiter_nvme_async_event [nvme_core]
+__traceiter_nvme_sq [nvme_core]
+nvme_getgeo [nvme_core]
+nvme_sysfs_show_address [nvme_core]
+nvme_dev_attrs_are_visible [nvme_core]
+ns_cmp [nvme_core]
+nvme_ctrl_from_file [nvme_core]
+nvme_try_sched_reset [nvme_core]
+nvme_change_ctrl_state [nvme_core]
+nvme_reset_ctrl [nvme_core]
+nvme_delete_ctrl [nvme_core]
+nvme_release_subsystem [nvme_core]
+nvme_destroy_subsystem [nvme_core]
+nvme_alloc_request [nvme_core]
+nvme_end_sync_rq [nvme_core]
+nvme_stop_keep_alive [nvme_core]
+nvme_subsys_show_nqn [nvme_core]
+nvme_sysfs_show_hostid [nvme_core]
+nvme_sysfs_show_hostnqn [nvme_core]
+nvme_sysfs_show_subsysnqn [nvme_core]
+nvme_sysfs_show_transport [nvme_core]
+subsys_firmware_rev_show [nvme_core]
+subsys_serial_show [nvme_core]
+subsys_model_show [nvme_core]
+nsid_show [nvme_core]
+eui_show [nvme_core]
+nguid_show [nvme_core]
+sqsize_show [nvme_core]
+queue_count_show [nvme_core]
+numa_node_show [nvme_core]
+nvme_sysfs_show_state [nvme_core]
+cntlid_show [nvme_core]
+firmware_rev_show [nvme_core]
+serial_show [nvme_core]
+model_show [nvme_core]
+string_matches [nvme_core]
+nvme_set_queue_limits [nvme_core]
+nvme_dev_release [nvme_core]
+nvme_dev_open [nvme_core]
+nvme_ns_id_attrs_are_visible [nvme_core]
+nvme_stop_ctrl [nvme_core]
+nvme_keep_alive_end_io [nvme_core]
+nvme_uninit_ctrl [nvme_core]
+nvme_ctrl_reconnect_delay_store [nvme_core]
+nvme_ctrl_loss_tmo_store [nvme_core]
+nvme_async_event_work [nvme_core]
+nvme_unfreeze [nvme_core]
+nvme_update_bdev_size [nvme_core]
+nvme_init_ctrl [nvme_core]
+nvme_start_queues [nvme_core]
+nvme_kill_queues [nvme_core]
+nvme_wait_freeze_timeout [nvme_core]
+nvme_wait_freeze [nvme_core]
+nvme_start_freeze [nvme_core]
+nvme_stop_queues [nvme_core]
+nvme_sync_io_queues [nvme_core]
+nvme_sync_queues [nvme_core]
+nvme_class_uevent [nvme_core]
+nvme_state_terminal [nvme_core]
+nvme_wait_reset [nvme_core]
+nvme_keep_alive_work [nvme_core]
+nvme_queue_scan.part.0 [nvme_core]
+nvme_sysfs_rescan [nvme_core]
+nvme_shutdown_ctrl [nvme_core]
+nvme_cancel_request [nvme_core]
+nvme_reset_ctrl_sync [nvme_core]
+nvme_sysfs_reset [nvme_core]
+nvme_cleanup_cmd.part.0 [nvme_core]
+nvme_cleanup_cmd [nvme_core]
+nvme_command_effects [nvme_core]
+nvme_ctrl_loss_tmo_show [nvme_core]
+__nvme_submit_sync_cmd [nvme_core]
+nvme_submit_sync_cmd [nvme_core]
+nvme_identify_ctrl [nvme_core]
+nvme_toggle_streams [nvme_core]
+nvme_get_stream_params [nvme_core]
+nvme_update_disk_info [nvme_core]
+nvme_update_ns_info [nvme_core]
+nvme_features [nvme_core]
+nvme_set_features [nvme_core]
+nvme_get_features [nvme_core]
+nvme_start_ctrl [nvme_core]
+nvme_set_queue_count [nvme_core]
+nvme_sec_submit [nvme_core]
+nvme_identify_ns [nvme_core]
+nvme_complete_rq [nvme_core]
+nvme_wait_ready [nvme_core]
+nvme_disable_ctrl [nvme_core]
+nvme_enable_ctrl [nvme_core]
+nvme_ctrl_reconnect_delay_show [nvme_core]
+nvme_free_ns_head [nvme_core]
+nvme_ns_head_release [nvme_core]
+nvme_configure_apst.part.0 [nvme_core]
+nvme_set_latency_tolerance [nvme_core]
+nvme_free_ns [nvme_core]
+nvme_put_ns [nvme_core]
+nvme_release [nvme_core]
+uuid_show [nvme_core]
+nvme_get_ns_from_disk.part.0 [nvme_core]
+nvme_pr_command [nvme_core]
+nvme_pr_clear [nvme_core]
+nvme_pr_preempt [nvme_core]
+nvme_pr_release [nvme_core]
+nvme_pr_reserve [nvme_core]
+nvme_pr_register [nvme_core]
+nvme_ns_ids_equal [nvme_core]
+nvme_complete_async_event [nvme_core]
+nvme_ns_remove [nvme_core]
+nvme_remove_invalid_namespaces [nvme_core]
+nvme_remove_namespaces [nvme_core]
+nvme_do_delete_ctrl [nvme_core]
+nvme_sysfs_delete [nvme_core]
+nvme_delete_ctrl_work [nvme_core]
+wwid_show [nvme_core]
+nvme_free_ctrl [nvme_core]
+nvme_setup_discard [nvme_core]
+nvme_ns_head_open [nvme_core]
+nvme_find_get_ns [nvme_core]
+nvme_identify_ns_descs [nvme_core]
+nvme_open [nvme_core]
+nvme_setup_cmd [nvme_core]
+nvme_get_ns_from_disk [nvme_core]
+nvme_put_ns_from_disk [nvme_core]
+nvme_get_log [nvme_core]
+nvme_get_effects_log [nvme_core]
+nvme_init_identify [nvme_core]
+nvme_execute_passthru_rq [nvme_core]
+nvme_submit_user_cmd [nvme_core]
+nvme_user_cmd [nvme_core]
+nvme_submit_io [nvme_core]
+nvme_user_cmd64 [nvme_core]
+nvme_ioctl [nvme_core]
+nvme_compat_ioctl [nvme_core]
+nvme_dev_ioctl [nvme_core]
+nvme_alloc_ns [nvme_core]
+nvme_validate_or_alloc_ns [nvme_core]
+nvme_fw_act_work [nvme_core]
+nvme_scan_work [nvme_core]
+nvme_trace_parse_admin_cmd [nvme_core]
+nvme_trace_parse_nvm_cmd [nvme_core]
+nvme_trace_parse_fabrics_cmd [nvme_core]
+nvme_trace_disk_name [nvme_core]
+nvme_subsys_iopolicy_show [nvme_core]
+ana_grpid_show [nvme_core]
+ana_state_show [nvme_core]
+nvme_parse_ana_log [nvme_core]
+nvme_subsys_iopolicy_store [nvme_core]
+nvme_anatt_timeout [nvme_core]
+nvme_read_ana_log [nvme_core]
+nvme_ana_work [nvme_core]
+nvme_lookup_ana_group_desc [nvme_core]
+nvme_path_is_disabled.part.0 [nvme_core]
+__nvme_find_path [nvme_core]
+nvme_mpath_set_live [nvme_core]
+nvme_update_ns_ana_state [nvme_core]
+nvme_update_ana_state [nvme_core]
+nvme_requeue_work [nvme_core]
+nvme_mpath_unfreeze [nvme_core]
+nvme_mpath_wait_freeze [nvme_core]
+nvme_mpath_start_freeze [nvme_core]
+nvme_set_disk_name [nvme_core]
+nvme_kick_requeue_lists [nvme_core]
+nvme_mpath_clear_current_path [nvme_core]
+nvme_failover_req [nvme_core]
+nvme_mpath_clear_ctrl_paths [nvme_core]
+nvme_ns_head_submit_bio [nvme_core]
+nvme_mpath_alloc_disk [nvme_core]
+nvme_mpath_stop [nvme_core]
+nvme_mpath_add_disk [nvme_core]
+nvme_mpath_remove_disk [nvme_core]
+nvme_mpath_init [nvme_core]
+nvme_mpath_uninit [nvme_core]
+nvme_zone_parse_entry [nvme_core]
+nvme_set_max_append [nvme_core]
+nvme_revalidate_zones [nvme_core]
+nvme_update_zone_info [nvme_core]
+nvme_report_zones [nvme_core]
+nvme_setup_zone_mgmt_send [nvme_core]
+nvme_set_temp_thresh [nvme_core]
+nvme_hwmon_read_string [nvme_core]
+nvme_hwmon_write [nvme_core]
+nvme_get_temp_thresh [nvme_core]
+nvme_hwmon_get_smart_log [nvme_core]
+nvme_hwmon_read [nvme_core]
+nvme_hwmon_is_visible [nvme_core]
+nvme_hwmon_init [nvme_core]
+i801_func [i2c_i801]
+i801_enable_host_notify [i2c_i801]
+i801_resume [i2c_i801]
+i801_suspend [i2c_i801]
+i801_check_pre [i2c_i801]
+i801_check_post [i2c_i801]
+check_acpi_smo88xx_device [i2c_i801]
+i801_acpi_io_handler [i2c_i801]
+i801_acpi_remove [i2c_i801]
+i801_isr [i2c_i801]
+i801_remove [i2c_i801]
+i801_wait_intr [i2c_i801]
+i801_transaction [i2c_i801]
+dmi_check_onboard_devices [i2c_i801]
+i801_access [i2c_i801]
+i801_probe [i2c_i801]
+i801_shutdown [i2c_i801]
+register_dell_lis3lv02d_i2c_device [i2c_i801]
+i801_add_tco_cnl.isra.0 [i2c_i801]
+i801_add_tco_spt.isra.0 [i2c_i801]
+i801_add_tco [i2c_i801]
+rtl8169_get_regs_len [r8169]
+rtl8169_get_sset_count [r8169]
+rtl_ocp_gphy_cond_check [r8169]
+rtl_phyar_cond_check [r8169]
+rtl_ocpar_cond_check [r8169]
+rtl_ephyar_cond_check [r8169]
+rtl_eriar_cond_check [r8169]
+rtl_ocp_tx_cond_check [r8169]
+rtl_efusear_cond_check [r8169]
+rtl8169_irq_mask_and_ack [r8169]
+rtl8169_get_wol [r8169]
+rtl8169_fix_features [r8169]
+rtl_set_rx_config_features [r8169]
+rtl8169_set_features [r8169]
+rtl_counters_cond_check [r8169]
+rtl_init_rxcfg [r8169]
+rtl_chipcmd_cond_check [r8169]
+rtl_npq_cond_check [r8169]
+rtl_txcfg_empty_cond_check [r8169]
+rtl_rxtx_empty_cond_check [r8169]
+rtl_rxtx_empty_cond_2_check [r8169]
+rtl_csiar_cond_check [r8169]
+rtl_hw_start_8168b [r8169]
+rtl_link_list_ready_cond_check [r8169]
+rtl_mac_ocp_e00e_cond_check [r8169]
+rtl_hw_aspm_clkreq_enable [r8169]
+rtl8169_runtime_idle [r8169]
+rtl_get_coalesce [r8169]
+rtl8169_unmap_tx_skb [r8169]
+rtl8169_tx_clear_range [r8169]
+__rtl_hw_start_8168cp [r8169]
+rtl_jumbo_config [r8169]
+rtl_set_rx_mode [r8169]
+rtl_disable_clk [r8169]
+rtl8169_set_eee [r8169]
+rtl8169_get_eee [r8169]
+rtl_set_coalesce [r8169]
+rtl8169_get_regs [r8169]
+rtl8169_get_drvinfo [r8169]
+rtl8169_change_mtu [r8169]
+rtl8169_rx_clear [r8169]
+rtl8169_get_strings [r8169]
+rtl_wol_suspend_quirk [r8169]
+rtl_ocp_reg_failure.part.0 [r8169]
+r8168_mac_ocp_write [r8169]
+r8168_mac_ocp_read [r8169]
+r8168_mac_ocp_modify [r8169]
+mac_mcu_read [r8169]
+mac_mcu_write [r8169]
+rtl8169_poll [r8169]
+rtl_schedule_task.constprop.0 [r8169]
+rtl8169_tx_timeout [r8169]
+rtl8169_interrupt [r8169]
+rtl8169_netpoll [r8169]
+rtl8169_tx_map [r8169]
+rtl_loop_wait [r8169]
+rtl_enable_rxdvgate [r8169]
+rtl_ephy_read [r8169]
+rtl8168ep_stop_cmac [r8169]
+r8168dp_ocp_read [r8169]
+rtl_dp_ocp_read_cond_check [r8169]
+r8169_mdio_read [r8169]
+rtl_ephy_write [r8169]
+__rtl_ephy_init [r8169]
+rtl_hw_start_8105e_1 [r8169]
+rtl_hw_start_8401 [r8169]
+rtl_hw_start_8105e_2 [r8169]
+rtl_hw_start_8125_common [r8169]
+rtl8169_do_counters [r8169]
+rtl8169_update_counters [r8169]
+rtl8169_get_ethtool_stats [r8169]
+r8168dp_1_mdio_access [r8169]
+rtl_readphy [r8169]
+r8169_mdio_read_reg [r8169]
+r8169_mdio_write [r8169]
+rtl_writephy [r8169]
+r8169_mdio_write_reg [r8169]
+_rtl_eri_write [r8169]
+rtl8168g_set_pause_thresholds [r8169]
+rtl_rar_set [r8169]
+rtl_set_mac_address [r8169]
+rtl_hw_start_8106 [r8169]
+rtl_set_fifo_size.constprop.0 [r8169]
+r8168dp_oob_notify [r8169]
+rtl_csi_access_enable.constprop.0 [r8169]
+rtl_hw_start_8168d_4 [r8169]
+rtl_hw_start_8168cp_1 [r8169]
+rtl_hw_start_8168c_1 [r8169]
+rtl_hw_start_8168c_2 [r8169]
+rtl_hw_start_8168c_3 [r8169]
+rtl_hw_start_8168c_4 [r8169]
+rtl_hw_start_8168d [r8169]
+rtl_hw_start_8168e_1 [r8169]
+rtl_hw_start_8102e_1 [r8169]
+rtl_hw_start_8102e_2 [r8169]
+rtl_hw_start_8102e_3 [r8169]
+rtl_hw_start_8168cp_2 [r8169]
+rtl_hw_start_8168cp_3 [r8169]
+rtl_hw_start_8125a_1 [r8169]
+rtl_hw_start_8125a_2 [r8169]
+rtl_hw_start_8125b [r8169]
+rtl8169_cleanup [r8169]
+_rtl_eri_read [r8169]
+rtl_ep_ocp_read_cond_check [r8169]
+r8168_check_dash [r8169]
+rtl_w0w1_eri [r8169]
+rtl_reset_packet_filter [r8169]
+r8169_phylink_handler [r8169]
+rtl8168_config_eee_mac [r8169]
+__rtl8169_set_wol [r8169]
+rtl8169_set_wol [r8169]
+rtl_pll_power_down.part.0 [r8169]
+rtl_hw_start_8168ep [r8169]
+rtl_hw_start_8168ep_3 [r8169]
+rtl_hw_start_8168ep_2 [r8169]
+rtl_hw_start_8168ep_1 [r8169]
+rtl_hw_start_8168g [r8169]
+rtl_hw_start_8411_2 [r8169]
+rtl_hw_start_8168g_2 [r8169]
+rtl_hw_start_8168g_1 [r8169]
+rtl_hw_start_8402 [r8169]
+rtl_hw_start_8168h_1 [r8169]
+rtl_hw_start_8168f [r8169]
+rtl_hw_start_8411 [r8169]
+rtl_hw_start_8168f_1 [r8169]
+rtl_hw_start_8168e_2 [r8169]
+rtl_init_one [r8169]
+rtl8169_down [r8169]
+rtl8169_net_suspend [r8169]
+rtl8169_runtime_suspend [r8169]
+rtl8169_suspend [r8169]
+rtl_shutdown [r8169]
+rtl8169_close [r8169]
+rtl_reset_work [r8169]
+rtl_task [r8169]
+rtl_remove_one [r8169]
+rtl8169_get_stats64 [r8169]
+rtl8169_up [r8169]
+rtl8169_net_resume [r8169]
+rtl8169_runtime_resume [r8169]
+rtl8169_resume [r8169]
+rtl_open [r8169]
+rtl8169_start_xmit [r8169]
+rtl8169_features_check [r8169]
+rtl8168d_efuse_read [r8169]
+r8169_apply_firmware [r8169]
+rtl_hw_start_8117 [r8169]
+rtl8168h_2_get_adc_bias_ioffset [r8169]
+rtl_fw_write_firmware [r8169]
+rtl_fw_release_firmware [r8169]
+rtl_fw_request_firmware [r8169]
+rtl8168g_2_hw_phy_config [r8169]
+rtl8168h_config_eee_phy [r8169]
+rtl8125a_config_eee_phy [r8169]
+rtl8401_hw_phy_config [r8169]
+rtl8168cp_2_hw_phy_config [r8169]
+rtl8168bef_hw_phy_config [r8169]
+rtl8169sb_hw_phy_config [r8169]
+rtl8168bb_hw_phy_config [r8169]
+rtl8168cp_1_hw_phy_config [r8169]
+rtl8402_hw_phy_config [r8169]
+rtl8105e_hw_phy_config [r8169]
+r8168g_phy_param [r8169]
+rtl8117_hw_phy_config [r8169]
+rtl8168g_phy_adjust_10m_aldps [r8169]
+rtl8168ep_1_hw_phy_config [r8169]
+rtl8125a_1_hw_phy_config [r8169]
+rtl8168h_2_hw_phy_config [r8169]
+rtl8168h_1_hw_phy_config [r8169]
+rtl8125b_hw_phy_config [r8169]
+rtl8168ep_2_hw_phy_config [r8169]
+rtl8125a_2_hw_phy_config [r8169]
+rtl8168g_1_hw_phy_config [r8169]
+r8168d_modify_extpage [r8169]
+rtl8168d_4_hw_phy_config [r8169]
+r8168d_phy_param [r8169]
+rtl8168f_config_eee_phy [r8169]
+rtl8168e_2_hw_phy_config [r8169]
+__rtl_writephy_batch [r8169]
+rtl8168d_3_hw_phy_config [r8169]
+rtl8168c_3_hw_phy_config [r8169]
+rtl8168c_2_hw_phy_config [r8169]
+rtl8168c_1_hw_phy_config [r8169]
+rtl8102e_hw_phy_config [r8169]
+rtl8169sce_hw_phy_config [r8169]
+rtl8169scd_hw_phy_config [r8169]
+rtl8169s_hw_phy_config [r8169]
+rtl8168e_1_hw_phy_config [r8169]
+rtl8106e_hw_phy_config [r8169]
+rtl8168d_apply_firmware_cond [r8169]
+rtl8168d_2_hw_phy_config [r8169]
+rtl8168d_1_hw_phy_config [r8169]
+rtl8168f_hw_phy_config.isra.0 [r8169]
+rtl8168f_2_hw_phy_config [r8169]
+rtl8411_hw_phy_config [r8169]
+rtl8168f_1_hw_phy_config [r8169]
+r8169_hw_phy_config [r8169]
+ahci_shutdown_one [ahci]
+ahci_remove_one [ahci]
+ahci_pci_device_runtime_suspend [ahci]
+ahci_pci_init_controller [ahci]
+ahci_pci_device_runtime_resume [ahci]
+ahci_pci_device_resume [ahci]
+ahci_pci_device_suspend [ahci]
+remapped_nvme_show [ahci]
+ahci_get_irq_vector [ahci]
+ahci_vt8251_hardreset [ahci]
+ahci_p5wdh_hardreset [ahci]
+ahci_init_one [ahci]
+ahci_avn_hardreset [ahci]
+ahci_mcp89_apple_enable [ahci]
+io_queue_depth_set [nvme]
+nvme_simple_resume [nvme]
+nvme_irq_check [nvme]
+nvme_calc_irq_sets [nvme]
+nvme_pci_reg_read32 [nvme]
+nvme_pci_reg_write32 [nvme]
+nvme_pci_reg_read64 [nvme]
+nvme_cmb_size_unit [nvme]
+nvme_del_queue_end [nvme]
+nvme_del_cq_end [nvme]
+nvme_init_queue [nvme]
+nvme_admin_init_hctx [nvme]
+nvme_init_hctx [nvme]
+__nvme_disable_io_queues [nvme]
+nvme_disable_io_queues [nvme]
+abort_endio [nvme]
+nvme_suspend_queue [nvme]
+nvme_resume [nvme]
+nvme_error_resume [nvme]
+nvme_reset_done [nvme]
+nvme_slot_reset [nvme]
+nvme_cmb_show [nvme]
+nvme_free_queue [nvme]
+nvme_dbbuf_dma_free [nvme]
+nvme_free_host_mem [nvme]
+nvme_dev_remove_admin [nvme]
+nvme_async_probe [nvme]
+nvme_pci_get_address [nvme]
+nvme_pci_free_ctrl [nvme]
+nvme_remove_dead_ctrl_work [nvme]
+nvme_remap_bar [nvme]
+queue_request_irq [nvme]
+adapter_delete_queue [nvme]
+nvme_unmap_data [nvme]
+nvme_pci_complete_rq [nvme]
+nvme_poll [nvme]
+nvme_alloc_queue [nvme]
+nvme_map_data [nvme]
+nvme_init_request [nvme]
+nvme_pci_map_queues [nvme]
+nvme_dev_unmap [nvme]
+nvme_probe [nvme]
+nvme_commit_rqs [nvme]
+nvme_submit_cmd [nvme]
+nvme_pci_submit_async_event [nvme]
+nvme_queue_rq [nvme]
+nvme_irq [nvme]
+nvme_poll_irqdisable [nvme]
+nvme_dev_disable [nvme]
+nvme_reset_prepare [nvme]
+nvme_simple_suspend [nvme]
+nvme_suspend [nvme]
+nvme_error_detected [nvme]
+nvme_remove [nvme]
+nvme_reset_work [nvme]
+nvme_shutdown [nvme]
+nvme_timeout [nvme]
+io_queue_count_set [nvme]
+crc32_pclmul_cra_init [crc32_pclmul]
+crc32_pclmul_setkey [crc32_pclmul]
+crc32_pclmul_init [crc32_pclmul]
+crc32_pclmul_final [crc32_pclmul]
+crc32_pclmul_le [crc32_pclmul]
+crc32_pclmul_finup [crc32_pclmul]
+crc32_pclmul_digest [crc32_pclmul]
+crc32_pclmul_update [crc32_pclmul]
+autofs_mount [autofs4]
+autofs_show_options [autofs4]
+autofs_evict_inode [autofs4]
+autofs_new_ino [autofs4]
+autofs_clean_ino [autofs4]
+autofs_free_ino [autofs4]
+autofs_kill_sb [autofs4]
+autofs_get_inode [autofs4]
+autofs_fill_super [autofs4]
+autofs_mount_wait [autofs4]
+autofs_root_ioctl_unlocked [autofs4]
+autofs_root_compat_ioctl [autofs4]
+autofs_root_ioctl [autofs4]
+autofs_del_active [autofs4]
+autofs_dir_symlink [autofs4]
+autofs_dir_unlink [autofs4]
+autofs_dentry_release [autofs4]
+autofs_dir_open [autofs4]
+autofs_dir_mkdir [autofs4]
+autofs_lookup [autofs4]
+do_expire_wait [autofs4]
+autofs_dir_rmdir [autofs4]
+autofs_d_manage [autofs4]
+autofs_d_automount [autofs4]
+is_autofs_dentry [autofs4]
+autofs_get_link [autofs4]
+autofs_find_wait [autofs4]
+autofs_catatonic_mode [autofs4]
+autofs_wait_release [autofs4]
+autofs_notify_daemon [autofs4]
+autofs_wait [autofs4]
+autofs_mount_busy [autofs4]
+autofs_direct_busy [autofs4]
+positive_after [autofs4]
+get_next_positive_dentry [autofs4]
+should_expire [autofs4]
+autofs_expire_indirect [autofs4]
+autofs_expire_wait [autofs4]
+autofs_expire_run [autofs4]
+autofs_do_expire_multi [autofs4]
+autofs_expire_multi [autofs4]
+autofs_dev_ioctl_version [autofs4]
+autofs_dev_ioctl_protover [autofs4]
+autofs_dev_ioctl_protosubver [autofs4]
+test_by_dev [autofs4]
+test_by_type [autofs4]
+autofs_dev_ioctl_timeout [autofs4]
+find_autofs_mount [autofs4]
+autofs_dev_ioctl_ismountpoint [autofs4]
+autofs_dev_ioctl_askumount [autofs4]
+autofs_dev_ioctl_expire [autofs4]
+autofs_dev_ioctl_requester [autofs4]
+autofs_dev_ioctl_catatonic [autofs4]
+autofs_dev_ioctl_setpipefd [autofs4]
+autofs_dev_ioctl_fail [autofs4]
+autofs_dev_ioctl_ready [autofs4]
+autofs_dev_ioctl_closemount [autofs4]
+autofs_dev_ioctl_openmount [autofs4]
+_autofs_dev_ioctl [autofs4]
+autofs_dev_ioctl [autofs4]
+autofs_dev_ioctl_compat [autofs4]
+autofs_dev_ioctl_exit [autofs4]
+xt_compat_lock [x_tables]
+xt_compat_unlock [x_tables]
+xt_net_init [x_tables]
+xt_compat_calc_jump [x_tables]
+xt_compat_match_offset [x_tables]
+xt_find_jump_offset [x_tables]
+xt_compat_target_offset [x_tables]
+xt_table_get_private_protected [x_tables]
+xt_register_target [x_tables]
+xt_unregister_target [x_tables]
+xt_unregister_targets [x_tables]
+xt_register_targets [x_tables]
+xt_register_match [x_tables]
+xt_unregister_match [x_tables]
+xt_unregister_matches [x_tables]
+xt_register_matches [x_tables]
+xt_table_unlock [x_tables]
+target_revfn [x_tables]
+match_revfn [x_tables]
+xt_find_revision [x_tables]
+xt_net_exit [x_tables]
+xt_check_proc_name [x_tables]
+xt_check_table_hooks [x_tables]
+xt_compat_add_offset [x_tables]
+xt_compat_flush_offsets [x_tables]
+xt_compat_init_offsets [x_tables]
+xt_find_table_lock [x_tables]
+xt_request_find_table_lock [x_tables]
+xt_compat_match_from_user [x_tables]
+xt_compat_target_from_user [x_tables]
+xt_alloc_entry_offsets [x_tables]
+xt_alloc_table_info [x_tables]
+xt_free_table_info [x_tables]
+xt_counters_alloc [x_tables]
+xt_unregister_table [x_tables]
+xt_proto_init [x_tables]
+xt_proto_fini [x_tables]
+xt_target_seq_show [x_tables]
+xt_match_seq_show [x_tables]
+xt_table_seq_show [x_tables]
+xt_table_seq_stop [x_tables]
+xt_table_seq_next [x_tables]
+xt_table_seq_start [x_tables]
+xt_percpu_counter_alloc [x_tables]
+xt_percpu_counter_free [x_tables]
+xt_find_match [x_tables]
+xt_find_target [x_tables]
+xt_request_find_match [x_tables]
+xt_request_find_target [x_tables]
+xt_mttg_seq_stop [x_tables]
+xt_mttg_seq_next.constprop.0 [x_tables]
+xt_match_seq_next [x_tables]
+xt_target_seq_start [x_tables]
+xt_target_seq_next [x_tables]
+error_tg_ok.constprop.0 [x_tables]
+textify_hooks.constprop.0 [x_tables]
+xt_check_target [x_tables]
+xt_check_match [x_tables]
+xt_match_seq_start [x_tables]
+xt_compat_check_entry_offsets [x_tables]
+xt_check_entry_offsets [x_tables]
+xt_hook_ops_alloc [x_tables]
+xt_data_to_user [x_tables]
+xt_obj_to_user [x_tables]
+xt_match_to_user [x_tables]
+xt_target_to_user [x_tables]
+xt_compat_match_to_user [x_tables]
+xt_compat_target_to_user [x_tables]
+xt_copy_counters [x_tables]
+xt_replace_table [x_tables]
+xt_register_table [x_tables]
+icmp_checkentry [ip_tables]
+cleanup_match [ip_tables]
+cleanup_entry [ip_tables]
+__ipt_unregister_table [ip_tables]
+ipt_unregister_table_exit [ip_tables]
+ipt_unregister_table_pre_exit [ip_tables]
+ipt_unregister_table [ip_tables]
+compat_table_info [ip_tables]
+compat_standard_to_user [ip_tables]
+compat_standard_from_user [ip_tables]
+ip_tables_net_exit [ip_tables]
+ip_tables_net_init [ip_tables]
+ipt_do_table [ip_tables]
+alloc_counters [ip_tables]
+compat_get_entries [ip_tables]
+find_check_entry.isra.0 [ip_tables]
+ipt_error [ip_tables]
+icmp_match [ip_tables]
+ipt_alloc_initial_table [ip_tables]
+__do_replace [ip_tables]
+get_info [ip_tables]
+do_ipt_get_ctl [ip_tables]
+translate_table [ip_tables]
+ipt_register_table [ip_tables]
+translate_compat_table [ip_tables]
+compat_do_replace.isra.0 [ip_tables]
+do_ipt_set_ctl [ip_tables]
+efi_pstore_open [efi_pstore]
+efi_pstore_update_entry [efi_pstore]
+efi_pstore_erase_name [efi_pstore]
+efi_pstore_erase [efi_pstore]
+efi_pstore_erase_func [efi_pstore]
+efi_pstore_write [efi_pstore]
+efi_pstore_read_func.part.0 [efi_pstore]
+efi_pstore_read_func [efi_pstore]
+efi_pstore_close [efi_pstore]
+efi_pstore_update_entries [efi_pstore]
+efi_pstore_callback [efi_pstore]
+efi_pstore_scan_sysfs_exit.constprop.0 [efi_pstore]
+efi_pstore_read [efi_pstore]
+psz_pstore_open [pstore_zone]
+psz_ftrace_read [pstore_zone]
+psz_free_zone [pstore_zone]
+psz_free_zones [pstore_zone]
+psz_zone_write [pstore_zone]
+psz_flush_dirty_zone [pstore_zone]
+psz_flush_dirty_zones.part.0 [pstore_zone]
+psz_flush_all_dirty_zones [pstore_zone]
+psz_free_all_zones.constprop.0 [pstore_zone]
+unregister_pstore_zone [pstore_zone]
+psz_recover_zone [pstore_zone]
+psz_pstore_read [pstore_zone]
+psz_pstore_erase [pstore_zone]
+psz_record_read [pstore_zone]
+psz_init_zone [pstore_zone]
+psz_kmsg_read [pstore_zone]
+psz_init_zones [pstore_zone]
+register_pstore_zone [pstore_zone]
+free_rs [reed_solomon]
+encode_rs8 [reed_solomon]
+decode_rs16 [reed_solomon]
+decode_rs8 [reed_solomon]
+init_rs_internal [reed_solomon]
+init_rs_gfp [reed_solomon]
+init_rs_non_canonical [reed_solomon]
+psblk_blk_panic_write [pstore_blk]
+__unregister_pstore_device [pstore_blk]
+unregister_pstore_device [pstore_blk]
+__unregister_pstore_blk [pstore_blk]
+unregister_pstore_blk [pstore_blk]
+psblk_generic_blk_read [pstore_blk]
+pstore_blk_get_config [pstore_blk]
+__register_pstore_device [pstore_blk]
+register_pstore_device [pstore_blk]
+__register_pstore_blk [pstore_blk]
+register_pstore_blk [pstore_blk]
+psblk_generic_blk_write [pstore_blk]
+prz_ok [ramoops]
+ramoops_pstore_open [ramoops]
+ramoops_pstore_erase [ramoops]
+ramoops_get_next_prz [ramoops]
+ramoops_init_prz.constprop.0 [ramoops]
+ramoops_free_przs.constprop.0 [ramoops]
+ramoops_remove [ramoops]
+ramoops_pstore_read [ramoops]
+ramoops_init_przs.part.0.constprop.0 [ramoops]
+ramoops_probe [ramoops]
+buffer_size_add [ramoops]
+persistent_ram_decode_rs8 [ramoops]
+buffer_start_add [ramoops]
+persistent_ram_ecc_string [ramoops]
+persistent_ram_save_old [ramoops]
+persistent_ram_old_size [ramoops]
+persistent_ram_old [ramoops]
+persistent_ram_free_old [ramoops]
+persistent_ram_zap [ramoops]
+persistent_ram_free [ramoops]
+persistent_ram_new [ramoops]
+drm_master_internal_release [drm]
+drm_master_internal_acquire [drm]
+drm_master_destroy [drm]
+drm_is_current_master [drm]
+drm_master_check_perm.isra.0 [drm]
+drm_master_put [drm]
+drm_drop_master [drm]
+drm_master_get [drm]
+drm_set_master [drm]
+drm_getmagic [drm]
+drm_authmagic [drm]
+drm_master_create [drm]
+drm_new_set_master [drm]
+drm_setmaster_ioctl [drm]
+drm_dropmaster_ioctl [drm]
+drm_master_open [drm]
+drm_master_release [drm]
+drm_clflush_virt_range [drm]
+drm_clflush_page [drm]
+drm_clflush_pages [drm]
+drm_clflush_sg [drm]
+drm_poll [drm]
+drm_event_reserve_init_locked [drm]
+drm_event_reserve_init [drm]
+drm_addr_inflate [drm]
+drm_get_unmapped_area [drm]
+drm_file_free.part.0 [drm]
+drm_close_helper [drm]
+drm_send_event_locked [drm]
+drm_send_event [drm]
+drm_event_cancel_free [drm]
+drm_read [drm]
+drm_dev_needs_global_mutex [drm]
+drm_file_alloc [drm]
+drm_open [drm]
+drm_file_free [drm]
+drm_lastclose [drm]
+drm_release [drm]
+drm_release_noglobal [drm]
+mock_drm_getfile [drm]
+drm_gem_object_free [drm]
+drm_gem_init_release [drm]
+drm_gem_free_mmap_offset [drm]
+drm_gem_create_mmap_offset_size [drm]
+drm_gem_create_mmap_offset [drm]
+drm_gem_get_pages [drm]
+drm_gem_put_pages [drm]
+drm_gem_object_release [drm]
+drm_gem_lock_reservations [drm]
+drm_gem_unlock_reservations [drm]
+drm_gem_private_object_init [drm]
+drm_gem_object_init [drm]
+drm_gem_vm_open [drm]
+drm_gem_object_put_locked [drm]
+drm_gem_vm_close [drm]
+objects_lookup [drm]
+drm_gem_objects_lookup [drm]
+drm_gem_object_lookup [drm]
+drm_gem_dumb_map_offset [drm]
+drm_gem_dma_resv_wait [drm]
+drm_gem_object_handle_put_unlocked [drm]
+drm_gem_object_release_handle [drm]
+drm_gem_handle_delete [drm]
+drm_gem_dumb_destroy [drm]
+drm_gem_mmap_obj [drm]
+drm_gem_fence_array_add [drm]
+drm_gem_fence_array_add_implicit [drm]
+drm_gem_mmap [drm]
+drm_gem_init [drm]
+drm_gem_handle_create_tail [drm]
+drm_gem_handle_create [drm]
+drm_gem_close_ioctl [drm]
+drm_gem_flink_ioctl [drm]
+drm_gem_open_ioctl [drm]
+drm_gem_open [drm]
+drm_gem_release [drm]
+drm_gem_print_info [drm]
+drm_gem_pin [drm]
+drm_gem_unpin [drm]
+drm_gem_vmap [drm]
+drm_gem_vunmap [drm]
+drm_invalid_op [drm]
+drm_noop [drm]
+drm_copy_field [drm]
+drm_version [drm]
+drm_setversion [drm]
+drm_getstats [drm]
+drm_getcap [drm]
+drm_getclient [drm]
+drm_ioctl_permit [drm]
+drm_setclientcap [drm]
+drm_ioctl_flags [drm]
+drm_ioctl_kernel [drm]
+drm_ioctl [drm]
+drm_getunique [drm]
+drm_irq_install [drm]
+drm_irq_uninstall [drm]
+agp_remap [drm]
+drm_legacy_ioremapfree [drm]
+drm_legacy_ioremap_wc [drm]
+drm_need_swiotlb [drm]
+drm_legacy_ioremap [drm]
+drm_free_agp [drm]
+drm_bind_agp [drm]
+drm_unbind_agp [drm]
+drm_fs_init_fs_context [drm]
+drm_dev_release [drm]
+drm_dev_init_release [drm]
+drm_minor_alloc_release [drm]
+drm_dev_set_unique [drm]
+drm_minor_get_slot.part.0 [drm]
+drm_minor_alloc [drm]
+drm_dev_init [drm]
+drm_minor_register [drm]
+drm_minor_unregister [drm]
+remove_compat_control_link [drm]
+drm_dev_register [drm]
+drm_dev_unregister [drm]
+drm_dev_unplug [drm]
+__devm_drm_dev_alloc [drm]
+drm_dev_get [drm]
+drm_dev_alloc [drm]
+drm_dev_exit [drm]
+drm_dev_enter [drm]
+drm_put_dev [drm]
+drm_dev_put [drm]
+devm_drm_dev_init_release [drm]
+drm_minor_acquire [drm]
+drm_stub_open [drm]
+drm_minor_release [drm]
+drm_core_exit [drm]
+drm_devnode [drm]
+edid_show [drm]
+modes_show [drm]
+dpms_show [drm]
+enabled_show [drm]
+status_store [drm]
+status_show [drm]
+drm_class_device_unregister [drm]
+drm_sysfs_hotplug_event [drm]
+drm_sysfs_connector_status_event [drm]
+drm_sysfs_release [drm]
+drm_class_device_register [drm]
+drm_sysfs_init [drm]
+drm_sysfs_destroy [drm]
+drm_sysfs_connector_add [drm]
+drm_sysfs_connector_remove [drm]
+drm_sysfs_lease_event [drm]
+drm_sysfs_minor_alloc [drm]
+drm_ht_remove_item [drm]
+drm_ht_insert_item [drm]
+drm_ht_find_item [drm]
+drm_ht_just_insert_please [drm]
+drm_ht_remove [drm]
+drm_ht_create [drm]
+drm_ht_verbose_list [drm]
+drm_ht_remove_key [drm]
+drm_mm_interval_tree_augment_rotate [drm]
+__drm_mm_interval_first [drm]
+augment_callbacks_rotate [drm]
+find_hole_addr [drm]
+drm_mm_scan_init_with_range [drm]
+drm_mm_scan_remove_block [drm]
+drm_mm_scan_color_evict [drm]
+drm_mm_interval_tree_add_node [drm]
+add_hole [drm]
+drm_mm_init [drm]
+drm_mm_scan_add_block [drm]
+drm_mm_replace_node [drm]
+drm_mm_takedown [drm]
+drm_mm_print [drm]
+rm_hole [drm]
+drm_mm_reserve_node [drm]
+drm_mm_remove_node [drm]
+drm_mm_insert_node_in_range [drm]
+drm_crtc_from_index [drm]
+drm_crtc_init_with_planes [drm]
+drm_crtc_cleanup [drm]
+__drm_mode_set_config_internal [drm]
+drm_mode_set_config_internal [drm]
+drm_crtc_check_viewport [drm]
+fence_to_crtc.part.0 [drm]
+drm_crtc_fence_get_timeline_name [drm]
+drm_crtc_fence_get_driver_name [drm]
+drm_crtc_force_disable [drm]
+drm_crtc_register_all [drm]
+drm_crtc_unregister_all [drm]
+drm_crtc_create_fence [drm]
+drm_mode_getcrtc [drm]
+drm_mode_setcrtc [drm]
+drm_mode_crtc_set_obj_prop [drm]
+drm_get_format_name [drm]
+drm_mode_legacy_fb_format [drm]
+drm_driver_legacy_fb_format [drm]
+drm_format_info_block_width [drm]
+drm_format_info_block_height [drm]
+drm_format_info_min_pitch [drm]
+drm_format_info.part.0 [drm]
+drm_format_info [drm]
+drm_get_format_info [drm]
+__drm_format_info [drm]
+drm_mode_destroy [drm]
+drm_mode_sort [drm]
+drm_mode_is_420_only [drm]
+drm_mode_is_420_also [drm]
+drm_mode_is_420 [drm]
+drm_display_mode_to_videomode [drm]
+drm_bus_flags_from_videomode [drm]
+drm_mode_set_crtcinfo [drm]
+drm_mode_get_hv_timing [drm]
+drm_mode_copy [drm]
+drm_mode_validate_size [drm]
+drm_mode_parse_cmdline_extra [drm]
+drm_mode_probed_add [drm]
+drm_mode_vrefresh [drm]
+drm_mode_debug_printmodeline [drm]
+drm_mode_compare [drm]
+drm_mode_set_name [drm]
+drm_display_mode_from_videomode [drm]
+drm_mode_prune_invalid [drm]
+drm_mode_parse_cmdline_int [drm]
+drm_mode_validate_driver [drm]
+drm_mode_match [drm]
+drm_mode_equal [drm]
+drm_mode_equal_no_clocks [drm]
+drm_mode_equal_no_clocks_no_stereo [drm]
+drm_connector_list_update [drm]
+drm_mode_validate_ycbcr420 [drm]
+drm_mode_parse_command_line_for_connector [drm]
+drm_cvt_mode [drm]
+drm_mode_create [drm]
+drm_mode_duplicate [drm]
+drm_gtf_mode_complex [drm]
+drm_gtf_mode [drm]
+drm_mode_create_from_cmdline_mode [drm]
+drm_get_mode_status_name [drm]
+drm_mode_convert_to_umode [drm]
+drm_mode_convert_umode [drm]
+drm_edid_header_is_valid [drm]
+monitor_name [drm]
+get_monitor_range [drm]
+drm_set_preferred_mode [drm]
+drm_hdmi_avi_infoframe_colorspace [drm]
+drm_hdmi_avi_infoframe_bars [drm]
+drm_do_probe_ddc_edid [drm]
+drm_probe_ddc [drm]
+drm_edid_duplicate [drm]
+valid_inferred_mode [drm]
+cea_mode_alternate_clock [drm]
+drm_mode_find_dmt [drm]
+drm_display_mode_from_cea_vic [drm]
+drm_display_mode_from_vic_index [drm]
+drm_match_hdmi_mode [drm]
+clear_eld [drm]
+drm_add_modes_noedid [drm]
+drm_hdmi_infoframe_set_hdr_metadata [drm]
+drm_av_sync_delay [drm]
+is_hdmi2_sink [drm]
+drm_get_override_edid [drm]
+drm_edid_are_equal [drm]
+drm_for_each_detailed_block.part.0 [drm]
+drm_gtf2_hbreak [drm]
+get_monitor_name [drm]
+is_rb [drm]
+find_gtf2 [drm]
+cea_db_offsets [drm]
+cea_db_is_hdmi_vsdb.part.0 [drm]
+drm_edid_get_monitor_name [drm]
+cea_mode_alternate_timings [drm]
+drm_match_cea_mode [drm]
+drm_default_rgb_quant_range [drm]
+drm_hdmi_avi_infoframe_quant_range [drm]
+do_established_modes [drm]
+do_cvt_mode [drm]
+drm_monitor_supports_rb.part.0 [drm]
+drm_mode_std [drm]
+do_standard_modes [drm]
+mode_in_range [drm]
+drm_mode_hdmi_vic [drm]
+drm_hdmi_avi_infoframe_from_display_mode [drm]
+drm_hdmi_vendor_infoframe_from_display_mode [drm]
+drm_match_cea_mode_clock_tolerance.constprop.0 [drm]
+do_detailed_mode [drm]
+drm_find_displayid_extension [drm]
+drm_find_cea_extension [drm]
+drm_edid_to_speaker_allocation [drm]
+drm_detect_hdmi_monitor [drm]
+drm_detect_monitor_audio [drm]
+drm_edid_to_sad [drm]
+drm_edid_is_zero.constprop.0 [drm]
+drm_edid_block_valid [drm]
+drm_edid_is_valid.part.0 [drm]
+drm_edid_is_valid [drm]
+connector_bad_edid [drm]
+drm_do_get_edid [drm]
+drm_get_edid [drm]
+drm_get_edid_switcheroo [drm]
+drm_mode_fixup_1366x768 [drm]
+do_inferred_modes [drm]
+drm_reset_display_info [drm]
+drm_add_display_info [drm]
+drm_add_edid_modes [drm]
+drm_add_override_edid_modes [drm]
+drm_update_tile_info [drm]
+drm_i2c_encoder_dpms [drm]
+drm_i2c_encoder_prepare [drm]
+drm_i2c_encoder_commit [drm]
+drm_i2c_encoder_mode_fixup [drm]
+drm_i2c_encoder_mode_set [drm]
+drm_i2c_encoder_detect [drm]
+drm_i2c_encoder_save [drm]
+drm_i2c_encoder_restore [drm]
+drm_i2c_encoder_destroy [drm]
+drm_i2c_encoder_init [drm]
+__traceiter_drm_vblank_event [drm]
+__traceiter_drm_vblank_event_queued [drm]
+__traceiter_drm_vblank_event_delivered [drm]
+drm_gem_dmabuf_mmap [drm]
+drm_prime_add_buf_handle [drm]
+drm_gem_map_attach [drm]
+drm_gem_map_detach [drm]
+drm_gem_map_dma_buf [drm]
+drm_gem_dmabuf_vmap [drm]
+drm_gem_dmabuf_vunmap [drm]
+drm_prime_pages_to_sg [drm]
+drm_prime_get_contiguous_size [drm]
+drm_prime_gem_destroy [drm]
+drm_prime_sg_to_page_addr_arrays [drm]
+drm_gem_unmap_dma_buf [drm]
+drm_gem_prime_import_dev [drm]
+drm_gem_prime_import [drm]
+drm_gem_prime_fd_to_handle [drm]
+drm_gem_dmabuf_release [drm]
+drm_gem_dmabuf_export [drm]
+drm_gem_prime_export [drm]
+drm_gem_prime_handle_to_fd [drm]
+drm_gem_prime_mmap [drm]
+drm_prime_remove_buf_handle_locked [drm]
+drm_prime_init_file_private [drm]
+drm_prime_destroy_file_private [drm]
+drm_prime_fd_to_handle_ioctl [drm]
+drm_prime_handle_to_fd_ioctl [drm]
+drm_rect_intersect [drm]
+drm_rect_rotate [drm]
+drm_rect_rotate_inv [drm]
+drm_calc_scale [drm]
+drm_rect_calc_hscale [drm]
+drm_rect_calc_vscale [drm]
+clip_scaled.part.0 [drm]
+drm_rect_clip_scaled [drm]
+drm_rect_debug_print [drm]
+drm_vma_offset_manager_destroy [drm]
+drm_vma_offset_add [drm]
+drm_vma_offset_manager_init [drm]
+drm_vma_offset_lookup_locked [drm]
+drm_vma_node_is_allowed [drm]
+drm_vma_offset_remove [drm]
+drm_vma_node_allow [drm]
+drm_vma_node_revoke [drm]
+drm_flip_work_queue_task [drm]
+drm_flip_work_commit [drm]
+drm_flip_work_init [drm]
+flip_worker [drm]
+drm_flip_work_cleanup [drm]
+drm_flip_work_queue [drm]
+drm_flip_work_allocate_task [drm]
+drm_modeset_acquire_fini [drm]
+drm_modeset_acquire_init [drm]
+drm_modeset_lock_single_interruptible [drm]
+drm_modeset_lock_init [drm]
+drm_modeset_unlock [drm]
+drm_modeset_drop_locks [drm]
+drm_modeset_unlock_all [drm]
+drm_warn_on_modeset_not_all_locked.part.0 [drm]
+drm_warn_on_modeset_not_all_locked [drm]
+drm_modeset_lock [drm]
+drm_modeset_lock_all_ctx [drm]
+drm_modeset_backoff [drm]
+drm_modeset_lock_all [drm]
+__drm_crtc_commit_free [drm]
+drm_atomic_get_old_private_obj_state [drm]
+drm_atomic_get_old_bridge_state [drm]
+drm_atomic_get_new_private_obj_state [drm]
+drm_atomic_get_new_bridge_state [drm]
+drm_atomic_get_old_connector_for_encoder [drm]
+drm_atomic_get_new_connector_for_encoder [drm]
+drm_atomic_state_default_release [drm]
+drm_atomic_get_crtc_state [drm]
+drm_atomic_get_plane_state [drm]
+drm_atomic_private_obj_init [drm]
+drm_atomic_get_private_obj_state [drm]
+drm_atomic_get_bridge_state [drm]
+drm_atomic_get_connector_state [drm]
+drm_atomic_add_affected_connectors [drm]
+drm_atomic_add_affected_planes [drm]
+__drm_atomic_helper_set_config [drm]
+drm_atomic_plane_print_state [drm]
+drm_atomic_check_only [drm]
+drm_atomic_commit [drm]
+drm_atomic_nonblocking_commit [drm]
+drm_atomic_connector_print_state [drm]
+drm_atomic_crtc_print_state [drm]
+__drm_state_dump [drm]
+drm_state_dump [drm]
+drm_state_info [drm]
+drm_atomic_private_obj_fini [drm]
+drm_atomic_add_encoder_bridges [drm]
+__drm_atomic_helper_disable_plane [drm]
+drm_atomic_state_default_clear [drm]
+drm_atomic_state_clear [drm]
+__drm_atomic_state_free [drm]
+drm_atomic_state_init [drm]
+drm_atomic_state_alloc [drm]
+drm_atomic_print_state [drm]
+drm_atomic_debugfs_init [drm]
+drm_bridge_add [drm]
+drm_bridge_remove [drm]
+drm_bridge_atomic_duplicate_priv_state [drm]
+drm_bridge_atomic_destroy_priv_state [drm]
+drm_bridge_chain_mode_fixup [drm]
+drm_bridge_chain_mode_valid [drm]
+drm_bridge_chain_disable [drm]
+drm_bridge_chain_post_disable [drm]
+drm_bridge_chain_mode_set [drm]
+drm_bridge_chain_pre_enable [drm]
+drm_bridge_chain_enable [drm]
+drm_bridge_detect [drm]
+drm_bridge_get_edid [drm]
+drm_bridge_hpd_notify [drm]
+drm_bridge_attach [drm]
+drm_atomic_bridge_chain_disable [drm]
+drm_atomic_bridge_chain_post_disable [drm]
+drm_atomic_bridge_chain_pre_enable [drm]
+drm_atomic_bridge_chain_enable [drm]
+select_bus_fmt_recursive [drm]
+drm_atomic_bridge_chain_check [drm]
+drm_bridge_get_modes [drm]
+drm_bridge_hpd_disable [drm]
+drm_bridge_hpd_enable [drm]
+drm_bridge_detach [drm]
+drm_framebuffer_cleanup [drm]
+drm_framebuffer_free [drm]
+drm_framebuffer_init [drm]
+drm_framebuffer_lookup [drm]
+fb_plane_width.part.0 [drm]
+drm_framebuffer_plane_width [drm]
+fb_plane_height.part.0 [drm]
+drm_framebuffer_plane_height [drm]
+drm_framebuffer_unregister_private [drm]
+drm_framebuffer_remove [drm]
+drm_mode_rmfb_work_fn [drm]
+drm_framebuffer_check_src_coords [drm]
+drm_internal_framebuffer_create [drm]
+drm_mode_addfb2 [drm]
+drm_mode_addfb [drm]
+drm_mode_addfb_ioctl [drm]
+drm_mode_addfb2_ioctl [drm]
+drm_mode_rmfb [drm]
+drm_mode_rmfb_ioctl [drm]
+drm_mode_getfb [drm]
+drm_mode_getfb2_ioctl [drm]
+drm_mode_dirtyfb_ioctl [drm]
+drm_fb_release [drm]
+drm_framebuffer_print_info [drm]
+drm_framebuffer_info [drm]
+drm_framebuffer_debugfs_init [drm]
+drm_get_connector_type_name [drm]
+drm_get_connector_status_name [drm]
+drm_get_subpixel_order_name [drm]
+drm_connector_list_iter_begin [drm]
+drm_hdmi_avi_infoframe_content_type [drm]
+drm_connector_free [drm]
+drm_connector_attach_edid_property [drm]
+drm_connector_attach_tv_margin_properties [drm]
+drm_connector_attach_encoder [drm]
+drm_connector_has_possible_encoder [drm]
+drm_connector_unregister [drm]
+drm_display_info_set_bus_formats [drm]
+drm_mode_create_dvi_i_properties [drm]
+drm_connector_attach_dp_subconnector_property [drm]
+drm_mode_create_scaling_mode_property [drm]
+drm_mode_create_aspect_ratio_property [drm]
+drm_mode_create_hdmi_colorspace_property [drm]
+drm_mode_create_dp_colorspace_property [drm]
+drm_mode_create_content_type_property [drm]
+drm_connector_attach_content_type_property [drm]
+drm_connector_set_panel_orientation [drm]
+drm_connector_attach_vrr_capable_property [drm]
+drm_mode_create_suggested_offset_properties [drm]
+drm_connector_attach_max_bpc_property [drm]
+drm_connector_attach_scaling_mode_property [drm]
+drm_connector_set_path_property [drm]
+drm_connector_set_vrr_capable_property [drm]
+drm_connector_set_link_status_property [drm]
+drm_connector_set_panel_orientation_with_quirk [drm]
+drm_tile_group_free [drm]
+drm_connector_register [drm]
+drm_connector_set_tile_property [drm]
+drm_connector_update_edid_property [drm]
+drm_connector_init [drm]
+drm_connector_init_with_ddc [drm]
+drm_mode_create_tv_margin_properties [drm]
+drm_mode_create_tv_properties [drm]
+drm_mode_create_tile_group [drm]
+drm_mode_get_tile_group [drm]
+drm_mode_put_tile_group [drm]
+__drm_connector_put_safe [drm]
+drm_connector_list_iter_end [drm]
+drm_connector_list_iter_next [drm]
+drm_connector_cleanup [drm]
+drm_connector_ida_init [drm]
+drm_connector_ida_destroy [drm]
+drm_connector_free_work_fn [drm]
+drm_connector_unregister_all [drm]
+drm_connector_register_all [drm]
+drm_get_connector_force_name [drm]
+drm_get_dpms_name [drm]
+drm_get_dvi_i_select_name [drm]
+drm_get_dvi_i_subconnector_name [drm]
+drm_get_tv_select_name [drm]
+drm_get_tv_subconnector_name [drm]
+drm_get_dp_subconnector_name [drm]
+drm_connector_create_standard_properties [drm]
+drm_connector_set_obj_prop [drm]
+drm_connector_property_set_ioctl [drm]
+drm_mode_getconnector [drm]
+drm_atomic_state_zpos_cmp [drm]
+drm_plane_create_alpha_property [drm]
+drm_plane_create_zpos_property [drm]
+drm_plane_create_zpos_immutable_property [drm]
+drm_plane_create_rotation_property [drm]
+drm_plane_create_blend_mode_property [drm]
+drm_rotation_simplify [drm]
+drm_atomic_normalize_zpos [drm]
+drm_encoder_init [drm]
+drm_encoder_cleanup [drm]
+drm_encoder_register_all [drm]
+drm_encoder_unregister_all [drm]
+drm_mode_getencoder [drm]
+drm_object_property_set_value [drm]
+__drm_object_property_get_value [drm]
+drm_object_property_get_value [drm]
+drm_object_attach_property [drm]
+drm_mode_object_put [drm]
+drm_mode_object_get [drm]
+__drm_mode_object_add [drm]
+drm_mode_object_add [drm]
+drm_mode_object_register [drm]
+drm_mode_object_unregister [drm]
+drm_mode_object_lease_required [drm]
+__drm_mode_object_find [drm]
+drm_mode_object_find [drm]
+drm_mode_object_get_properties [drm]
+drm_mode_obj_get_properties_ioctl [drm]
+drm_mode_obj_find_prop_id [drm]
+drm_mode_obj_set_property_ioctl [drm]
+drm_property_destroy [drm]
+drm_property_free_blob [drm]
+drm_property_blob_put [drm]
+drm_property_blob_get [drm]
+drm_property_replace_blob [drm]
+drm_property_lookup_blob [drm]
+drm_property_create_blob.part.0 [drm]
+drm_property_create_blob [drm]
+drm_property_replace_global_blob [drm]
+drm_property_create [drm]
+drm_property_create_range [drm]
+drm_property_create_bool [drm]
+drm_property_create_signed_range [drm]
+drm_property_create_object [drm]
+drm_property_add_enum [drm]
+drm_property_create_enum [drm]
+drm_property_create_bitmask [drm]
+drm_mode_getproperty_ioctl [drm]
+drm_property_destroy_user_blobs [drm]
+drm_mode_getblob_ioctl [drm]
+drm_mode_createblob_ioctl [drm]
+drm_mode_destroyblob_ioctl [drm]
+drm_property_change_valid_get [drm]
+drm_property_change_valid_put [drm]
+drm_plane_from_index [drm]
+drm_plane_cleanup [drm]
+drm_plane_force_disable [drm]
+drm_mode_plane_set_obj_prop [drm]
+drm_universal_plane_init [drm]
+drm_plane_init [drm]
+drm_plane_register_all [drm]
+drm_plane_unregister_all [drm]
+drm_mode_getplane_res [drm]
+drm_mode_getplane [drm]
+drm_plane_check_pixel_format [drm]
+drm_any_plane_has_format [drm]
+__setplane_check [drm]
+__setplane_atomic [drm]
+__setplane_internal [drm]
+drm_mode_cursor_universal [drm]
+drm_mode_cursor_common [drm]
+drm_mode_setplane [drm]
+drm_mode_cursor_ioctl [drm]
+drm_mode_cursor2_ioctl [drm]
+drm_mode_page_flip_ioctl [drm]
+drm_color_ctm_s31_32_to_qm_n [drm]
+drm_crtc_enable_color_mgmt [drm]
+drm_plane_create_color_properties [drm]
+drm_color_lut_check [drm]
+drm_mode_crtc_set_gamma_size [drm]
+drm_mode_gamma_set_ioctl [drm]
+drm_mode_gamma_get_ioctl [drm]
+drm_get_color_encoding_name [drm]
+drm_get_color_range_name [drm]
+__drm_puts_coredump [drm]
+__drm_printfn_coredump [drm]
+__drm_puts_seq_file [drm]
+__drm_printfn_seq_file [drm]
+__drm_printfn_info [drm]
+__drm_printfn_debug [drm]
+__drm_printfn_err [drm]
+drm_printf [drm]
+drm_puts [drm]
+drm_print_regset32 [drm]
+drm_print_bits [drm]
+__drm_dbg [drm]
+__drm_err [drm]
+drm_dev_printk [drm]
+drm_dev_dbg [drm]
+drm_mode_create_dumb [drm]
+drm_mode_create_dumb_ioctl [drm]
+drm_mode_mmap_dumb_ioctl [drm]
+drm_mode_destroy_dumb [drm]
+drm_mode_destroy_dumb_ioctl [drm]
+drm_mode_config_reset [drm]
+drmm_mode_config_init [drm]
+drm_mode_config_cleanup [drm]
+drm_mode_config_init_release [drm]
+drm_modeset_register_all [drm]
+drm_modeset_unregister_all [drm]
+drm_mode_getresources [drm]
+drm_mode_config_validate [drm]
+drm_dev_has_vblank [drm]
+drm_crtc_vblank_waitqueue [drm]
+drm_vblank_count_and_time [drm]
+drm_crtc_vblank_count_and_time [drm]
+drm_crtc_set_max_vblank_count [drm]
+drm_get_last_vbltimestamp [drm]
+drm_vblank_init [drm]
+drm_wait_vblank_reply [drm]
+send_vblank_event [drm]
+drm_crtc_send_vblank_event [drm]
+__get_vblank_counter [drm]
+drm_vblank_init_release [drm]
+drm_crtc_vblank_helper_get_vblank_timestamp_internal [drm]
+drm_crtc_vblank_helper_get_vblank_timestamp [drm]
+drm_calc_timestamping_constants [drm]
+store_vblank [drm]
+drm_reset_vblank_timestamp [drm]
+drm_update_vblank_count [drm]
+drm_vblank_restore [drm]
+drm_crtc_vblank_restore [drm]
+drm_vblank_enable [drm]
+drm_crtc_vblank_reset [drm]
+drm_crtc_vblank_on [drm]
+drm_vblank_count [drm]
+drm_crtc_accurate_vblank_count [drm]
+drm_crtc_arm_vblank_event [drm]
+drm_crtc_vblank_count [drm]
+drm_vblank_disable_and_save [drm]
+vblank_disable_fn [drm]
+drm_vblank_get [drm]
+drm_crtc_vblank_get [drm]
+drm_vblank_put [drm]
+drm_crtc_vblank_put [drm]
+drm_wait_one_vblank [drm]
+drm_crtc_wait_one_vblank [drm]
+drm_crtc_vblank_off [drm]
+drm_handle_vblank [drm]
+drm_crtc_handle_vblank [drm]
+drm_legacy_modeset_ctl_ioctl [drm]
+drm_wait_vblank_ioctl [drm]
+drm_crtc_get_sequence_ioctl [drm]
+drm_crtc_queue_sequence_ioctl [drm]
+syncobj_wait_fence_func [drm]
+drm_timeout_abs_to_jiffies.part.0 [drm]
+drm_timeout_abs_to_jiffies [drm]
+drm_syncobj_get_fd [drm]
+drm_syncobj_find [drm]
+syncobj_wait_syncobj_func [drm]
+drm_syncobj_add_point [drm]
+drm_syncobj_replace_fence [drm]
+drm_syncobj_assign_null_handle [drm]
+drm_syncobj_create [drm]
+drm_syncobj_free [drm]
+drm_syncobj_array_free [drm]
+drm_syncobj_release_handle [drm]
+drm_syncobj_file_release [drm]
+drm_syncobj_get_handle [drm]
+drm_syncobj_fence_add_wait [drm]
+drm_syncobj_find_fence [drm]
+drm_syncobj_array_find [drm]
+drm_syncobj_array_wait_timeout [drm]
+drm_syncobj_array_wait.constprop.0 [drm]
+drm_syncobj_open [drm]
+drm_syncobj_release [drm]
+drm_syncobj_create_ioctl [drm]
+drm_syncobj_destroy_ioctl [drm]
+drm_syncobj_handle_to_fd_ioctl [drm]
+drm_syncobj_fd_to_handle_ioctl [drm]
+drm_syncobj_transfer_ioctl [drm]
+drm_syncobj_wait_ioctl [drm]
+drm_syncobj_timeline_wait_ioctl [drm]
+drm_syncobj_reset_ioctl [drm]
+drm_syncobj_signal_ioctl [drm]
+drm_syncobj_timeline_signal_ioctl [drm]
+drm_syncobj_query_ioctl [drm]
+_drm_lease_revoke [drm]
+drm_lease_owner [drm]
+_drm_lease_held [drm]
+drm_lease_held [drm]
+drm_lease_filter_crtcs [drm]
+drm_lease_destroy [drm]
+drm_lease_revoke [drm]
+drm_mode_create_lease_ioctl [drm]
+drm_mode_list_lessees_ioctl [drm]
+drm_mode_get_lease_ioctl [drm]
+drm_mode_revoke_lease_ioctl [drm]
+drm_writeback_fence_enable_signaling [drm]
+drm_writeback_fence_get_driver_name [drm]
+drm_writeback_fence_get_timeline_name [drm]
+drm_writeback_prepare_job [drm]
+drm_writeback_queue_job [drm]
+drm_writeback_connector_init [drm]
+drm_writeback_signal_completion [drm]
+drm_writeback_get_out_fence [drm]
+drm_writeback_cleanup_job [drm]
+cleanup_work [drm]
+drm_writeback_set_fb [drm]
+drm_client_framebuffer_flush [drm]
+drm_client_register [drm]
+drm_client_init [drm]
+drm_client_release [drm]
+drm_client_buffer_vmap [drm]
+drm_client_buffer_vunmap [drm]
+drm_client_debugfs_internal_clients [drm]
+drm_client_dev_hotplug [drm]
+drm_client_buffer_delete [drm]
+drm_client_framebuffer_create [drm]
+drm_client_framebuffer_delete [drm]
+drm_client_dev_unregister [drm]
+drm_client_dev_restore [drm]
+drm_client_debugfs_init [drm]
+drm_client_modeset_release [drm]
+drm_client_rotation [drm]
+drm_connector_pick_cmdline_mode [drm]
+drm_connector_enabled [drm]
+drm_client_pick_crtcs [drm]
+drm_client_modeset_probe [drm]
+drm_client_modeset_commit_atomic [drm]
+drm_client_modeset_check [drm]
+drm_client_modeset_commit_locked [drm]
+drm_client_modeset_commit [drm]
+drm_client_modeset_dpms [drm]
+drm_client_modeset_free [drm]
+drm_client_modeset_create [drm]
+drm_atomic_set_mode_for_crtc [drm]
+drm_atomic_set_mode_prop_for_crtc [drm]
+drm_atomic_set_crtc_for_plane [drm]
+drm_atomic_set_fb_for_plane [drm]
+drm_atomic_set_crtc_for_connector [drm]
+drm_atomic_replace_property_blob_from_id [drm]
+setup_out_fence [drm]
+drm_atomic_set_fence_for_plane [drm]
+drm_atomic_get_property [drm]
+drm_atomic_connector_commit_dpms [drm]
+drm_atomic_set_property [drm]
+drm_mode_atomic_ioctl [drm]
+drm_connector_attach_content_protection_property [drm]
+drm_hdcp_update_content_protection [drm]
+drm_hdcp_check_ksvs_revoked [drm]
+drm_get_content_protection_name [drm]
+drm_get_hdcp_content_type_name [drm]
+add_dr [drm]
+__drmm_add_action [drm]
+__drmm_add_action_or_reset [drm]
+drmm_kmalloc [drm]
+drmm_kstrdup [drm]
+drmm_kfree [drm]
+drm_managed_release [drm]
+drmm_add_final_kfree [drm]
+drm_vblank_work_schedule [drm]
+drm_vblank_work_init [drm]
+drm_vblank_work_flush [drm]
+drm_vblank_work_cancel_sync [drm]
+drm_handle_vblank_works [drm]
+drm_vblank_cancel_pending_works [drm]
+drm_vblank_worker_init [drm]
+compat_drm_setunique [drm]
+compat_drm_agp_unbind [drm]
+compat_drm_agp_free [drm]
+compat_drm_agp_enable [drm]
+compat_drm_update_draw [drm]
+compat_drm_agp_bind [drm]
+compat_drm_mode_addfb2 [drm]
+compat_drm_wait_vblank [drm]
+compat_drm_agp_alloc [drm]
+compat_drm_agp_info [drm]
+compat_drm_getclient [drm]
+compat_drm_getunique [drm]
+compat_drm_version [drm]
+compat_drm_getstats [drm]
+drm_compat_ioctl [drm]
+drm_gem_cma_prime_vunmap [drm]
+drm_gem_cma_prime_vmap [drm]
+drm_gem_cma_free_object [drm]
+drm_gem_cma_mmap_obj [drm]
+drm_gem_cma_print_info [drm]
+drm_gem_cma_prime_mmap [drm]
+drm_gem_cma_mmap [drm]
+__drm_gem_cma_create [drm]
+drm_gem_cma_prime_import_sg_table [drm]
+drm_gem_cma_prime_import_sg_table_vmap [drm]
+drm_gem_cma_prime_get_sg_table [drm]
+drm_gem_cma_create_object_default_funcs [drm]
+drm_gem_cma_create [drm]
+drm_gem_cma_create_with_handle [drm]
+drm_gem_cma_dumb_create_internal [drm]
+drm_gem_cma_dumb_create [drm]
+drm_gem_shmem_get_pages [drm]
+drm_gem_shmem_pin [drm]
+drm_gem_shmem_madvise [drm]
+drm_gem_shmem_put_pages_locked [drm]
+drm_gem_shmem_put_pages [drm]
+drm_gem_shmem_free_object [drm]
+drm_gem_shmem_unpin [drm]
+drm_gem_shmem_vunmap [drm]
+drm_gem_shmem_purge_locked [drm]
+drm_gem_shmem_purge [drm]
+drm_gem_shmem_vm_close [drm]
+drm_gem_shmem_fault [drm]
+drm_gem_shmem_vm_open [drm]
+drm_gem_shmem_print_info [drm]
+drm_gem_shmem_get_sg_table [drm]
+drm_gem_shmem_get_pages_sgt [drm]
+drm_gem_shmem_vmap [drm]
+__drm_gem_shmem_create [drm]
+drm_gem_shmem_create [drm]
+drm_gem_shmem_prime_import_sg_table [drm]
+drm_gem_shmem_mmap [drm]
+drm_gem_shmem_create_with_handle [drm]
+drm_gem_shmem_dumb_create [drm]
+drm_gem_shmem_create_object_cached [drm]
+drm_panel_add [drm]
+drm_panel_remove [drm]
+drm_panel_init [drm]
+drm_panel_prepare [drm]
+drm_panel_unprepare [drm]
+drm_panel_get_modes [drm]
+drm_panel_enable [drm]
+drm_panel_of_backlight [drm]
+drm_panel_disable [drm]
+drm_agp_info [drm]
+drm_agp_acquire [drm]
+drm_agp_release [drm]
+drm_agp_enable [drm]
+drm_agp_unbind [drm]
+drm_agp_bind [drm]
+drm_agp_free [drm]
+drm_agp_alloc [drm]
+drm_agp_init [drm]
+drm_agp_info_ioctl [drm]
+drm_agp_acquire_ioctl [drm]
+drm_agp_release_ioctl [drm]
+drm_agp_enable_ioctl [drm]
+drm_agp_alloc_ioctl [drm]
+drm_agp_unbind_ioctl [drm]
+drm_agp_bind_ioctl [drm]
+drm_agp_free_ioctl [drm]
+drm_legacy_agp_clear [drm]
+drm_pci_set_busid [drm]
+drm_irq_by_busid [drm]
+drm_pci_agp_destroy [drm]
+drm_debugfs_create_files [drm]
+drm_debugfs_open [drm]
+vrr_range_open [drm]
+edid_open [drm]
+connector_open [drm]
+drm_gem_one_name_info [drm]
+drm_name_info [drm]
+vrr_range_show [drm]
+drm_gem_name_info [drm]
+drm_debugfs_remove_files [drm]
+edid_write [drm]
+connector_show [drm]
+connector_write [drm]
+drm_clients_info [drm]
+edid_show [drm]
+drm_debugfs_init [drm]
+drm_debugfs_cleanup [drm]
+drm_debugfs_connector_add [drm]
+drm_debugfs_connector_remove [drm]
+drm_debugfs_crtc_add [drm]
+drm_debugfs_crtc_remove [drm]
+crc_control_open [drm]
+crc_control_show [drm]
+drm_crtc_add_crc_entry [drm]
+crtc_crc_data_count.part.0 [drm]
+crtc_crc_release [drm]
+crtc_crc_poll [drm]
+crtc_crc_open [drm]
+crc_control_write [drm]
+crtc_crc_read [drm]
+drm_debugfs_crtc_crc_add [drm]
+__drm_set_edid_firmware_path [drm]
+__drm_get_edid_firmware_path [drm]
+edid_load [drm]
+drm_load_edid_firmware [drm]
+dead_write_lines [parport]
+dead_read_lines [parport]
+dead_frob_lines [parport]
+dead_onearg [parport]
+dead_initstate [parport]
+dead_write [parport]
+parport_unregister_driver [parport]
+parport_get_port [parport]
+parport_del_port [parport]
+parport_put_port [parport]
+port_detect [parport]
+driver_check [parport]
+driver_detach [parport]
+parport_probe [parport]
+free_pardevice [parport]
+attach_driver_chain [parport]
+detach_driver_chain [parport]
+parport_claim [parport]
+parport_claim_or_block [parport]
+parport_release [parport]
+parport_irq_handler [parport]
+port_check [parport]
+port_detach [parport]
+__parport_register_driver [parport]
+dead_read [parport]
+dead_state [parport]
+parport_announce_port [parport]
+parport_find_number [parport]
+parport_find_base [parport]
+free_port [parport]
+parport_remove_port [parport]
+parport_unregister_device [parport]
+parport_register_port [parport]
+parport_register_dev_model [parport]
+parport_bus_init [parport]
+parport_bus_exit [parport]
+parport_wait_event [parport]
+timeout_waiting_on_port [parport]
+parport_set_timeout [parport]
+parport_ieee1284_interrupt [parport]
+parport_poll_peripheral [parport]
+parport_wait_peripheral [parport]
+parport_ieee1284_terminate [parport]
+parport_negotiate [parport]
+parport_write [parport]
+parport_read [parport]
+parport_ieee1284_read_nibble [parport]
+parport_ieee1284_read_byte [parport]
+parport_ieee1284_write_compat [parport]
+parport_ieee1284_ecp_read_data [parport]
+parport_ieee1284_epp_write_data [parport]
+parport_ieee1284_epp_read_data [parport]
+parport_ieee1284_epp_write_addr [parport]
+parport_ieee1284_epp_read_addr [parport]
+parport_ieee1284_ecp_write_addr [parport]
+parport_ieee1284_ecp_write_data [parport]
+do_active_device [parport]
+do_autoprobe [parport]
+do_hardware_modes [parport]
+do_hardware_dma [parport]
+do_hardware_irq [parport]
+do_hardware_base_addr [parport]
+parport_proc_register [parport]
+parport_proc_unregister [parport]
+parport_device_proc_register [parport]
+parport_device_proc_unregister [parport]
+daisy_drv_probe [parport]
+cpp_mux [parport]
+cpp_daisy [parport]
+add_dev [parport]
+parport_daisy_fini [parport]
+parport_daisy_init [parport]
+parport_open [parport]
+parport_close [parport]
+parport_daisy_deselect_all [parport]
+parport_daisy_select [parport]
+parport_device_id [parport]
+lp_preempt [lp]
+lp_claim_parport_or_block [lp]
+lp_release_parport [lp]
+lp_reset [lp]
+lp_detach [lp]
+lp_release [lp]
+lp_open [lp]
+lp_set_timeout64 [lp]
+lp_do_ioctl [lp]
+lp_compat_ioctl [lp]
+lp_ioctl [lp]
+lp_register [lp]
+lp_attach [lp]
+lp_error [lp]
+lp_wait_ready [lp]
+lp_write [lp]
+lp_read [lp]
+lp_cleanup_module [lp]
+pp_poll [ppdev]
+pp_probe [ppdev]
+pp_detach [ppdev]
+pp_attach [ppdev]
+pp_release [ppdev]
+pp_open [ppdev]
+pp_irq [ppdev]
+register_device [ppdev]
+pp_set_timeout [ppdev]
+pp_ioctl [ppdev]
+pp_write [ppdev]
+pp_read [ppdev]
+parport_pc_platform_probe [parport_pc]
+parport_pc_init_state [parport_pc]
+parport_pc_save_state [parport_pc]
+parport_PS2_supported [parport_pc]
+parport_EPP_supported [parport_pc]
+frob_econtrol [parport_pc]
+change_mode [parport_pc]
+parport_pc_epp_write_data [parport_pc]
+parport_pc_restore_state [parport_pc]
+parport_irq_probe.constprop.0 [parport_pc]
+parport_pc_fifo_write_block_dma [parport_pc]
+parport_pc_probe_port [parport_pc]
+parport_pc_pci_probe [parport_pc]
+parport_pc_pnp_probe [parport_pc]
+sio_ite_8872_probe [parport_pc]
+parport_pc_unregister_port [parport_pc]
+parport_pc_pci_remove [parport_pc]
+parport_pc_pnp_remove [parport_pc]
+parport_pc_fifo_write_block_pio [parport_pc]
+parport_pc_epp_write_addr [parport_pc]
+parport_pc_epp_read_addr [parport_pc]
+parport_pc_epp_read_data [parport_pc]
+parport_pc_ecpepp_write_data [parport_pc]
+parport_pc_ecpepp_write_addr [parport_pc]
+parport_pc_ecpepp_read_addr [parport_pc]
+parport_pc_ecpepp_read_data [parport_pc]
+parport_pc_compat_write_block_pio [parport_pc]
+parport_pc_ecp_write_block_pio [parport_pc]
+sio_via_probe [parport_pc]
+msr_device_destroy [msr]
+msr_device_create [msr]
+msr_open [msr]
+msr_devnode [msr]
+msr_ioctl [msr]
+msr_write [msr]
+msr_read [msr]
+get_allow_writes [msr]
+set_allow_writes [msr]
+fq_codel_leaf [sch_fq_codel]
+fq_codel_find [sch_fq_codel]
+fq_codel_bind [sch_fq_codel]
+fq_codel_unbind [sch_fq_codel]
+fq_codel_tcf_block [sch_fq_codel]
+fq_codel_dump_class [sch_fq_codel]
+fq_codel_walk [sch_fq_codel]
+fq_codel_destroy [sch_fq_codel]
+dequeue_func [sch_fq_codel]
+codel_get_enqueue_time [sch_fq_codel]
+codel_vars_init [sch_fq_codel]
+fq_codel_reset [sch_fq_codel]
+drop_func [sch_fq_codel]
+fq_codel_enqueue [sch_fq_codel]
+fq_codel_dump [sch_fq_codel]
+codel_should_drop.isra.0.constprop.0 [sch_fq_codel]
+fq_codel_dump_stats [sch_fq_codel]
+fq_codel_dump_class_stats [sch_fq_codel]
+fq_codel_dequeue [sch_fq_codel]
+fq_codel_change [sch_fq_codel]
+fq_codel_init [sch_fq_codel]
+mac_hid_emumouse_disconnect [mac_hid]
+mac_hid_stop_emulation [mac_hid]
+mac_hid_toggle_emumouse [mac_hid]
+mac_hid_emumouse_filter [mac_hid]
+mac_hid_emumouse_connect [mac_hid]
+acpi_pad_idle_cpus [acpi_pad]
+acpi_pad_notify [acpi_pad]
+acpi_pad_remove_sysfs [acpi_pad]
+acpi_pad_remove [acpi_pad]
+acpi_pad_rrtime_store [acpi_pad]
+acpi_pad_idlepct_store [acpi_pad]
+acpi_pad_idlecpus_store [acpi_pad]
+acpi_pad_rrtime_show [acpi_pad]
+acpi_pad_idlepct_show [acpi_pad]
+acpi_pad_idlecpus_show [acpi_pad]
+acpi_pad_add [acpi_pad]
+power_saving_thread [acpi_pad]
+caps_show [acpi_tad]
+acpi_tad_status_read [acpi_tad]
+ac_status_show [acpi_tad]
+dc_status_show [acpi_tad]
+acpi_tad_wake_set [acpi_tad]
+acpi_tad_wake_write [acpi_tad]
+ac_policy_store [acpi_tad]
+dc_policy_store [acpi_tad]
+ac_alarm_store [acpi_tad]
+dc_alarm_store [acpi_tad]
+acpi_tad_wake_read [acpi_tad]
+ac_policy_show [acpi_tad]
+dc_policy_show [acpi_tad]
+ac_alarm_show [acpi_tad]
+dc_alarm_show [acpi_tad]
+acpi_tad_clear_status [acpi_tad]
+acpi_tad_status_write [acpi_tad]
+ac_status_store [acpi_tad]
+dc_status_store [acpi_tad]
+acpi_tad_remove [acpi_tad]
+acpi_tad_rt_next_field [acpi_tad]
+time_store [acpi_tad]
+time_show [acpi_tad]
+acpi_tad_probe [acpi_tad]
+__glue_xts_req_128bit [glue_helper]
+glue_cbc_encrypt_req_128bit [glue_helper]
+glue_xts_crypt_128bit_one [glue_helper]
+glue_ctr_req_128bit [glue_helper]
+glue_xts_req_128bit [glue_helper]
+glue_ecb_req_128bit [glue_helper]
+glue_cbc_decrypt_req_128bit [glue_helper]
+ee1004_remove [ee1004]
+ee1004_read [ee1004]
+ee1004_probe [ee1004]
+sound_devnode [soundcore]
+sound_remove_unit [soundcore]
+unregister_sound_special [soundcore]
+unregister_sound_mixer [soundcore]
+unregister_sound_dsp [soundcore]
+soundcore_open [soundcore]
+sound_insert_unit.constprop.0 [soundcore]
+register_sound_dsp [soundcore]
+register_sound_mixer [soundcore]
+register_sound_special_device [soundcore]
+register_sound_special [soundcore]
+wmi_bmof_remove [wmi_bmof]
+read_bmof [wmi_bmof]
+wmi_bmof_probe [wmi_bmof]
+sparse_keymap_entry_from_scancode [sparse_keymap]
+sparse_keymap_entry_from_keycode [sparse_keymap]
+sparse_keymap_setup [sparse_keymap]
+sparse_keymap_locate [sparse_keymap]
+sparse_keymap_setkeycode [sparse_keymap]
+sparse_keymap_getkeycode [sparse_keymap]
+sparse_keymap_report_entry.part.0 [sparse_keymap]
+sparse_keymap_report_entry [sparse_keymap]
+sparse_keymap_report_event [sparse_keymap]
+cryptd_shash_desc [cryptd]
+cryptd_skcipher_queued [cryptd]
+cryptd_ahash_queued [cryptd]
+cryptd_aead_queued [cryptd]
+cryptd_hash_export [cryptd]
+cryptd_skcipher_child [cryptd]
+cryptd_ahash_child [cryptd]
+cryptd_hash_import [cryptd]
+cryptd_aead_child [cryptd]
+cryptd_alloc_skcipher [cryptd]
+cryptd_skcipher_exit_tfm [cryptd]
+cryptd_aead_exit_tfm [cryptd]
+cryptd_hash_exit_tfm [cryptd]
+cryptd_alloc_ahash [cryptd]
+cryptd_alloc_aead [cryptd]
+cryptd_skcipher_setkey [cryptd]
+cryptd_skcipher_init_tfm [cryptd]
+cryptd_hash_init_tfm [cryptd]
+cryptd_aead_init_tfm [cryptd]
+cryptd_init_instance [cryptd]
+cryptd_skcipher_free [cryptd]
+cryptd_hash_free [cryptd]
+cryptd_aead_free [cryptd]
+cryptd_hash_setkey [cryptd]
+cryptd_aead_setauthsize [cryptd]
+cryptd_aead_setkey [cryptd]
+cryptd_queue_worker [cryptd]
+cryptd_aead_crypt [cryptd]
+cryptd_aead_decrypt [cryptd]
+cryptd_aead_encrypt [cryptd]
+cryptd_enqueue_request [cryptd]
+cryptd_skcipher_decrypt_enqueue [cryptd]
+cryptd_skcipher_encrypt_enqueue [cryptd]
+cryptd_hash_digest_enqueue [cryptd]
+cryptd_hash_finup_enqueue [cryptd]
+cryptd_hash_final_enqueue [cryptd]
+cryptd_hash_update_enqueue [cryptd]
+cryptd_hash_init_enqueue [cryptd]
+cryptd_aead_decrypt_enqueue [cryptd]
+cryptd_aead_encrypt_enqueue [cryptd]
+cryptd_create [cryptd]
+cryptd_free_skcipher [cryptd]
+cryptd_free_ahash [cryptd]
+cryptd_free_aead [cryptd]
+cryptd_skcipher_complete [cryptd]
+cryptd_skcipher_decrypt [cryptd]
+cryptd_skcipher_encrypt [cryptd]
+cryptd_hash_complete [cryptd]
+cryptd_hash_init [cryptd]
+cryptd_hash_digest [cryptd]
+cryptd_hash_finup [cryptd]
+cryptd_hash_final [cryptd]
+cryptd_hash_update [cryptd]
+cryptd_fini_queue.constprop.0 [cryptd]
+fan1_label_show [asus_wmi]
+charge_control_end_threshold_show [asus_wmi]
+asus_wmi_get_event_code [asus_wmi]
+throttle_thermal_policy_show [asus_wmi]
+fan_boost_mode_show [asus_wmi]
+pwm1_enable_show [asus_wmi]
+lightbar_led_set [asus_wmi]
+wlan_led_set [asus_wmi]
+tpd_led_set [asus_wmi]
+ashs_present [asus_wmi]
+asus_register_rfkill_notifier [asus_wmi]
+asus_wmi_battery_remove [asus_wmi]
+asus_wmi_debugfs_open [asus_wmi]
+show_call [asus_wmi]
+asus_wmi_led_exit [asus_wmi]
+asus_wmi_unregister_driver [asus_wmi]
+asus_wmi_register_driver [asus_wmi]
+asus_rfkill_notify [asus_wmi]
+asus_unregister_rfkill_notifier.isra.0 [asus_wmi]
+asus_wmi_evaluate_method3.constprop.0 [asus_wmi]
+asus_wmi_fnlock_update [asus_wmi]
+show_devs [asus_wmi]
+show_dsts [asus_wmi]
+asus_wmi_battery_add [asus_wmi]
+charge_control_end_threshold_store [asus_wmi]
+pwm1_show [asus_wmi]
+throttle_thermal_policy_write [asus_wmi]
+throttle_thermal_policy_store [asus_wmi]
+fan_boost_mode_write [asus_wmi]
+fan_boost_mode_store [asus_wmi]
+asus_rfkill_set [asus_wmi]
+asus_rfkill_wlan_set [asus_wmi]
+tpd_led_update [asus_wmi]
+wlan_led_update [asus_wmi]
+lightbar_led_update [asus_wmi]
+do_kbd_led_set [asus_wmi]
+kbd_led_set [asus_wmi]
+asus_hwmon_sysfs_is_visible [asus_wmi]
+asus_hwmon_temp1 [asus_wmi]
+asus_wmi_has_fnlock_key [asus_wmi]
+asus_hotk_resume [asus_wmi]
+read_brightness [asus_wmi]
+wlan_led_get [asus_wmi]
+lightbar_led_get [asus_wmi]
+asus_wmi_dev_is_present [asus_wmi]
+asus_wmi_get_devstate_bits [asus_wmi]
+tpd_led_get [asus_wmi]
+store_sys_wmi [asus_wmi]
+store_als_enable [asus_wmi]
+store_lid_resume [asus_wmi]
+store_touchpad [asus_wmi]
+store_cardr [asus_wmi]
+store_camera [asus_wmi]
+show_sys_wmi [asus_wmi]
+show_als_enable [asus_wmi]
+show_lid_resume [asus_wmi]
+show_touchpad [asus_wmi]
+show_cardr [asus_wmi]
+show_camera [asus_wmi]
+asus_get_adapter_status [asus_wmi]
+kbd_led_get [asus_wmi]
+asus_hotk_thaw [asus_wmi]
+asus_rfkill_query [asus_wmi]
+asus_rfkill_hotplug [asus_wmi]
+asus_hotplug_work [asus_wmi]
+asus_wmi_rfkill_exit [asus_wmi]
+asus_sysfs_is_visible [asus_wmi]
+read_backlight_power [asus_wmi]
+update_bl_status [asus_wmi]
+asus_hotk_restore [asus_wmi]
+asus_wmi_notify [asus_wmi]
+asus_new_rfkill [asus_wmi]
+cpufv_store [asus_wmi]
+asus_wmi_evaluate_method_agfn [asus_wmi]
+asus_agfn_fan_speed_read.isra.0.constprop.0 [asus_wmi]
+fan1_input_show [asus_wmi]
+asus_wmi_evaluate_method [asus_wmi]
+asus_fan_set_auto [asus_wmi]
+pwm1_enable_store [asus_wmi]
+asus_wmi_remove [asus_wmi]
+pwm1_store [asus_wmi]
+asus_wmi_probe [asus_wmi]
+simd_skcipher_free [crypto_simd]
+simd_aead_free [crypto_simd]
+simd_skcipher_decrypt [crypto_simd]
+simd_skcipher_encrypt [crypto_simd]
+simd_skcipher_setkey [crypto_simd]
+simd_skcipher_exit [crypto_simd]
+simd_skcipher_init [crypto_simd]
+simd_unregister_skciphers [crypto_simd]
+simd_aead_decrypt [crypto_simd]
+simd_aead_encrypt [crypto_simd]
+simd_aead_setauthsize [crypto_simd]
+simd_aead_setkey [crypto_simd]
+simd_aead_exit [crypto_simd]
+simd_aead_init [crypto_simd]
+simd_unregister_aeads [crypto_simd]
+simd_skcipher_create_compat [crypto_simd]
+simd_skcipher_create [crypto_simd]
+simd_register_skciphers_compat [crypto_simd]
+simd_aead_create_compat [crypto_simd]
+simd_aead_create [crypto_simd]
+simd_register_aeads_compat [crypto_simd]
+eeepc_wmi_key_filter [eeepc_wmi]
+dmi_matched [eeepc_wmi]
+eeepc_wmi_quirks [eeepc_wmi]
+eeepc_wmi_probe [eeepc_wmi]
+common_rfc4106_set_authsize [aesni_intel]
+generic_gcmaes_set_authsize [aesni_intel]
+xts_decrypt [aesni_intel]
+xts_encrypt [aesni_intel]
+aesni_encrypt [aesni_intel]
+aesni_xts_dec [aesni_intel]
+aesni_xts_enc [aesni_intel]
+aesni_xts_dec8 [aesni_intel]
+aesni_xts_enc8 [aesni_intel]
+ctr_crypt [aesni_intel]
+cbc_decrypt [aesni_intel]
+cbc_encrypt [aesni_intel]
+ecb_decrypt [aesni_intel]
+ecb_encrypt [aesni_intel]
+aesni_decrypt [aesni_intel]
+aesni_ctr_enc_avx_tfm [aesni_intel]
+aes_set_key_common.isra.0 [aesni_intel]
+aesni_skcipher_setkey [aesni_intel]
+aes_set_key [aesni_intel]
+xts_aesni_setkey [aesni_intel]
+rfc4106_set_hash_subkey [aesni_intel]
+generic_gcmaes_set_key [aesni_intel]
+common_rfc4106_set_key [aesni_intel]
+gcmaes_crypt_by_sg.constprop.0 [aesni_intel]
+helper_rfc4106_encrypt [aesni_intel]
+generic_gcmaes_encrypt [aesni_intel]
+helper_rfc4106_decrypt [aesni_intel]
+generic_gcmaes_decrypt [aesni_intel]
+snd_lookup_minor_data [snd]
+snd_unregister_device [snd]
+snd_minor_info_read [snd]
+snd_register_device [snd]
+snd_request_card [snd]
+snd_open [snd]
+default_release [snd]
+snd_disconnect_llseek [snd]
+snd_disconnect_read [snd]
+snd_disconnect_poll [snd]
+snd_disconnect_ioctl [snd]
+snd_disconnect_mmap [snd]
+snd_disconnect_fasync [snd]
+card_id_show_attr [snd]
+module_slot_match [snd]
+check_empty_slot [snd]
+snd_device_initialize [snd]
+snd_card_add_dev_attr [snd]
+card_number_show_attr [snd]
+get_slot_from_bitmask [snd]
+release_card_device [snd]
+snd_card_ref [snd]
+snd_card_module_info_read [snd]
+snd_component_add [snd]
+snd_power_wait [snd]
+card_id_ok.part.0 [snd]
+card_id_store_attr [snd]
+snd_card_info_read [snd]
+snd_disconnect_write [snd]
+snd_card_new [snd]
+snd_card_set_id_no_lock [snd]
+snd_card_set_id [snd]
+snd_card_register [snd]
+snd_card_file_add [snd]
+snd_disconnect_release [snd]
+snd_card_file_remove [snd]
+snd_card_disconnect [snd]
+snd_card_free_when_closed [snd]
+snd_card_free [snd]
+snd_card_disconnect_sync [snd]
+snd_card_locked [snd]
+snd_card_info_read_oss [snd]
+copy_from_user_toio [snd]
+copy_to_user_fromio [snd]
+snd_ctl_poll [snd]
+snd_ctl_get_preferred_subdevice [snd]
+snd_ctl_boolean_mono_info [snd]
+snd_ctl_boolean_stereo_info [snd]
+snd_ctl_find_numid [snd]
+snd_ctl_free_one [snd]
+snd_ctl_empty_read_queue [snd]
+_snd_ctl_unregister_ioctl [snd]
+snd_ctl_unregister_ioctl [snd]
+snd_ctl_unregister_ioctl_compat [snd]
+snd_ctl_dev_disconnect [snd]
+snd_ctl_dev_register [snd]
+snd_ctl_fasync [snd]
+snd_ctl_release [snd]
+snd_ctl_elem_list [snd]
+snd_ctl_elem_user_free [snd]
+snd_ctl_new [snd]
+snd_ctl_new1 [snd]
+snd_ctl_find_id [snd]
+snd_ctl_rename_id [snd]
+snd_ctl_enum_info [snd]
+_snd_ctl_register_ioctl [snd]
+snd_ctl_register_ioctl [snd]
+snd_ctl_register_ioctl_compat [snd]
+snd_ctl_notify.part.0 [snd]
+snd_ctl_notify [snd]
+snd_ctl_remove [snd]
+snd_ctl_remove_id [snd]
+snd_ctl_remove_user_ctl [snd]
+snd_ctl_dev_free [snd]
+__snd_ctl_add_replace [snd]
+snd_ctl_add_replace [snd]
+snd_ctl_add [snd]
+snd_ctl_replace [snd]
+snd_ctl_open [snd]
+snd_ctl_elem_user_get [snd]
+snd_ctl_elem_user_info [snd]
+snd_ctl_elem_read [snd]
+snd_ctl_elem_user_put [snd]
+snd_ctl_activate_id [snd]
+snd_ctl_elem_info [snd]
+snd_ctl_elem_info_user [snd]
+snd_ctl_elem_write [snd]
+copy_ctl_value_from_user [snd]
+snd_ctl_read [snd]
+snd_ctl_elem_user_enum_info [snd]
+snd_ctl_elem_user_tlv [snd]
+copy_ctl_value_to_user.isra.0 [snd]
+ctl_elem_read_user [snd]
+ctl_elem_write_user [snd]
+snd_ctl_tlv_ioctl [snd]
+snd_ctl_elem_add [snd]
+snd_ctl_elem_add_compat [snd]
+snd_ctl_elem_add_user [snd]
+snd_ctl_ioctl [snd]
+snd_ctl_create [snd]
+snd_pci_quirk_lookup_id [snd]
+snd_pci_quirk_lookup [snd]
+release_and_free_resource [snd]
+snd_device_register [snd]
+snd_device_get_state [snd]
+__snd_device_disconnect [snd]
+__snd_device_free [snd]
+snd_device_disconnect [snd]
+snd_device_free [snd]
+snd_device_new [snd]
+snd_device_register_all [snd]
+snd_device_disconnect_all [snd]
+snd_device_free_all [snd]
+snd_info_entry_read [snd]
+snd_info_entry_write [snd]
+snd_info_entry_poll [snd]
+snd_info_entry_ioctl [snd]
+snd_info_entry_mmap [snd]
+snd_info_seq_show [snd]
+snd_info_get_str [snd]
+snd_info_entry_llseek [snd]
+snd_info_get_line [snd]
+snd_info_version_read [snd]
+snd_card_id_read [snd]
+snd_info_disconnect [snd]
+snd_info_free_entry [snd]
+snd_info_register [snd]
+snd_info_text_entry_release [snd]
+snd_info_entry_release [snd]
+alloc_info_private [snd]
+snd_info_entry_open [snd]
+snd_info_text_entry_write [snd]
+snd_info_create_entry [snd]
+snd_info_create_module_entry [snd]
+snd_info_create_card_entry [snd]
+snd_card_rw_proc_new [snd]
+create_subdir [snd]
+snd_info_text_entry_open [snd]
+snd_info_check_reserved_words [snd]
+snd_info_card_create [snd]
+snd_info_card_register [snd]
+snd_info_card_id_change [snd]
+snd_info_card_disconnect [snd]
+snd_info_card_free [snd]
+snd_oss_info_register [snd]
+snd_sndstat_show_strings [snd]
+snd_sndstat_proc_read [snd]
+snd_dma_program [snd]
+snd_dma_disable [snd]
+snd_dma_pointer [snd]
+snd_lookup_oss_minor_data [snd]
+snd_oss_kernel_minor [snd]
+snd_register_oss_device [snd]
+snd_unregister_oss_device [snd]
+snd_minor_info_oss_read [snd]
+follower_info [snd]
+follower_tlv_cmd [snd]
+snd_ctl_add_vmaster_hook [snd]
+follower_free [snd]
+master_free [snd]
+_snd_ctl_add_follower [snd]
+snd_ctl_make_virtual_master [snd]
+follower_update [snd]
+follower_init [snd]
+master_init [snd]
+follower_put_val [snd]
+master_get [snd]
+master_info [snd]
+snd_ctl_apply_vmaster_followers [snd]
+follower_put [snd]
+follower_get [snd]
+sync_followers [snd]
+master_put [snd]
+snd_ctl_sync_vmaster [snd]
+jack_detect_kctl_get [snd]
+snd_kctl_jack_new [snd]
+snd_kctl_jack_report [snd]
+snd_jack_kctl_private_free [snd]
+snd_jack_set_parent [snd]
+snd_jack_set_key [snd]
+snd_jack_dev_disconnect [snd]
+snd_jack_dev_register [snd]
+snd_jack_dev_free [snd]
+snd_jack_report [snd]
+snd_jack_kctl_new [snd]
+snd_jack_add_new_kctl [snd]
+snd_jack_new [snd]
+ghash_async_exit_tfm [ghash_clmulni_intel]
+ghash_async_init_tfm [ghash_clmulni_intel]
+ghash_async_setkey [ghash_clmulni_intel]
+ghash_async_export [ghash_clmulni_intel]
+ghash_async_init [ghash_clmulni_intel]
+ghash_async_import [ghash_clmulni_intel]
+ghash_async_digest [ghash_clmulni_intel]
+ghash_async_final [ghash_clmulni_intel]
+ghash_async_update [ghash_clmulni_intel]
+ghash_setkey [ghash_clmulni_intel]
+ghash_final [ghash_clmulni_intel]
+ghash_update [ghash_clmulni_intel]
+ghash_init [ghash_clmulni_intel]
+chksum_init [crct10dif_pclmul]
+chksum_final [crct10dif_pclmul]
+chksum_update [crct10dif_pclmul]
+__chksum_finup [crct10dif_pclmul]
+chksum_digest [crct10dif_pclmul]
+chksum_finup [crct10dif_pclmul]
+snd_timer_find [snd_timer]
+snd_timer_resolution [snd_timer]
+snd_timer_reschedule [snd_timer]
+snd_timer_clear_callbacks [snd_timer]
+snd_timer_free_system [snd_timer]
+snd_timer_dev_disconnect [snd_timer]
+snd_timer_dev_register [snd_timer]
+timer_set_gparams [snd_timer]
+snd_timer_notify1 [snd_timer]
+snd_timer_start1 [snd_timer]
+snd_timer_stop1 [snd_timer]
+snd_timer_global_register [snd_timer]
+snd_timer_user_fasync [snd_timer]
+snd_timer_user_info_compat [snd_timer]
+snd_timer_user_disconnect [snd_timer]
+snd_timer_user_append_to_tqueue [snd_timer]
+snd_timer_user_ccallback [snd_timer]
+snd_timer_s_stop [snd_timer]
+snd_timer_s_start [snd_timer]
+snd_timer_s_close [snd_timer]
+snd_timer_proc_read [snd_timer]
+snd_timer_instance_free [snd_timer]
+snd_timer_notify [snd_timer]
+snd_timer_free.part.0 [snd_timer]
+snd_timer_dev_free [snd_timer]
+snd_timer_global_free [snd_timer]
+snd_timer_new [snd_timer]
+snd_timer_global_new [snd_timer]
+snd_timer_instance_new [snd_timer]
+snd_timer_process_callbacks [snd_timer]
+snd_timer_work [snd_timer]
+snd_timer_interrupt [snd_timer]
+snd_timer_s_function [snd_timer]
+snd_timer_user_interrupt [snd_timer]
+snd_timer_stop_slave [snd_timer]
+snd_timer_stop [snd_timer]
+snd_timer_pause [snd_timer]
+snd_timer_start_slave [snd_timer]
+snd_timer_start [snd_timer]
+snd_timer_user_start [snd_timer]
+snd_timer_continue [snd_timer]
+snd_timer_user_tinterrupt [snd_timer]
+snd_timer_user_poll [snd_timer]
+snd_timer_user_status32 [snd_timer]
+snd_timer_user_status64 [snd_timer]
+check_matching_master_slave.part.0 [snd_timer]
+snd_timer_close_locked [snd_timer]
+snd_timer_close [snd_timer]
+snd_timer_user_release [snd_timer]
+snd_timer_open [snd_timer]
+snd_timer_user_read [snd_timer]
+realloc_user_queue [snd_timer]
+snd_timer_user_open [snd_timer]
+snd_timer_user_params [snd_timer]
+__snd_timer_user_ioctl [snd_timer]
+snd_timer_user_ioctl_compat [snd_timer]
+snd_timer_user_ioctl [snd_timer]
+snd_timer_free_all [snd_timer]
+snd_seq_autoload_exit [snd_seq_device]
+autoload_drivers [snd_seq_device]
+snd_seq_device_info [snd_seq_device]
+snd_seq_autoload_init [snd_seq_device]
+snd_seq_device_load_drivers [snd_seq_device]
+snd_seq_driver_unregister [snd_seq_device]
+snd_seq_bus_match [snd_seq_device]
+snd_seq_dev_release [snd_seq_device]
+snd_seq_device_dev_disconnect [snd_seq_device]
+snd_seq_device_dev_free [snd_seq_device]
+__snd_seq_driver_register [snd_seq_device]
+print_dev_info [snd_seq_device]
+request_seq_drv [snd_seq_device]
+snd_seq_device_dev_register [snd_seq_device]
+snd_seq_device_new [snd_seq_device]
+ack_flush [kvm]
+kvm_get_running_vcpu [kvm]
+__traceiter_kvm_userspace_exit [kvm]
+__traceiter_kvm_vcpu_wakeup [kvm]
+__traceiter_kvm_set_irq [kvm]
+__traceiter_kvm_ioapic_set_irq [kvm]
+__traceiter_kvm_ioapic_delayed_eoi_inj [kvm]
+__traceiter_kvm_msi_set_irq [kvm]
+__traceiter_kvm_ack_irq [kvm]
+__traceiter_kvm_mmio [kvm]
+__traceiter_kvm_fpu [kvm]
+__traceiter_kvm_age_page [kvm]
+__traceiter_kvm_try_async_get_page [kvm]
+__traceiter_kvm_async_pf_doublefault [kvm]
+__traceiter_kvm_async_pf_not_present [kvm]
+__traceiter_kvm_async_pf_ready [kvm]
+__traceiter_kvm_async_pf_completed [kvm]
+__traceiter_kvm_halt_poll_ns [kvm]
+kvm_vcpu_mmap [kvm]
+kvm_device_mmap [kvm]
+kvm_io_bus_sort_cmp [kvm]
+kvm_stat_data_get [kvm]
+kvm_stat_data_clear [kvm]
+vcpu_load [kvm]
+kvm_sched_out [kvm]
+vcpu_put [kvm]
+kvm_vcpu_destroy [kvm]
+vcpu_stat_clear [kvm]
+vcpu_stat_get [kvm]
+vm_stat_clear [kvm]
+vm_stat_get [kvm]
+kvm_device_ioctl_attr [kvm]
+kvm_device_ioctl [kvm]
+kvm_vcpu_fault [kvm]
+vcpu_stat_fops_open [kvm]
+vm_stat_fops_open [kvm]
+kvm_vm_ioctl_check_extension_generic [kvm]
+install_new_memslots [kvm]
+kvm_set_memslot [kvm]
+kvm_delete_memslot [kvm]
+__kvm_set_memory_region [kvm]
+kvm_set_memory_region [kvm]
+kvm_io_bus_get_first_dev [kvm]
+__kvm_io_bus_write [kvm]
+kvm_io_bus_write [kvm]
+kvm_sched_in [kvm]
+check_processor_compat [kvm]
+kvm_init [kvm]
+kvm_exit [kvm]
+kvm_vm_worker_thread [kvm]
+__gfn_to_hva_many [kvm]
+gfn_to_hva_memslot [kvm]
+gfn_to_page_many_atomic [kvm]
+hardware_disable_all_nolock [kvm]
+kvm_vcpu_wake_up [kvm]
+kvm_vcpu_kick [kvm]
+kvm_free_memslots [kvm]
+kvm_uevent_notify_change.part.0 [kvm]
+kvm_vcpu_ioctl [kvm]
+kvm_vcpu_compat_ioctl [kvm]
+hardware_disable_nolock [kvm]
+kvm_suspend [kvm]
+kvm_get_kvm [kvm]
+kvm_put_kvm_no_destroy [kvm]
+kvm_vcpu_yield_to [kvm]
+kvm_mmu_notifier_release [kvm]
+kvm_io_bus_get_dev [kvm]
+mark_page_dirty_in_slot [kvm]
+kvm_dying_cpu [kvm]
+kvm_mmu_notifier_test_young [kvm]
+kvm_mmu_notifier_clear_young [kvm]
+kvm_mmu_notifier_invalidate_range_end [kvm]
+hardware_enable_nolock [kvm]
+kvm_resume [kvm]
+kvm_starting_cpu [kvm]
+__kvm_write_guest_page [kvm]
+__kvm_gfn_to_hva_cache_init [kvm]
+kvm_gfn_to_hva_cache_init [kvm]
+kvm_vcpu_check_block [kvm]
+kvm_vcpu_block [kvm]
+gfn_to_memslot [kvm]
+kvm_vcpu_gfn_to_memslot [kvm]
+kvm_vcpu_is_visible_gfn [kvm]
+kvm_vcpu_gfn_to_hva [kvm]
+kvm_vcpu_write_guest_page [kvm]
+kvm_vcpu_write_guest [kvm]
+kvm_vcpu_mark_page_dirty [kvm]
+kvm_get_dirty_log_protect [kvm]
+gfn_to_hva [kvm]
+kvm_write_guest_page [kvm]
+kvm_write_guest [kvm]
+kvm_write_guest_offset_cached [kvm]
+kvm_write_guest_cached [kvm]
+kvm_clear_guest_page [kvm]
+kvm_clear_guest [kvm]
+kvm_is_visible_gfn [kvm]
+mark_page_dirty [kvm]
+mark_page_dirty [kvm]
+kvm_mmu_notifier_invalidate_range [kvm]
+kvm_is_zone_device_pfn [kvm]
+kvm_is_reserved_pfn [kvm]
+kvm_pfn_to_page [kvm]
+kvm_release_pfn_clean [kvm]
+kvm_release_page_clean [kvm]
+kvm_set_pfn_dirty [kvm]
+kvm_release_pfn_dirty [kvm]
+kvm_release_page_dirty [kvm]
+__kvm_unmap_gfn [kvm]
+kvm_unmap_gfn [kvm]
+kvm_vcpu_unmap [kvm]
+kvm_set_pfn_accessed [kvm]
+kvm_get_pfn [kvm]
+__gfn_to_pfn_memslot [kvm]
+gfn_to_pfn_prot [kvm]
+gfn_to_pfn_memslot [kvm]
+gfn_to_pfn [kvm]
+gfn_to_page [kvm]
+kvm_vcpu_gfn_to_pfn [kvm]
+kvm_vcpu_gfn_to_page [kvm]
+gfn_to_pfn_memslot_atomic [kvm]
+kvm_vcpu_gfn_to_pfn_atomic [kvm]
+kvm_is_transparent_hugepage [kvm]
+kvm_make_vcpus_request_mask [kvm]
+kvm_make_all_cpus_request_except [kvm]
+kvm_flush_remote_tlbs [kvm]
+kvm_mmu_notifier_invalidate_range_start [kvm]
+kvm_mmu_notifier_change_pte [kvm]
+kvm_mmu_notifier_clear_flush_young [kvm]
+kvm_make_all_cpus_request [kvm]
+kvm_reload_remote_mmus [kvm]
+kvm_mmu_topup_memory_cache [kvm]
+kvm_mmu_memory_cache_nr_free_objects [kvm]
+kvm_mmu_free_memory_cache [kvm]
+kvm_mmu_memory_cache_alloc [kvm]
+kvm_mmu_memory_cache_alloc [kvm]
+kvm_mmu_memory_cache_alloc [kvm]
+kvm_put_kvm [kvm]
+kvm_dev_ioctl [kvm]
+kvm_vm_release [kvm]
+kvm_vcpu_release [kvm]
+kvm_device_release [kvm]
+kvm_debugfs_release [kvm]
+kvm_stat_data_open [kvm]
+gfn_to_hva_memslot_prot [kvm]
+__kvm_read_guest_page [kvm]
+kvm_read_guest_page [kvm]
+kvm_read_guest [kvm]
+kvm_read_guest_offset_cached [kvm]
+kvm_read_guest_cached [kvm]
+kvm_vcpu_read_guest_page [kvm]
+kvm_vcpu_read_guest [kvm]
+kvm_vcpu_read_guest_atomic [kvm]
+kvm_host_page_size [kvm]
+gfn_to_hva_prot [kvm]
+kvm_vcpu_gfn_to_hva_prot [kvm]
+kvm_release_pfn [kvm]
+__kvm_map_gfn [kvm]
+kvm_map_gfn [kvm]
+kvm_vcpu_map [kvm]
+kvm_sigset_activate [kvm]
+kvm_sigset_deactivate [kvm]
+kvm_sigset_deactivate [kvm]
+kvm_vcpu_on_spin [kvm]
+kvm_device_from_filp [kvm]
+kvm_register_device_ops [kvm]
+kvm_unregister_device_ops [kvm]
+kvm_unregister_device_ops [kvm]
+kvm_vm_ioctl [kvm]
+kvm_vm_compat_ioctl [kvm]
+kvm_io_bus_write_cookie [kvm]
+kvm_io_bus_read [kvm]
+kvm_io_bus_register_dev [kvm]
+kvm_io_bus_unregister_dev [kvm]
+kvm_get_running_vcpus [kvm]
+kvm_vm_create_worker_thread [kvm]
+coalesced_mmio_destructor [kvm]
+coalesced_mmio_write [kvm]
+kvm_coalesced_mmio_init [kvm]
+kvm_coalesced_mmio_free [kvm]
+kvm_vm_ioctl_register_coalesced_mmio [kvm]
+kvm_vm_ioctl_unregister_coalesced_mmio [kvm]
+kvm_arch_irq_bypass_stop [kvm]
+irqfd_ptable_queue_proc [kvm]
+irqfd_inject [kvm]
+irqfd_update [kvm]
+ioeventfd_write [kvm]
+kvm_deassign_ioeventfd_idx [kvm]
+irqfd_deactivate [kvm]
+kvm_arch_irq_bypass_start [kvm]
+kvm_assign_ioeventfd_idx [kvm]
+ioeventfd_destructor [kvm]
+irqfd_resampler_ack [kvm]
+kvm_irq_has_notifier [kvm]
+kvm_irq_has_notifier [kvm]
+kvm_irq_has_notifier [kvm]
+irqfd_wakeup [kvm]
+irqfd_wakeup [kvm]
+kvm_notify_acked_gsi [kvm]
+kvm_notify_acked_irq [kvm]
+kvm_register_irq_ack_notifier [kvm]
+kvm_unregister_irq_ack_notifier [kvm]
+irqfd_resampler_shutdown [kvm]
+irqfd_shutdown [kvm]
+kvm_eventfd_init [kvm]
+kvm_irqfd [kvm]
+kvm_irqfd_release [kvm]
+kvm_irq_routing_update [kvm]
+kvm_irqfd_init [kvm]
+kvm_irqfd_exit [kvm]
+kvm_ioeventfd [kvm]
+free_irq_routing_table.part.0 [kvm]
+kvm_irq_map_gsi [kvm]
+kvm_irq_map_chip_pin [kvm]
+kvm_send_userspace_msi [kvm]
+kvm_set_irq [kvm]
+kvm_free_irq_routing [kvm]
+kvm_free_irq_routing [kvm]
+kvm_free_irq_routing [kvm]
+kvm_set_irq_routing [kvm]
+kvm_vfio_group_set_kvm [kvm]
+kvm_vfio_group_put_external_user [kvm]
+kvm_vfio_has_attr [kvm]
+kvm_vfio_update_coherency [kvm]
+kvm_vfio_destroy [kvm]
+kvm_vfio_create [kvm]
+kvm_vfio_set_attr [kvm]
+kvm_vfio_ops_init [kvm]
+kvm_vfio_ops_exit [kvm]
+async_pf_execute [kvm]
+kvm_async_pf_init [kvm]
+kvm_async_pf_deinit [kvm]
+kvm_async_pf_vcpu_init [kvm]
+kvm_clear_async_pf_completion_queue [kvm]
+kvm_check_async_pf_completion [kvm]
+kvm_setup_async_pf [kvm]
+kvm_async_pf_wakeup_all [kvm]
+kvm_get_arch_capabilities [kvm]
+kvm_enable_efer_bits [kvm]
+kvmclock_cpu_down_prep [kvm]
+kvm_is_in_guest [kvm]
+kvm_is_user_mode [kvm]
+kvm_arch_start_assignment [kvm]
+kvm_arch_end_assignment [kvm]
+kvm_arch_register_noncoherent_dma [kvm]
+kvm_arch_unregister_noncoherent_dma [kvm]
+read_tsc [kvm]
+exception_type [kvm]
+kvm_arch_has_assigned_device [kvm]
+kvm_arch_has_noncoherent_dma [kvm]
+__traceiter_kvm_entry [kvm]
+__traceiter_kvm_hypercall [kvm]
+__traceiter_kvm_hv_hypercall [kvm]
+__traceiter_kvm_pio [kvm]
+__traceiter_kvm_fast_mmio [kvm]
+__traceiter_kvm_cpuid [kvm]
+__traceiter_kvm_apic [kvm]
+__traceiter_kvm_exit [kvm]
+__traceiter_kvm_inj_virq [kvm]
+__traceiter_kvm_inj_exception [kvm]
+__traceiter_kvm_page_fault [kvm]
+__traceiter_kvm_msr [kvm]
+__traceiter_kvm_cr [kvm]
+__traceiter_kvm_pic_set_irq [kvm]
+__traceiter_kvm_apic_ipi [kvm]
+__traceiter_kvm_apic_accept_irq [kvm]
+__traceiter_kvm_eoi [kvm]
+__traceiter_kvm_pv_eoi [kvm]
+__traceiter_kvm_nested_vmrun [kvm]
+__traceiter_kvm_nested_intercepts [kvm]
+__traceiter_kvm_nested_vmexit [kvm]
+__traceiter_kvm_nested_vmexit_inject [kvm]
+__traceiter_kvm_nested_intr_vmexit [kvm]
+__traceiter_kvm_invlpga [kvm]
+__traceiter_kvm_skinit [kvm]
+__traceiter_kvm_emulate_insn [kvm]
+__traceiter_vcpu_match_mmio [kvm]
+__traceiter_kvm_write_tsc_offset [kvm]
+__traceiter_kvm_update_master_clock [kvm]
+__traceiter_kvm_track_tsc [kvm]
+__traceiter_kvm_pml_full [kvm]
+__traceiter_kvm_ple_window_update [kvm]
+__traceiter_kvm_pvclock_update [kvm]
+__traceiter_kvm_wait_lapic_expire [kvm]
+__traceiter_kvm_enter_smm [kvm]
+__traceiter_kvm_pi_irte_update [kvm]
+__traceiter_kvm_hv_notify_acked_sint [kvm]
+__traceiter_kvm_hv_synic_set_irq [kvm]
+__traceiter_kvm_hv_synic_send_eoi [kvm]
+__traceiter_kvm_hv_synic_set_msr [kvm]
+__traceiter_kvm_hv_stimer_set_config [kvm]
+__traceiter_kvm_hv_stimer_set_count [kvm]
+__traceiter_kvm_hv_stimer_start_periodic [kvm]
+__traceiter_kvm_hv_stimer_start_one_shot [kvm]
+__traceiter_kvm_hv_stimer_callback [kvm]
+__traceiter_kvm_hv_stimer_expiration [kvm]
+__traceiter_kvm_hv_stimer_cleanup [kvm]
+__traceiter_kvm_apicv_update_request [kvm]
+__traceiter_kvm_avic_incomplete_ipi [kvm]
+__traceiter_kvm_avic_unaccelerated_access [kvm]
+__traceiter_kvm_avic_ga_log [kvm]
+__traceiter_kvm_hv_timer_state [kvm]
+__traceiter_kvm_hv_flush_tlb [kvm]
+__traceiter_kvm_hv_flush_tlb_ex [kvm]
+__traceiter_kvm_hv_send_ipi [kvm]
+__traceiter_kvm_hv_send_ipi_ex [kvm]
+__traceiter_kvm_pv_tlb_flush [kvm]
+__traceiter_kvm_nested_vmenter_failed [kvm]
+__traceiter_kvm_hv_syndbg_set_msr [kvm]
+__traceiter_kvm_hv_syndbg_get_msr [kvm]
+kvm_get_apic_base [kvm]
+kvm_get_apic_mode [kvm]
+kvm_valid_cr4 [kvm]
+kvm_update_dr7 [kvm]
+kvm_vcpu_exit_request [kvm]
+emulator_get_cpl [kvm]
+emulator_get_gdt [kvm]
+emulator_get_idt [kvm]
+emulator_set_gdt [kvm]
+emulator_set_idt [kvm]
+emulator_get_cached_segment_base [kvm]
+emulator_set_segment [kvm]
+emulator_get_smbase [kvm]
+emulator_set_smbase [kvm]
+emulator_halt [kvm]
+emulator_intercept [kvm]
+emulator_set_nmi_mask [kvm]
+emulator_get_hflags [kvm]
+emulator_set_hflags [kvm]
+emulator_pre_leave_smm [kvm]
+complete_fast_pio_out_port_0x7e [kvm]
+kvm_vcpu_halt [kvm]
+kvm_apicv_activated [kvm]
+enter_smm_get_segment_flags [kvm]
+__kvm_request_immediate_exit [kvm]
+kvm_vcpu_is_reset_bsp [kvm]
+kvm_get_rflags [kvm]
+kvm_arch_no_poll [kvm]
+kvm_fixup_and_inject_pf_error [kvm]
+emulator_write_gpr [kvm]
+kvm_scale_tsc [kvm]
+kvm_read_l1_tsc [kvm]
+kvm_get_cs_db_l_bits [kvm]
+write_exit_mmio [kvm]
+__kvm_valid_efer [kvm]
+kvm_valid_efer [kvm]
+emulator_guest_has_long_mode [kvm]
+emulator_guest_has_movbe [kvm]
+emulator_guest_has_fxsr [kvm]
+kvm_read_guest_page_mmu [kvm]
+kvm_read_guest_virt_helper [kvm]
+emulator_read_std [kvm]
+kvm_fetch_guest_virt [kvm]
+__kvm_set_xcr [kvm]
+emulator_set_xcr [kvm]
+kvm_get_cr8 [kvm]
+kvm_rdpmc [kvm]
+emulator_read_pmc [kvm]
+emulator_get_cr [kvm]
+kvm_msr_user_space [kvm]
+kvm_read_guest_virt [kvm]
+emulator_get_segment [kvm]
+kvm_write_guest_virt_helper [kvm]
+kvm_write_guest_virt_system [kvm]
+emulator_write_std [kvm]
+msr_io [kvm]
+kvm_clear_msr_filter [kvm]
+kvm_vm_ioctl_set_msr_filter [kvm]
+kernel_pio [kvm]
+tsc_khz_changed [kvm]
+kvmclock_cpu_online [kvm]
+kvm_vcpu_update_apicv [kvm]
+emulator_get_cpuid [kvm]
+emulator_check_pmc [kvm]
+emulator_invlpg [kvm]
+read_emulate [kvm]
+kvm_read_guest_phys_system [kvm]
+__x86_set_memory_region [kvm]
+kvm_deliver_exception_payload [kvm]
+kvm_can_deliver_async_pf [kvm]
+kvm_load_host_xsave_state [kvm]
+kvm_set_user_return_msr [kvm]
+kvm_set_apic_base [kvm]
+kvm_inject_emulated_page_fault [kvm]
+kvm_handle_memory_failure [kvm]
+kvm_get_msr_common [kvm]
+kvm_sched_yield [kvm]
+kvm_apicv_init [kvm]
+kvm_update_dr0123.part.0 [kvm]
+__kvm_set_dr [kvm]
+emulator_set_dr [kvm]
+kvm_get_dr [kvm]
+emulator_get_dr [kvm]
+read_prepare [kvm]
+kvm_define_user_return_msr [kvm]
+pdptrs_changed [kvm]
+kvm_set_cr8.part.0 [kvm]
+kvm_set_cr8 [kvm]
+pvclock_gtod_notify [kvm]
+kvm_request_apicv_update [kvm]
+kvm_save_current_fpu [kvm]
+kvm_put_guest_fpu [kvm]
+kvm_cpu_accept_dm_intr [kvm]
+update_cr8_intercept [kvm]
+kvmclock_sync_fn [kvm]
+kvm_vcpu_ready_for_interrupt_injection [kvm]
+emulator_pio_in [kvm]
+emulator_pio_in_emulated [kvm]
+kvm_set_tsc_khz [kvm]
+kvm_msr_ignored_check.constprop.0 [kvm]
+load_pdptrs [kvm]
+kvm_set_cr0 [kvm]
+kvm_lmsw [kvm]
+kvm_set_cr4 [kvm]
+wbinvd_ipi [kvm]
+kvmclock_cpufreq_notifier [kvm]
+pvclock_gtod_update_fn [kvm]
+emulator_pio_out [kvm]
+emulator_pio_out_emulated [kvm]
+vcpu_mmio_read [kvm]
+kvm_get_msr_feature [kvm]
+do_get_msr_feature [kvm]
+kvmclock_update_fn [kvm]
+pvclock_update_vm_gtod_copy [kvm]
+kvm_on_user_return [kvm]
+kvm_hyperv_tsc_notifier [kvm]
+read_exit_mmio [kvm]
+kvm_handle_intel_pt_intr [kvm]
+write_mmio [kvm]
+kvm_inject_nmi [kvm]
+kvm_load_guest_fpu [kvm]
+process_nmi [kvm]
+kvm_vcpu_ioctl_x86_get_vcpu_events [kvm]
+vcpu_is_mmio_gpa [kvm]
+emulator_read_write_onepage [kvm]
+emulator_read_write [kvm]
+emulator_write_emulated [kvm]
+emulator_read_emulated [kvm]
+emulator_cmpxchg_emulated [kvm]
+kvm_spec_ctrl_test_value [kvm]
+kvm_gen_update_masterclock [kvm]
+kvm_smm_changed [kvm]
+emulator_post_leave_smm [kvm]
+kvm_load_guest_xsave_state [kvm]
+kvm_msr_allowed [kvm]
+kvm_set_msr_ignored_check [kvm]
+kvm_set_msr [kvm]
+emulator_set_msr [kvm]
+do_set_msr [kvm]
+emulator_fix_hypercall [kvm]
+kvm_vcpu_ioctl_x86_set_vcpu_events [kvm]
+init_emulate_ctxt [kvm]
+kvm_get_guest_ip [kvm]
+kvm_synchronize_tsc [kvm]
+__get_regs [kvm]
+emulator_read_gpr [kvm]
+kvm_write_system_time [kvm]
+kvm_emulate_wbinvd_noskip [kvm]
+emulator_wbinvd [kvm]
+reexecute_instruction [kvm]
+kvm_get_linear_rip [kvm]
+kvm_is_linear_rip [kvm]
+__kvm_set_rflags [kvm]
+kvm_set_rflags [kvm]
+__set_regs [kvm]
+kvm_inject_realmode_interrupt [kvm]
+kvm_task_switch [kvm]
+kvm_multiple_exception [kvm]
+kvm_queue_exception [kvm]
+kvm_require_dr [kvm]
+kvm_requeue_exception [kvm]
+kvm_queue_exception_p [kvm]
+kvm_vcpu_do_singlestep [kvm]
+kvm_skip_emulated_instruction [kvm]
+kvm_emulate_halt [kvm]
+complete_fast_pio_out [kvm]
+handle_fastpath_set_msr_irqoff [kvm]
+kvm_emulate_wbinvd [kvm]
+complete_fast_pio_in [kvm]
+kvm_fast_pio [kvm]
+kvm_emulate_hypercall [kvm]
+kvm_queue_exception_e [kvm]
+kvm_set_dr.part.0 [kvm]
+complete_emulated_msr [kvm]
+complete_emulated_rdmsr [kvm]
+complete_emulated_wrmsr [kvm]
+kvm_set_xcr [kvm]
+kvm_set_dr [kvm]
+kvm_complete_insn_gp [kvm]
+kvm_inject_page_fault [kvm]
+kvm_require_cpl [kvm]
+handle_emulation_failure [kvm]
+kvm_requeue_exception_e [kvm]
+inject_emulated_exception [kvm]
+kvm_emulate_wrmsr [kvm]
+kvm_guest_time_update [kvm]
+enter_smm [kvm]
+__set_sregs [kvm]
+kvm_set_cr3 [kvm]
+emulator_set_cr [kvm]
+kvm_handle_invpcid [kvm]
+__get_sregs [kvm]
+__kvm_get_msr [kvm]
+kvm_get_msr_ignored_check [kvm]
+kvm_get_msr [kvm]
+kvm_emulate_rdmsr [kvm]
+emulator_get_msr [kvm]
+do_get_msr [kvm]
+kvm_make_mclock_inprogress_request [kvm]
+get_kvmclock_ns [kvm]
+kvm_write_wall_clock [kvm]
+kvm_set_msr_common [kvm]
+kvm_vm_ioctl_check_extension [kvm]
+kvm_arch_dev_ioctl [kvm]
+kvm_arch_vcpu_load [kvm]
+kvm_arch_vcpu_put [kvm]
+kvm_arch_vcpu_ioctl [kvm]
+kvm_arch_vcpu_fault [kvm]
+kvm_arch_sync_dirty_log [kvm]
+kvm_vm_ioctl_irq_line [kvm]
+kvm_vm_ioctl_enable_cap [kvm]
+kvm_arch_vm_ioctl [kvm]
+kvm_get_segment [kvm]
+translate_nested_gpa [kvm]
+kvm_mmu_gva_to_gpa_read [kvm]
+kvm_mmu_gva_to_gpa_fetch [kvm]
+kvm_mmu_gva_to_gpa_write [kvm]
+kvm_mmu_gva_to_gpa_system [kvm]
+emulator_write_phys [kvm]
+write_emulate [kvm]
+x86_emulate_instruction [kvm]
+kvm_emulate_instruction [kvm]
+handle_ud [kvm]
+complete_emulated_mmio [kvm]
+kvm_emulate_instruction_from_buffer [kvm]
+complete_emulated_pio [kvm]
+kvm_arch_init [kvm]
+kvm_arch_exit [kvm]
+kvm_make_scan_ioapic_request_mask [kvm]
+kvm_make_scan_ioapic_request [kvm]
+kvm_arch_mmu_notifier_invalidate_range [kvm]
+kvm_vcpu_reload_apic_access_page [kvm]
+kvm_arch_vcpu_ioctl_get_regs [kvm]
+kvm_arch_vcpu_ioctl_set_regs [kvm]
+kvm_arch_vcpu_ioctl_get_sregs [kvm]
+kvm_arch_vcpu_ioctl_get_mpstate [kvm]
+kvm_arch_vcpu_ioctl_set_mpstate [kvm]
+kvm_arch_vcpu_ioctl_set_sregs [kvm]
+kvm_arch_vcpu_ioctl_set_guest_debug [kvm]
+kvm_arch_vcpu_ioctl_translate [kvm]
+kvm_arch_vcpu_ioctl_get_fpu [kvm]
+kvm_arch_vcpu_ioctl_set_fpu [kvm]
+kvm_arch_vcpu_precreate [kvm]
+kvm_arch_vcpu_postcreate [kvm]
+kvm_arch_vcpu_destroy [kvm]
+kvm_vcpu_reset [kvm]
+kvm_arch_vcpu_create [kvm]
+kvm_vcpu_deliver_sipi_vector [kvm]
+kvm_arch_hardware_enable [kvm]
+kvm_arch_hardware_disable [kvm]
+kvm_arch_hardware_setup [kvm]
+kvm_arch_hardware_unsetup [kvm]
+kvm_arch_check_processor_compat [kvm]
+kvm_vcpu_is_bsp [kvm]
+kvm_arch_sched_in [kvm]
+kvm_arch_free_vm [kvm]
+kvm_arch_init_vm [kvm]
+kvm_arch_post_init_vm [kvm]
+kvm_arch_sync_events [kvm]
+kvm_arch_pre_destroy_vm [kvm]
+kvm_arch_destroy_vm [kvm]
+kvm_arch_free_memslot [kvm]
+kvm_arch_memslots_updated [kvm]
+kvm_arch_prepare_memory_region [kvm]
+kvm_arch_commit_memory_region [kvm]
+kvm_arch_flush_shadow_all [kvm]
+kvm_arch_flush_shadow_memslot [kvm]
+kvm_arch_vcpu_runnable [kvm]
+kvm_arch_vcpu_ioctl_run [kvm]
+kvm_arch_dy_runnable [kvm]
+kvm_arch_vcpu_in_kernel [kvm]
+kvm_arch_vcpu_should_kick [kvm]
+kvm_arch_interrupt_allowed [kvm]
+kvm_arch_async_page_ready [kvm]
+kvm_find_async_pf_gfn [kvm]
+kvm_can_do_async_pf [kvm]
+kvm_arch_async_page_not_present [kvm]
+kvm_arch_async_page_present [kvm]
+kvm_arch_async_page_present_queued [kvm]
+kvm_arch_can_dequeue_async_page_present [kvm]
+kvm_arch_has_irq_bypass [kvm]
+kvm_arch_irq_bypass_add_producer [kvm]
+kvm_arch_irq_bypass_del_producer [kvm]
+kvm_arch_update_irqfd_routing [kvm]
+kvm_vector_hashing_enabled [kvm]
+em_clflush [kvm]
+emulator_check_intercept [kvm]
+set_segment_selector [kvm]
+fetch_register_operand [kvm]
+write_register_operand [kvm]
+rsm_enter_protected_mode [kvm]
+vendor_intel [kvm]
+em_xchg [kvm]
+em_clts [kvm]
+em_hypercall [kvm]
+em_lmsw [kvm]
+em_out [kvm]
+em_bswap [kvm]
+em_movsxd [kvm]
+reg_write [kvm]
+em_rdtsc [kvm]
+reg_read [kvm]
+save_state_to_tss32 [kvm]
+em_cpuid [kvm]
+em_rdpmc [kvm]
+em_rdmsr [kvm]
+em_wrmsr [kvm]
+em_dr_write [kvm]
+em_cr_write [kvm]
+em_xsetbv [kvm]
+em_smsw [kvm]
+em_store_sreg [kvm]
+em_str [kvm]
+em_sldt [kvm]
+em_rdpid [kvm]
+em_sysenter [kvm]
+check_rdtsc [kvm]
+check_cr_read [kvm]
+em_syscall [kvm]
+check_svme [kvm]
+check_svme_pa [kvm]
+em_mov_rm_sreg [kvm]
+fastop [kvm]
+em_bsr_c [kvm]
+em_bsf_c [kvm]
+em_aad [kvm]
+em_imul_3op [kvm]
+em_das [kvm]
+check_fxsr [kvm]
+check_dr_read [kvm]
+check_dr_write [kvm]
+em_aam [kvm]
+get_descriptor_ptr [kvm]
+write_segment_descriptor [kvm]
+em_rsm [kvm]
+writeback_registers [kvm]
+emulator_get_fpu [kvm]
+read_sse_reg [kvm]
+em_mov [kvm]
+fxregs_fixup [kvm]
+check_rdpmc [kvm]
+emulator_bad_iopl.part.0 [kvm]
+em_sti [kvm]
+em_cli [kvm]
+decode_register [kvm]
+em_cmpxchg8b [kvm]
+read_segment_descriptor [kvm]
+em_movbe [kvm]
+em_fnstsw [kvm]
+em_fninit [kvm]
+em_fnstcw [kvm]
+fetch_possible_mmx_operand.part.0 [kvm]
+emulator_io_permited.part.0 [kvm]
+check_perm_out [kvm]
+check_cr_write [kvm]
+em_clflushopt [kvm]
+linearize [kvm]
+segmented_read_std [kvm]
+em_fxrstor.part.0 [kvm]
+em_fxrstor [kvm]
+segmented_write_std [kvm]
+emulate_store_desc_ptr [kvm]
+em_sidt [kvm]
+em_sgdt [kvm]
+em_fxsave.part.0 [kvm]
+em_fxsave [kvm]
+segmented_write [kvm]
+writeback [kvm]
+em_invlpg [kvm]
+segmented_read [kvm]
+rsp_increment [kvm]
+push [kvm]
+em_push [kvm]
+em_pushf [kvm]
+em_pusha [kvm]
+em_push_sreg [kvm]
+emulate_pop [kvm]
+em_popf [kvm]
+em_pop [kvm]
+em_popa [kvm]
+em_enter [kvm]
+em_leave [kvm]
+em_cmpxchg [kvm]
+em_cwd [kvm]
+em_sahf [kvm]
+em_lahf [kvm]
+check_perm_in [kvm]
+__load_segment_descriptor [kvm]
+load_segment_descriptor [kvm]
+__emulate_int_real [kvm]
+em_lseg [kvm]
+em_ltr [kvm]
+em_lldt [kvm]
+em_mov_sreg_rm [kvm]
+em_pop_sreg [kvm]
+em_iret [kvm]
+task_switch_32.constprop.0 [kvm]
+task_switch_16.constprop.0 [kvm]
+string_addr_inc [kvm]
+__do_insn_fetch_bytes [kvm]
+decode_imm [kvm]
+em_in [kvm]
+em_lgdt_lidt [kvm]
+em_lidt [kvm]
+em_lgdt [kvm]
+em_sysexit [kvm]
+em_jmp_abs [kvm]
+em_call_near_abs [kvm]
+em_call [kvm]
+assign_eip_far.isra.0 [kvm]
+em_jmp_far [kvm]
+em_ret_far [kvm]
+em_ret_far_imm [kvm]
+em_call_far [kvm]
+decode_operand [kvm]
+em_ret [kvm]
+em_ret_near_imm [kvm]
+em_jcxz [kvm]
+em_loop [kvm]
+emulate_int_real [kvm]
+emulator_task_switch [kvm]
+x86_decode_insn [kvm]
+x86_page_table_writing_insn [kvm]
+init_decode_cache [kvm]
+x86_emulate_insn [kvm]
+emulator_invalidate_register_cache [kvm]
+emulator_writeback_register_cache [kvm]
+emulator_can_use_gpa [kvm]
+pic_unlock [kvm]
+pic_clear_isr [kvm]
+pic_get_irq [kvm]
+pic_update_irq [kvm]
+picdev_read [kvm]
+picdev_eclr_read [kvm]
+picdev_slave_read [kvm]
+picdev_master_read [kvm]
+pic_ioport_write [kvm]
+picdev_write [kvm]
+picdev_eclr_write [kvm]
+picdev_slave_write [kvm]
+picdev_master_write [kvm]
+kvm_pic_update_irq [kvm]
+kvm_pic_set_irq [kvm]
+kvm_pic_clear_all [kvm]
+kvm_pic_read_irq [kvm]
+kvm_pic_init [kvm]
+kvm_pic_destroy [kvm]
+kvm_cpu_has_pending_timer [kvm]
+kvm_inject_pending_timer_irqs [kvm]
+kvm_cpu_has_extint [kvm]
+kvm_cpu_has_injectable_intr [kvm]
+kvm_cpu_has_interrupt [kvm]
+kvm_cpu_get_interrupt [kvm]
+__kvm_migrate_timers [kvm]
+kvm_arch_irqfd_allowed [kvm]
+kvm_apic_map_free [kvm]
+__kvm_apic_update_irr [kvm]
+kvm_apic_update_irr [kvm]
+apic_get_tmcct [kvm]
+kvm_can_post_timer_interrupt [kvm]
+kvm_can_use_hv_timer [kvm]
+kvm_apic_match_dest [kvm]
+kvm_apic_is_broadcast_dest [kvm]
+kvm_lapic_hv_timer_in_use [kvm]
+kvm_apic_update_apicv [kvm]
+cancel_hv_timer [kvm]
+limit_periodic_timer_frequency.part.0 [kvm]
+apic_update_lvtt [kvm]
+apic_manage_nmi_watchdog [kvm]
+kvm_apic_state_fixup.part.0 [kvm]
+advance_periodic_target_expiration [kvm]
+kvm_lapic_find_highest_irr [kvm]
+__apic_update_ppr [kvm]
+apic_has_interrupt_for_ppr [kvm]
+apic_update_ppr [kvm]
+kvm_apic_update_ppr [kvm]
+kvm_apic_has_interrupt [kvm]
+kvm_ioapic_send_eoi [kvm]
+kvm_apic_set_eoi_accelerated [kvm]
+apic_set_eoi [kvm]
+kvm_apic_clear_irr [kvm]
+kvm_lapic_reg_read [kvm]
+apic_mmio_read [kvm]
+__apic_accept_irq [kvm]
+kvm_wait_lapic_expire [kvm]
+kvm_apic_pending_eoi [kvm]
+kvm_recalculate_apic_map [kvm]
+kvm_apic_set_version [kvm]
+kvm_apic_set_irq [kvm]
+__pv_send_ipi [kvm]
+kvm_pv_send_ipi [kvm]
+kvm_vector_to_index [kvm]
+kvm_irq_delivery_to_apic_fast [kvm]
+kvm_intr_is_single_vcpu_fast [kvm]
+kvm_bitmap_or_dest_vcpus [kvm]
+kvm_apic_compare_prio [kvm]
+kvm_apic_send_ipi [kvm]
+kvm_free_lapic [kvm]
+kvm_get_lapic_tscdeadline_msr [kvm]
+kvm_lapic_set_tpr [kvm]
+kvm_lapic_get_cr8 [kvm]
+kvm_lapic_set_base [kvm]
+kvm_lapic_reset [kvm]
+apic_has_pending_timer [kvm]
+kvm_apic_local_deliver [kvm]
+apic_timer_expired [kvm]
+start_sw_timer [kvm]
+restart_apic_timer [kvm]
+kvm_lapic_switch_to_hv_timer [kvm]
+kvm_lapic_restart_hv_timer [kvm]
+__start_apic_timer [kvm]
+kvm_set_lapic_tscdeadline_msr [kvm]
+kvm_lapic_reg_write [kvm]
+kvm_lapic_set_eoi [kvm]
+kvm_apic_write_nodecode [kvm]
+apic_mmio_write [kvm]
+kvm_lapic_switch_to_sw_timer [kvm]
+kvm_lapic_expired_hv_timer [kvm]
+apic_timer_fn [kvm]
+kvm_apic_nmi_wd_deliver [kvm]
+kvm_create_lapic [kvm]
+kvm_apic_accept_pic_intr [kvm]
+kvm_inject_apic_timer_irqs [kvm]
+kvm_get_apic_interrupt [kvm]
+kvm_apic_get_state [kvm]
+kvm_apic_set_state [kvm]
+__kvm_migrate_apic_timer [kvm]
+kvm_lapic_sync_from_vapic [kvm]
+kvm_lapic_sync_to_vapic [kvm]
+kvm_lapic_set_vapic_addr [kvm]
+kvm_x2apic_msr_write [kvm]
+kvm_x2apic_msr_read [kvm]
+kvm_hv_vapic_msr_write [kvm]
+kvm_hv_vapic_msr_read [kvm]
+kvm_lapic_enable_pv_eoi [kvm]
+kvm_apic_accept_events [kvm]
+kvm_lapic_init [kvm]
+kvm_lapic_exit [kvm]
+pit_mask_notifer [kvm]
+kvm_pit_ack_irq [kvm]
+pit_do_work [kvm]
+create_pit_timer [kvm]
+pit_load_count [kvm]
+pit_get_out [kvm]
+speaker_ioport_read [kvm]
+pit_timer_fn [kvm]
+speaker_ioport_write [kvm]
+pit_get_count [kvm]
+pit_ioport_read [kvm]
+pit_ioport_write [kvm]
+__kvm_migrate_pit_timer [kvm]
+kvm_pit_set_reinject [kvm]
+kvm_pit_load_count [kvm]
+kvm_create_pit [kvm]
+kvm_free_pit [kvm]
+ioapic_service [kvm]
+ioapic_mmio_read [kvm]
+kvm_rtc_eoi_tracking_restore_all [kvm]
+rtc_status_pending_eoi_check_valid [kvm]
+__rtc_irq_eoi_tracking_restore_one [kvm]
+rtc_irq_eoi [kvm]
+ioapic_set_irq [kvm]
+kvm_ioapic_eoi_inject_work [kvm]
+ioapic_mmio_write [kvm]
+kvm_rtc_eoi_tracking_restore_one [kvm]
+kvm_ioapic_scan_entry [kvm]
+kvm_arch_post_irq_ack_notifier_list_update [kvm]
+kvm_ioapic_set_irq [kvm]
+kvm_ioapic_clear_all [kvm]
+kvm_ioapic_update_eoi [kvm]
+kvm_ioapic_init [kvm]
+kvm_ioapic_destroy [kvm]
+kvm_get_ioapic [kvm]
+kvm_set_ioapic [kvm]
+kvm_hv_set_sint [kvm]
+kvm_set_ioapic_irq [kvm]
+kvm_set_pic_irq [kvm]
+kvm_set_msi_irq [kvm]
+kvm_intr_is_single_vcpu [kvm]
+kvm_irq_delivery_to_apic [kvm]
+kvm_set_msi [kvm]
+kvm_arch_set_irq_inatomic [kvm]
+kvm_request_irq_source_id [kvm]
+kvm_free_irq_source_id [kvm]
+kvm_register_irq_mask_notifier [kvm]
+kvm_unregister_irq_mask_notifier [kvm]
+kvm_fire_mask_notifiers [kvm]
+kvm_arch_can_set_irq_routing [kvm]
+kvm_set_routing_entry [kvm]
+kvm_setup_default_irq_routing [kvm]
+kvm_setup_empty_irq_routing [kvm]
+kvm_arch_post_irq_routing_update [kvm]
+kvm_scan_ioapic_routes [kvm]
+kvm_arch_irq_routing_update [kvm]
+xstate_required_size [kvm]
+do_host_cpuid [kvm]
+__do_cpuid_func_emulated [kvm]
+kvm_set_cpu_caps [kvm]
+kvm_find_cpuid_entry [kvm]
+kvm_check_cpuid [kvm]
+kvm_cpuid [kvm]
+kvm_emulate_cpuid [kvm]
+kvm_update_pv_runtime [kvm]
+kvm_update_cpuid_runtime [kvm]
+cpuid_query_maxphyaddr [kvm]
+kvm_vcpu_after_set_cpuid [kvm]
+kvm_vcpu_ioctl_set_cpuid [kvm]
+kvm_vcpu_ioctl_set_cpuid2 [kvm]
+kvm_vcpu_ioctl_get_cpuid2 [kvm]
+kvm_dev_ioctl_get_cpuid [kvm]
+pmc_pause_counter [kvm]
+pmc_resume_counter [kvm]
+kvm_perf_overflow [kvm]
+kvm_perf_overflow_intr [kvm]
+pmc_reprogram_counter [kvm]
+reprogram_fixed_counter [kvm]
+reprogram_gp_counter [kvm]
+reprogram_counter [kvm]
+kvm_pmu_is_valid_rdpmc_ecx [kvm]
+is_vmware_backdoor_pmc [kvm]
+kvm_pmu_rdpmc [kvm]
+kvm_pmu_deliver_pmi [kvm]
+kvm_pmi_trigger_fn [kvm]
+kvm_pmu_is_valid_msr [kvm]
+kvm_pmu_get_msr [kvm]
+kvm_pmu_set_msr [kvm]
+kvm_pmu_refresh [kvm]
+kvm_pmu_reset [kvm]
+kvm_pmu_init [kvm]
+kvm_pmu_cleanup [kvm]
+kvm_pmu_handle_event [kvm]
+kvm_pmu_destroy [kvm]
+kvm_vm_ioctl_set_pmu_event_filter [kvm]
+__mtrr_lookup_var_next [kvm]
+mtrr_lookup_next [kvm]
+kvm_mtrr_valid [kvm]
+fixed_msr_to_seg_unit [kvm]
+fixed_msr_to_range_index [kvm]
+mtrr_lookup_okay [kvm]
+mtrr_lookup_start.constprop.0 [kvm]
+kvm_mtrr_get_guest_memory_type [kvm]
+kvm_mtrr_set_msr [kvm]
+kvm_mtrr_get_msr [kvm]
+kvm_vcpu_mtrr_init [kvm]
+kvm_mtrr_check_gfn_range_consistency [kvm]
+kvm_hv_syndbg_complete_userspace [kvm]
+kvm_hv_assist_page_enabled [kvm]
+synic_set_irq [kvm]
+stimer_cleanup [kvm]
+kvm_hv_send_ipi [kvm]
+synic_get [kvm]
+kvm_hv_get_assist_page [kvm]
+current_task_runtime_100ns [kvm]
+synic_update_vector.part.0 [kvm]
+get_time_ref_counter [kvm]
+kvm_hv_hypercall_set_result [kvm]
+kvm_hv_hypercall_complete_userspace [kvm]
+stimer_mark_pending [kvm]
+stimer_timer_callback [kvm]
+kvm_hv_notify_acked_sint [kvm]
+kvm_hv_flush_tlb [kvm]
+kvm_hv_synic_set_irq [kvm]
+kvm_hv_synic_send_eoi [kvm]
+kvm_hv_irq_routing_update [kvm]
+kvm_hv_process_stimers [kvm]
+kvm_hv_vcpu_uninit [kvm]
+kvm_hv_vcpu_init [kvm]
+kvm_hv_vcpu_postcreate [kvm]
+kvm_hv_activate_synic [kvm]
+kvm_hv_setup_tsc_page [kvm]
+kvm_hv_set_msr_common [kvm]
+kvm_hv_get_msr_common [kvm]
+kvm_hv_hypercall_enabled [kvm]
+kvm_hv_hypercall [kvm]
+kvm_hv_init_vm [kvm]
+kvm_hv_destroy_vm [kvm]
+kvm_vm_ioctl_hv_eventfd [kvm]
+kvm_vcpu_ioctl_get_hv_cpuid [kvm]
+vcpu_tsc_scaling_frac_fops_open [kvm]
+vcpu_tsc_scaling_fops_open [kvm]
+vcpu_timer_advance_ns_fops_open [kvm]
+vcpu_tsc_offset_fops_open [kvm]
+vcpu_get_timer_advance_ns [kvm]
+vcpu_get_tsc_offset [kvm]
+vcpu_get_tsc_scaling_ratio [kvm]
+vcpu_get_tsc_scaling_frac_bits [kvm]
+kvm_arch_create_vcpu_debugfs [kvm]
+nonpaging_sync_page [kvm]
+nonpaging_update_pte [kvm]
+mmu_shrink_count [kvm]
+kvm_flush_remote_tlbs_with_range [kvm]
+__traceiter_kvm_mmu_pagetable_walk [kvm]
+__traceiter_kvm_mmu_paging_element [kvm]
+__traceiter_kvm_mmu_set_accessed_bit [kvm]
+__traceiter_kvm_mmu_set_dirty_bit [kvm]
+__traceiter_kvm_mmu_walker_error [kvm]
+__traceiter_kvm_mmu_get_page [kvm]
+__traceiter_kvm_mmu_sync_page [kvm]
+__traceiter_kvm_mmu_unsync_page [kvm]
+__traceiter_kvm_mmu_prepare_zap_page [kvm]
+__traceiter_mark_mmio_spte [kvm]
+__traceiter_handle_mmio_page_fault [kvm]
+__traceiter_fast_page_fault [kvm]
+__traceiter_kvm_mmu_zap_all_fast [kvm]
+__traceiter_check_mmio_spte [kvm]
+__traceiter_kvm_mmu_set_spte [kvm]
+__traceiter_kvm_mmu_spte_requested [kvm]
+mmu_pages_next [kvm]
+nonpaging_gva_to_gpa [kvm]
+nonpaging_gva_to_gpa_nested [kvm]
+kvm_calc_mmu_role_ext [kvm]
+kvm_calc_mmu_role_common [kvm]
+kvm_calc_tdp_mmu_root_page_role [kvm]
+kvm_calc_shadow_root_page_role_common [kvm]
+kvm_calc_shadow_mmu_root_page_role [kvm]
+get_cr3 [kvm]
+kvm_mmu_invpcid_gva [kvm]
+shadow_walk_okay [kvm]
+translate_gpa [kvm]
+mmu_pages_first [kvm]
+mmu_pages_clear_parents [kvm]
+__pte_list_remove [kvm]
+kvm_mmu_commit_zap_page [kvm]
+free_mmu_pages [kvm]
+validate_direct_spte [kvm]
+gfn_to_memslot_dirty_bitmap [kvm]
+pte_list_add [kvm]
+mark_mmio_spte [kvm]
+pte_prefetch_gfn_to_pfn [kvm]
+paging64_gpte_changed [kvm]
+paging32_gpte_changed [kvm]
+ept_gpte_changed [kvm]
+mmu_destroy_caches [kvm]
+mmu_pages_add [kvm]
+update_permission_bitmask [kvm]
+kvm_unlink_unsync_page [kvm]
+__mmu_unsync_walk [kvm]
+shadow_walk_init_using_root [kvm]
+try_async_pf [kvm]
+__kvm_mmu_create [kvm]
+spte_has_volatile_bits [kvm]
+mmu_spte_update_no_track [kvm]
+mmu_spte_update [kvm]
+set_spte [kvm]
+mmu_spte_clear_track_bits [kvm]
+mmio_info_in_cache [kvm]
+kvm_mmu_page_get_gfn [kvm]
+update_pkru_bitmask.part.0 [kvm]
+kvm_mmu_invalidate_gva [kvm]
+kvm_mmu_invlpg [kvm]
+rmap_get_first [kvm]
+rmap_get_next [kvm]
+kvm_test_age_rmapp [kvm]
+kvm_mmu_mark_parents_unsync [kvm]
+mark_unsync [kvm]
+link_shadow_page [kvm]
+kvm_age_rmapp [kvm]
+kvm_set_pte_rmapp [kvm]
+set_nx_huge_pages_recovery_ratio [kvm]
+page_fault_handle_page_track.part.0 [kvm]
+mmu_topup_memory_caches [kvm]
+handle_abnormal_pfn [kvm]
+sync_mmio_spte [kvm]
+paging64_cmpxchg_gpte.isra.0 [kvm]
+kvm_configure_mmu [kvm]
+__rmap_clear_dirty.constprop.0 [kvm]
+__rmap_write_protect.constprop.0 [kvm]
+kvm_zap_rmapp.constprop.0 [kvm]
+kvm_unmap_rmapp [kvm]
+kvm_mmu_flush_or_zap [kvm]
+kvm_mmu_clear_dirty_pt_masked [kvm]
+update_gfn_disallow_lpage_count [kvm]
+rmap_walk_init_level [kvm]
+slot_rmap_walk_next [kvm]
+kvm_handle_hva_range [kvm]
+shadow_page_table_clear_flood [kvm]
+gfn_to_rmap [kvm]
+drop_spte [kvm]
+drop_large_spte [kvm]
+paging64_prefetch_invalid_gpte.isra.0 [kvm]
+ept_prefetch_invalid_gpte.isra.0 [kvm]
+paging64_sync_page [kvm]
+paging32_sync_page [kvm]
+ept_sync_page [kvm]
+mmu_set_spte [kvm]
+__direct_pte_prefetch [kvm]
+paging64_prefetch_gpte [kvm]
+paging64_update_pte [kvm]
+paging32_prefetch_gpte [kvm]
+paging32_update_pte [kvm]
+ept_prefetch_gpte [kvm]
+ept_update_pte [kvm]
+paging64_walk_addr_generic [kvm]
+paging64_gva_to_gpa [kvm]
+paging64_gva_to_gpa_nested [kvm]
+kvm_mmu_slot_set_dirty [kvm]
+kvm_mmu_slot_leaf_clear_dirty [kvm]
+kvm_mmu_slot_largepage_remove_write_access [kvm]
+__kvm_mmu_prepare_zap_page [kvm]
+kvm_mmu_zap_all_fast [kvm]
+set_nx_huge_pages [kvm]
+kvm_mmu_invalidate_zap_pages_in_memslot [kvm]
+mmu_zap_unsync_children [kvm]
+mmu_page_zap_pte [kvm]
+paging64_invlpg [kvm]
+paging32_invlpg [kvm]
+ept_invlpg [kvm]
+kvm_mmu_unprotect_page [kvm]
+kvm_mmu_unprotect_page_virt [kvm]
+mmu_free_root_page [kvm]
+__kvm_sync_page [kvm]
+kvm_nx_lpage_recovery_worker [kvm]
+kvm_mmu_zap_oldest_mmu_pages [kvm]
+make_mmu_pages_available [kvm]
+kvm_mmu_free_roots [kvm]
+__kvm_mmu_new_pgd [kvm]
+kvm_mmu_new_pgd [kvm]
+kvm_mmu_unload [kvm]
+__reset_rsvds_bits_mask_ept [kvm]
+kvm_init_shadow_ept_mmu [kvm]
+mmu_shrink_scan [kvm]
+kvm_mmu_pte_write [kvm]
+__reset_rsvds_bits_mask.constprop.0 [kvm]
+reset_rsvds_bits_mask [kvm]
+paging64_init_context_common [kvm]
+reset_shadow_zero_bits_mask [kvm]
+shadow_mmu_init_context [kvm]
+kvm_init_mmu [kvm]
+kvm_mmu_reset_context [kvm]
+kvm_init_shadow_npt_mmu [kvm]
+paging32_walk_addr_generic [kvm]
+paging32_gva_to_gpa [kvm]
+paging32_gva_to_gpa_nested [kvm]
+ept_walk_addr_generic [kvm]
+ept_gva_to_gpa [kvm]
+kvm_flush_remote_tlbs_with_address [kvm]
+is_nx_huge_page_enabled [kvm]
+kvm_mmu_gfn_disallow_lpage [kvm]
+kvm_mmu_gfn_allow_lpage [kvm]
+account_huge_nx_page [kvm]
+unaccount_huge_nx_page [kvm]
+kvm_arch_mmu_enable_log_dirty_pt_masked [kvm]
+kvm_mmu_slot_gfn_write_protect [kvm]
+kvm_mmu_get_page [kvm]
+mmu_alloc_root [kvm]
+mmu_sync_children [kvm]
+kvm_mmu_sync_roots [kvm]
+kvm_mmu_load [kvm]
+kvm_unmap_hva_range [kvm]
+kvm_set_spte_hva [kvm]
+kvm_age_hva [kvm]
+kvm_test_age_hva [kvm]
+kvm_mmu_change_mmu_pages [kvm]
+mmu_need_write_protect [kvm]
+kvm_mmu_hugepage_adjust [kvm]
+disallowed_hugepage_adjust [kvm]
+direct_page_fault [kvm]
+kvm_tdp_page_fault [kvm]
+kvm_mmu_page_fault [kvm]
+kvm_handle_page_fault [kvm]
+nonpaging_page_fault [kvm]
+paging64_page_fault [kvm]
+paging32_page_fault [kvm]
+ept_page_fault [kvm]
+kvm_mmu_create [kvm]
+kvm_mmu_init_vm [kvm]
+kvm_mmu_uninit_vm [kvm]
+kvm_zap_gfn_range [kvm]
+kvm_mmu_slot_remove_write_access [kvm]
+kvm_mmu_zap_collapsible_sptes [kvm]
+kvm_arch_flush_remote_tlbs_memslot [kvm]
+kvm_mmu_zap_all [kvm]
+kvm_mmu_invalidate_mmio_sptes [kvm]
+kvm_mmu_module_init [kvm]
+kvm_mmu_calculate_default_mmu_pages [kvm]
+kvm_mmu_destroy [kvm]
+kvm_mmu_module_exit [kvm]
+kvm_mmu_post_init_vm [kvm]
+kvm_mmu_pre_destroy_vm [kvm]
+kvm_page_track_unregister_notifier [kvm]
+update_gfn_track [kvm]
+kvm_slot_page_track_add_page [kvm]
+kvm_slot_page_track_remove_page [kvm]
+kvm_page_track_register_notifier [kvm]
+kvm_page_track_free_memslot [kvm]
+kvm_page_track_create_memslot [kvm]
+kvm_page_track_is_active [kvm]
+kvm_page_track_cleanup [kvm]
+kvm_page_track_init [kvm]
+kvm_page_track_write [kvm]
+kvm_page_track_flush_slot [kvm]
+kvm_mmu_set_mmio_spte_mask [kvm]
+kvm_mmu_set_mask_ptes [kvm]
+kvm_is_mmio_pfn [kvm]
+make_mmio_spte [kvm]
+make_nonleaf_spte [kvm]
+mark_spte_for_access_track [kvm]
+make_spte [kvm]
+kvm_mmu_changed_pte_notifier_make_spte [kvm]
+kvm_mmu_reset_all_pte_masks [kvm]
+round_gfn_for_level [kvm]
+tdp_iter_refresh_sptep [kvm]
+tdp_iter_start [kvm]
+spte_to_child_pt [kvm]
+tdp_iter_next [kvm]
+tdp_iter_refresh_walk [kvm]
+tdp_iter_root_pt [kvm]
+handle_changed_spte_acc_track [kvm]
+alloc_tdp_mmu_page [kvm]
+test_age_gfn [kvm]
+handle_changed_spte_dirty_log.part.0 [kvm]
+tdp_mmu_iter_cond_resched [kvm]
+tdp_mmu_iter_flush_cond_resched [kvm]
+__handle_changed_spte [kvm]
+kvm_tdp_mmu_handle_hva_range [kvm]
+zap_gfn_range [kvm]
+zap_gfn_range_hva_wrapper [kvm]
+age_gfn_range [kvm]
+set_tdp_spte [kvm]
+kvm_mmu_init_tdp_mmu [kvm]
+kvm_mmu_uninit_tdp_mmu [kvm]
+is_tdp_mmu_root [kvm]
+kvm_tdp_mmu_free_root [kvm]
+kvm_tdp_mmu_get_vcpu_root_hpa [kvm]
+kvm_tdp_mmu_zap_gfn_range [kvm]
+kvm_tdp_mmu_zap_all [kvm]
+kvm_tdp_mmu_map [kvm]
+kvm_tdp_mmu_zap_hva_range [kvm]
+kvm_tdp_mmu_age_hva_range [kvm]
+kvm_tdp_mmu_test_age_hva [kvm]
+kvm_tdp_mmu_set_spte_hva [kvm]
+kvm_tdp_mmu_wrprot_slot [kvm]
+kvm_tdp_mmu_clear_dirty_slot [kvm]
+kvm_tdp_mmu_clear_dirty_pt_masked [kvm]
+kvm_tdp_mmu_slot_set_dirty [kvm]
+kvm_tdp_mmu_zap_collapsible_sptes [kvm]
+kvm_tdp_mmu_write_protect_gfn [kvm]
+kvm_tdp_mmu_get_walk [kvm]
+kvm_reboot [kvm]
+vmx_can_emulate_instruction [kvm_intel]
+handle_machine_check [kvm_intel]
+enable_smi_window [kvm_intel]
+vmx_check_apicv_inhibit_reasons [kvm_intel]
+vmx_setup_uret_msr [kvm_intel]
+vmx_set_identity_map_addr [kvm_intel]
+handle_triple_fault [kvm_intel]
+vmx_patch_hypercall [kvm_intel]
+vmx_request_immediate_exit [kvm_intel]
+vmx_cancel_hv_timer [kvm_intel]
+vmx_setup_mce [kvm_intel]
+vmx_segment_cache_test_set [kvm_intel]
+vmx_apicv_post_state_restore [kvm_intel]
+vmx_set_guest_uret_msr [kvm_intel]
+nested_vmx_truncate_sysenter_addr [kvm_intel]
+free_kvm_area [kvm_intel]
+handle_invalid_op [kvm_intel]
+handle_xsetbv [kvm_intel]
+handle_invd [kvm_intel]
+handle_wbinvd [kvm_intel]
+handle_desc [kvm_intel]
+handle_tpr_below_threshold [kvm_intel]
+handle_vmcall [kvm_intel]
+handle_rdpmc [kvm_intel]
+kvm_fill_hv_flush_list_func [kvm_intel]
+vmx_set_hv_timer [kvm_intel]
+vmx_post_block [kvm_intel]
+vmx_enable_log_dirty_pt_masked [kvm_intel]
+vmx_flush_log_dirty [kvm_intel]
+vmx_slot_disable_log_dirty [kvm_intel]
+vmx_slot_enable_log_dirty [kvm_intel]
+handle_interrupt_nmi_irqoff [kvm_intel]
+kvm_machine_check [kvm_intel]
+vmx_check_intercept [kvm_intel]
+vmx_get_mt_mask [kvm_intel]
+vmx_update_emulated_instruction [kvm_intel]
+vmx_smi_allowed [kvm_intel]
+vmx_apic_init_signal_blocked [kvm_intel]
+handle_monitor [kvm_intel]
+handle_mwait [kvm_intel]
+vmx_get_msr_feature [kvm_intel]
+vmx_vm_init [kvm_intel]
+hardware_unsetup [kvm_intel]
+vmentry_l1d_flush_get [kvm_intel]
+vmx_segment_access_rights.part.0 [kvm_intel]
+handle_pause [kvm_intel]
+is_valid_passthrough_msr.part.0 [kvm_intel]
+is_valid_passthrough_msr [kvm_intel]
+vmx_set_msr_bitmap_read.part.0 [kvm_intel]
+vmx_set_msr_bitmap_write.part.0 [kvm_intel]
+vmx_migrate_timers [kvm_intel]
+vmx_pre_block [kvm_intel]
+vmx_msr_bitmap_mode [kvm_intel]
+vmx_has_emulated_msr [kvm_intel]
+vmx_setup_l1d_flush [kvm_intel]
+vmentry_l1d_flush_set [kvm_intel]
+handle_fastpath_preemption_timer [kvm_intel]
+handle_preemption_timer [kvm_intel]
+vmx_pre_leave_smm [kvm_intel]
+vmx_set_tss_addr [kvm_intel]
+hv_enable_direct_tlbflush [kvm_intel]
+handle_monitor_trap [kvm_intel]
+handle_vmx_instruction [kvm_intel]
+handle_encls [kvm_intel]
+vmx_sched_in [kvm_intel]
+hv_remote_flush_tlb_with_range [kvm_intel]
+hv_remote_flush_tlb [kvm_intel]
+vmx_deliver_posted_interrupt [kvm_intel]
+vmx_compute_secondary_exec_control [kvm_intel]
+vmx_prepare_switch_to_host [kvm_intel]
+vmx_vcpu_put [kvm_intel]
+vmx_get_interrupt_shadow [kvm_intel]
+vmx_get_nmi_mask [kvm_intel]
+handle_ept_misconfig [kvm_intel]
+vmx_guest_apic_has_interrupt [kvm_intel]
+handle_apic_write [kvm_intel]
+handle_apic_eoi_induced [kvm_intel]
+handle_invlpg [kvm_intel]
+vmx_get_gdt [kvm_intel]
+vmx_get_idt [kvm_intel]
+handle_io [kvm_intel]
+handle_apic_access [kvm_intel]
+vmx_get_rflags [kvm_intel]
+handle_invpcid [kvm_intel]
+vmx_read_guest_seg_selector [kvm_intel]
+vmx_get_exit_info [kvm_intel]
+vmx_handle_exit_irqoff [kvm_intel]
+vmx_read_guest_seg_ar [kvm_intel]
+vmx_get_cpl [kvm_intel]
+vmx_get_cs_db_l_bits [kvm_intel]
+vmx_read_guest_seg_base [kvm_intel]
+vmx_get_segment [kvm_intel]
+rmode_segment_valid [kvm_intel]
+data_segment_valid [kvm_intel]
+vmx_get_segment_base [kvm_intel]
+vmx_update_msr_bitmap_x2apic.part.0 [kvm_intel]
+vmread_error [kvm_intel]
+vmwrite_error [kvm_intel]
+vmx_set_interrupt_shadow [kvm_intel]
+skip_emulated_instruction [kvm_intel]
+vmx_skip_emulated_instruction [kvm_intel]
+handle_exception_nmi [kvm_intel]
+vmx_set_dr7 [kvm_intel]
+vmx_hwapic_isr_update [kvm_intel]
+vmx_set_rvi [kvm_intel]
+vmx_hwapic_irr_update [kvm_intel]
+vmx_sync_pir_to_irr [kvm_intel]
+handle_dr [kvm_intel]
+vmx_set_idt [kvm_intel]
+vmx_set_gdt [kvm_intel]
+seg_setup [kvm_intel]
+update_cr8_intercept [kvm_intel]
+vmx_write_l1_tsc_offset [kvm_intel]
+vmx_load_eoi_exitmap [kvm_intel]
+vmx_clear_hlt [kvm_intel]
+vmx_pre_enter_smm [kvm_intel]
+update_exception_bitmap [kvm_intel]
+vmx_set_nmi_mask [kvm_intel]
+handle_task_switch [kvm_intel]
+__vmx_complete_interrupts [kvm_intel]
+vmx_cancel_injection [kvm_intel]
+handle_pml_full [kvm_intel]
+fix_rmode_seg [kvm_intel]
+handle_ept_violation [kvm_intel]
+vmx_queue_exception [kvm_intel]
+vmx_inject_nmi [kvm_intel]
+vmx_inject_irq [kvm_intel]
+enable_irq_window [kvm_intel]
+handle_interrupt_window [kvm_intel]
+handle_nmi_window [kvm_intel]
+vmx_sync_dirty_debug_regs [kvm_intel]
+enable_nmi_window [kvm_intel]
+clear_atomic_switch_msr [kvm_intel]
+add_atomic_switch_msr.constprop.0 [kvm_intel]
+vmx_vcpu_run [kvm_intel]
+vmclear_error [kvm_intel]
+crash_vmclear_local_loaded_vmcss [kvm_intel]
+__loaded_vmcs_clear [kvm_intel]
+hardware_disable [kvm_intel]
+vmptrld_error [kvm_intel]
+invvpid_error [kvm_intel]
+vmx_flush_tlb_guest [kvm_intel]
+vmx_flush_tlb_gva [kvm_intel]
+invept_error [kvm_intel]
+vmx_flush_tlb_all [kvm_intel]
+hardware_enable [kvm_intel]
+vmx_find_uret_msr [kvm_intel]
+loaded_vmcs_clear [kvm_intel]
+vmx_find_loadstore_msr_slot [kvm_intel]
+vmx_set_host_fs_gs [kvm_intel]
+vmx_prepare_switch_to_guest [kvm_intel]
+vmx_vcpu_load_vmcs [kvm_intel]
+vmx_vcpu_load [kvm_intel]
+nested_vmx_allowed [kvm_intel]
+vmx_set_cr4 [kvm_intel]
+vmx_get_msr [kvm_intel]
+alloc_vmcs_cpu [kvm_intel]
+free_vmcs [kvm_intel]
+free_loaded_vmcs [kvm_intel]
+alloc_loaded_vmcs [kvm_intel]
+vmx_ept_load_pdptrs [kvm_intel]
+ept_save_pdptrs [kvm_intel]
+vmx_cache_reg [kvm_intel]
+construct_eptp [kvm_intel]
+vmx_load_mmu_pgd [kvm_intel]
+vmx_flush_tlb_current [kvm_intel]
+vmx_set_apic_access_page_addr [kvm_intel]
+__vmx_guest_state_valid [kvm_intel]
+emulation_required [kvm_intel]
+vmx_set_rflags [kvm_intel]
+vmx_set_segment [kvm_intel]
+fix_pmode_seg [kvm_intel]
+allocate_vpid [kvm_intel]
+free_vpid [kvm_intel]
+vmx_free_vcpu [kvm_intel]
+vmx_update_msr_bitmap [kvm_intel]
+setup_msrs [kvm_intel]
+vmx_set_efer [kvm_intel]
+vmx_set_cr0 [kvm_intel]
+handle_cr [kvm_intel]
+vmx_vcpu_reset [kvm_intel]
+vmx_set_virtual_apic_mode [kvm_intel]
+pt_update_intercept_for_msr [kvm_intel]
+vmx_msr_filter_changed [kvm_intel]
+vmx_set_msr [kvm_intel]
+vmx_set_constant_host_state [kvm_intel]
+set_cr4_guest_host_mask [kvm_intel]
+vmx_vcpu_after_set_cpuid [kvm_intel]
+vmx_pin_based_exec_ctrl [kvm_intel]
+vmx_refresh_apicv_exec_ctrl [kvm_intel]
+vmx_exec_control [kvm_intel]
+vmx_create_vcpu [kvm_intel]
+vmx_nmi_blocked [kvm_intel]
+vmx_nmi_allowed [kvm_intel]
+vmx_interrupt_blocked [kvm_intel]
+vmx_interrupt_allowed [kvm_intel]
+dump_vmcs [kvm_intel]
+vmx_handle_exit [kvm_intel]
+vmx_exit [kvm_intel]
+intel_find_fixed_event [kvm_intel]
+intel_msr_idx_to_pmc [kvm_intel]
+intel_is_valid_rdpmc_ecx [kvm_intel]
+intel_rdpmc_ecx_to_pmc [kvm_intel]
+intel_is_valid_msr [kvm_intel]
+intel_pmu_init [kvm_intel]
+intel_find_arch_event [kvm_intel]
+intel_pmc_is_enabled [kvm_intel]
+intel_pmu_refresh [kvm_intel]
+intel_pmc_idx_to_pmc [kvm_intel]
+intel_pmu_reset [kvm_intel]
+intel_pmu_set_msr [kvm_intel]
+intel_pmu_get_msr [kvm_intel]
+nested_enlightened_vmentry [kvm_intel]
+nested_get_evmcs_version [kvm_intel]
+nested_evmcs_filter_control_msr [kvm_intel]
+nested_evmcs_check_controls [kvm_intel]
+nested_enable_evmcs [kvm_intel]
+is_shadow_field_rw [kvm_intel]
+nested_vmx_failInvalid [kvm_intel]
+nested_vmx_succeed [kvm_intel]
+copy_enlightened_to_vmcs12 [kvm_intel]
+nested_vmx_fail [kvm_intel]
+nested_vmx_disable_intercept_for_msr [kvm_intel]
+nested_vmx_calc_efer [kvm_intel]
+nested_vmx_preemption_timer_pending [kvm_intel]
+nested_vmx_check_exception [kvm_intel]
+vmx_switch_vmcs [kvm_intel]
+nested_vmx_write_pml_buffer [kvm_intel]
+nested_vmx_check_msr_switch.part.0 [kvm_intel]
+nested_vmx_check_permission [kvm_intel]
+nested_vmx_handle_enlightened_vmptrld [kvm_intel]
+vmx_preemption_timer_fn [kvm_intel]
+nested_vmx_abort [kvm_intel]
+nested_vmx_transition_tlb_flush [kvm_intel]
+nested_vmx_update_pending_dbg [kvm_intel]
+enter_vmx_operation [kvm_intel]
+nested_vmx_exit_handled_vmcs_access.part.0 [kvm_intel]
+copy_shadow_to_vmcs12 [kvm_intel]
+sync_vmcs02_to_vmcs12_rare [kvm_intel]
+copy_vmcs02_to_vmcs12_rare [kvm_intel]
+vmx_disable_shadow_vmcs [kvm_intel]
+free_nested [kvm_intel]
+handle_vmoff [kvm_intel]
+nested_vmx_msr_check_common [kvm_intel]
+nested_vmx_load_msr_check [kvm_intel]
+nested_vmx_load_msr [kvm_intel]
+read_and_check_msr_entry [kvm_intel]
+prepare_vmcs02_rare [kvm_intel]
+set_current_vmptr [kvm_intel]
+nested_vmx_check_guest_state [kvm_intel]
+nested_vmx_check_host_state [kvm_intel]
+nested_get_vmcs12_pages [kvm_intel]
+nested_vmx_load_cr3 [kvm_intel]
+load_vmcs12_host_state [kvm_intel]
+prepare_vmcs02_early [kvm_intel]
+sync_vmcs02_to_vmcs12 [kvm_intel]
+vmx_get_nested_state [kvm_intel]
+nested_vmx_check_eptp [kvm_intel]
+nested_vmx_check_controls [kvm_intel]
+vmx_set_vmx_msr [kvm_intel]
+vmx_get_vmx_msr [kvm_intel]
+nested_sync_vmcs12_to_shadow [kvm_intel]
+nested_vmx_enter_non_root_mode [kvm_intel]
+nested_vmx_run [kvm_intel]
+handle_vmresume [kvm_intel]
+handle_vmlaunch [kvm_intel]
+nested_mark_vmcs12_pages_dirty [kvm_intel]
+nested_vmx_vmexit [kvm_intel]
+handle_vmfunc [kvm_intel]
+vmx_inject_page_fault_nested [kvm_intel]
+nested_ept_inject_page_fault [kvm_intel]
+nested_vmx_inject_exception_vmexit [kvm_intel]
+vmx_check_nested_events [kvm_intel]
+get_vmx_mem_address [kvm_intel]
+handle_invvpid [kvm_intel]
+handle_invept [kvm_intel]
+nested_vmx_get_vmptr [kvm_intel]
+handle_vmon [kvm_intel]
+handle_vmptrld [kvm_intel]
+handle_vmclear [kvm_intel]
+handle_vmwrite [kvm_intel]
+handle_vmread [kvm_intel]
+handle_vmptrst [kvm_intel]
+nested_vmx_pmu_entry_exit_ctls_update [kvm_intel]
+nested_vmx_check_io_bitmaps [kvm_intel]
+nested_vmx_reflect_vmexit [kvm_intel]
+vmx_leave_nested [kvm_intel]
+nested_vmx_free_vcpu [kvm_intel]
+vmx_set_nested_state [kvm_intel]
+nested_vmx_set_vmcs_shadowing_bitmap [kvm_intel]
+nested_vmx_setup_ctls_msrs [kvm_intel]
+nested_vmx_hardware_unsetup [kvm_intel]
+__pi_post_block [kvm_intel]
+vmx_vcpu_pi_load [kvm_intel]
+vmx_vcpu_pi_put [kvm_intel]
+pi_pre_block [kvm_intel]
+pi_post_block [kvm_intel]
+pi_wakeup_handler [kvm_intel]
+pi_has_pending_interrupt [kvm_intel]
+pi_update_irte [kvm_intel]
+vmx_dump_dtsel [kvm_intel]
+vmx_dump_sel [kvm_intel]
+show_ttarget [coretemp]
+show_tjmax [coretemp]
+show_crit_alarm [coretemp]
+coretemp_probe [coretemp]
+coretemp_cpu_offline [coretemp]
+show_label [coretemp]
+show_temp [coretemp]
+create_core_data [coretemp]
+coretemp_remove [coretemp]
+coretemp_cpu_online [coretemp]
+duration_set [intel_powerclamp]
+window_size_set [intel_powerclamp]
+powerclamp_get_max_state [intel_powerclamp]
+start_power_clamp_worker [intel_powerclamp]
+stop_power_clamp_worker [intel_powerclamp]
+powerclamp_debug_open [intel_powerclamp]
+powerclamp_debug_show [intel_powerclamp]
+pkg_state_counter [intel_powerclamp]
+powerclamp_get_cur_state [intel_powerclamp]
+poll_pkg_cstate [intel_powerclamp]
+clamp_idle_injection_func [intel_powerclamp]
+clamp_balancing_func [intel_powerclamp]
+powerclamp_cpu_online [intel_powerclamp]
+powerclamp_cpu_predown [intel_powerclamp]
+powerclamp_set_cur_state [intel_powerclamp]
+end_power_clamp [intel_powerclamp]
+snd_use_lock_sync_helper [snd_seq]
+snd_seq_ioctl_pversion [snd_seq]
+snd_seq_ioctl_client_id [snd_seq]
+snd_seq_ioctl_get_queue_timer [snd_seq]
+snd_seq_ioctl_get_queue_tempo [snd_seq]
+update_timestamp_of_queue [snd_seq]
+snd_seq_ioctl_get_queue_status [snd_seq]
+snd_seq_set_queue_tempo [snd_seq]
+snd_seq_ioctl_set_queue_tempo [snd_seq]
+snd_seq_ioctl_get_queue_client [snd_seq]
+snd_seq_ioctl_remove_events [snd_seq]
+get_client_info [snd_seq]
+snd_seq_ioctl_set_queue_client [snd_seq]
+snd_seq_ioctl_set_queue_timer [snd_seq]
+snd_seq_ioctl_get_named_queue [snd_seq]
+snd_seq_ioctl_set_queue_info [snd_seq]
+snd_seq_ioctl_set_client_info [snd_seq]
+snd_seq_ioctl_get_queue_info [snd_seq]
+snd_seq_ioctl_delete_queue [snd_seq]
+snd_seq_ioctl_create_queue [snd_seq]
+snd_seq_ioctl_set_port_info [snd_seq]
+snd_seq_ioctl_delete_port [snd_seq]
+snd_seq_ioctl_create_port [snd_seq]
+snd_seq_ioctl_system_info [snd_seq]
+snd_seq_info_dump_subscribers [snd_seq]
+snd_seq_poll [snd_seq]
+snd_seq_read [snd_seq]
+clientptr.part.0 [snd_seq]
+snd_seq_kernel_client_write_poll [snd_seq]
+check_event_type_and_length [snd_seq]
+check_subscription_permission [snd_seq]
+snd_seq_kernel_client_ctl [snd_seq]
+snd_seq_call_port_info_ioctl [snd_seq]
+snd_seq_ioctl [snd_seq]
+snd_seq_ioctl_compat [snd_seq]
+seq_free_client1.part.0 [snd_seq]
+seq_free_client [snd_seq]
+snd_seq_delete_kernel_client [snd_seq]
+snd_seq_release [snd_seq]
+seq_create_client1 [snd_seq]
+snd_seq_create_kernel_client [snd_seq]
+snd_seq_open [snd_seq]
+snd_seq_client_use_ptr [snd_seq]
+snd_seq_client_ioctl_lock [snd_seq]
+snd_seq_client_ioctl_unlock [snd_seq]
+snd_seq_ioctl_query_subs [snd_seq]
+snd_seq_ioctl_query_next_port [snd_seq]
+snd_seq_ioctl_query_next_client [snd_seq]
+snd_seq_ioctl_get_subscription [snd_seq]
+snd_seq_ioctl_get_client_pool [snd_seq]
+snd_seq_ioctl_set_client_pool [snd_seq]
+snd_seq_ioctl_get_port_info [snd_seq]
+snd_seq_ioctl_get_client_info [snd_seq]
+snd_seq_ioctl_running_mode [snd_seq]
+snd_seq_deliver_single_event.constprop.0 [snd_seq]
+snd_seq_deliver_event [snd_seq]
+snd_seq_kernel_client_dispatch [snd_seq]
+snd_seq_client_enqueue_event.constprop.0 [snd_seq]
+snd_seq_kernel_client_enqueue [snd_seq]
+snd_seq_write [snd_seq]
+snd_seq_dispatch_event [snd_seq]
+snd_seq_client_notify_subscription [snd_seq]
+snd_seq_ioctl_unsubscribe_port [snd_seq]
+snd_seq_ioctl_subscribe_port [snd_seq]
+snd_seq_info_clients_read [snd_seq]
+snd_sequencer_device_done [snd_seq]
+seq_copy_in_user [snd_seq]
+seq_copy_in_kernel [snd_seq]
+snd_seq_cell_alloc.isra.0 [snd_seq]
+snd_seq_dump_var_event [snd_seq]
+snd_seq_expand_var_event [snd_seq]
+snd_seq_cell_free [snd_seq]
+snd_seq_event_dup [snd_seq]
+snd_seq_pool_poll_wait [snd_seq]
+snd_seq_pool_init [snd_seq]
+snd_seq_pool_mark_closing [snd_seq]
+snd_seq_pool_done [snd_seq]
+snd_seq_pool_new [snd_seq]
+snd_seq_pool_delete [snd_seq]
+snd_seq_info_pool [snd_seq]
+queue_delete [snd_seq]
+queue_use [snd_seq]
+queue_broadcast_event [snd_seq]
+queue_access_lock [snd_seq]
+queue_list_remove [snd_seq]
+snd_seq_queue_get_cur_queues [snd_seq]
+snd_seq_queues_delete [snd_seq]
+snd_seq_queue_alloc [snd_seq]
+snd_seq_queue_delete [snd_seq]
+queueptr [snd_seq]
+snd_seq_queue_find_name [snd_seq]
+snd_seq_check_queue [snd_seq]
+snd_seq_enqueue_event [snd_seq]
+snd_seq_queue_check_access [snd_seq]
+snd_seq_queue_set_owner [snd_seq]
+snd_seq_queue_timer_open [snd_seq]
+snd_seq_queue_timer_close [snd_seq]
+snd_seq_queue_timer_set_tempo [snd_seq]
+snd_seq_queue_use [snd_seq]
+snd_seq_queue_is_used [snd_seq]
+snd_seq_queue_client_termination [snd_seq]
+snd_seq_queue_client_leave [snd_seq]
+snd_seq_queue_client_leave_cells [snd_seq]
+snd_seq_queue_remove_cells [snd_seq]
+snd_seq_control_queue [snd_seq]
+snd_seq_info_queues_read [snd_seq]
+snd_seq_fifo_new [snd_seq]
+snd_seq_fifo_clear [snd_seq]
+snd_seq_fifo_delete [snd_seq]
+snd_seq_fifo_event_in [snd_seq]
+snd_seq_fifo_cell_out [snd_seq]
+snd_seq_fifo_cell_putback [snd_seq]
+snd_seq_fifo_poll_wait [snd_seq]
+snd_seq_fifo_resize [snd_seq]
+snd_seq_fifo_unused_cells [snd_seq]
+snd_seq_prioq_new [snd_seq]
+snd_seq_prioq_cell_in [snd_seq]
+snd_seq_prioq_cell_out [snd_seq]
+snd_seq_prioq_delete [snd_seq]
+snd_seq_prioq_avail [snd_seq]
+snd_seq_prioq_leave [snd_seq]
+snd_seq_prioq_remove_events [snd_seq]
+snd_seq_timer_set_tick_resolution [snd_seq]
+snd_seq_timer_interrupt [snd_seq]
+initialize_timer [snd_seq]
+snd_seq_timer_defaults [snd_seq]
+snd_seq_timer_reset [snd_seq]
+snd_seq_timer_new [snd_seq]
+snd_seq_timer_set_tempo [snd_seq]
+snd_seq_timer_set_tempo_ppq [snd_seq]
+snd_seq_timer_set_position_tick [snd_seq]
+snd_seq_timer_set_position_time [snd_seq]
+snd_seq_timer_set_skew [snd_seq]
+snd_seq_timer_open [snd_seq]
+snd_seq_timer_close [snd_seq]
+snd_seq_timer_stop [snd_seq]
+snd_seq_timer_delete [snd_seq]
+snd_seq_timer_start [snd_seq]
+snd_seq_timer_continue [snd_seq]
+snd_seq_timer_get_cur_time [snd_seq]
+snd_seq_timer_get_cur_tick [snd_seq]
+snd_seq_info_timer_read [snd_seq]
+event_input_timer [snd_seq]
+snd_seq_system_broadcast [snd_seq]
+snd_seq_system_notify [snd_seq]
+snd_seq_system_client_done [snd_seq]
+snd_seq_event_port_attach [snd_seq]
+snd_seq_event_port_detach [snd_seq]
+match_subs_info [snd_seq]
+check_and_subscribe_port [snd_seq]
+delete_and_unsubscribe_port [snd_seq]
+snd_seq_port_use_ptr [snd_seq]
+get_client_port [snd_seq]
+clear_subscriber_list [snd_seq]
+port_delete [snd_seq]
+snd_seq_port_query_nearest [snd_seq]
+snd_seq_create_port [snd_seq]
+snd_seq_delete_port [snd_seq]
+snd_seq_delete_all_ports [snd_seq]
+snd_seq_set_port_info [snd_seq]
+snd_seq_get_port_info [snd_seq]
+snd_seq_port_connect [snd_seq]
+snd_seq_port_disconnect [snd_seq]
+snd_seq_port_get_subscription [snd_seq]
+snd_seq_info_done [snd_seq]
+pkg_thermal_rate_control [x86_pkg_temp_thermal]
+pkg_thermal_schedule_work [x86_pkg_temp_thermal]
+sys_get_trip_type [x86_pkg_temp_thermal]
+sys_set_trip_temp [x86_pkg_temp_thermal]
+sys_get_curr_temp [x86_pkg_temp_thermal]
+pkg_thermal_notify [x86_pkg_temp_thermal]
+sys_get_trip_temp [x86_pkg_temp_thermal]
+pkg_temp_thermal_threshold_work_fn [x86_pkg_temp_thermal]
+pkg_thermal_cpu_offline [x86_pkg_temp_thermal]
+pkg_thermal_cpu_online [x86_pkg_temp_thermal]
+uni2char [nls_iso8859_1]
+char2uni [nls_iso8859_1]
+power_limit_irq_save_cpu [intel_rapl_common]
+rapl_find_package_domain [intel_rapl_common]
+rapl_unit_xlate [intel_rapl_common]
+get_max_energy_counter [intel_rapl_common]
+rapl_check_unit_atom [intel_rapl_common]
+rapl_check_unit_core [intel_rapl_common]
+rapl_read_data_raw [intel_rapl_common]
+contraint_to_pl [intel_rapl_common]
+get_constraint_name [intel_rapl_common]
+set_floor_freq_atom [intel_rapl_common]
+rapl_write_data_raw [intel_rapl_common]
+set_floor_freq_default [intel_rapl_common]
+rapl_remove_package [intel_rapl_common]
+release_zone [intel_rapl_common]
+get_max_power [intel_rapl_common]
+get_time_window [intel_rapl_common]
+set_time_window [intel_rapl_common]
+get_current_power_limit [intel_rapl_common]
+get_domain_enable [intel_rapl_common]
+set_domain_enable [intel_rapl_common]
+get_energy_counter [intel_rapl_common]
+rapl_pm_callback [intel_rapl_common]
+set_power_limit [intel_rapl_common]
+rapl_compute_time_window_atom [intel_rapl_common]
+rapl_compute_time_window_core [intel_rapl_common]
+rapl_add_package [intel_rapl_common]
+release_rawmidi_device [snd_rawmidi]
+snd_rawmidi_input_event_work [snd_rawmidi]
+reset_runtime_ptrs [snd_rawmidi]
+snd_rawmidi_dev_seq_free [snd_rawmidi]
+snd_rawmidi_set_ops [snd_rawmidi]
+snd_rawmidi_free_substreams [snd_rawmidi]
+snd_rawmidi_info [snd_rawmidi]
+snd_rawmidi_info_select [snd_rawmidi]
+__snd_rawmidi_transmit_peek [snd_rawmidi]
+snd_rawmidi_transmit_peek [snd_rawmidi]
+__snd_rawmidi_transmit_ack [snd_rawmidi]
+snd_rawmidi_transmit_ack [snd_rawmidi]
+snd_rawmidi_proceed [snd_rawmidi]
+snd_rawmidi_info_user [snd_rawmidi]
+snd_rawmidi_info_select_user [snd_rawmidi]
+snd_rawmidi_control_ioctl [snd_rawmidi]
+snd_rawmidi_kernel_read1 [snd_rawmidi]
+snd_rawmidi_dev_disconnect [snd_rawmidi]
+snd_rawmidi_dev_register [snd_rawmidi]
+assign_substream [snd_rawmidi]
+snd_rawmidi_transmit [snd_rawmidi]
+snd_rawmidi_receive [snd_rawmidi]
+snd_rawmidi_proc_info_read [snd_rawmidi]
+snd_rawmidi_transmit_empty [snd_rawmidi]
+snd_rawmidi_free [snd_rawmidi]
+snd_rawmidi_dev_free [snd_rawmidi]
+snd_rawmidi_input_trigger [snd_rawmidi]
+snd_rawmidi_drain_input [snd_rawmidi]
+snd_rawmidi_poll [snd_rawmidi]
+snd_rawmidi_kernel_read [snd_rawmidi]
+snd_rawmidi_alloc_substreams [snd_rawmidi]
+snd_rawmidi_new [snd_rawmidi]
+open_substream [snd_rawmidi]
+snd_rawmidi_drop_output [snd_rawmidi]
+snd_rawmidi_drain_output [snd_rawmidi]
+snd_rawmidi_kernel_write1 [snd_rawmidi]
+snd_rawmidi_kernel_write [snd_rawmidi]
+close_substream.part.0 [snd_rawmidi]
+rawmidi_open_priv [snd_rawmidi]
+snd_rawmidi_kernel_open [snd_rawmidi]
+snd_rawmidi_open [snd_rawmidi]
+rawmidi_release_priv [snd_rawmidi]
+snd_rawmidi_kernel_release [snd_rawmidi]
+snd_rawmidi_release [snd_rawmidi]
+snd_rawmidi_output_status [snd_rawmidi]
+snd_rawmidi_input_status [snd_rawmidi]
+snd_rawmidi_ioctl_status32 [snd_rawmidi]
+snd_rawmidi_ioctl_status64 [snd_rawmidi]
+snd_rawmidi_ioctl_status_compat64 [snd_rawmidi]
+snd_rawmidi_read [snd_rawmidi]
+snd_rawmidi_write [snd_rawmidi]
+resize_runtime_buffer [snd_rawmidi]
+snd_rawmidi_input_params [snd_rawmidi]
+snd_rawmidi_output_params [snd_rawmidi]
+snd_rawmidi_ioctl [snd_rawmidi]
+snd_rawmidi_ioctl_compat [snd_rawmidi]
+rapl_msr_remove [intel_rapl_msr]
+rapl_cpu_online [intel_rapl_msr]
+rapl_msr_update_func [intel_rapl_msr]
+rapl_cpu_down_prep [intel_rapl_msr]
+rapl_msr_write_raw [intel_rapl_msr]
+rapl_msr_read_raw [intel_rapl_msr]
+rapl_msr_probe [intel_rapl_msr]
+snd_midi_event_reset_encode [snd_seq_midi_event]
+snd_midi_event_reset_decode [snd_seq_midi_event]
+snd_midi_event_no_status [snd_seq_midi_event]
+note_event [snd_seq_midi_event]
+one_param_ctrl_event [snd_seq_midi_event]
+pitchbend_ctrl_event [snd_seq_midi_event]
+two_param_ctrl_event [snd_seq_midi_event]
+one_param_event [snd_seq_midi_event]
+songpos_event [snd_seq_midi_event]
+note_decode [snd_seq_midi_event]
+one_param_decode [snd_seq_midi_event]
+pitchbend_decode [snd_seq_midi_event]
+two_param_decode [snd_seq_midi_event]
+songpos_decode [snd_seq_midi_event]
+extra_decode_ctrl14 [snd_seq_midi_event]
+extra_decode_xrpn [snd_seq_midi_event]
+snd_midi_event_decode [snd_seq_midi_event]
+snd_midi_event_encode_byte [snd_seq_midi_event]
+snd_midi_event_free [snd_seq_midi_event]
+snd_midi_event_new [snd_seq_midi_event]
+snd_seq_midisynth_delete [snd_seq_midi]
+snd_seq_midisynth_remove [snd_seq_midi]
+midisynth_unuse [snd_seq_midi]
+midisynth_unsubscribe [snd_seq_midi]
+midisynth_use [snd_seq_midi]
+midisynth_subscribe [snd_seq_midi]
+snd_midi_input_event [snd_seq_midi]
+dump_midi [snd_seq_midi]
+event_process_midi [snd_seq_midi]
+snd_seq_midisynth_probe [snd_seq_midi]
+snd_pcm_format_name [snd_pcm]
+show_pcm_class [snd_pcm]
+snd_pcm_substream_proc_sw_params_read [snd_pcm]
+snd_pcm_substream_proc_hw_params_read [snd_pcm]
+snd_pcm_proc_read [snd_pcm]
+snd_pcm_substream_proc_status_read [snd_pcm]
+snd_pcm_free_stream [snd_pcm]
+snd_pcm_dev_disconnect [snd_pcm]
+snd_pcm_control_ioctl [snd_pcm]
+snd_pcm_dev_register [snd_pcm]
+do_pcm_suspend [snd_pcm]
+snd_pcm_free [snd_pcm]
+snd_pcm_dev_free [snd_pcm]
+snd_pcm_proc_info_read.part.0 [snd_pcm]
+snd_pcm_stream_proc_info_read [snd_pcm]
+snd_pcm_substream_proc_info_read [snd_pcm]
+snd_pcm_new_stream [snd_pcm]
+_snd_pcm_new [snd_pcm]
+snd_pcm_new [snd_pcm]
+snd_pcm_new_internal [snd_pcm]
+snd_pcm_attach_substream [snd_pcm]
+snd_pcm_detach_substream [snd_pcm]
+snd_pcm_post_drain_init [snd_pcm]
+snd_pcm_action_single [snd_pcm]
+snd_pcm_pre_start [snd_pcm]
+snd_pcm_pre_stop [snd_pcm]
+snd_pcm_pre_pause [snd_pcm]
+snd_pcm_pre_suspend [snd_pcm]
+snd_pcm_pre_resume [snd_pcm]
+snd_pcm_pre_reset [snd_pcm]
+snd_pcm_pre_prepare [snd_pcm]
+snd_pcm_pre_drain_init [snd_pcm]
+snd_pcm_mmap_status_fault [snd_pcm]
+snd_pcm_mmap_control_fault [snd_pcm]
+snd_pcm_hw_convert_from_old_params [snd_pcm]
+snd_pcm_hw_convert_to_old_params [snd_pcm]
+snd_pcm_hw_rule_buffer_bytes_max [snd_pcm]
+snd_pcm_do_pause [snd_pcm]
+do_pcm_hwsync [snd_pcm]
+snd_pcm_post_reset [snd_pcm]
+snd_pcm_hw_rule_muldivk [snd_pcm]
+snd_pcm_hw_rule_mulkdiv [snd_pcm]
+snd_pcm_hw_rule_mul [snd_pcm]
+snd_pcm_hw_rule_div [snd_pcm]
+snd_pcm_hw_rule_sample_bits [snd_pcm]
+snd_pcm_hw_rule_rate [snd_pcm]
+snd_pcm_ops_ioctl [snd_pcm]
+snd_pcm_do_reset [snd_pcm]
+snd_pcm_mmap_data_fault [snd_pcm]
+snd_pcm_lib_mmap_iomem [snd_pcm]
+snd_pcm_read [snd_pcm]
+snd_pcm_write [snd_pcm]
+snd_pcm_ioctl_xferi_compat [snd_pcm]
+snd_pcm_fasync [snd_pcm]
+snd_pcm_stream_lock [snd_pcm]
+snd_pcm_stream_lock_irq [snd_pcm]
+_snd_pcm_stream_lock_irqsave [snd_pcm]
+snd_pcm_stream_lock_nested [snd_pcm]
+snd_pcm_stream_unlock_irqrestore [snd_pcm]
+snd_pcm_stop_xrun [snd_pcm]
+snd_pcm_action_group [snd_pcm]
+snd_pcm_action_nonatomic [snd_pcm]
+snd_pcm_do_stop [snd_pcm]
+snd_pcm_undo_pause [snd_pcm]
+snd_pcm_undo_resume [snd_pcm]
+snd_pcm_do_resume [snd_pcm]
+hw_support_mmap [snd_pcm]
+snd_pcm_lib_default_mmap [snd_pcm]
+snd_pcm_mmap_data [snd_pcm]
+snd_pcm_mmap [snd_pcm]
+snd_pcm_sync_stop [snd_pcm]
+do_hw_free [snd_pcm]
+snd_pcm_do_prepare [snd_pcm]
+fixup_unreferenced_params [snd_pcm]
+snd_pcm_do_start [snd_pcm]
+snd_pcm_undo_start [snd_pcm]
+snd_pcm_do_suspend [snd_pcm]
+snd_pcm_hw_rule_format [snd_pcm]
+snd_pcm_trigger_tstamp [snd_pcm]
+snd_pcm_post_start [snd_pcm]
+snd_pcm_post_stop [snd_pcm]
+snd_pcm_do_drain_init [snd_pcm]
+snd_pcm_post_suspend [snd_pcm]
+snd_pcm_post_pause [snd_pcm]
+snd_pcm_post_resume [snd_pcm]
+snd_pcm_stream_unlock [snd_pcm]
+relink_to_local [snd_pcm]
+snd_pcm_hw_refine [snd_pcm]
+snd_pcm_group_unref.part.0 [snd_pcm]
+snd_pcm_stream_group_ref [snd_pcm]
+snd_pcm_action [snd_pcm]
+snd_pcm_stop [snd_pcm]
+snd_pcm_suspend_all [snd_pcm]
+snd_pcm_stream_unlock_irq [snd_pcm]
+snd_pcm_set_state [snd_pcm]
+snd_pcm_post_prepare [snd_pcm]
+snd_pcm_poll [snd_pcm]
+snd_pcm_delay [snd_pcm]
+snd_pcm_hwsync [snd_pcm]
+snd_pcm_forward.part.0 [snd_pcm]
+snd_pcm_sync_ptr [snd_pcm]
+snd_pcm_rewind.part.0 [snd_pcm]
+snd_pcm_channel_info [snd_pcm]
+snd_pcm_channel_info_user [snd_pcm]
+snd_pcm_sw_params [snd_pcm]
+snd_pcm_sw_params_user [snd_pcm]
+snd_pcm_ioctl_sw_params_compat [snd_pcm]
+snd_pcm_drop [snd_pcm]
+snd_pcm_release_substream.part.0 [snd_pcm]
+snd_pcm_release_substream [snd_pcm]
+snd_pcm_open_substream [snd_pcm]
+snd_pcm_open [snd_pcm]
+snd_pcm_capture_open [snd_pcm]
+snd_pcm_playback_open [snd_pcm]
+snd_pcm_release [snd_pcm]
+snd_pcm_prepare [snd_pcm]
+snd_pcm_action_lock_irq [snd_pcm]
+snd_pcm_drain [snd_pcm]
+snd_pcm_hw_params [snd_pcm]
+snd_pcm_ioctl_hw_params_compat [snd_pcm]
+snd_pcm_kernel_ioctl [snd_pcm]
+snd_pcm_unlink [snd_pcm]
+pcm_release_private [snd_pcm]
+snd_pcm_writev [snd_pcm]
+snd_pcm_readv [snd_pcm]
+snd_pcm_ioctl_xfern_compat [snd_pcm]
+snd_pcm_group_init [snd_pcm]
+snd_pcm_info [snd_pcm]
+snd_pcm_info_user [snd_pcm]
+snd_pcm_status64 [snd_pcm]
+snd_pcm_status_user64 [snd_pcm]
+snd_pcm_status_user32 [snd_pcm]
+snd_pcm_common_ioctl [snd_pcm]
+snd_pcm_ioctl [snd_pcm]
+snd_pcm_status_user_compat64 [snd_pcm]
+snd_pcm_ioctl_compat [snd_pcm]
+snd_pcm_start [snd_pcm]
+snd_pcm_drain_done [snd_pcm]
+snd_pcm_hw_constraint_integer [snd_pcm]
+snd_pcm_set_ops [snd_pcm]
+snd_pcm_set_sync [snd_pcm]
+interleaved_copy [snd_pcm]
+pcm_chmap_ctl_info [snd_pcm]
+fill_silence [snd_pcm]
+noninterleaved_copy [snd_pcm]
+valid_chmap_channels [snd_pcm]
+pcm_chmap_ctl_tlv [snd_pcm]
+snd_pcm_hw_rule_add [snd_pcm]
+snd_pcm_hw_constraint_list [snd_pcm]
+snd_pcm_hw_constraint_ranges [snd_pcm]
+snd_pcm_hw_constraint_ratnums [snd_pcm]
+snd_pcm_hw_constraint_ratdens [snd_pcm]
+snd_pcm_hw_constraint_msbits [snd_pcm]
+snd_pcm_hw_constraint_step [snd_pcm]
+snd_pcm_hw_constraint_pow2 [snd_pcm]
+snd_pcm_hw_rule_noresample [snd_pcm]
+snd_pcm_hw_constraint_mask64 [snd_pcm]
+pcm_chmap_ctl_get [snd_pcm]
+default_read_copy [snd_pcm]
+default_read_copy_kernel [snd_pcm]
+default_write_copy_kernel [snd_pcm]
+pcm_chmap_ctl_private_free [snd_pcm]
+_snd_pcm_hw_param_any [snd_pcm]
+_snd_pcm_hw_params_any [snd_pcm]
+snd_pcm_add_chmap_ctls [snd_pcm]
+snd_pcm_hw_rule_msbits [snd_pcm]
+snd_pcm_hw_rule_step [snd_pcm]
+snd_pcm_hw_param_value [snd_pcm]
+snd_pcm_hw_param_last [snd_pcm]
+snd_interval_refine [snd_pcm]
+snd_pcm_hw_constraint_minmax [snd_pcm]
+snd_interval_ranges [snd_pcm]
+snd_pcm_hw_rule_ranges [snd_pcm]
+snd_interval_ratnum [snd_pcm]
+snd_pcm_hw_rule_ratnums [snd_pcm]
+snd_interval_list [snd_pcm]
+snd_pcm_hw_rule_list [snd_pcm]
+snd_pcm_hw_rule_pow2 [snd_pcm]
+snd_pcm_hw_rule_noresample_func [snd_pcm]
+snd_pcm_hw_rule_ratdens [snd_pcm]
+default_write_copy [snd_pcm]
+_snd_pcm_hw_param_setempty [snd_pcm]
+snd_pcm_hw_param_first [snd_pcm]
+update_audio_tstamp [snd_pcm]
+snd_pcm_playback_silence [snd_pcm]
+__snd_pcm_xrun [snd_pcm]
+snd_pcm_update_state [snd_pcm]
+snd_pcm_update_hw_ptr0 [snd_pcm]
+snd_pcm_period_elapsed [snd_pcm]
+snd_pcm_lib_ioctl [snd_pcm]
+__snd_pcm_lib_xfer [snd_pcm]
+snd_pcm_update_hw_ptr [snd_pcm]
+snd_interval_mul [snd_pcm]
+snd_interval_div [snd_pcm]
+snd_interval_muldivk [snd_pcm]
+snd_interval_mulkdiv [snd_pcm]
+snd_pcm_hw_constraint_mask [snd_pcm]
+pcm_lib_apply_appl_ptr [snd_pcm]
+snd_pcm_format_signed [snd_pcm]
+snd_pcm_format_unsigned [snd_pcm]
+snd_pcm_format_linear [snd_pcm]
+snd_pcm_format_little_endian [snd_pcm]
+snd_pcm_format_big_endian [snd_pcm]
+snd_pcm_format_width [snd_pcm]
+snd_pcm_format_physical_width [snd_pcm]
+snd_pcm_format_size [snd_pcm]
+snd_pcm_format_silence_64 [snd_pcm]
+snd_pcm_rate_mask_intersect [snd_pcm]
+snd_pcm_hw_limit_rates [snd_pcm]
+snd_pcm_rate_to_rate_bit [snd_pcm]
+snd_pcm_rate_bit_to_rate [snd_pcm]
+snd_pcm_rate_range_to_bits [snd_pcm]
+snd_pcm_format_set_silence [snd_pcm]
+do_free_pages [snd_pcm]
+do_alloc_pages [snd_pcm]
+preallocate_pages [snd_pcm]
+snd_pcm_lib_preallocate_pages [snd_pcm]
+snd_pcm_set_managed_buffer [snd_pcm]
+snd_pcm_set_managed_buffer_all [snd_pcm]
+snd_pcm_lib_preallocate_max_proc_read [snd_pcm]
+snd_pcm_lib_preallocate_proc_read [snd_pcm]
+snd_pcm_lib_preallocate_free_for_all [snd_pcm]
+snd_pcm_lib_preallocate_proc_write [snd_pcm]
+snd_pcm_lib_free_pages [snd_pcm]
+snd_pcm_lib_free_vmalloc_buffer [snd_pcm]
+_snd_pcm_lib_alloc_vmalloc_buffer [snd_pcm]
+snd_pcm_lib_get_vmalloc_page [snd_pcm]
+snd_pcm_lib_malloc_pages [snd_pcm]
+snd_pcm_lib_preallocate_pages_for_all [snd_pcm]
+snd_pcm_lib_preallocate_free [snd_pcm]
+snd_pcm_sgbuf_ops_page [snd_pcm]
+snd_dma_alloc_pages [snd_pcm]
+snd_dma_alloc_pages_fallback [snd_pcm]
+snd_dma_free_pages [snd_pcm]
+snd_pcm_timer_resolution [snd_pcm]
+snd_pcm_timer_start [snd_pcm]
+snd_pcm_timer_stop [snd_pcm]
+snd_pcm_timer_free [snd_pcm]
+snd_pcm_timer_resolution_change [snd_pcm]
+snd_pcm_timer_init [snd_pcm]
+snd_pcm_timer_done [snd_pcm]
+snd_sgbuf_get_chunk_size [snd_pcm]
+snd_free_sgbuf_pages [snd_pcm]
+snd_malloc_sgbuf_pages [snd_pcm]
+eld_limit_channels [snd_pcm]
+eld_limit_rates [snd_pcm]
+snd_pcm_hw_constraint_eld [snd_pcm]
+create_iec958_consumer [snd_pcm]
+snd_pcm_create_iec958_consumer_hw_params [snd_pcm]
+snd_pcm_create_iec958_consumer [snd_pcm]
+release_hwdep_device [snd_hwdep]
+snd_hwdep_llseek [snd_hwdep]
+snd_hwdep_read [snd_hwdep]
+snd_hwdep_write [snd_hwdep]
+snd_hwdep_poll [snd_hwdep]
+snd_hwdep_mmap [snd_hwdep]
+snd_hwdep_dev_free [snd_hwdep]
+snd_hwdep_dev_disconnect [snd_hwdep]
+snd_hwdep_dev_register [snd_hwdep]
+snd_hwdep_release [snd_hwdep]
+snd_hwdep_open [snd_hwdep]
+snd_hwdep_dsp_load [snd_hwdep]
+snd_hwdep_info [snd_hwdep]
+snd_hwdep_ioctl [snd_hwdep]
+snd_hwdep_ioctl_compat [snd_hwdep]
+snd_hwdep_proc_read [snd_hwdep]
+snd_hwdep_control_ioctl [snd_hwdep]
+snd_hwdep_new [snd_hwdep]
+hda_uevent [snd_hda_core]
+hdac_get_device_id [snd_hda_core]
+hda_bus_match [snd_hda_core]
+snd_hdac_bus_init [snd_hda_core]
+snd_hdac_bus_exit [snd_hda_core]
+snd_hdac_bus_exec_verb_unlocked [snd_hda_core]
+snd_hdac_bus_process_unsol_events [snd_hda_core]
+snd_hdac_bus_exec_verb [snd_hda_core]
+snd_hdac_bus_queue_event [snd_hda_core]
+snd_hdac_bus_add_device [snd_hda_core]
+snd_hdac_bus_remove_device [snd_hda_core]
+snd_hdac_device_register [snd_hda_core]
+_snd_hdac_read_parm [snd_hda_core]
+snd_hdac_read_parm_uncached [snd_hda_core]
+snd_hdac_power_up [snd_hda_core]
+snd_hdac_calc_stream_format [snd_hda_core]
+snd_hdac_make_cmd [snd_hda_core]
+snd_hdac_device_exit [snd_hda_core]
+default_release [snd_hda_core]
+snd_hdac_device_unregister [snd_hda_core]
+snd_hdac_codec_modalias [snd_hda_core]
+query_pcm_param [snd_hda_core]
+query_stream_param [snd_hda_core]
+snd_hdac_is_supported_format [snd_hda_core]
+snd_hdac_get_sub_nodes [snd_hda_core]
+snd_hdac_override_parm [snd_hda_core]
+snd_hdac_refresh_widgets [snd_hda_core]
+snd_hdac_query_supported_pcm [snd_hda_core]
+snd_hdac_power_down [snd_hda_core]
+snd_hdac_power_up_pm [snd_hda_core]
+snd_hdac_device_set_chip_name [snd_hda_core]
+snd_hdac_power_down_pm [snd_hda_core]
+snd_hdac_exec_verb [snd_hda_core]
+snd_hdac_read [snd_hda_core]
+snd_hdac_device_init [snd_hda_core]
+snd_hdac_get_connections [snd_hda_core]
+codec_read [snd_hda_core]
+snd_hdac_codec_read [snd_hda_core]
+snd_hdac_sync_power_state [snd_hda_core]
+snd_hdac_check_power_state [snd_hda_core]
+snd_hdac_codec_write [snd_hda_core]
+snd_hdac_keep_power_up [snd_hda_core]
+modalias_show [snd_hda_core]
+gpio_caps_show [snd_hda_core]
+pin_caps_show [snd_hda_core]
+caps_show [snd_hda_core]
+connections_show [snd_hda_core]
+pin_cfg_show [snd_hda_core]
+widget_release [snd_hda_core]
+chip_name_show [snd_hda_core]
+vendor_name_show [snd_hda_core]
+mfg_show [snd_hda_core]
+afg_show [snd_hda_core]
+revision_id_show [snd_hda_core]
+subsystem_id_show [snd_hda_core]
+vendor_id_show [snd_hda_core]
+type_show [snd_hda_core]
+power_caps_show [snd_hda_core]
+amp_out_caps_show [snd_hda_core]
+amp_in_caps_show [snd_hda_core]
+widget_attr_store [snd_hda_core]
+widget_attr_show [snd_hda_core]
+has_pcm_cap.part.0 [snd_hda_core]
+pcm_formats_show [snd_hda_core]
+pcm_caps_show [snd_hda_core]
+add_widget_node [snd_hda_core]
+widget_tree_free [snd_hda_core]
+hda_widget_sysfs_init [snd_hda_core]
+hda_widget_sysfs_exit [snd_hda_core]
+hda_widget_sysfs_reinit [snd_hda_core]
+hda_writeable_reg [snd_hda_core]
+hda_readable_reg [snd_hda_core]
+hda_reg_write [snd_hda_core]
+hda_reg_read [snd_hda_core]
+snd_hdac_regmap_init [snd_hda_core]
+snd_hdac_regmap_exit [snd_hda_core]
+snd_hdac_regmap_add_vendor_verb [snd_hda_core]
+reg_raw_write [snd_hda_core]
+reg_raw_read [snd_hda_core]
+__snd_hdac_regmap_read_raw [snd_hda_core]
+snd_hdac_regmap_read_raw [snd_hda_core]
+snd_hdac_regmap_sync [snd_hda_core]
+reg_raw_update [snd_hda_core]
+reg_raw_update_once [snd_hda_core]
+hda_volatile_reg [snd_hda_core]
+snd_hdac_regmap_write_raw [snd_hda_core]
+snd_hdac_regmap_update_raw [snd_hda_core]
+snd_hdac_regmap_update_raw_once [snd_hda_core]
+snd_hdac_regmap_read_raw_uncached [snd_hda_core]
+snd_hdac_bus_update_rirb [snd_hda_core]
+snd_hdac_bus_parse_capabilities [snd_hda_core]
+snd_hdac_bus_enter_link_reset [snd_hda_core]
+snd_hdac_bus_exit_link_reset [snd_hda_core]
+snd_hdac_bus_reset_link [snd_hda_core]
+snd_hdac_bus_handle_stream_irq [snd_hda_core]
+snd_hdac_bus_alloc_stream_pages [snd_hda_core]
+snd_hdac_bus_free_stream_pages [snd_hda_core]
+snd_hdac_bus_stop_cmd_io [snd_hda_core]
+snd_hdac_bus_stop_chip [snd_hda_core]
+snd_hdac_bus_init_cmd_io [snd_hda_core]
+snd_hdac_bus_init_chip [snd_hda_core]
+snd_hdac_bus_get_response [snd_hda_core]
+snd_hdac_bus_send_cmd [snd_hda_core]
+snd_hdac_stream_clear [snd_hda_core]
+snd_hdac_stream_cleanup [snd_hda_core]
+snd_hdac_get_stream [snd_hda_core]
+azx_cc_read [snd_hda_core]
+snd_hdac_stream_sync_trigger [snd_hda_core]
+snd_hdac_get_stream_stripe_ctl [snd_hda_core]
+snd_hdac_stream_setup [snd_hda_core]
+snd_hdac_stream_init [snd_hda_core]
+snd_hdac_stream_start [snd_hda_core]
+snd_hdac_stream_stop [snd_hda_core]
+snd_hdac_dsp_trigger [snd_hda_core]
+snd_hdac_stream_reset [snd_hda_core]
+snd_hdac_stream_sync [snd_hda_core]
+setup_bdle [snd_hda_core]
+snd_hdac_stream_setup_periods [snd_hda_core]
+snd_hdac_stream_set_params [snd_hda_core]
+snd_hdac_stream_timecounter_init [snd_hda_core]
+snd_hdac_stream_release [snd_hda_core]
+snd_hdac_stream_assign [snd_hda_core]
+snd_hdac_dsp_cleanup [snd_hda_core]
+snd_hdac_dsp_prepare [snd_hda_core]
+snd_array_new [snd_hda_core]
+snd_array_free [snd_hda_core]
+snd_hdac_get_active_channels [snd_hda_core]
+snd_hdac_get_ch_alloc_from_ca [snd_hda_core]
+hdmi_pin_set_slot_channel [snd_hda_core]
+hdmi_set_channel_count [snd_hda_core]
+hdmi_pin_get_slot_channel [snd_hda_core]
+snd_hdac_chmap_to_spk_mask [snd_hda_core]
+snd_hdac_spk_to_chmap [snd_hda_core]
+hdmi_manual_channel_allocation [snd_hda_core]
+hdmi_chmap_ctl_info [snd_hda_core]
+hdmi_chmap_cea_alloc_validate_get_type [snd_hda_core]
+snd_hdac_register_chmap_ops [snd_hda_core]
+snd_hdac_print_channel_allocation [snd_hda_core]
+snd_hdac_channel_allocation [snd_hda_core]
+snd_hdac_add_chmap_ctls [snd_hda_core]
+hdmi_chmap_ctl_get [snd_hda_core]
+hdmi_chmap_ctl_put [snd_hda_core]
+hdmi_cea_alloc_to_tlv_chmap [snd_hda_core]
+snd_hdac_setup_channel_mapping [snd_hda_core]
+hdmi_chmap_ctl_tlv [snd_hda_core]
+__traceiter_hda_send_cmd [snd_hda_core]
+__traceiter_hda_get_response [snd_hda_core]
+__traceiter_hda_unsol_event [snd_hda_core]
+__traceiter_snd_hdac_stream_start [snd_hda_core]
+__traceiter_snd_hdac_stream_stop [snd_hda_core]
+hdac_acomp_release [snd_hda_core]
+snd_hdac_sync_audio_rate [snd_hda_core]
+snd_hdac_acomp_get_eld [snd_hda_core]
+snd_hdac_acomp_register_notifier [snd_hda_core]
+snd_hdac_set_codec_wakeup [snd_hda_core]
+snd_hdac_display_power [snd_hda_core]
+hdac_component_master_bind [snd_hda_core]
+snd_hdac_acomp_init [snd_hda_core]
+snd_hdac_acomp_exit [snd_hda_core]
+hdac_component_master_unbind [snd_hda_core]
+snd_hdac_i915_set_bclk [snd_hda_core]
+i915_component_master_match [snd_hda_core]
+snd_hdac_i915_init [snd_hda_core]
+hda_codec_driver_unregister [snd_hda_codec]
+hda_codec_match [snd_hda_codec]
+hda_codec_unsol_event [snd_hda_codec]
+__hda_codec_driver_register [snd_hda_codec]
+request_codec_module [snd_hda_codec]
+snd_hda_codec_configure [snd_hda_codec]
+hda_codec_driver_shutdown [snd_hda_codec]
+snd_hda_codec_set_name [snd_hda_codec]
+hda_codec_driver_probe [snd_hda_codec]
+hda_codec_driver_remove [snd_hda_codec]
+check_follower_present [snd_hda_codec]
+convert_to_spdif_status [snd_hda_codec]
+hda_pcm_default_open_close [snd_hda_codec]
+hda_codec_pm_prepare [snd_hda_codec]
+snd_hda_codec_set_pin_target [snd_hda_codec]
+snd_hda_codec_get_pin_target [snd_hda_codec]
+vmaster_mute_mode_get [snd_hda_codec]
+vmaster_hook [snd_hda_codec]
+snd_hda_mixer_amp_switch_info [snd_hda_codec]
+snd_hda_spdif_mask_info [snd_hda_codec]
+snd_hda_spdif_cmask_get [snd_hda_codec]
+snd_hda_spdif_pmask_get [snd_hda_codec]
+snd_hda_spdif_out_of_nid [snd_hda_codec]
+spdif_share_sw_get [snd_hda_codec]
+spdif_share_sw_put [snd_hda_codec]
+snd_hda_spdif_in_switch_get [snd_hda_codec]
+snd_hda_sequence_write [snd_hda_codec]
+snd_hda_codec_set_power_to_all [snd_hda_codec]
+snd_hda_get_num_devices [snd_hda_codec]
+read_pin_defaults [snd_hda_codec]
+snd_hda_spdif_out_switch_get [snd_hda_codec]
+snd_hda_spdif_default_get [snd_hda_codec]
+snd_hda_spdif_ctls_unassign [snd_hda_codec]
+snd_hda_codec_cleanup [snd_hda_codec]
+snd_hda_multi_out_dig_close [snd_hda_codec]
+really_cleanup_stream [snd_hda_codec]
+snd_hda_codec_prepare [snd_hda_codec]
+hda_jackpoll_work [snd_hda_codec]
+codec_exec_verb [snd_hda_codec]
+snd_hda_codec_dev_release [snd_hda_codec]
+update_pcm_format [snd_hda_codec]
+hda_set_power_state [snd_hda_codec]
+hda_call_codec_suspend [snd_hda_codec]
+query_amp_caps [snd_hda_codec]
+encode_amp [snd_hda_codec]
+get_ctl_amp_tlv [snd_hda_codec]
+snd_hda_set_vmaster_tlv [snd_hda_codec]
+snd_hda_get_default_vref [snd_hda_codec]
+snd_hda_override_amp_caps [snd_hda_codec]
+snd_hda_codec_amp_update [snd_hda_codec]
+snd_hda_codec_amp_stereo [snd_hda_codec]
+snd_hda_mixer_amp_switch_put [snd_hda_codec]
+set_dig_out [snd_hda_codec]
+snd_hda_spdif_out_switch_put [snd_hda_codec]
+snd_hda_spdif_default_put [snd_hda_codec]
+snd_hda_codec_amp_init [snd_hda_codec]
+snd_hda_codec_amp_init_stereo [snd_hda_codec]
+snd_hda_mixer_amp_volume_info [snd_hda_codec]
+snd_hda_spdif_in_status_get [snd_hda_codec]
+snd_hda_mixer_amp_tlv [snd_hda_codec]
+snd_hda_input_mux_info [snd_hda_codec]
+snd_hda_ctl_add [snd_hda_codec]
+add_follower [snd_hda_codec]
+map_followers [snd_hda_codec]
+snd_hda_create_spdif_share_sw [snd_hda_codec]
+vmaster_mute_mode_info [snd_hda_codec]
+snd_hda_enum_helper_info [snd_hda_codec]
+snd_hda_spdif_in_switch_put [snd_hda_codec]
+snd_hda_input_mux_put [snd_hda_codec]
+hda_call_codec_resume [snd_hda_codec]
+snd_hda_codec_parse_pcms [snd_hda_codec]
+snd_hda_set_power_save [snd_hda_codec]
+snd_hda_multi_out_analog_open [snd_hda_codec]
+snd_hda_add_imux_item [snd_hda_codec]
+snd_print_pcm_bits [snd_hda_codec]
+snd_hda_set_dev_select [snd_hda_codec]
+snd_hda_get_dev_select [snd_hda_codec]
+snd_hda_shutup_pins [snd_hda_codec]
+get_hda_cvt_setup [snd_hda_codec]
+__snd_hda_codec_cleanup_stream.part.0 [snd_hda_codec]
+__snd_hda_codec_cleanup_stream [snd_hda_codec]
+hda_pcm_default_cleanup [snd_hda_codec]
+cleanup_dig_out_stream [snd_hda_codec]
+snd_hda_multi_out_dig_open [snd_hda_codec]
+snd_hda_multi_out_dig_cleanup [snd_hda_codec]
+snd_hda_add_nid [snd_hda_codec]
+snd_hda_codec_get_pincfg [snd_hda_codec]
+snd_hda_multi_out_analog_cleanup [snd_hda_codec]
+snd_hda_codec_setup_stream.part.0 [snd_hda_codec]
+snd_hda_codec_setup_stream [snd_hda_codec]
+hda_pcm_default_prepare [snd_hda_codec]
+setup_dig_out_stream [snd_hda_codec]
+snd_hda_multi_out_dig_prepare [snd_hda_codec]
+snd_hda_multi_out_analog_prepare [snd_hda_codec]
+snd_hda_check_amp_caps [snd_hda_codec]
+snd_hda_codec_eapd_power_filter [snd_hda_codec]
+snd_hda_correct_pin_ctl.part.0 [snd_hda_codec]
+snd_hda_correct_pin_ctl [snd_hda_codec]
+_snd_hda_set_pin_ctl [snd_hda_codec]
+snd_hda_add_vmaster_hook [snd_hda_codec]
+snd_hda_sync_vmaster_hook [snd_hda_codec]
+vmaster_mute_mode_put [snd_hda_codec]
+hda_codec_pm_complete [snd_hda_codec]
+snd_hda_codec_build_controls [snd_hda_codec]
+find_mixer_ctl.constprop.0 [snd_hda_codec]
+snd_hda_add_new_ctls [snd_hda_codec]
+snd_hda_create_spdif_in_ctls [snd_hda_codec]
+snd_hda_create_dig_out_ctls [snd_hda_codec]
+snd_hda_find_mixer_ctl [snd_hda_codec]
+read_widget_caps.constprop.0 [snd_hda_codec]
+snd_hda_codec_update_widgets [snd_hda_codec]
+snd_hda_codec_device_new [snd_hda_codec]
+snd_hda_codec_new [snd_hda_codec]
+snd_hda_codec_pcm_new [snd_hda_codec]
+put_kctl_with_value [snd_hda_codec]
+init_follower_unmute [snd_hda_codec]
+init_follower_0dB [snd_hda_codec]
+__snd_hda_add_vmaster [snd_hda_codec]
+hda_codec_suspend [snd_hda_codec]
+hda_codec_runtime_suspend [snd_hda_codec]
+hda_codec_pm_freeze [snd_hda_codec]
+hda_codec_pm_suspend [snd_hda_codec]
+snd_hda_codec_dev_free [snd_hda_codec]
+hda_codec_resume [snd_hda_codec]
+hda_codec_runtime_resume [snd_hda_codec]
+hda_codec_pm_restore [snd_hda_codec]
+hda_codec_pm_thaw [snd_hda_codec]
+hda_codec_pm_resume [snd_hda_codec]
+snd_hda_mixer_amp_volume_put [snd_hda_codec]
+snd_hda_check_amp_list_power [snd_hda_codec]
+release_pcm [snd_hda_codec]
+snd_hda_codec_pcm_put [snd_hda_codec]
+snd_hda_mixer_amp_switch_get [snd_hda_codec]
+snd_hda_mixer_amp_volume_get [snd_hda_codec]
+snd_hda_unlock_devices [snd_hda_codec]
+snd_hda_spdif_ctls_assign [snd_hda_codec]
+snd_hda_lock_devices [snd_hda_codec]
+snd_hda_override_conn_list [snd_hda_codec]
+snd_hda_get_conn_list [snd_hda_codec]
+snd_hda_get_connections [snd_hda_codec]
+snd_hda_get_conn_index [snd_hda_codec]
+snd_hda_get_devices [snd_hda_codec]
+snd_hda_add_pincfg [snd_hda_codec]
+snd_hda_codec_set_pincfg [snd_hda_codec]
+snd_hda_codec_register [snd_hda_codec]
+snd_hda_codec_dev_register [snd_hda_codec]
+snd_hda_ctls_clear [snd_hda_codec]
+snd_hda_codec_cleanup_for_unbind [snd_hda_codec]
+snd_hda_codec_reset [snd_hda_codec]
+snd_hda_update_power_acct [snd_hda_codec]
+snd_hda_codec_build_pcms [snd_hda_codec]
+snd_hda_bus_reset_codecs [snd_hda_codec]
+read_pin_sense [snd_hda_codec]
+snd_hda_jack_tbl_get_mst [snd_hda_codec]
+snd_hda_jack_tbl_get_from_tag [snd_hda_codec]
+snd_hda_jack_set_dirty_all [snd_hda_codec]
+hda_free_jack_priv [snd_hda_codec]
+call_jack_callback [snd_hda_codec]
+snd_hda_jack_tbl_new [snd_hda_codec]
+snd_hda_jack_set_gating_jack [snd_hda_codec]
+is_jack_detectable.part.0 [snd_hda_codec]
+is_jack_detectable [snd_hda_codec]
+jack_detect_update [snd_hda_codec]
+snd_hda_jack_pin_sense [snd_hda_codec]
+snd_hda_jack_detect_state_mst [snd_hda_codec]
+snd_hda_jack_add_kctl_mst [snd_hda_codec]
+snd_hda_jack_report_sync [snd_hda_codec]
+snd_hda_jack_unsol_event [snd_hda_codec]
+snd_hda_jack_poll_all [snd_hda_codec]
+snd_hda_jack_detect_enable_callback_mst [snd_hda_codec]
+snd_hda_jack_detect_enable [snd_hda_codec]
+add_jack_kctl [snd_hda_codec]
+snd_hda_jack_add_kctls [snd_hda_codec]
+snd_hda_jack_tbl_clear [snd_hda_codec]
+snd_hda_get_input_pin_attr [snd_hda_codec]
+hda_get_input_pin_label [snd_hda_codec]
+check_output_pfx [snd_hda_codec]
+compare_seq [snd_hda_codec]
+compare_input_type [snd_hda_codec]
+snd_hda_pick_pin_fixup [snd_hda_codec]
+hda_get_autocfg_input_label [snd_hda_codec]
+sort_pins_by_sequence [snd_hda_codec]
+add_auto_cfg_input_pin [snd_hda_codec]
+fill_audio_out_name [snd_hda_codec]
+snd_hda_get_pin_label [snd_hda_codec]
+snd_hda_add_verbs [snd_hda_codec]
+snd_hda_apply_verbs [snd_hda_codec]
+snd_hda_apply_pincfgs [snd_hda_codec]
+apply_fixup [snd_hda_codec]
+snd_hda_pick_fixup [snd_hda_codec]
+reorder_outputs.part.0 [snd_hda_codec]
+can_be_headset_mic.part.0 [snd_hda_codec]
+snd_hda_parse_pin_defcfg [snd_hda_codec]
+snd_hda_apply_fixup [snd_hda_codec]
+get_hint [snd_hda_codec]
+snd_hda_get_hint [snd_hda_codec]
+snd_hda_get_bool_hint [snd_hda_codec]
+snd_hda_get_int_hint [snd_hda_codec]
+parse_revision_id_mode [snd_hda_codec]
+parse_subsystem_id_mode [snd_hda_codec]
+parse_vendor_id_mode [snd_hda_codec]
+revision_id_store [snd_hda_codec]
+subsystem_id_store [snd_hda_codec]
+vendor_id_store [snd_hda_codec]
+parse_chip_name_mode [snd_hda_codec]
+kstrndup_noeol [snd_hda_codec]
+modelname_store [snd_hda_codec]
+chip_name_store [snd_hda_codec]
+vendor_name_store [snd_hda_codec]
+parse_init_verbs [snd_hda_codec]
+parse_verb_mode [snd_hda_codec]
+init_verbs_store [snd_hda_codec]
+parse_codec_mode [snd_hda_codec]
+parse_user_pin_configs [snd_hda_codec]
+parse_pincfg_mode [snd_hda_codec]
+user_pin_configs_store [snd_hda_codec]
+parse_model_mode [snd_hda_codec]
+reconfig_store [snd_hda_codec]
+pin_configs_show [snd_hda_codec]
+user_pin_configs_show [snd_hda_codec]
+driver_pin_configs_show [snd_hda_codec]
+init_pin_configs_show [snd_hda_codec]
+modelname_show [snd_hda_codec]
+chip_name_show [snd_hda_codec]
+vendor_name_show [snd_hda_codec]
+mfg_show [snd_hda_codec]
+afg_show [snd_hda_codec]
+revision_id_show [snd_hda_codec]
+subsystem_id_show [snd_hda_codec]
+vendor_id_show [snd_hda_codec]
+hints_show [snd_hda_codec]
+init_verbs_show [snd_hda_codec]
+power_off_acct_show [snd_hda_codec]
+power_on_acct_show [snd_hda_codec]
+remove_trail_spaces.part.0 [snd_hda_codec]
+parse_hints [snd_hda_codec]
+hints_store [snd_hda_codec]
+parse_hint_mode [snd_hda_codec]
+snd_hda_load_patch [snd_hda_codec]
+snd_hda_sysfs_init [snd_hda_codec]
+snd_hda_sysfs_clear [snd_hda_codec]
+clear_store [snd_hda_codec]
+azx_get_pos_lpib [snd_hda_codec]
+azx_get_pos_posbuf [snd_hda_codec]
+__traceiter_azx_pcm_trigger [snd_hda_codec]
+__traceiter_azx_get_position [snd_hda_codec]
+__traceiter_azx_pcm_open [snd_hda_codec]
+__traceiter_azx_pcm_close [snd_hda_codec]
+__traceiter_azx_pcm_hw_params [snd_hda_codec]
+__traceiter_azx_pcm_prepare [snd_hda_codec]
+azx_get_position [snd_hda_codec]
+azx_pcm_mmap [snd_hda_codec]
+azx_pcm_pointer [snd_hda_codec]
+azx_stop_all_streams [snd_hda_codec]
+azx_pcm_prepare [snd_hda_codec]
+azx_pcm_hw_params [snd_hda_codec]
+azx_pcm_hw_free [snd_hda_codec]
+azx_pcm_close [snd_hda_codec]
+azx_pcm_free [snd_hda_codec]
+azx_free_streams [snd_hda_codec]
+snd_hda_codec_load_dsp_trigger [snd_hda_codec]
+azx_stop_chip [snd_hda_codec]
+azx_bus_init [snd_hda_codec]
+azx_codec_configure [snd_hda_codec]
+azx_init_chip [snd_hda_codec]
+azx_get_response [snd_hda_codec]
+azx_send_cmd.part.0 [snd_hda_codec]
+azx_send_cmd [snd_hda_codec]
+azx_probe_codecs [snd_hda_codec]
+azx_get_sync_time [snd_hda_codec]
+azx_pcm_open [snd_hda_codec]
+azx_init_streams [snd_hda_codec]
+azx_get_time_info [snd_hda_codec]
+stream_update [snd_hda_codec]
+snd_hda_codec_load_dsp_prepare [snd_hda_codec]
+azx_interrupt [snd_hda_codec]
+snd_hda_codec_load_dsp_cleanup [snd_hda_codec]
+azx_pcm_trigger [snd_hda_codec]
+snd_hda_attach_pcm_stream [snd_hda_codec]
+snd_hda_bus_reset [snd_hda_codec]
+print_power_state [snd_hda_codec]
+print_amp_vals [snd_hda_codec]
+print_amp_caps [snd_hda_codec]
+print_nid_array.constprop.0 [snd_hda_codec]
+print_pcm_caps [snd_hda_codec]
+print_codec_info [snd_hda_codec]
+snd_hda_codec_proc_new [snd_hda_codec]
+hda_hwdep_open [snd_hda_codec]
+hda_hwdep_ioctl [snd_hda_codec]
+hda_hwdep_ioctl_compat [snd_hda_codec]
+snd_hda_create_hwdep [snd_hda_codec]
+generate_tone [snd_hda_codec]
+turn_off_beep [snd_hda_codec]
+snd_hda_enable_beep_device [snd_hda_codec]
+snd_hda_generate_beep [snd_hda_codec]
+beep_dev_free [snd_hda_codec]
+snd_hda_beep_event [snd_hda_codec]
+beep_dev_disconnect [snd_hda_codec]
+beep_dev_register [snd_hda_codec]
+snd_hda_mixer_amp_switch_get_beep [snd_hda_codec]
+snd_hda_mixer_amp_switch_put_beep [snd_hda_codec]
+snd_hda_detach_beep_device [snd_hda_codec]
+snd_hda_attach_beep_device [snd_hda_codec]
+snd_intel_dsp_check_dmic [snd_intel_dspcfg]
+snd_intel_dsp_driver_probe [snd_intel_dspcfg]
+intel_nhlt_init [snd_intel_dspcfg]
+intel_nhlt_free [snd_intel_dspcfg]
+intel_nhlt_get_dmic_geo [snd_intel_dspcfg]
+__traceiter_azx_suspend [snd_hda_intel]
+__traceiter_azx_resume [snd_hda_intel]
+__traceiter_azx_runtime_suspend [snd_hda_intel]
+__traceiter_azx_runtime_resume [snd_hda_intel]
+azx_clear_irq_pending [snd_hda_intel]
+azx_get_delay_from_fifo [snd_hda_intel]
+azx_prepare [snd_hda_intel]
+azx_complete [snd_hda_intel]
+update_pci_byte [snd_hda_intel]
+azx_init_pci [snd_hda_intel]
+intel_ml_lctl_set_power [snd_hda_intel]
+hda_intel_init_chip [snd_hda_intel]
+__azx_runtime_resume [snd_hda_intel]
+azx_runtime_resume [snd_hda_intel]
+azx_shutdown [snd_hda_intel]
+__azx_runtime_suspend [snd_hda_intel]
+azx_runtime_suspend [snd_hda_intel]
+azx_thaw_noirq [snd_hda_intel]
+azx_freeze_noirq [snd_hda_intel]
+azx_acquire_irq [snd_hda_intel]
+azx_resume [snd_hda_intel]
+azx_suspend [snd_hda_intel]
+disable_msi_reset_irq [snd_hda_intel]
+azx_dev_disconnect [snd_hda_intel]
+azx_remove [snd_hda_intel]
+azx_free [snd_hda_intel]
+azx_dev_free [snd_hda_intel]
+azx_get_delay_from_lpib [snd_hda_intel]
+azx_get_pos_fifo [snd_hda_intel]
+azx_via_get_position [snd_hda_intel]
+pcm_mmap_prepare [snd_hda_intel]
+azx_vs_can_switch [snd_hda_intel]
+azx_runtime_idle [snd_hda_intel]
+set_default_power_save [snd_hda_intel]
+azx_position_ok [snd_hda_intel]
+param_set_xint [snd_hda_intel]
+azx_get_pos_skl [snd_hda_intel]
+get_bound_vga [snd_hda_intel]
+azx_probe [snd_hda_intel]
+setup_vga_switcheroo_runtime_pm.part.0 [snd_hda_intel]
+azx_vs_gpu_bound [snd_hda_intel]
+azx_probe_continue [snd_hda_intel]
+azx_firmware_cb [snd_hda_intel]
+azx_probe_work [snd_hda_intel]
+azx_vs_set_state [snd_hda_intel]
+azx_position_check [snd_hda_intel]
+azx_irq_pending_work [snd_hda_intel]
+sys_imageblit [sysimgblt]
+sys_fillrect [sysfillrect]
+bitfill_unaligned [sysfillrect]
+bitfill_unaligned_rev [sysfillrect]
+bitfill_aligned [sysfillrect]
+bitfill_aligned_rev [sysfillrect]
+sys_copyarea [syscopyarea]
+fb_sys_read [fb_sys_fops]
+fb_sys_write [fb_sys_fops]
+bit_func [i2c_algo_bit]
+sclhi [i2c_algo_bit]
+i2c_stop [i2c_algo_bit]
+i2c_start [i2c_algo_bit]
+i2c_repstart [i2c_algo_bit]
+acknak [i2c_algo_bit]
+i2c_outb [i2c_algo_bit]
+try_address [i2c_algo_bit]
+bit_xfer [i2c_algo_bit]
+bit_xfer_atomic [i2c_algo_bit]
+__i2c_bit_add_bus [i2c_algo_bit]
+i2c_bit_add_bus [i2c_algo_bit]
+i2c_bit_add_numbered_bus [i2c_algo_bit]
+rc_dev_release [rc_core]
+rc_devnode [rc_core]
+rc_map_cmp [rc_core]
+ir_lookup_by_scancode [rc_core]
+rc_g_keycode_from_table [rc_core]
+ir_free_table [rc_core]
+ir_getkeycode [rc_core]
+show_wakeup_protocols [rc_core]
+show_protocols [rc_core]
+rc_free_rx_device [rc_core]
+rc_repeat [rc_core]
+ir_timer_repeat [rc_core]
+rc_dev_uevent [rc_core]
+show_filter [rc_core]
+rc_free_device.part.0 [rc_core]
+rc_free_device [rc_core]
+devm_rc_alloc_release [rc_core]
+rc_unregister_device [rc_core]
+devm_rc_release [rc_core]
+ir_do_keyup [rc_core]
+rc_keyup [rc_core]
+ir_timer_keyup [rc_core]
+ir_do_keydown [rc_core]
+rc_keydown_notimeout [rc_core]
+rc_keydown [rc_core]
+rc_close.part.0 [rc_core]
+ir_close [rc_core]
+rc_allocate_device [rc_core]
+devm_rc_allocate_device [rc_core]
+rc_map_register [rc_core]
+rc_map_unregister [rc_core]
+seek_rc_map [rc_core]
+rc_map_get [rc_core]
+ir_resize_table.constprop.0 [rc_core]
+ir_update_mapping [rc_core]
+ir_establish_scancode [rc_core]
+ir_setkeycode [rc_core]
+rc_validate_scancode [rc_core]
+store_filter [rc_core]
+rc_open [rc_core]
+ir_open [rc_core]
+rc_close [rc_core]
+ir_raw_load_modules [rc_core]
+store_wakeup_protocols [rc_core]
+store_protocols [rc_core]
+rc_register_device [rc_core]
+devm_rc_register_device [rc_core]
+ir_raw_event_store [rc_core]
+ir_raw_event_set_idle [rc_core]
+ir_raw_event_store_with_timeout [rc_core]
+ir_raw_event_handle [rc_core]
+ir_raw_gen_manchester [rc_core]
+ir_raw_gen_pd [rc_core]
+ir_raw_gen_pl [rc_core]
+ir_raw_encode_scancode [rc_core]
+ir_raw_encode_carrier [rc_core]
+change_protocol [rc_core]
+ir_raw_handler_register [rc_core]
+ir_raw_handler_unregister [rc_core]
+ir_raw_event_store_with_filter [rc_core]
+ir_raw_event_thread [rc_core]
+ir_raw_event_store_edge [rc_core]
+ir_raw_edge_handle [rc_core]
+ir_raw_get_allowed_protocols [rc_core]
+ir_raw_event_prepare [rc_core]
+ir_raw_event_register [rc_core]
+ir_raw_event_free [rc_core]
+ir_raw_event_unregister [rc_core]
+lirc_release_device [rc_core]
+lirc_scancode_event [rc_core]
+lirc_close [rc_core]
+lirc_poll [rc_core]
+lirc_ioctl [rc_core]
+lirc_read [rc_core]
+lirc_open [rc_core]
+lirc_transmit [rc_core]
+lirc_raw_event [rc_core]
+lirc_register [rc_core]
+lirc_unregister [rc_core]
+rc_dev_get_from_fd [rc_core]
+cec_error_inj_show [cec]
+cec_error_inj_open [cec]
+cec_error_inj_write [cec]
+cec_delete_adapter.part.0 [cec]
+cec_delete_adapter [cec]
+cec_unregister_adapter [cec]
+cec_allocate_adapter [cec]
+cec_register_adapter [cec]
+cec_devnode_release [cec]
+cec_get_device [cec]
+cec_put_device [cec]
+cec_get_edid_phys_addr [cec]
+cec_fill_msg_report_features [cec]
+cec_fill_conn_info_from_drm [cec]
+cec_claim_log_addrs [cec]
+cec_queue_event_fh [cec]
+cec_queue_pin_cec_event [cec]
+cec_queue_pin_hpd_event [cec]
+cec_queue_pin_5v_event [cec]
+cec_queue_msg_fh [cec]
+cec_queue_msg_monitor [cec]
+cec_data_completed [cec]
+cec_data_cancel [cec]
+cec_flush [cec]
+cec_transmit_done_ts [cec]
+cec_transmit_attempt_done_ts [cec]
+cec_wait_timeout [cec]
+cec_post_state_event [cec]
+cec_adap_unconfigure [cec]
+cec_s_conn_info [cec]
+cec_thread_func [cec]
+cec_transmit_msg_fh [cec]
+cec_transmit_msg [cec]
+cec_feature_abort_reason [cec]
+cec_received_msg_ts [cec]
+cec_config_log_addr [cec]
+cec_config_thread_func [cec]
+__cec_s_phys_addr [cec]
+cec_s_phys_addr_from_edid [cec]
+cec_s_phys_addr [cec]
+__cec_s_log_addrs [cec]
+cec_s_log_addrs [cec]
+cec_monitor_all_cnt_inc [cec]
+cec_monitor_all_cnt_dec [cec]
+cec_monitor_pin_cnt_inc [cec]
+cec_monitor_pin_cnt_dec [cec]
+cec_adap_status [cec]
+cec_receive_msg [cec]
+cec_poll [cec]
+cec_release [cec]
+cec_ioctl [cec]
+cec_open [cec]
+cec_notifier_parse_hdmi_phandle [cec]
+cec_notifier_set_phys_addr.part.0 [cec]
+cec_notifier_set_phys_addr [cec]
+cec_notifier_set_phys_addr_from_edid [cec]
+cec_notifier_put [cec]
+cec_notifier_cec_adap_unregister [cec]
+cec_notifier_conn_unregister [cec]
+cec_notifier_get_conn [cec]
+cec_notifier_conn_register [cec]
+cec_notifier_cec_adap_register [cec]
+drm_bridge_connector_hpd_notify [drm_kms_helper]
+drm_bridge_connector_enable_hpd [drm_kms_helper]
+drm_bridge_connector_hpd_cb [drm_kms_helper]
+drm_bridge_connector_disable_hpd [drm_kms_helper]
+drm_bridge_connector_destroy [drm_kms_helper]
+drm_bridge_connector_detect [drm_kms_helper]
+drm_bridge_connector_get_modes [drm_kms_helper]
+drm_bridge_connector_init [drm_kms_helper]
+drm_encoder_disable [drm_kms_helper]
+drm_helper_encoder_in_use [drm_kms_helper]
+drm_helper_crtc_in_use [drm_kms_helper]
+drm_helper_choose_encoder_dpms [drm_kms_helper]
+drm_helper_choose_crtc_dpms [drm_kms_helper]
+drm_helper_connector_dpms [drm_kms_helper]
+__drm_helper_disable_unused_functions [drm_kms_helper]
+drm_helper_disable_unused_functions [drm_kms_helper]
+drm_crtc_helper_set_mode [drm_kms_helper]
+drm_helper_resume_force_mode [drm_kms_helper]
+drm_helper_force_disable_all [drm_kms_helper]
+drm_connector_get_single_encoder [drm_kms_helper]
+drm_crtc_helper_set_config [drm_kms_helper]
+drm_dp_link_rate_to_bw_code [drm_kms_helper]
+drm_dp_bw_code_to_link_rate [drm_kms_helper]
+drm_dp_i2c_functionality [drm_kms_helper]
+lock_bus [drm_kms_helper]
+unlock_bus [drm_kms_helper]
+drm_dp_clock_recovery_ok [drm_kms_helper]
+drm_dp_get_adjust_request_voltage [drm_kms_helper]
+drm_dp_get_adjust_request_pre_emphasis [drm_kms_helper]
+drm_dp_get_adjust_request_post_cursor [drm_kms_helper]
+drm_dp_downstream_is_type [drm_kms_helper]
+drm_dp_downstream_max_dotclock [drm_kms_helper]
+drm_dp_downstream_max_tmds_clock [drm_kms_helper]
+drm_dp_downstream_max_bpc [drm_kms_helper]
+drm_dp_remote_aux_init [drm_kms_helper]
+drm_dp_psr_setup_time [drm_kms_helper]
+drm_dp_dsc_sink_max_slice_count [drm_kms_helper]
+drm_dp_dsc_sink_line_buf_depth [drm_kms_helper]
+drm_dp_dsc_sink_supported_input_bpcs [drm_kms_helper]
+drm_dp_read_sink_count_cap [drm_kms_helper]
+drm_dp_link_train_clock_recovery_delay [drm_kms_helper]
+drm_dp_link_train_channel_eq_delay [drm_kms_helper]
+drm_dp_dpcd_access [drm_kms_helper]
+drm_dp_aux_init [drm_kms_helper]
+trylock_bus [drm_kms_helper]
+drm_dp_i2c_do_msg [drm_kms_helper]
+drm_dp_i2c_xfer [drm_kms_helper]
+drm_dp_aux_register [drm_kms_helper]
+drm_dp_aux_unregister [drm_kms_helper]
+drm_dp_vsc_sdp_log [drm_kms_helper]
+drm_dp_dpcd_read [drm_kms_helper]
+drm_dp_dpcd_read_link_status [drm_kms_helper]
+drm_dp_read_dpcd_caps [drm_kms_helper]
+drm_dp_read_downstream_info [drm_kms_helper]
+drm_dp_downstream_id [drm_kms_helper]
+drm_dp_read_sink_count [drm_kms_helper]
+drm_dp_read_desc [drm_kms_helper]
+drm_dp_aux_get_crc [drm_kms_helper]
+drm_dp_aux_crc_work [drm_kms_helper]
+drm_dp_channel_eq_ok [drm_kms_helper]
+drm_dp_downstream_is_tmds [drm_kms_helper]
+drm_dp_downstream_min_tmds_clock [drm_kms_helper]
+drm_dp_downstream_debug [drm_kms_helper]
+drm_dp_downstream_420_passthrough [drm_kms_helper]
+drm_dp_downstream_444_to_420_conversion [drm_kms_helper]
+drm_dp_subconnector_type [drm_kms_helper]
+drm_dp_set_subconnector_property [drm_kms_helper]
+drm_dp_get_edid_quirks [drm_kms_helper]
+drm_dp_downstream_mode [drm_kms_helper]
+drm_dp_get_phy_test_pattern [drm_kms_helper]
+drm_dp_dpcd_write [drm_kms_helper]
+drm_dp_start_crc [drm_kms_helper]
+drm_dp_stop_crc [drm_kms_helper]
+drm_dp_send_real_edid_checksum [drm_kms_helper]
+drm_dp_set_phy_test_pattern [drm_kms_helper]
+drm_dsc_dp_pps_header_init [drm_kms_helper]
+drm_dsc_pps_payload_pack [drm_kms_helper]
+drm_dsc_compute_rc_parameters [drm_kms_helper]
+drm_helper_probe_detect_ctx [drm_kms_helper]
+drm_helper_probe_detect [drm_kms_helper]
+drm_kms_helper_hotplug_event [drm_kms_helper]
+drm_kms_helper_is_poll_worker [drm_kms_helper]
+output_poll_execute [drm_kms_helper]
+drm_kms_helper_poll_disable [drm_kms_helper]
+drm_kms_helper_poll_fini [drm_kms_helper]
+drm_kms_helper_poll_enable [drm_kms_helper]
+drm_kms_helper_poll_init [drm_kms_helper]
+drm_helper_hpd_irq_event [drm_kms_helper]
+drm_crtc_mode_valid [drm_kms_helper]
+drm_encoder_mode_valid [drm_kms_helper]
+drm_connector_mode_valid [drm_kms_helper]
+drm_helper_probe_single_connector_modes [drm_kms_helper]
+drm_primary_helper_disable [drm_kms_helper]
+drm_primary_helper_destroy [drm_kms_helper]
+get_connectors_for_crtc [drm_kms_helper]
+drm_plane_helper_check_update.constprop.0 [drm_kms_helper]
+drm_primary_helper_update [drm_kms_helper]
+drm_dp_mst_i2c_functionality [drm_kms_helper]
+drm_dp_mst_topology_get_mstb_validated_locked [drm_kms_helper]
+drm_dp_mst_topology_get_port_validated_locked [drm_kms_helper]
+drm_dp_get_last_connected_port_to_mstb [drm_kms_helper]
+drm_dp_mst_topology_mgr_invalidate_mstb [drm_kms_helper]
+drm_dp_mst_reset_vcpi_slots [drm_kms_helper]
+drm_dp_msg_header_crc4 [drm_kms_helper]
+drm_dp_msg_data_crc4 [drm_kms_helper]
+drm_dp_mst_connector_late_register [drm_kms_helper]
+drm_dp_mst_connector_early_unregister [drm_kms_helper]
+drm_dp_dpcd_write_payload [drm_kms_helper]
+drm_dp_mst_topology_mgr_suspend [drm_kms_helper]
+drm_dp_sideband_append_payload [drm_kms_helper]
+drm_dp_find_vcpi_slots [drm_kms_helper]
+drm_dp_check_act_status [drm_kms_helper]
+drm_atomic_get_mst_topology_state [drm_kms_helper]
+get_mst_branch_device_by_guid_helper [drm_kms_helper]
+drm_dp_mst_dump_mstb [drm_kms_helper]
+drm_dp_read_mst_cap [drm_kms_helper]
+drm_dp_calc_pbn_mode [drm_kms_helper]
+drm_dp_mst_atomic_check_mstb_bw_limit [drm_kms_helper]
+drm_dp_mst_atomic_check [drm_kms_helper]
+drm_dp_mst_is_virtual_dpcd.part.0 [drm_kms_helper]
+drm_dp_mst_dsc_aux_for_port [drm_kms_helper]
+drm_dp_mst_add_affected_dsc_crtcs [drm_kms_helper]
+drm_dp_mst_port_add_connector [drm_kms_helper]
+drm_dp_mst_rad_to_str.constprop.0 [drm_kms_helper]
+drm_dp_mst_topology_try_get_port [drm_kms_helper]
+drm_dp_get_port [drm_kms_helper]
+drm_dp_mst_topology_get_port_validated [drm_kms_helper]
+drm_dp_mst_put_port_malloc [drm_kms_helper]
+drm_dp_mst_put_mstb_malloc [drm_kms_helper]
+drm_dp_mst_destroy_state [drm_kms_helper]
+drm_dp_atomic_release_vcpi_slots [drm_kms_helper]
+drm_dp_mst_topology_put_port [drm_kms_helper]
+drm_dp_mst_get_vcpi_slots [drm_kms_helper]
+drm_dp_mst_topology_unlink_port [drm_kms_helper]
+drm_dp_mst_get_edid [drm_kms_helper]
+drm_dp_mst_dump_topology [drm_kms_helper]
+drm_dp_mst_detect_port [drm_kms_helper]
+drm_dp_mst_topology_put_mstb [drm_kms_helper]
+drm_dp_mst_topology_try_get_mstb [drm_kms_helper]
+drm_dp_mst_topology_get_mstb_validated [drm_kms_helper]
+drm_dp_get_mst_branch_device [drm_kms_helper]
+drm_dp_get_one_sb_msg [drm_kms_helper]
+drm_dp_add_mst_branch_device [drm_kms_helper]
+drm_dp_mst_topology_mgr_set_mst [drm_kms_helper]
+drm_dp_mst_topology_mgr_destroy [drm_kms_helper]
+drm_dp_mst_get_port_malloc [drm_kms_helper]
+drm_dp_mst_allocate_vcpi [drm_kms_helper]
+drm_dp_mst_duplicate_state [drm_kms_helper]
+drm_dp_port_set_pdt [drm_kms_helper]
+drm_dp_delayed_destroy_work [drm_kms_helper]
+drm_dp_mst_add_port [drm_kms_helper]
+drm_dp_mst_deallocate_vcpi [drm_kms_helper]
+drm_dp_atomic_find_vcpi_slots [drm_kms_helper]
+drm_dp_mst_atomic_enable_dsc [drm_kms_helper]
+drm_dp_mst_topology_mgr_init [drm_kms_helper]
+drm_dp_encode_sideband_req [drm_kms_helper]
+build_dpcd_read [drm_kms_helper]
+build_dpcd_write [drm_kms_helper]
+build_power_updown_phy [drm_kms_helper]
+build_query_stream_enc_status [drm_kms_helper]
+build_allocate_payload [drm_kms_helper]
+build_enum_path_resources [drm_kms_helper]
+build_clear_payload_id_table [drm_kms_helper]
+build_link_address [drm_kms_helper]
+drm_dp_decode_sideband_req [drm_kms_helper]
+drm_dp_dump_sideband_msg_req_body [drm_kms_helper]
+process_single_tx_qlock [drm_kms_helper]
+process_single_down_tx_qlock [drm_kms_helper]
+drm_dp_tx_work [drm_kms_helper]
+drm_dp_mst_hpd_irq [drm_kms_helper]
+drm_dp_queue_down_tx [drm_kms_helper]
+drm_dp_mst_wait_tx_reply [drm_kms_helper]
+drm_dp_send_dpcd_write [drm_kms_helper]
+drm_dp_check_mstb_guid [drm_kms_helper]
+drm_dp_mst_topology_mgr_resume [drm_kms_helper]
+drm_dp_send_power_updown_phy [drm_kms_helper]
+drm_dp_send_query_stream_enc_status [drm_kms_helper]
+drm_dp_payload_send_msg [drm_kms_helper]
+drm_dp_update_payload_part2 [drm_kms_helper]
+drm_dp_update_payload_part1 [drm_kms_helper]
+drm_dp_send_enum_path_resources [drm_kms_helper]
+drm_dp_mst_up_req_work [drm_kms_helper]
+drm_dp_mst_i2c_read [drm_kms_helper]
+drm_dp_mst_i2c_write [drm_kms_helper]
+drm_dp_mst_i2c_xfer [drm_kms_helper]
+drm_dp_send_link_address [drm_kms_helper]
+drm_dp_check_and_send_link_address [drm_kms_helper]
+drm_dp_mst_link_probe_work [drm_kms_helper]
+drm_dp_mst_dpcd_read [drm_kms_helper]
+drm_dp_mst_dpcd_write [drm_kms_helper]
+drm_atomic_helper_cleanup_planes [drm_kms_helper]
+drm_atomic_helper_async_commit [drm_kms_helper]
+set_best_encoder [drm_kms_helper]
+drm_atomic_helper_disable_planes_on_crtc [drm_kms_helper]
+handle_conflicting_encoders [drm_kms_helper]
+drm_atomic_helper_wait_for_dependencies [drm_kms_helper]
+drm_atomic_helper_wait_for_flip_done [drm_kms_helper]
+drm_atomic_helper_async_check [drm_kms_helper]
+init_commit [drm_kms_helper]
+drm_atomic_helper_fake_vblank [drm_kms_helper]
+drm_atomic_helper_commit_duplicated_state [drm_kms_helper]
+crtc_needs_disable [drm_kms_helper]
+plane_crtc_active [drm_kms_helper]
+drm_atomic_helper_update_legacy_modeset_state [drm_kms_helper]
+drm_atomic_helper_check_modeset [drm_kms_helper]
+drm_atomic_helper_check_plane_state [drm_kms_helper]
+drm_atomic_helper_calc_timestamping_constants [drm_kms_helper]
+page_flip_common [drm_kms_helper]
+drm_atomic_helper_check_planes [drm_kms_helper]
+drm_atomic_helper_commit_modeset_enables [drm_kms_helper]
+drm_atomic_helper_prepare_planes [drm_kms_helper]
+drm_atomic_helper_commit_modeset_disables [drm_kms_helper]
+drm_atomic_helper_wait_for_vblanks.part.0 [drm_kms_helper]
+drm_atomic_helper_wait_for_vblanks [drm_kms_helper]
+drm_atomic_helper_check [drm_kms_helper]
+crtc_or_fake_commit.part.0 [drm_kms_helper]
+drm_atomic_helper_duplicate_state [drm_kms_helper]
+drm_atomic_helper_bridge_propagate_bus_fmt [drm_kms_helper]
+drm_atomic_helper_commit_cleanup_done [drm_kms_helper]
+drm_atomic_helper_commit_planes [drm_kms_helper]
+drm_atomic_helper_commit_planes_on_crtc [drm_kms_helper]
+drm_atomic_helper_wait_for_fences [drm_kms_helper]
+release_crtc_commit [drm_kms_helper]
+drm_atomic_helper_swap_state [drm_kms_helper]
+drm_atomic_helper_commit_hw_done [drm_kms_helper]
+drm_atomic_helper_commit_tail [drm_kms_helper]
+drm_atomic_helper_commit_tail_rpm [drm_kms_helper]
+drm_atomic_helper_page_flip [drm_kms_helper]
+drm_atomic_helper_disable_plane [drm_kms_helper]
+drm_atomic_helper_update_plane [drm_kms_helper]
+drm_atomic_helper_page_flip_target [drm_kms_helper]
+drm_atomic_helper_set_config [drm_kms_helper]
+drm_atomic_helper_resume [drm_kms_helper]
+drm_atomic_helper_legacy_gamma_set [drm_kms_helper]
+commit_tail [drm_kms_helper]
+commit_work [drm_kms_helper]
+drm_atomic_helper_setup_commit [drm_kms_helper]
+drm_atomic_helper_commit [drm_kms_helper]
+drm_atomic_helper_disable_all [drm_kms_helper]
+drm_atomic_helper_shutdown [drm_kms_helper]
+drm_atomic_helper_suspend [drm_kms_helper]
+edid_firmware_get [drm_kms_helper]
+drm_dp_dual_mode_read [drm_kms_helper]
+drm_dp_dual_mode_write [drm_kms_helper]
+drm_dp_dual_mode_set_tmds_output [drm_kms_helper]
+is_hdmi_adaptor [drm_kms_helper]
+drm_dp_dual_mode_detect [drm_kms_helper]
+drm_dp_get_dual_mode_type_name [drm_kms_helper]
+drm_dp_dual_mode_max_tmds_clock [drm_kms_helper]
+drm_dp_dual_mode_get_tmds_output [drm_kms_helper]
+drm_lspcon_get_mode [drm_kms_helper]
+drm_lspcon_set_mode [drm_kms_helper]
+drm_simple_kms_format_mod_supported [drm_kms_helper]
+drm_simple_encoder_init [drm_kms_helper]
+drm_simple_display_pipe_attach_bridge [drm_kms_helper]
+drm_simple_kms_crtc_mode_valid [drm_kms_helper]
+drm_simple_kms_crtc_enable [drm_kms_helper]
+drm_simple_kms_crtc_disable [drm_kms_helper]
+drm_simple_kms_crtc_enable_vblank [drm_kms_helper]
+drm_simple_kms_crtc_disable_vblank [drm_kms_helper]
+drm_simple_kms_plane_atomic_update [drm_kms_helper]
+drm_simple_kms_plane_prepare_fb [drm_kms_helper]
+drm_simple_kms_plane_cleanup_fb [drm_kms_helper]
+drm_simple_display_pipe_init [drm_kms_helper]
+drm_simple_kms_crtc_check [drm_kms_helper]
+drm_simple_kms_plane_atomic_check [drm_kms_helper]
+drm_helper_move_panel_connectors_to_head [drm_kms_helper]
+drm_helper_mode_fill_fb_struct [drm_kms_helper]
+drm_mode_config_helper_resume [drm_kms_helper]
+drm_mode_config_helper_suspend [drm_kms_helper]
+drm_crtc_init [drm_kms_helper]
+drm_scdc_read [drm_kms_helper]
+drm_scdc_write [drm_kms_helper]
+drm_scdc_get_scrambling_status [drm_kms_helper]
+drm_scdc_set_scrambling [drm_kms_helper]
+drm_scdc_set_high_tmds_clock_ratio [drm_kms_helper]
+drm_gem_fb_get_obj [drm_kms_helper]
+drm_gem_fb_create_handle [drm_kms_helper]
+drm_gem_fb_afbc_init [drm_kms_helper]
+drm_gem_fb_prepare_fb [drm_kms_helper]
+drm_gem_fb_simple_display_pipe_prepare_fb [drm_kms_helper]
+drm_gem_fb_destroy [drm_kms_helper]
+drm_gem_fb_init_with_funcs [drm_kms_helper]
+drm_gem_fb_create_with_funcs [drm_kms_helper]
+drm_gem_fb_create [drm_kms_helper]
+drm_gem_fb_create_with_dirty [drm_kms_helper]
+__drm_atomic_helper_crtc_state_reset [drm_kms_helper]
+__drm_atomic_helper_plane_state_reset [drm_kms_helper]
+__drm_atomic_helper_plane_reset [drm_kms_helper]
+__drm_atomic_helper_connector_state_reset [drm_kms_helper]
+__drm_atomic_helper_connector_reset [drm_kms_helper]
+drm_atomic_helper_connector_tv_reset [drm_kms_helper]
+__drm_atomic_helper_crtc_reset [drm_kms_helper]
+__drm_atomic_helper_private_obj_duplicate_state [drm_kms_helper]
+__drm_atomic_helper_bridge_duplicate_state [drm_kms_helper]
+drm_atomic_helper_bridge_destroy_state [drm_kms_helper]
+__drm_atomic_helper_plane_duplicate_state [drm_kms_helper]
+drm_atomic_helper_plane_duplicate_state [drm_kms_helper]
+__drm_atomic_helper_connector_duplicate_state [drm_kms_helper]
+drm_atomic_helper_connector_duplicate_state [drm_kms_helper]
+__drm_atomic_helper_bridge_reset [drm_kms_helper]
+__drm_atomic_helper_crtc_duplicate_state [drm_kms_helper]
+drm_atomic_helper_crtc_duplicate_state [drm_kms_helper]
+drm_atomic_helper_crtc_reset [drm_kms_helper]
+drm_atomic_helper_bridge_reset [drm_kms_helper]
+drm_atomic_helper_bridge_duplicate_state [drm_kms_helper]
+__drm_atomic_helper_connector_destroy_state [drm_kms_helper]
+drm_atomic_helper_connector_reset [drm_kms_helper]
+drm_atomic_helper_connector_destroy_state [drm_kms_helper]
+__drm_atomic_helper_plane_destroy_state [drm_kms_helper]
+drm_atomic_helper_plane_reset [drm_kms_helper]
+drm_atomic_helper_plane_destroy_state [drm_kms_helper]
+__drm_atomic_helper_crtc_destroy_state [drm_kms_helper]
+drm_atomic_helper_crtc_destroy_state [drm_kms_helper]
+drm_plane_enable_fb_damage_clips [drm_kms_helper]
+drm_atomic_helper_check_plane_damage [drm_kms_helper]
+drm_atomic_helper_damage_iter_init [drm_kms_helper]
+drm_atomic_helper_damage_iter_next [drm_kms_helper]
+drm_atomic_helper_damage_merged [drm_kms_helper]
+drm_atomic_helper_dirtyfb [drm_kms_helper]
+drm_fb_memcpy [drm_kms_helper]
+drm_fb_memcpy_dstclip [drm_kms_helper]
+drm_fb_xrgb8888_to_rgb565_line [drm_kms_helper]
+drm_fb_swab [drm_kms_helper]
+drm_fb_xrgb8888_to_rgb565_dstclip [drm_kms_helper]
+drm_fb_xrgb8888_to_rgb565 [drm_kms_helper]
+drm_fb_xrgb8888_to_rgb888_dstclip [drm_kms_helper]
+drm_fb_xrgb8888_to_gray8 [drm_kms_helper]
+drm_self_refresh_helper_cleanup [drm_kms_helper]
+drm_self_refresh_helper_update_avg_times [drm_kms_helper]
+drm_self_refresh_helper_alter_state [drm_kms_helper]
+drm_self_refresh_helper_entry_work [drm_kms_helper]
+drm_self_refresh_helper_init [drm_kms_helper]
+panel_bridge_detach [drm_kms_helper]
+drm_panel_bridge_connector [drm_kms_helper]
+panel_bridge_get_modes [drm_kms_helper]
+panel_bridge_connector_get_modes [drm_kms_helper]
+panel_bridge_enable [drm_kms_helper]
+panel_bridge_pre_enable [drm_kms_helper]
+panel_bridge_post_disable [drm_kms_helper]
+panel_bridge_disable [drm_kms_helper]
+panel_bridge_attach [drm_kms_helper]
+drm_panel_bridge_add_typed.part.0 [drm_kms_helper]
+drm_panel_bridge_add_typed [drm_kms_helper]
+drm_panel_bridge_add [drm_kms_helper]
+devm_drm_panel_bridge_add_typed [drm_kms_helper]
+devm_drm_panel_bridge_add [drm_kms_helper]
+devm_drm_panel_bridge_release [drm_kms_helper]
+drm_panel_bridge_remove [drm_kms_helper]
+drm_fb_helper_fill_pixel_fmt [drm_kms_helper]
+drm_fbdev_fb_mmap [drm_kms_helper]
+drm_fb_helper_dpms [drm_kms_helper]
+drm_fb_helper_blank [drm_kms_helper]
+drm_fb_helper_prepare [drm_kms_helper]
+drm_fb_helper_set_suspend [drm_kms_helper]
+drm_fb_helper_resume_worker [drm_kms_helper]
+drm_fb_helper_unregister_fbi [drm_kms_helper]
+drm_fb_helper_restore_work_fn [drm_kms_helper]
+drm_fb_helper_sysrq [drm_kms_helper]
+drm_fb_helper_sys_read [drm_kms_helper]
+drm_fb_helper_set_suspend_unlocked [drm_kms_helper]
+drm_fb_helper_ioctl [drm_kms_helper]
+drm_fb_helper_check_var [drm_kms_helper]
+drm_fb_helper_fill_info [drm_kms_helper]
+drm_setup_crtcs_fb [drm_kms_helper]
+drm_fbdev_fb_release [drm_kms_helper]
+drm_fbdev_fb_open [drm_kms_helper]
+drm_fbdev_use_shadow_fb [drm_kms_helper]
+drm_fb_helper_dirty [drm_kms_helper]
+drm_fb_helper_deferred_io [drm_kms_helper]
+drm_fb_helper_sys_fillrect [drm_kms_helper]
+drm_fb_helper_sys_copyarea [drm_kms_helper]
+drm_fb_helper_sys_imageblit [drm_kms_helper]
+drm_fb_helper_cfb_fillrect [drm_kms_helper]
+drm_fb_helper_cfb_copyarea [drm_kms_helper]
+drm_fb_helper_cfb_imageblit [drm_kms_helper]
+drm_fb_helper_debug_enter [drm_kms_helper]
+drm_fb_helper_debug_leave [drm_kms_helper]
+drm_fb_helper_dirty_work [drm_kms_helper]
+__drm_fb_helper_initial_config_and_unlock [drm_kms_helper]
+drm_fb_helper_sys_write [drm_kms_helper]
+drm_fb_helper_init [drm_kms_helper]
+drm_fb_helper_fini [drm_kms_helper]
+drm_fbdev_cleanup [drm_kms_helper]
+drm_fbdev_client_unregister [drm_kms_helper]
+drm_fb_helper_initial_config [drm_kms_helper]
+drm_fb_helper_hotplug_event [drm_kms_helper]
+__drm_fb_helper_restore_fbdev_mode_unlocked [drm_kms_helper]
+drm_fb_helper_restore_fbdev_mode_unlocked [drm_kms_helper]
+drm_fb_helper_lastclose [drm_kms_helper]
+drm_fbdev_client_restore [drm_kms_helper]
+drm_fb_helper_set_par [drm_kms_helper]
+drm_fb_helper_output_poll_changed [drm_kms_helper]
+drm_fbdev_client_hotplug [drm_kms_helper]
+drm_fbdev_generic_setup [drm_kms_helper]
+drm_fb_helper_setcmap [drm_kms_helper]
+drm_fb_helper_alloc_fbi [drm_kms_helper]
+drm_fb_helper_generic_probe [drm_kms_helper]
+drm_fbdev_fb_destroy [drm_kms_helper]
+drm_fb_helper_pan_display [drm_kms_helper]
+drm_fb_cma_get_gem_obj [drm_kms_helper]
+drm_fb_cma_get_gem_addr [drm_kms_helper]
+auxdev_write_iter [drm_kms_helper]
+auxdev_read_iter [drm_kms_helper]
+auxdev_llseek [drm_kms_helper]
+drm_dp_aux_dev_get_by_minor [drm_kms_helper]
+auxdev_open [drm_kms_helper]
+name_show [drm_kms_helper]
+auxdev_release [drm_kms_helper]
+drm_dp_aux_unregister_devnode [drm_kms_helper]
+drm_dp_aux_register_devnode [drm_kms_helper]
+drm_dp_aux_dev_init [drm_kms_helper]
+drm_dp_aux_dev_exit [drm_kms_helper]
+drm_dp_cec_adap_enable [drm_kms_helper]
+drm_dp_cec_adap_monitor_all_enable [drm_kms_helper]
+drm_dp_cec_adap_transmit [drm_kms_helper]
+drm_dp_cec_unregister_work [drm_kms_helper]
+drm_dp_cec_unregister_connector [drm_kms_helper]
+drm_dp_cec_adap_status [drm_kms_helper]
+drm_dp_cec_adap_log_addr [drm_kms_helper]
+drm_dp_cec_register_connector [drm_kms_helper]
+drm_dp_cec_irq [drm_kms_helper]
+drm_dp_cec_set_edid [drm_kms_helper]
+drm_dp_cec_unset_edid [drm_kms_helper]
+edid_firmware_set [drm_kms_helper]
+i915_gem_reject_pin_ioctl [i915]
+i915_driver_lastclose [i915]
+i915_driver_open [i915]
+i915_driver_postclose [i915]
+i915_pm_prepare [i915]
+i915_driver_hw_remove [i915]
+i915_driver_late_release [i915]
+i915_drm_suspend [i915]
+i915_pm_suspend [i915]
+i915_drm_suspend_late [i915]
+i915_pm_poweroff_late [i915]
+i915_pm_suspend_late [i915]
+i915_drm_resume_early [i915]
+i915_pm_resume_early [i915]
+i915_pm_thaw_early [i915]
+i915_pm_restore_early [i915]
+i915_drm_resume [i915]
+i915_pm_resume [i915]
+i915_pm_thaw [i915]
+i915_pm_restore [i915]
+i915_pm_freeze_late [i915]
+i915_pm_freeze [i915]
+intel_teardown_mchbar [i915]
+intel_runtime_resume [i915]
+intel_runtime_suspend [i915]
+i915_driver_release [i915]
+i915_driver_probe [i915]
+i915_driver_remove [i915]
+i915_suspend_switcheroo [i915]
+i915_resume_switcheroo [i915]
+i915_fence_context_timeout [i915]
+gen11_port_hotplug_long_detect [i915]
+bxt_port_hotplug_long_detect [i915]
+icp_ddi_port_hotplug_long_detect [i915]
+icp_tc_port_hotplug_long_detect [i915]
+spt_port_hotplug2_long_detect [i915]
+spt_port_hotplug_long_detect [i915]
+ilk_port_hotplug_long_detect [i915]
+pch_port_hotplug_long_detect [i915]
+i9xx_port_hotplug_long_detect [i915]
+icp_ddi_hpd_detection_setup [i915]
+icp_tc_hpd_detection_setup [i915]
+gen11_hpd_detection_setup [i915]
+ilk_hpd_detection_setup [i915]
+ibx_hpd_detection_setup [i915]
+spt_hpd_detection_setup [i915]
+i9xx_error_irq_ack [i915]
+gen3_assert_iir_is_zero [i915]
+ibx_irq_postinstall [i915]
+ibx_irq_pre_postinstall [i915]
+i9xx_pipestat_irq_reset [i915]
+intel_get_hpd_pins [i915]
+__bxt_hpd_detection_setup [i915]
+ilk_hpd_irq_handler [i915]
+ibx_hpd_irq_handler [i915]
+i9xx_hpd_irq_handler [i915]
+cpt_irq_handler [i915]
+i9xx_hpd_irq_ack [i915]
+__intel_get_crtc_scanline [i915]
+i915_get_crtc_scanoutpos [i915]
+bdw_update_port_irq [i915]
+bxt_hpd_irq_setup [i915]
+i9xx_error_irq_handler [i915]
+i915_hpd_irq_setup [i915]
+display_pipe_crc_irq_handler [i915]
+hsw_pipe_crc_irq_handler [i915]
+i9xx_pipe_crc_irq_handler [i915]
+ilk_irq_handler [i915]
+valleyview_pipestat_irq_handler [i915]
+gen8_de_irq_handler [i915]
+gen11_display_irq_handler [i915]
+gen8_irq_handler [i915]
+ivb_parity_work [i915]
+gen3_irq_reset [i915]
+vlv_display_irq_reset [i915]
+ibx_irq_reset [i915]
+gen2_irq_reset [i915]
+gen3_irq_init [i915]
+gen8_de_irq_postinstall [i915]
+gen2_irq_init [i915]
+i915_hotplug_interrupt_update [i915]
+intel_irq_reset [i915]
+ilk_update_display_irq [i915]
+bdw_update_pipe_irq [i915]
+ibx_display_interrupt_update [i915]
+ilk_hpd_irq_setup [i915]
+spt_hpd_irq_setup [i915]
+icp_hpd_irq_setup [i915]
+gen11_hpd_irq_setup [i915]
+mcc_hpd_irq_setup [i915]
+jsp_hpd_irq_setup [i915]
+i915_pipestat_enable_mask [i915]
+i9xx_pipestat_irq_ack [i915]
+i8xx_irq_handler [i915]
+i915_irq_handler [i915]
+i965_irq_handler [i915]
+valleyview_irq_handler [i915]
+cherryview_irq_handler [i915]
+i915_enable_pipestat [i915]
+vlv_display_irq_postinstall [i915]
+i915_enable_asle_pipestat [i915]
+intel_irq_postinstall [i915]
+i915_disable_pipestat [i915]
+i915_get_vblank_counter [i915]
+g4x_get_vblank_counter [i915]
+intel_crtc_get_vblank_timestamp [i915]
+intel_get_crtc_scanline [i915]
+i8xx_enable_vblank [i915]
+i915gm_enable_vblank [i915]
+i965_enable_vblank [i915]
+ilk_enable_vblank [i915]
+bdw_enable_vblank [i915]
+i8xx_disable_vblank [i915]
+i915gm_disable_vblank [i915]
+i965_disable_vblank [i915]
+ilk_disable_vblank [i915]
+bdw_disable_vblank [i915]
+gen8_irq_power_well_post_enable [i915]
+gen8_irq_power_well_pre_disable [i915]
+valleyview_enable_display_irqs [i915]
+valleyview_disable_display_irqs [i915]
+intel_irq_init [i915]
+intel_irq_fini [i915]
+intel_irq_install [i915]
+intel_irq_uninstall [i915]
+intel_runtime_pm_disable_interrupts [i915]
+intel_runtime_pm_enable_interrupts [i915]
+intel_irqs_enabled [i915]
+gen11_irq_handler [i915]
+dg1_irq_handler [i915]
+intel_synchronize_irq [i915]
+i915_getparam_ioctl [i915]
+i915_params_dump [i915]
+i915_params_copy [i915]
+i915_params_free [i915]
+i915_pci_remove [i915]
+i915_pci_probe [i915]
+i915_sg_trim [i915]
+i915_save_state [i915]
+i915_restore_state [i915]
+i915_switcheroo_can_switch [i915]
+i915_switcheroo_set_state [i915]
+i915_switcheroo_register [i915]
+i915_switcheroo_unregister [i915]
+show_rc6_mask [i915]
+gt_act_freq_mhz_show [i915]
+gt_min_freq_mhz_show [i915]
+gt_max_freq_mhz_show [i915]
+gt_boost_freq_mhz_show [i915]
+gt_cur_freq_mhz_show [i915]
+vlv_rpe_freq_mhz_show [i915]
+gt_min_freq_mhz_store [i915]
+gt_max_freq_mhz_store [i915]
+gt_boost_freq_mhz_store [i915]
+calc_residency [i915]
+show_rc6pp_ms [i915]
+show_rc6p_ms [i915]
+show_media_rc6_ms [i915]
+show_rc6_ms [i915]
+error_state_write [i915]
+gt_rp_mhz_show [i915]
+i915_l3_write [i915]
+error_state_read [i915]
+i915_l3_read [i915]
+i915_setup_sysfs [i915]
+i915_teardown_sysfs [i915]
+__i915_printk [i915]
+add_taint_for_CI [i915]
+cancel_timer [i915]
+set_timer_ms [i915]
+intel_platform_name [i915]
+intel_device_info_print_static [i915]
+intel_device_info_print_runtime [i915]
+intel_device_info_subplatform_init [i915]
+intel_device_info_runtime_init [i915]
+intel_driver_caps_print [i915]
+skl_is_16gb_dimm [i915]
+skl_dram_get_dimm_info [i915]
+skl_dram_get_channel_info [i915]
+bxt_get_dimm_size [i915]
+intel_dram_detect [i915]
+intel_dram_edram_detect [i915]
+intel_memory_region_free_pages [i915]
+__intel_memory_region_destroy [i915]
+intel_memory_region_by_type [i915]
+__intel_memory_region_put_pages_buddy [i915]
+__intel_memory_region_put_block_buddy [i915]
+__intel_memory_region_get_pages_buddy [i915]
+__intel_memory_region_get_block_buddy [i915]
+intel_memory_region_init_buddy [i915]
+intel_memory_region_release_buddy [i915]
+intel_memory_region_create [i915]
+intel_memory_region_set_name [i915]
+intel_memory_region_get [i915]
+intel_memory_region_put [i915]
+intel_memory_regions_driver_release [i915]
+intel_memory_regions_hw_probe [i915]
+intel_pch_type [i915]
+intel_detect_pch [i915]
+gen9_init_clock_gating [i915]
+bxt_init_clock_gating [i915]
+glk_init_clock_gating [i915]
+skl_init_clock_gating [i915]
+_ilk_disable_lp_wm [i915]
+lpt_init_clock_gating [i915]
+hsw_init_clock_gating [i915]
+kbl_init_clock_gating [i915]
+nop_init_clock_gating [i915]
+gen6_check_mch_setup [i915]
+i830_get_fifo_size [i915]
+i845_get_fifo_size [i915]
+i9xx_get_fifo_size [i915]
+vlv_invalidate_wms [i915]
+g4x_disable_trickle_feed [i915]
+ilk_init_clock_gating [i915]
+g4x_init_clock_gating [i915]
+cpt_init_clock_gating [i915]
+gen6_init_clock_gating [i915]
+skl_compute_dbuf_slices [i915]
+i830_init_clock_gating [i915]
+i85x_init_clock_gating [i915]
+gen3_init_clock_gating [i915]
+i965g_init_clock_gating [i915]
+i965gm_init_clock_gating [i915]
+vlv_init_clock_gating [i915]
+ivb_init_clock_gating [i915]
+_intel_set_memory_cxsr [i915]
+intel_print_wm_latency [i915]
+chv_set_memory_pm5 [i915]
+chv_set_memory_dvfs [i915]
+intel_calculate_wm [i915]
+intel_add_affected_pipes [i915]
+intel_dbuf_destroy_state [i915]
+intel_dbuf_duplicate_state [i915]
+intel_crtc_active [i915]
+single_enabled_crtc [i915]
+i845_update_wm [i915]
+skl_write_wm_level [i915]
+vlv_compute_intermediate_wm [i915]
+vlv_atomic_update_fifo [i915]
+intel_wm_method2 [i915]
+vlv_program_watermarks [i915]
+vlv_initial_watermarks [i915]
+vlv_optimize_watermarks [i915]
+intel_read_wm_latency [i915]
+g4x_plane_fifo_size.part.0 [i915]
+g4x_plane_fifo_size [i915]
+g4x_compute_intermediate_wm [i915]
+cnp_init_clock_gating.part.0 [i915]
+cfl_init_clock_gating [i915]
+cnl_init_clock_gating [i915]
+intel_get_cxsr_latency.part.0 [i915]
+intel_wm_plane_visible [i915]
+ilk_compute_fbc_wm [i915]
+ilk_compute_wm_level.isra.0 [i915]
+ilk_validate_wm_level [i915]
+ilk_wm_merge [i915]
+intel_enable_ipc.part.0 [i915]
+gen8_set_l3sqc_credits.constprop.0 [i915]
+bdw_init_clock_gating [i915]
+chv_init_clock_gating [i915]
+ilk_increase_wm_latency.constprop.0 [i915]
+tgl_init_clock_gating [i915]
+g4x_raw_crtc_wm_is_valid.part.0 [i915]
+icl_init_clock_gating [i915]
+skl_compute_plane_wm [i915]
+skl_compute_wm_levels [i915]
+skl_plane_downscale_amount [i915]
+skl_plane_relative_data_rate [i915]
+g4x_program_watermarks [i915]
+g4x_initial_watermarks [i915]
+g4x_optimize_watermarks [i915]
+skl_compute_wm_params [i915]
+skl_compute_plane_wm_params [i915]
+skl_build_plane_wm_single [i915]
+ilk_plane_wm_max [i915]
+ilk_compute_wm_maximums [i915]
+ilk_validate_pipe_wm [i915]
+ilk_compute_intermediate_wm [i915]
+ilk_compute_pipe_wm [i915]
+ilk_program_watermarks [i915]
+ilk_optimize_watermarks [i915]
+ilk_initial_watermarks [i915]
+g4x_compute_pipe_wm [i915]
+vlv_compute_pipe_wm [i915]
+intel_set_memory_cxsr [i915]
+i9xx_update_wm [i915]
+i965_update_wm [i915]
+pnv_update_wm [i915]
+ilk_wm_max_level [i915]
+ilk_disable_lp_wm [i915]
+intel_enabled_dbuf_slices_mask [i915]
+intel_enable_sagv [i915]
+intel_disable_sagv [i915]
+intel_sagv_pre_plane_update [i915]
+intel_sagv_post_plane_update [i915]
+intel_can_enable_sagv [i915]
+intel_get_ddb_size [i915]
+skl_allocate_pipe_ddb [i915]
+skl_ddb_dbuf_slice_mask [i915]
+skl_pipe_ddb_get_hw_state [i915]
+skl_write_plane_wm [i915]
+skl_write_cursor_wm [i915]
+skl_wm_level_equals [i915]
+skl_plane_wm_equals [i915]
+skl_compute_wm [i915]
+skl_ddb_allocation_overlaps [i915]
+skl_pipe_wm_get_hw_state [i915]
+skl_wm_get_hw_state [i915]
+g4x_wm_get_hw_state [i915]
+g4x_wm_sanitize [i915]
+vlv_wm_get_hw_state [i915]
+vlv_wm_sanitize [i915]
+ilk_wm_get_hw_state [i915]
+intel_update_watermarks [i915]
+intel_enable_ipc [i915]
+intel_init_ipc [i915]
+intel_init_clock_gating [i915]
+intel_suspend_hw [i915]
+intel_init_clock_gating_hooks [i915]
+intel_init_pm [i915]
+intel_pm_setup [i915]
+intel_atomic_get_dbuf_state [i915]
+intel_dbuf_init [i915]
+intel_dbuf_pre_plane_update [i915]
+intel_dbuf_post_plane_update [i915]
+intel_runtime_pm_release [i915]
+intel_runtime_pm_acquire [i915]
+__intel_runtime_pm_get [i915]
+intel_runtime_pm_get_raw [i915]
+intel_runtime_pm_get [i915]
+intel_runtime_pm_get_if_in_use [i915]
+intel_runtime_pm_get_noresume [i915]
+intel_runtime_pm_put_raw [i915]
+intel_runtime_pm_put_unchecked [i915]
+intel_runtime_pm_enable [i915]
+intel_runtime_pm_disable [i915]
+intel_runtime_pm_driver_release [i915]
+intel_runtime_pm_init_early [i915]
+ping [i915]
+__sandybridge_pcode_rw [i915]
+skl_pcode_try_request [i915]
+intel_sbi_rw [i915]
+vlv_sideband_rw.constprop.0 [i915]
+vlv_iosf_sb_get [i915]
+vlv_iosf_sb_put [i915]
+vlv_punit_read [i915]
+vlv_punit_write [i915]
+vlv_bunit_read [i915]
+vlv_bunit_write [i915]
+vlv_nc_read [i915]
+vlv_iosf_sb_read [i915]
+vlv_iosf_sb_write [i915]
+vlv_cck_read [i915]
+vlv_cck_write [i915]
+vlv_ccu_read [i915]
+vlv_ccu_write [i915]
+vlv_dpio_read [i915]
+vlv_dpio_write [i915]
+vlv_flisdsi_read [i915]
+vlv_flisdsi_write [i915]
+intel_sbi_read [i915]
+intel_sbi_write [i915]
+sandybridge_pcode_read [i915]
+sandybridge_pcode_write_timeout [i915]
+skl_pcode_request [i915]
+gen6_reg_write_fw_domains [i915]
+gen6_reg_read_fw_domains [i915]
+gen8_reg_write_fw_domains [i915]
+__intel_uncore_forcewake_get [i915]
+__intel_uncore_forcewake_put [i915]
+fw_domains_put [i915]
+find_fw_domain [i915]
+gen12_fwtable_reg_read_fw_domains [i915]
+fwtable_reg_read_fw_domains [i915]
+gen12_fwtable_reg_write_fw_domains [i915]
+gen11_fwtable_reg_write_fw_domains [i915]
+fwtable_reg_write_fw_domains [i915]
+___force_wake_auto [i915]
+__gen6_gt_wait_for_fifo [i915]
+fw_domain_fini [i915]
+intel_uncore_fw_domains_fini [i915]
+__gen6_gt_wait_for_thread_c0 [i915]
+check_for_unclaimed_mmio.part.0 [i915]
+__unclaimed_reg_debug [i915]
+intel_uncore_fw_release_timer [i915]
+intel_uncore_forcewake_domain_to_str.part.0 [i915]
+__fw_domain_init [i915]
+gen11_fwtable_reg_read_fw_domains [i915]
+fw_domain_wait_ack_with_fallback [i915]
+fw_domains_get [i915]
+fw_domains_get_with_thread_status [i915]
+fw_domains_get_with_fallback [i915]
+vgpu_write16 [i915]
+vgpu_write32 [i915]
+vgpu_read16 [i915]
+vgpu_read32 [i915]
+vgpu_read64 [i915]
+vgpu_read8 [i915]
+vgpu_write8 [i915]
+fwtable_write16 [i915]
+intel_uncore_forcewake_get.part.0 [i915]
+i915_pmic_bus_access_notifier [i915]
+gen2_write16 [i915]
+gen2_write32 [i915]
+gen2_read8 [i915]
+gen2_write8 [i915]
+gen2_read32 [i915]
+gen2_read16 [i915]
+gen2_read64 [i915]
+gen5_write32 [i915]
+gen5_read32 [i915]
+gen5_read8 [i915]
+gen5_read64 [i915]
+gen5_write8 [i915]
+gen5_write16 [i915]
+gen5_read16 [i915]
+gen6_write32 [i915]
+gen6_write16 [i915]
+gen6_write8 [i915]
+gen6_read32 [i915]
+gen6_read16 [i915]
+gen6_read8 [i915]
+gen6_read64 [i915]
+gen12_fwtable_read16 [i915]
+gen11_fwtable_read16 [i915]
+gen12_fwtable_read64 [i915]
+gen11_fwtable_read64 [i915]
+gen12_fwtable_read32 [i915]
+gen11_fwtable_read32 [i915]
+gen12_fwtable_read8 [i915]
+gen11_fwtable_read8 [i915]
+fwtable_read8 [i915]
+fwtable_read64 [i915]
+fwtable_read16 [i915]
+fwtable_read32 [i915]
+gen8_write8 [i915]
+gen8_write32 [i915]
+gen8_write16 [i915]
+gen12_fwtable_write8 [i915]
+gen12_fwtable_write32 [i915]
+gen12_fwtable_write16 [i915]
+gen11_fwtable_write8 [i915]
+gen11_fwtable_write32 [i915]
+gen11_fwtable_write16 [i915]
+fwtable_write32 [i915]
+fwtable_write8 [i915]
+intel_uncore_mmio_debug_init_early [i915]
+intel_uncore_forcewake_domain_to_str [i915]
+intel_uncore_runtime_resume [i915]
+intel_uncore_forcewake_get [i915]
+intel_uncore_forcewake_user_get [i915]
+intel_uncore_forcewake_user_put [i915]
+intel_uncore_forcewake_get__locked [i915]
+intel_uncore_forcewake_put [i915]
+intel_uncore_forcewake_flush [i915]
+intel_uncore_forcewake_put__locked [i915]
+assert_forcewakes_inactive [i915]
+intel_uncore_forcewake_reset [i915]
+intel_uncore_suspend [i915]
+forcewake_early_sanitize [i915]
+assert_forcewakes_active [i915]
+intel_uncore_init_early [i915]
+intel_uncore_prune_engine_fw_domains [i915]
+intel_uncore_fini_mmio [i915]
+i915_reg_read_ioctl [i915]
+__intel_wait_for_register_fw [i915]
+intel_uncore_unclaimed_mmio [i915]
+intel_uncore_resume_early [i915]
+intel_uncore_init_mmio [i915]
+intel_uncore_arm_unclaimed_mmio_detection [i915]
+intel_uncore_forcewake_for_reg [i915]
+__intel_wait_for_register [i915]
+____intel_wakeref_put_last [i915]
+__intel_wakeref_put_work [i915]
+wakeref_auto_timeout [i915]
+__intel_wakeref_get_first [i915]
+__intel_wakeref_put_last [i915]
+__intel_wakeref_init [i915]
+intel_wakeref_wait_for_idle [i915]
+intel_wakeref_auto_init [i915]
+intel_wakeref_auto [i915]
+intel_wakeref_auto_fini [i915]
+vlv_check_no_gt_access [i915]
+vlv_force_gfx_clock [i915]
+vlv_wait_for_pw_status [i915]
+vlv_allow_gt_wake [i915]
+vlv_suspend_complete [i915]
+vlv_resume_prepare [i915]
+vlv_suspend_init [i915]
+vlv_suspend_cleanup [i915]
+i915_memcpy_from_wc [i915]
+i915_unaligned_memcpy_from_wc [i915]
+i915_memcpy_init_early [i915]
+remap_sg [i915]
+remap_pfn [i915]
+remap_io_mapping [i915]
+remap_io_sg [i915]
+__i915_sw_fence_complete [i915]
+irq_i915_sw_fence_work [i915]
+i915_sw_fence_wake [i915]
+i915_sw_fence_complete [i915]
+dma_i915_sw_fence_wake_timer [i915]
+timer_i915_sw_fence_wake [i915]
+dma_i915_sw_fence_wake [i915]
+__dma_i915_sw_fence_wake [i915]
+i915_sw_fence_await [i915]
+__i915_sw_fence_await_sw_fence [i915]
+__i915_sw_fence_init [i915]
+i915_sw_fence_reinit [i915]
+i915_sw_fence_commit [i915]
+i915_sw_fence_await_sw_fence [i915]
+i915_sw_fence_await_sw_fence_gfp [i915]
+i915_sw_fence_await_dma_fence [i915]
+__i915_sw_fence_await_dma_fence [i915]
+i915_sw_fence_await_reservation [i915]
+get_driver_name [i915]
+fence_release [i915]
+get_timeline_name [i915]
+fence_complete [i915]
+fence_work [i915]
+fence_notify [i915]
+dma_fence_work_init [i915]
+dma_fence_work_chain [i915]
+__sync_alloc_leaf [i915]
+__sync_free [i915]
+__sync_set [i915]
+i915_syncmap_init [i915]
+i915_syncmap_is_later [i915]
+i915_syncmap_set [i915]
+i915_syncmap_free [i915]
+i915_user_extensions [i915]
+compat_i915_getparam [i915]
+i915_ioc32_compat_ioctl [i915]
+i915_perf_noa_delay_get [i915]
+i915_drop_caches_get [i915]
+i915_shrinker_info [i915]
+i915_llc [i915]
+i915_rps_boost_info [i915]
+i915_perf_noa_delay_set [i915]
+i915_sseu_status [i915]
+i915_wa_registers [i915]
+i915_engine_info [i915]
+i915_swizzle_info [i915]
+i915_cache_sharing_get [i915]
+i915_runtime_pm_status [i915]
+i915_ring_freq_table [i915]
+i915_frequency_info [i915]
+gen8_display_interrupt_info [i915]
+i915_interrupt_info [i915]
+i915_capabilities [i915]
+i915_gpu_info_open [i915]
+gpu_state_read [i915]
+i915_error_state_open [i915]
+i915_cache_sharing_set [i915]
+i915_error_state_write [i915]
+i915_drop_caches_fops_open [i915]
+i915_cache_sharing_fops_open [i915]
+i915_wedged_fops_open [i915]
+i915_perf_noa_delay_fops_open [i915]
+i915_wedged_get [i915]
+i915_wedged_set [i915]
+i915_forcewake_open [i915]
+i915_drop_caches_set [i915]
+i915_forcewake_release [i915]
+gpu_state_release [i915]
+per_file_stats [i915]
+print_context_stats [i915]
+i915_gem_object_info [i915]
+i915_debugfs_describe_obj [i915]
+i915_context_status [i915]
+i915_gem_fence_regs_info [i915]
+i915_debugfs_register [i915]
+i915_param_int_open [i915]
+i915_param_uint_open [i915]
+i915_param_charp_open [i915]
+i915_param_int_show [i915]
+i915_param_uint_show [i915]
+i915_param_charp_show [i915]
+i915_param_int_write [i915]
+i915_param_uint_write [i915]
+i915_debugfs_params [i915]
+intel_lpsp_power_well_enabled [i915]
+i915_edp_psr_debug_fops_open [i915]
+i915_drrs_ctl_fops_open [i915]
+i915_fbc_false_color_fops_open [i915]
+i915_lpsp_capability_show [i915]
+i915_lpsp_status [i915]
+i915_dmc_info [i915]
+i915_ips_status [i915]
+i915_frontbuffer_tracking [i915]
+i915_hpd_short_storm_ctl_show [i915]
+i915_panel_show [i915]
+i915_ddb_info [i915]
+i915_displayport_test_type_show [i915]
+i915_displayport_test_data_show [i915]
+i915_fbc_false_color_set [i915]
+intel_panel_info [i915]
+intel_hdcp_info [i915]
+i915_hdcp_sink_capability_show [i915]
+i915_power_domain_info [i915]
+i915_gem_framebuffer_info [i915]
+i915_vbt [i915]
+i915_opregion [i915]
+i915_sr_status [i915]
+i915_fbc_status [i915]
+i915_ipc_status_open [i915]
+i915_hpd_short_storm_ctl_open [i915]
+i915_hpd_storm_ctl_open [i915]
+i915_displayport_test_active_open [i915]
+i915_displayport_test_type_open [i915]
+i915_displayport_test_data_open [i915]
+cur_wm_latency_open [i915]
+spr_wm_latency_open [i915]
+pri_wm_latency_open [i915]
+i915_lpsp_capability_open [i915]
+i915_dsc_fec_support_open [i915]
+i915_hdcp_sink_capability_open [i915]
+i915_psr_sink_status_open [i915]
+i915_panel_open [i915]
+i915_hpd_storm_ctl_show [i915]
+i915_displayport_test_active_write [i915]
+wm_latency_show [i915]
+cur_wm_latency_show [i915]
+spr_wm_latency_show [i915]
+pri_wm_latency_show [i915]
+i915_fbc_false_color_get [i915]
+i915_edp_psr_debug_get [i915]
+i915_ipc_status_show [i915]
+i915_shared_dplls_info [i915]
+i915_displayport_test_active_show [i915]
+i915_edp_psr_status [i915]
+i915_drrs_status [i915]
+i915_dp_mst_info [i915]
+i915_edp_psr_debug_set [i915]
+i915_drrs_ctl_set [i915]
+i915_dsc_fec_support_write [i915]
+i915_ipc_status_write [i915]
+i915_hpd_short_storm_ctl_write [i915]
+i915_fifo_underrun_reset_write [i915]
+i915_dsc_fec_support_show [i915]
+i915_psr_sink_status_show [i915]
+wm_latency_write.isra.0 [i915]
+cur_wm_latency_write [i915]
+spr_wm_latency_write [i915]
+pri_wm_latency_write [i915]
+plane_rotation.constprop.0 [i915]
+i915_display_info [i915]
+i915_hpd_storm_ctl_write [i915]
+intel_display_debugfs_register [i915]
+intel_connector_debugfs_add [i915]
+i9xx_pipe_crc_auto_source [i915]
+get_new_crc_ctl_reg [i915]
+intel_crtc_crc_setup_workarounds [i915]
+intel_crtc_crc_init [i915]
+intel_crtc_get_crc_sources [i915]
+intel_crtc_verify_crc_source [i915]
+intel_crtc_set_crc_source [i915]
+intel_crtc_enable_pipe_crc [i915]
+intel_crtc_disable_pipe_crc [i915]
+i915_pmu_event_event_idx [i915]
+i915_pmu_get_attr_cpumask [i915]
+engine_sample [i915]
+__get_rc6 [i915]
+free_event_attributes [i915]
+i915_pmu_event_destroy [i915]
+i915_pmu_format_show [i915]
+i915_pmu_event_show [i915]
+config_status [i915]
+i915_pmu_event_init [i915]
+__i915_pmu_maybe_start_timer [i915]
+i915_pmu_cpu_offline [i915]
+__i915_pmu_event_read [i915]
+i915_pmu_event_read [i915]
+i915_pmu_event_stop [i915]
+i915_pmu_event_del [i915]
+i915_pmu_enable [i915]
+i915_pmu_event_start [i915]
+i915_pmu_event_add [i915]
+i915_pmu_cpu_online [i915]
+i915_sample [i915]
+i915_pmu_gt_parked [i915]
+i915_pmu_gt_unparked [i915]
+i915_pmu_register [i915]
+i915_pmu_unregister [i915]
+engines_open [i915]
+engines_show [i915]
+debugfs_engines_register [i915]
+debugfs_gt_register [i915]
+intel_gt_debugfs_register_files [i915]
+llc_eval [i915]
+rps_eval [i915]
+rps_boost_open [i915]
+llc_open [i915]
+fw_domains_open [i915]
+frequency_open [i915]
+drpc_open [i915]
+rps_boost_show [i915]
+llc_show [i915]
+fw_domains_show [i915]
+frequency_show [i915]
+print_rc6_res [i915]
+drpc_show [i915]
+debugfs_gt_pm_register [i915]
+__gen2_emit_breadcrumb.constprop.0 [i915]
+gen2_emit_flush [i915]
+gen4_emit_flush_rcs [i915]
+gen4_emit_flush_vcs [i915]
+gen3_emit_breadcrumb [i915]
+gen5_emit_breadcrumb [i915]
+i830_emit_bb_start [i915]
+gen3_emit_bb_start [i915]
+gen4_emit_bb_start [i915]
+gen2_irq_enable [i915]
+gen2_irq_disable [i915]
+gen3_irq_enable [i915]
+gen3_irq_disable [i915]
+gen5_irq_enable [i915]
+gen5_irq_disable [i915]
+mi_flush_dw [i915]
+gen6_emit_flush_rcs [i915]
+gen6_emit_breadcrumb_rcs [i915]
+gen6_emit_flush_xcs [i915]
+gen6_emit_flush_vcs [i915]
+gen6_emit_bb_start [i915]
+hsw_emit_bb_start [i915]
+gen7_emit_flush_rcs [i915]
+gen7_emit_breadcrumb_rcs [i915]
+gen6_emit_breadcrumb_xcs [i915]
+gen7_emit_breadcrumb_xcs [i915]
+gen6_irq_enable [i915]
+gen6_irq_disable [i915]
+hsw_irq_enable_vecs [i915]
+hsw_irq_disable_vecs [i915]
+pd_vma_set_pages [i915]
+pd_vma_clear_pages [i915]
+gen6_ppgtt_insert_entries [i915]
+gen6_ppgtt_clear_range [i915]
+gen6_flush_pd [i915]
+pd_vma_bind [i915]
+pd_vma_unbind [i915]
+gen6_ppgtt_cleanup [i915]
+gen6_alloc_va_range [i915]
+gen7_ppgtt_enable [i915]
+gen6_ppgtt_enable [i915]
+gen6_ppgtt_pin [i915]
+gen6_ppgtt_unpin [i915]
+gen6_ppgtt_unpin_all [i915]
+gen6_ppgtt_create [i915]
+emit_batch [i915]
+gen7_setup_clear_gpr_bb [i915]
+gen8_pde_encode [i915]
+gen8_pte_encode [i915]
+__gen8_ppgtt_cleanup [i915]
+gen8_ppgtt_notify_vgt [i915]
+gen8_ppgtt_insert [i915]
+gen8_ppgtt_cleanup [i915]
+__gen8_ppgtt_clear [i915]
+gen8_ppgtt_clear [i915]
+__gen8_ppgtt_alloc [i915]
+gen8_ppgtt_alloc [i915]
+gen8_ppgtt_create [i915]
+__signal_request [i915]
+irq_enable [i915]
+irq_disable [i915]
+signal_irq_work [i915]
+intel_breadcrumbs_create [i915]
+intel_breadcrumbs_reset [i915]
+intel_breadcrumbs_park [i915]
+intel_breadcrumbs_free [i915]
+i915_request_enable_breadcrumb [i915]
+i915_request_cancel_breadcrumb [i915]
+intel_engine_print_breadcrumbs [i915]
+rcu_context_free [i915]
+i915_global_context_exit [i915]
+i915_global_context_shrink [i915]
+intel_context_post_unpin [i915]
+__intel_context_active [i915]
+__intel_context_retire [i915]
+intel_context_free [i915]
+intel_context_alloc_state [i915]
+__intel_context_do_pin_ww [i915]
+__intel_context_do_pin [i915]
+intel_context_unpin [i915]
+intel_context_init [i915]
+intel_context_create [i915]
+intel_context_fini [i915]
+intel_context_enter_engine [i915]
+intel_context_exit_engine [i915]
+intel_context_prepare_remote_request [i915]
+intel_context_create_request [i915]
+intel_context_set_ring_size [i915]
+intel_context_get_ring_size [i915]
+intel_context_reconfigure_sseu [i915]
+read_subslice_reg [i915]
+hexdump [i915]
+print_request [i915]
+get_timeline [i915]
+print_ring.part.0 [i915]
+intel_engine_context_size [i915]
+intel_engine_set_hwsp_writemask [i915]
+cleanup_status_page [i915]
+intel_engines_release [i915]
+intel_engine_free_request_pool [i915]
+intel_engines_free [i915]
+intel_engines_init_mmio [i915]
+intel_engine_init_execlists [i915]
+intel_engine_init_active [i915]
+intel_engines_init [i915]
+intel_engine_cleanup_common [i915]
+intel_engine_resume [i915]
+intel_engine_get_active_head [i915]
+intel_engine_get_last_batch_head [i915]
+intel_engine_print_registers [i915]
+intel_engine_stop_cs [i915]
+intel_engine_cancel_stop_cs [i915]
+i915_cache_level_str [i915]
+intel_engine_get_instdone [i915]
+intel_engine_flush_submission [i915]
+intel_engine_is_idle [i915]
+intel_engines_are_idle [i915]
+intel_engines_reset_default_submission [i915]
+intel_engine_can_store_dword [i915]
+intel_engine_get_busy_time [i915]
+intel_engine_find_active_request [i915]
+intel_engine_dump [i915]
+next_heartbeat [i915]
+__intel_engine_pulse [i915]
+heartbeat [i915]
+intel_engine_unpark_heartbeat [i915]
+intel_engine_park_heartbeat [i915]
+intel_engine_init_heartbeat [i915]
+intel_engine_set_heartbeat [i915]
+intel_engine_pulse [i915]
+intel_engine_flush_barriers [i915]
+__engine_unpark [i915]
+__engine_park [i915]
+duration [i915]
+intel_engine_init__pm [i915]
+engine_cmp [i915]
+intel_engine_lookup_user [i915]
+intel_engine_add_user [i915]
+intel_engine_class_repr [i915]
+intel_engines_driver_register [i915]
+intel_engines_has_context_isolation [i915]
+gen8_ggtt_pte_encode [i915]
+nop_clear_range [i915]
+byt_pte_encode [i915]
+hsw_pte_encode [i915]
+iris_pte_encode [i915]
+snb_pte_encode [i915]
+ivb_pte_encode [i915]
+gmch_ggtt_invalidate [i915]
+i915_gmch_remove [i915]
+i915_ggtt_clear_range [i915]
+i915_ggtt_insert_page [i915]
+bxt_vtd_ggtt_insert_page__BKL [i915]
+bxt_vtd_ggtt_insert_entries__BKL [i915]
+cleanup_init_ggtt [i915]
+gen6_ggtt_invalidate [i915]
+gen8_ggtt_invalidate [i915]
+guc_ggtt_invalidate [i915]
+gen8_ggtt_insert_page [i915]
+bxt_vtd_ggtt_insert_page__cb [i915]
+ggtt_bind_vma [i915]
+ggtt_unbind_vma [i915]
+i915_ggtt_color_adjust [i915]
+gen8_ggtt_insert_entries [i915]
+bxt_vtd_ggtt_insert_entries__cb [i915]
+aliasing_gtt_unbind_vma [i915]
+aliasing_gtt_bind_vma [i915]
+gen8_ggtt_clear_range [i915]
+intel_rotate_pages [i915]
+intel_remap_pages [i915]
+intel_partial_pages [i915]
+i915_ggtt_insert_entries [i915]
+gen6_gmch_remove [i915]
+gen6_ggtt_insert_entries [i915]
+gen6_ggtt_insert_page [i915]
+gen6_ggtt_clear_range [i915]
+ggtt_probe_common [i915]
+ggtt_set_pages [i915]
+i915_ggtt_init_hw [i915]
+i915_ggtt_suspend [i915]
+i915_init_ggtt [i915]
+i915_ggtt_driver_release [i915]
+i915_ggtt_probe_hw [i915]
+i915_ggtt_enable_hw [i915]
+i915_ggtt_enable_guc [i915]
+i915_ggtt_disable_guc [i915]
+i915_ggtt_resume [i915]
+fence_write [i915]
+fence_update [i915]
+i915_vma_revoke_fence [i915]
+__i915_vma_pin_fence [i915]
+i915_vma_pin_fence [i915]
+i915_reserve_fence [i915]
+i915_unreserve_fence [i915]
+intel_ggtt_restore_fences [i915]
+i915_gem_object_do_bit_17_swizzle [i915]
+i915_gem_object_save_bit_17_swizzle [i915]
+intel_ggtt_init_fences [i915]
+intel_ggtt_fini_fences [i915]
+intel_gt_init_swizzling [i915]
+init_unused_ring [i915]
+__engines_record_defaults [i915]
+intel_gt_init_early [i915]
+intel_gt_init_hw_early [i915]
+intel_gt_init_mmio [i915]
+intel_gt_init_hw [i915]
+intel_gt_clear_error_registers [i915]
+intel_gt_check_and_clear_faults [i915]
+intel_gt_flush_ggtt_writes [i915]
+intel_gt_chipset_flush [i915]
+intel_gt_driver_register [i915]
+intel_gt_init [i915]
+intel_gt_driver_remove [i915]
+intel_gt_driver_unregister [i915]
+intel_gt_driver_release [i915]
+intel_gt_driver_late_release [i915]
+intel_gt_info_print [i915]
+pool_retire [i915]
+pool_active [i915]
+node_free [i915]
+pool_free_older_than [i915]
+pool_free_work [i915]
+intel_gt_get_buffer_pool [i915]
+intel_gt_init_buffer_pool [i915]
+intel_gt_flush_buffer_pool [i915]
+intel_gt_fini_buffer_pool [i915]
+intel_gt_init_clock_frequency [i915]
+intel_gt_clock_interval_to_ns [i915]
+intel_gt_pm_interval_to_ns [i915]
+intel_gt_ns_to_clock_interval [i915]
+intel_gt_ns_to_pm_interval [i915]
+gen11_gt_engine_identity [i915]
+cs_irq_handler [i915]
+gen11_gt_irq_handler [i915]
+gen11_gt_reset_one_iir [i915]
+gen11_gt_irq_reset [i915]
+gen11_gt_irq_postinstall [i915]
+gen5_gt_irq_handler [i915]
+gen6_gt_irq_handler [i915]
+gen8_gt_irq_handler [i915]
+gen8_gt_irq_reset [i915]
+gen8_gt_irq_postinstall [i915]
+gen5_gt_enable_irq [i915]
+gen5_gt_disable_irq [i915]
+gen5_gt_irq_reset [i915]
+gen5_gt_irq_postinstall [i915]
+wait_for_suspend [i915]
+__gt_park [i915]
+__gt_unpark [i915]
+gt_sanitize [i915]
+user_forcewake [i915]
+intel_gt_pm_init_early [i915]
+intel_gt_pm_init [i915]
+intel_gt_pm_fini [i915]
+intel_gt_resume [i915]
+intel_gt_suspend_prepare [i915]
+intel_gt_suspend_late [i915]
+intel_gt_runtime_suspend [i915]
+intel_gt_runtime_resume [i915]
+write_pm_ier [i915]
+gen6_gt_pm_update_irq [i915]
+gen6_gt_pm_unmask_irq [i915]
+gen6_gt_pm_mask_irq [i915]
+gen6_gt_pm_reset_iir [i915]
+gen6_gt_pm_enable_irq [i915]
+gen6_gt_pm_disable_irq [i915]
+retire_requests [i915]
+flush_submission.part.0 [i915]
+engine_retire [i915]
+intel_engine_add_retire [i915]
+intel_engine_init_retire [i915]
+intel_engine_fini_retire [i915]
+intel_gt_retire_requests_timeout [i915]
+retire_work_handler [i915]
+intel_gt_wait_for_idle [i915]
+intel_gt_init_requests [i915]
+intel_gt_park_requests [i915]
+intel_gt_unpark_requests [i915]
+intel_gt_fini_requests [i915]
+__i915_vm_release [i915]
+alloc_pt_dma [i915]
+pin_pt_dma [i915]
+__i915_vm_close [i915]
+i915_address_space_fini [i915]
+i915_vm_release [i915]
+i915_address_space_init [i915]
+clear_pages [i915]
+__px_dma [i915]
+__px_page [i915]
+fill_page_dma [i915]
+setup_scratch_page [i915]
+free_scratch [i915]
+gtt_write_workarounds [i915]
+setup_private_pat [i915]
+intel_llc_enable [i915]
+intel_llc_disable [i915]
+execlists_park [i915]
+set_offsets [i915]
+execlists_context_unpin [i915]
+execlists_context_post_unpin [i915]
+gen12_emit_timestamp_wa [i915]
+gen12_emit_restore_scratch [i915]
+gen12_emit_indirect_ctx_xcs [i915]
+gen12_emit_indirect_ctx_rcs [i915]
+nop_submission_tasklet [i915]
+gen8_logical_ring_enable_irq [i915]
+gen8_logical_ring_disable_irq [i915]
+gen8_emit_fini_breadcrumb [i915]
+gen11_emit_fini_breadcrumb_rcs [i915]
+gen12_emit_fini_breadcrumb [i915]
+gen12_emit_fini_breadcrumb_rcs [i915]
+virtual_bond_execute [i915]
+hold_request [i915]
+intel_execlists_set_default_submission [i915]
+gen8_emit_bb_start_noarb [i915]
+gen8_emit_bb_start [i915]
+gen8_emit_flush [i915]
+reset_csb_pointers [i915]
+lrc_ring_setup_indirect_ctx [i915]
+execlists_reset_prepare [i915]
+execlists_request_alloc [i915]
+execlists_release [i915]
+execlists_sanitize [i915]
+execlists_context_pre_pin [i915]
+execlists_resume [i915]
+virtual_context_destroy [i915]
+virtual_context_enter [i915]
+gen8_emit_init_breadcrumb [i915]
+reg_offsets [i915]
+active_context [i915]
+start_timeslice [i915]
+__execlists_update_reg_state [i915]
+__execlists_context_pin [i915]
+execlists_context_pin [i915]
+virtual_context_pin [i915]
+virtual_context_exit [i915]
+__unwind_incomplete_requests [i915]
+active_request [i915]
+mark_eio [i915]
+can_merge_rq [i915]
+execlists_timeslice [i915]
+execlists_preempt [i915]
+execlists_init_reg_state [i915]
+restore_default_state [i915]
+execlists_context_reset [i915]
+gen10_init_indirectctx_bb [i915]
+gen12_emit_flush [i915]
+gen8_emit_flush_coherentl3_wa [i915]
+gen8_init_indirectctx_bb [i915]
+gen9_init_indirectctx_bb [i915]
+gen8_emit_fini_breadcrumb_rcs [i915]
+execlists_reset_finish [i915]
+gen12_emit_flush_render [i915]
+gen11_emit_flush_render [i915]
+execlists_context_destroy [i915]
+gen8_emit_flush_render [i915]
+virtual_submit_request [i915]
+execlists_capture_work [i915]
+virtual_submission_tasklet [i915]
+process_csb [i915]
+__execlists_reset [i915]
+execlists_reset_rewind [i915]
+execlists_reset_cancel [i915]
+__execlists_context_alloc [i915]
+execlists_context_alloc [i915]
+virtual_context_alloc [i915]
+execlists_reset [i915]
+rcu_virtual_context_destroy [i915]
+execlists_dequeue [i915]
+execlists_submission_tasklet [i915]
+execlists_submit_request [i915]
+execlists_unwind_incomplete_requests [i915]
+intel_execlists_submission_setup [i915]
+intel_execlists_create_virtual [i915]
+intel_execlists_clone_virtual [i915]
+intel_virtual_engine_attach_bond [i915]
+intel_virtual_engine_get_sibling [i915]
+intel_execlists_show_requests [i915]
+intel_lr_context_reset [i915]
+intel_engine_in_execlists_submission_mode [i915]
+__init_mocs_table [i915]
+get_mocs_settings [i915]
+intel_mocs_init_engine [i915]
+intel_mocs_init [i915]
+pd_count [i915]
+ppgtt_set_pages [i915]
+ppgtt_bind_vma [i915]
+ppgtt_unbind_vma [i915]
+alloc_pt [i915]
+__alloc_pd [i915]
+alloc_pd [i915]
+free_px [i915]
+__set_pd_entry [i915]
+clear_pd_entry [i915]
+release_pd_entry [i915]
+i915_ppgtt_init_hw [i915]
+i915_ppgtt_create [i915]
+i915_vm_pin_pt_stash [i915]
+i915_vm_free_pt_stash [i915]
+i915_vm_alloc_pt_stash [i915]
+ppgtt_init [i915]
+pctx_corrupted [i915]
+__intel_rc6_disable [i915]
+intel_rc6_init [i915]
+intel_rc6_sanitize [i915]
+intel_rc6_enable [i915]
+intel_rc6_unpark [i915]
+intel_rc6_disable [i915]
+intel_rc6_park [i915]
+intel_rc6_fini [i915]
+intel_rc6_residency_ns [i915]
+intel_rc6_residency_us [i915]
+intel_renderstate_init [i915]
+intel_renderstate_emit [i915]
+intel_renderstate_fini [i915]
+intel_get_gpu_reset [i915]
+reset_prepare_engine [i915]
+i915_do_reset [i915]
+g33_do_reset [i915]
+g4x_do_reset [i915]
+ilk_do_reset [i915]
+nop_submit_request [i915]
+reset_finish_engine [i915]
+gen6_hw_domain_reset [i915]
+gen6_reset_engines [i915]
+gen8_reset_engines [i915]
+reset_prepare [i915]
+reset_finish [i915]
+__i915_request_reset [i915]
+__intel_gt_reset [i915]
+__intel_gt_set_wedged.part.0 [i915]
+__intel_gt_unset_wedged [i915]
+intel_has_gpu_reset [i915]
+intel_has_reset_engine [i915]
+intel_reset_guc [i915]
+intel_gt_set_wedged [i915]
+intel_wedge_me [i915]
+intel_gt_unset_wedged [i915]
+intel_gt_reset [i915]
+intel_engine_reset [i915]
+intel_gt_reset_trylock [i915]
+intel_gt_reset_unlock [i915]
+intel_gt_terminally_wedged [i915]
+intel_gt_set_wedged_on_init [i915]
+intel_gt_set_wedged_on_fini [i915]
+intel_gt_init_reset [i915]
+intel_gt_fini_reset [i915]
+__intel_init_wedge [i915]
+intel_gt_reset_global [i915]
+intel_gt_handle_error [i915]
+__intel_fini_wedge [i915]
+wait_for_space [i915]
+intel_ring_update_space [i915]
+__intel_ring_pin [i915]
+intel_ring_pin [i915]
+intel_ring_reset [i915]
+intel_ring_unpin [i915]
+intel_engine_create_ring [i915]
+intel_ring_free [i915]
+intel_ring_begin [i915]
+intel_ring_cacheline_align [i915]
+reset_finish [i915]
+ring_context_pin [i915]
+i9xx_set_default_submission [i915]
+gen6_bsd_set_default_submission [i915]
+i9xx_submit_request [i915]
+ring_context_reset [i915]
+ring_context_post_unpin [i915]
+ring_context_pre_pin [i915]
+reset_cancel [i915]
+reset_rewind [i915]
+reset_prepare [i915]
+stop_ring [i915]
+xcs_resume [i915]
+gen6_bsd_submit_request [i915]
+switch_mm [i915]
+ring_context_unpin [i915]
+ring_context_destroy [i915]
+ring_release [i915]
+ring_context_alloc [i915]
+ring_request_alloc [i915]
+intel_ring_submission_setup [i915]
+rps_set_power [i915]
+rps_set [i915]
+rps_reset [i915]
+gen5_rps_set [i915]
+rps_timer [i915]
+vlv_init_gpll_ref_freq [i915]
+mchdev_get [i915]
+i915_gpu_busy [i915]
+__gen5_ips_update [i915]
+i915_read_mch_val [i915]
+rps_disable_interrupts [i915]
+i915_gpu_lower [i915]
+i915_gpu_raise [i915]
+i915_gpu_turbo_disable [i915]
+intel_rps_mark_interactive [i915]
+intel_rps_park [i915]
+intel_rps_boost [i915]
+intel_rps_set [i915]
+intel_rps_unpark [i915]
+rps_work [i915]
+intel_rps_enable [i915]
+intel_rps_disable [i915]
+intel_gpu_freq [i915]
+intel_freq_opcode [i915]
+gen11_rps_irq_handler [i915]
+gen6_rps_irq_handler [i915]
+gen5_rps_irq_handler [i915]
+intel_rps_init_early [i915]
+intel_rps_init [i915]
+intel_rps_sanitize [i915]
+intel_rps_get_cagf [i915]
+intel_rps_read_actual_frequency [i915]
+intel_rps_driver_register [i915]
+intel_rps_driver_unregister [i915]
+sseu_set_eus [i915]
+sseu_get_eus [i915]
+compute_eu_total [i915]
+intel_sseu_set_info [i915]
+intel_sseu_subslice_total [i915]
+intel_sseu_get_subslices [i915]
+intel_sseu_set_subslices [i915]
+gen11_compute_sseu_info [i915]
+intel_sseu_subslices_per_slice [i915]
+intel_sseu_info_init [i915]
+intel_sseu_make_rpcs [i915]
+intel_sseu_dump [i915]
+intel_sseu_print_topology [i915]
+sseu_copy_subslices [i915]
+gen10_sseu_device_status [i915]
+rcs_topology_open [i915]
+sseu_status_open [i915]
+rcs_topology_show [i915]
+i915_print_sseu_info [i915]
+intel_sseu_status [i915]
+sseu_status_show [i915]
+intel_sseu_debugfs_register [i915]
+__rcu_cacheline_free [i915]
+__cacheline_active [i915]
+hwsp_alloc [i915]
+cacheline_alloc [i915]
+__idle_hwsp_free [i915]
+__idle_cacheline_free [i915]
+__cacheline_retire [i915]
+cacheline_free [i915]
+__intel_timeline_get_seqno [i915]
+intel_gt_init_timelines [i915]
+__intel_timeline_create [i915]
+__intel_timeline_pin [i915]
+intel_timeline_pin [i915]
+intel_timeline_reset_seqno [i915]
+intel_timeline_enter [i915]
+intel_timeline_exit [i915]
+intel_timeline_get_seqno [i915]
+intel_timeline_read_hwsp [i915]
+intel_timeline_unpin [i915]
+__intel_timeline_free [i915]
+intel_gt_fini_timelines [i915]
+wa_list_apply [i915]
+mcr_range.part.0 [i915]
+wa_init_finish [i915]
+_wa_add [i915]
+gen9_gt_workarounds_init [i915]
+gen9_whitelist_build [i915]
+skl_whitelist_build [i915]
+icl_whitelist_build [i915]
+cfl_whitelist_build [i915]
+wa_masked_en [i915]
+gen12_ctx_workarounds_init.isra.0 [i915]
+gen9_ctx_workarounds_init [i915]
+gen8_ctx_workarounds_init.isra.0 [i915]
+ivb_gt_workarounds_init [i915]
+g4x_gt_workarounds_init.isra.0 [i915]
+wa_init_mcr [i915]
+icl_gt_workarounds_init [i915]
+rcs_engine_wa_init [i915]
+intel_engine_init_ctx_wa [i915]
+intel_engine_emit_ctx_wa [i915]
+intel_gt_init_workarounds [i915]
+intel_gt_apply_workarounds [i915]
+intel_gt_verify_workarounds [i915]
+intel_engine_init_whitelist [i915]
+intel_engine_apply_whitelist [i915]
+intel_engine_init_workarounds [i915]
+intel_engine_apply_workarounds [i915]
+intel_engine_verify_workarounds [i915]
+__shmem_rw [i915]
+shmem_create_from_data [i915]
+shmem_create_from_object [i915]
+shmem_pin_map [i915]
+shmem_unpin_map [i915]
+shmem_read [i915]
+shmem_write [i915]
+kobj_engine_release [i915]
+name_show [i915]
+heartbeat_store [i915]
+stop_store [i915]
+preempt_timeout_store [i915]
+preempt_timeout_show [i915]
+timeslice_show [i915]
+preempt_timeout_default [i915]
+timeslice_default [i915]
+heartbeat_default [i915]
+stop_default [i915]
+max_spin_default [i915]
+heartbeat_show [i915]
+stop_show [i915]
+max_spin_show [i915]
+mmio_show [i915]
+inst_show [i915]
+class_show [i915]
+timeslice_store [i915]
+max_spin_store [i915]
+__caps_show [i915]
+all_caps_show [i915]
+caps_show [i915]
+intel_engines_add_sysfs [i915]
+i915_gem_busy_ioctl [i915]
+clflush_release [i915]
+clflush_work [i915]
+i915_gem_clflush_object [i915]
+clear_pages_work_driver_name [i915]
+clear_pages_work_timeline_name [i915]
+vma_set_pages [i915]
+vma_clear_pages [i915]
+vma_bind [i915]
+vma_unbind [i915]
+clear_pages_work_release [i915]
+clear_pages_worker [i915]
+clear_pages_signal_irq_worker [i915]
+clear_pages_work_notify [i915]
+clear_pages_dma_fence_cb [i915]
+i915_gem_schedule_fill_pages_blt [i915]
+i915_global_gem_context_exit [i915]
+i915_global_gem_context_shrink [i915]
+skip_ppgtt_update [i915]
+clone_flags [i915]
+clone_schedattr [i915]
+create_clone [i915]
+clone_sseu [i915]
+__get_ringsize [i915]
+__apply_ringsize [i915]
+emit_ppgtt_update [i915]
+pin_ppgtt_update [i915]
+cb_retire [i915]
+set_engines__bond [i915]
+__context_set_persistence [i915]
+__apply_priority [i915]
+context_apply_all [i915]
+context_get_vm_rcu [i915]
+__set_ppgtt [i915]
+__free_engines [i915]
+free_engines_rcu [i915]
+gem_context_register [i915]
+kill_engines [i915]
+engines_idle_release [i915]
+lut_close [i915]
+lookup_user_engine [i915]
+__apply_ppgtt [i915]
+set_ppgtt_barrier [i915]
+__assign_ppgtt.part.0 [i915]
+clone_vm [i915]
+__set_timeline [i915]
+__apply_timeline [i915]
+clone_timeline [i915]
+i915_gem_context_free [i915]
+contexts_free_worker [i915]
+intel_context_set_gem [i915]
+set_engines__load_balance [i915]
+alloc_engines [i915]
+default_engines [i915]
+clone_engines [i915]
+i915_lut_handle_alloc [i915]
+i915_lut_handle_free [i915]
+i915_gem_context_release [i915]
+context_close [i915]
+i915_gem_create_context [i915]
+engines_notify [i915]
+i915_gem_init__contexts [i915]
+i915_gem_driver_release__contexts [i915]
+i915_gem_context_open [i915]
+i915_gem_context_close [i915]
+i915_gem_vm_create_ioctl [i915]
+i915_gem_vm_destroy_ioctl [i915]
+i915_gem_user_to_context_sseu [i915]
+ctx_setparam [i915]
+create_setparam [i915]
+i915_gem_context_create_ioctl [i915]
+i915_gem_context_destroy_ioctl [i915]
+i915_gem_context_getparam_ioctl [i915]
+i915_gem_context_setparam_ioctl [i915]
+i915_gem_context_reset_stats_ioctl [i915]
+i915_gem_engines_iter_next [i915]
+i915_gem_dmabuf_vmap [i915]
+i915_gem_dmabuf_vunmap [i915]
+i915_gem_dmabuf_mmap [i915]
+i915_gem_unmap_dma_buf [i915]
+i915_gem_map_dma_buf [i915]
+i915_gem_object_put_pages_dmabuf [i915]
+i915_gem_object_get_pages_dmabuf [i915]
+i915_gem_end_cpu_access [i915]
+i915_gem_begin_cpu_access [i915]
+i915_gem_prime_export [i915]
+i915_gem_prime_import [i915]
+__i915_gem_object_flush_for_display [i915]
+i915_gem_object_bump_inactive_ggtt [i915]
+i915_gem_object_flush_if_display [i915]
+i915_gem_object_flush_if_display_locked [i915]
+i915_gem_object_set_to_wc_domain [i915]
+i915_gem_object_set_to_gtt_domain [i915]
+i915_gem_object_set_cache_level [i915]
+i915_gem_get_caching_ioctl [i915]
+i915_gem_set_caching_ioctl [i915]
+i915_gem_object_pin_to_display_plane [i915]
+i915_gem_object_unpin_from_display_plane [i915]
+i915_gem_object_set_to_cpu_domain [i915]
+i915_gem_set_domain_ioctl [i915]
+i915_gem_object_prepare_read [i915]
+i915_gem_object_prepare_write [i915]
+eb_pin_flags [i915]
+i915_gem_check_execbuffer [i915]
+num_vcs_engines [i915]
+shadow_batch_pin [i915]
+vma_phys_addr [i915]
+__eb_parse_release [i915]
+__eb_parse [i915]
+eb_vma_misplaced [i915]
+reloc_gpu_flush [i915]
+reloc_cache_reset [i915]
+check_relocations [i915]
+eb_validate_vmas [i915]
+eb_release_vmas [i915]
+eb_pin_engine [i915]
+eb_parse [i915]
+eb_relocate_entry [i915]
+eb_relocate_vma [i915]
+eb_relocate_parse_slow [i915]
+i915_gem_do_execbuffer [i915]
+parse_timeline_fences [i915]
+i915_gem_execbuffer_ioctl [i915]
+i915_gem_execbuffer2_ioctl [i915]
+stub_driver_name [i915]
+stub_timeline_name [i915]
+stub_release [i915]
+stub_notify [i915]
+i915_gem_object_lock_fence [i915]
+i915_gem_object_unlock_fence [i915]
+internal_free_pages [i915]
+i915_gem_object_put_pages_internal [i915]
+i915_gem_object_get_pages_internal [i915]
+i915_gem_object_create_internal [i915]
+i915_global_objects_exit [i915]
+i915_global_objects_shrink [i915]
+__i915_gem_free_object_rcu [i915]
+__i915_gem_free_objects.isra.0 [i915]
+__i915_gem_free_work [i915]
+i915_gem_object_alloc [i915]
+i915_gem_object_free [i915]
+i915_gem_object_init [i915]
+i915_gem_object_set_cache_coherency [i915]
+i915_gem_close_object [i915]
+i915_gem_flush_free_objects [i915]
+i915_gem_free_object [i915]
+__i915_gem_object_flush_frontbuffer [i915]
+i915_gem_object_flush_write_domain [i915]
+__i915_gem_object_invalidate_frontbuffer [i915]
+i915_gem_init__objects [i915]
+intel_emit_vma_fill_blt [i915]
+intel_emit_vma_mark_active [i915]
+intel_emit_vma_release [i915]
+i915_gem_object_fill_blt [i915]
+intel_emit_vma_copy_blt [i915]
+i915_gem_object_copy_blt [i915]
+i915_gem_object_is_lmem [i915]
+i915_gem_object_create_lmem [i915]
+__i915_gem_lmem_object_create [i915]
+vm_access [i915]
+singleton_release [i915]
+i915_error_to_vmf_fault [i915]
+vm_fault_cpu [i915]
+vm_open [i915]
+vm_fault_gtt [i915]
+vm_close [i915]
+__assign_mmap_offset [i915]
+i915_gem_mmap_ioctl [i915]
+i915_gem_mmap_gtt_version [i915]
+__i915_gem_object_release_mmap_gtt [i915]
+i915_gem_object_release_mmap_gtt [i915]
+i915_gem_object_release_mmap_offset [i915]
+i915_gem_dumb_mmap_offset [i915]
+i915_gem_mmap_offset_ioctl [i915]
+i915_gem_mmap [i915]
+i915_gem_object_map_page [i915]
+i915_gem_object_map_pfn [i915]
+unmap_object.isra.0 [i915]
+__i915_gem_object_unset_pages.part.0 [i915]
+__i915_gem_object_set_pages [i915]
+____i915_gem_object_get_pages [i915]
+__i915_gem_object_get_pages [i915]
+i915_gem_object_truncate [i915]
+i915_gem_object_writeback [i915]
+__i915_gem_object_unset_pages [i915]
+__i915_gem_object_put_pages [i915]
+i915_gem_object_pin_map [i915]
+__i915_gem_object_flush_map [i915]
+__i915_gem_object_release_map [i915]
+i915_gem_object_get_sg [i915]
+i915_gem_object_get_page [i915]
+i915_gem_object_get_dirty_page [i915]
+i915_gem_object_get_dma_address_len [i915]
+i915_gem_object_get_dma_address [i915]
+phys_release [i915]
+phys_pwrite [i915]
+phys_pread [i915]
+i915_gem_object_get_pages_phys [i915]
+i915_gem_object_put_pages_phys [i915]
+i915_gem_object_attach_phys [i915]
+i915_gem_suspend [i915]
+i915_gem_suspend_late [i915]
+i915_gem_resume [i915]
+i915_gem_object_put_pages_buddy [i915]
+i915_gem_object_get_pages_buddy [i915]
+i915_gem_object_init_memory_region [i915]
+i915_gem_object_release_memory_region [i915]
+i915_gem_object_create_region [i915]
+shmem_release [i915]
+shmem_pwrite [i915]
+shmem_truncate [i915]
+shmem_get_pages [i915]
+create_shmem [i915]
+release_shmem [i915]
+init_shmem [i915]
+shmem_writeback [i915]
+__i915_gem_object_release_shmem [i915]
+shmem_put_pages [i915]
+i915_gem_object_create_shmem [i915]
+i915_gem_object_create_shmem_from_data [i915]
+i915_gem_shmem_setup [i915]
+__i915_gem_object_make_shrinkable [i915]
+i915_gem_shrinker_count [i915]
+i915_gem_shrink [i915]
+i915_gem_shrinker_vmap [i915]
+i915_gem_shrinker_oom [i915]
+i915_gem_shrinker_scan [i915]
+i915_gem_shrink_all [i915]
+i915_gem_driver_register__shrinker [i915]
+i915_gem_driver_unregister__shrinker [i915]
+i915_gem_shrinker_taints_mutex [i915]
+i915_gem_object_make_unshrinkable [i915]
+i915_gem_object_make_shrinkable [i915]
+i915_gem_object_make_purgeable [i915]
+i915_gem_object_put_pages_stolen [i915]
+i915_gem_object_get_pages_stolen [i915]
+__i915_gem_object_create_stolen [i915]
+release_stolen [i915]
+init_stolen [i915]
+i915_gem_object_release_stolen [i915]
+i915_gem_stolen_insert_node_in_range [i915]
+_i915_gem_object_create_stolen [i915]
+i915_gem_stolen_insert_node [i915]
+i915_gem_stolen_remove_node [i915]
+i915_gem_object_create_stolen [i915]
+i915_gem_stolen_setup [i915]
+i915_gem_object_create_stolen_for_preallocated [i915]
+i915_gem_throttle_ioctl [i915]
+i915_gem_fence_size [i915]
+i915_gem_fence_alignment [i915]
+i915_gem_object_set_tiling [i915]
+i915_gem_set_tiling_ioctl [i915]
+i915_gem_get_tiling_ioctl [i915]
+__i915_mm_struct_free__worker [i915]
+__i915_gem_userptr_alloc_pages [i915]
+i915_gem_userptr_init__mmu_notifier [i915]
+i915_gem_userptr_dmabuf_export [i915]
+__i915_mm_struct_find [i915]
+i915_gem_userptr_release [i915]
+userptr_mn_invalidate_range_start [i915]
+__i915_gem_userptr_set_active [i915]
+i915_gem_userptr_put_pages [i915]
+i915_gem_userptr_get_pages [i915]
+__i915_gem_userptr_get_pages_worker [i915]
+i915_gem_userptr_ioctl [i915]
+i915_gem_init_userptr [i915]
+i915_gem_cleanup_userptr [i915]
+i915_gem_object_wait_fence [i915]
+__fence_set_priority [i915]
+fence_set_priority.part.0 [i915]
+i915_gem_object_wait_reservation [i915]
+i915_gem_object_wait_priority [i915]
+i915_gem_object_wait [i915]
+i915_gem_wait_ioctl [i915]
+i915_gemfs_init [i915]
+i915_gemfs_fini [i915]
+i915_global_active_exit [i915]
+i915_global_active_shrink [i915]
+rq_await_fence [i915]
+sw_await_fence [i915]
+__active_lookup [i915]
+__active_retire [i915]
+active_work [i915]
+active_retire [i915]
+excl_retire [i915]
+node_retire [i915]
+____active_del_barrier.isra.0 [i915]
+barrier_wake [i915]
+auto_active [i915]
+enable_signaling [i915]
+flush_lazy_signals [i915]
+__await_active [i915]
+await_active.part.0 [i915]
+__i915_active_activate [i915]
+active_instance.part.0 [i915]
+__i915_active_init [i915]
+i915_active_acquire_if_busy [i915]
+i915_active_acquire [i915]
+i915_active_acquire_for_context [i915]
+i915_active_release [i915]
+__i915_active_wait [i915]
+i915_request_await_active [i915]
+i915_sw_fence_await_active [i915]
+i915_active_fini [i915]
+i915_active_acquire_preallocate_barrier [i915]
+i915_active_acquire_barrier [i915]
+i915_request_add_active_barriers [i915]
+__i915_active_fence_set [i915]
+i915_active_ref [i915]
+__i915_active_set_fence [i915]
+__i915_active_ref [i915]
+i915_active_set_exclusive [i915]
+i915_active_fence_set [i915]
+i915_active_noop [i915]
+i915_active_get [i915]
+i915_active_put [i915]
+auto_retire [i915]
+i915_active_create [i915]
+i915_global_buddy_exit [i915]
+i915_global_buddy_shrink [i915]
+__i915_buddy_free [i915]
+split_block [i915]
+i915_buddy_init [i915]
+i915_buddy_fini [i915]
+i915_buddy_free [i915]
+i915_buddy_free_list [i915]
+i915_buddy_alloc [i915]
+i915_buddy_alloc_range [i915]
+fini_hash_table [i915]
+gen9_blt_get_cmd_length_mask [i915]
+gen7_bsd_get_cmd_length_mask [i915]
+gen7_render_get_cmd_length_mask [i915]
+gen7_blt_get_cmd_length_mask [i915]
+intel_engine_init_cmd_parser [i915]
+intel_engine_cleanup_cmd_parser [i915]
+intel_engine_cmd_parser [i915]
+i915_cmd_parser_get_version [i915]
+i915_gem_evict_something [i915]
+i915_gem_evict_for_node [i915]
+i915_gem_evict_vm [i915]
+i915_gem_gtt_prepare_pages [i915]
+i915_gem_gtt_finish_pages [i915]
+i915_gem_gtt_reserve [i915]
+i915_gem_gtt_insert [i915]
+i915_gem_ww_ctx_unlock_all [i915]
+insert_mappable_node.constprop.0 [i915]
+i915_gem_create [i915]
+i915_gem_get_aperture_ioctl [i915]
+i915_gem_object_unbind [i915]
+i915_gem_dumb_create [i915]
+i915_gem_create_ioctl [i915]
+i915_gem_sw_finish_ioctl [i915]
+i915_gem_runtime_suspend [i915]
+i915_gem_object_ggtt_pin_ww [i915]
+i915_gem_gtt_pread [i915]
+i915_gem_pread_ioctl [i915]
+i915_gem_gtt_pwrite_fast [i915]
+i915_gem_pwrite_ioctl [i915]
+i915_gem_madvise_ioctl [i915]
+i915_gem_init [i915]
+i915_gem_driver_register [i915]
+i915_gem_driver_unregister [i915]
+i915_gem_driver_remove [i915]
+i915_gem_driver_release [i915]
+i915_gem_init_early [i915]
+i915_gem_cleanup_early [i915]
+i915_gem_freeze [i915]
+i915_gem_freeze_late [i915]
+i915_gem_open [i915]
+i915_gem_ww_ctx_init [i915]
+i915_gem_ww_unlock_single [i915]
+i915_gem_ww_ctx_fini [i915]
+i915_gem_ww_ctx_backoff [i915]
+__i915_globals_grace [i915]
+__i915_globals_queue_rcu [i915]
+__i915_globals_park [i915]
+i915_globals_park [i915]
+i915_globals_unpark [i915]
+copy_perf_config_registers_or_number [i915]
+query_perf_config_data [i915]
+query_perf_config [i915]
+copy_query_item.part.0.constprop.0 [i915]
+query_engine_info [i915]
+query_topology_info [i915]
+i915_query_ioctl [i915]
+i915_global_request_exit [i915]
+i915_global_request_shrink [i915]
+i915_fence_enable_signaling [i915]
+i915_fence_get_driver_name [i915]
+i915_fence_release [i915]
+irq_execute_cb [i915]
+__emit_semaphore_wait [i915]
+__i915_request_await_external [i915]
+request_wait_wake [i915]
+__i915_request_ctor [i915]
+__notify_execute_cb_imm.part.0 [i915]
+i915_fence_get_timeline_name [i915]
+i915_request_set_error_once.part.0 [i915]
+__i915_request_fill.constprop.0 [i915]
+i915_fence_signaled [i915]
+__await_execution.constprop.0 [i915]
+irq_execute_cb_hook [i915]
+semaphore_notify [i915]
+submit_notify [i915]
+i915_request_await_start [i915]
+__i915_request_await_execution.part.0 [i915]
+i915_request_slab_cache [i915]
+i915_request_retire [i915]
+request_alloc_slow [i915]
+i915_request_retire_upto [i915]
+__i915_request_skip [i915]
+i915_request_set_error_once [i915]
+__i915_request_submit [i915]
+i915_request_submit [i915]
+__i915_request_unsubmit [i915]
+i915_request_unsubmit [i915]
+__i915_request_create [i915]
+i915_request_create [i915]
+i915_request_await_dma_fence [i915]
+i915_request_await_external [i915]
+i915_request_await_execution [i915]
+i915_request_await_object [i915]
+__i915_request_commit [i915]
+__i915_request_queue [i915]
+i915_request_add [i915]
+i915_request_wait [i915]
+i915_fence_wait [i915]
+i915_global_scheduler_exit [i915]
+i915_global_scheduler_shrink [i915]
+sched_lock_engine [i915]
+i915_sched_lookup_priolist [i915]
+__i915_schedule [i915]
+__i915_priolist_free [i915]
+i915_schedule [i915]
+i915_schedule_bump_priority [i915]
+i915_sched_node_init [i915]
+i915_sched_node_reinit [i915]
+__i915_sched_node_add_dependency [i915]
+i915_sched_node_add_dependency [i915]
+i915_sched_node_fini [i915]
+__traceiter_intel_pipe_enable [i915]
+__traceiter_intel_pipe_disable [i915]
+__traceiter_intel_pipe_crc [i915]
+__traceiter_intel_cpu_fifo_underrun [i915]
+__traceiter_intel_pch_fifo_underrun [i915]
+__traceiter_intel_memory_cxsr [i915]
+__traceiter_g4x_wm [i915]
+__traceiter_vlv_wm [i915]
+__traceiter_vlv_fifo_size [i915]
+__traceiter_intel_update_plane [i915]
+__traceiter_intel_disable_plane [i915]
+__traceiter_intel_fbc_activate [i915]
+__traceiter_intel_fbc_deactivate [i915]
+__traceiter_intel_fbc_nuke [i915]
+__traceiter_intel_pipe_update_start [i915]
+__traceiter_intel_pipe_update_vblank_evaded [i915]
+__traceiter_intel_pipe_update_end [i915]
+__traceiter_i915_gem_object_create [i915]
+__traceiter_i915_gem_shrink [i915]
+__traceiter_i915_vma_bind [i915]
+__traceiter_i915_vma_unbind [i915]
+__traceiter_i915_gem_object_pwrite [i915]
+__traceiter_i915_gem_object_pread [i915]
+__traceiter_i915_gem_object_fault [i915]
+__traceiter_i915_gem_object_clflush [i915]
+__traceiter_i915_gem_object_destroy [i915]
+__traceiter_i915_gem_evict [i915]
+__traceiter_i915_gem_evict_node [i915]
+__traceiter_i915_gem_evict_vm [i915]
+__traceiter_i915_request_queue [i915]
+__traceiter_i915_request_add [i915]
+__traceiter_i915_request_retire [i915]
+__traceiter_i915_request_wait_begin [i915]
+__traceiter_i915_request_wait_end [i915]
+__traceiter_i915_reg_rw [i915]
+__traceiter_intel_gpu_freq_change [i915]
+__traceiter_i915_ppgtt_create [i915]
+__traceiter_i915_ppgtt_release [i915]
+__traceiter_i915_context_create [i915]
+__traceiter_i915_context_free [i915]
+i915_global_vma_exit [i915]
+i915_global_vma_shrink [i915]
+__vma_bind [i915]
+__vma_put_pages [i915]
+i915_vma_revoke_mmap.part.0 [i915]
+__i915_vma_remove_closed [i915]
+__i915_vma_active [i915]
+__i915_vma_retire [i915]
+__vma_release [i915]
+i915_vma_alloc [i915]
+i915_vma_free [i915]
+i915_vma_instance [i915]
+i915_vma_work [i915]
+i915_vma_wait_for_bind [i915]
+i915_vma_bind [i915]
+i915_vma_pin_iomap [i915]
+i915_vma_flush_writes [i915]
+i915_vma_unpin_iomap [i915]
+i915_vma_unpin_and_release [i915]
+i915_vma_misplaced [i915]
+__i915_vma_set_map_and_fenceable [i915]
+i915_gem_valid_gtt_space [i915]
+i915_vma_pin_ww [i915]
+i915_ggtt_pin [i915]
+i915_vma_close [i915]
+i915_vma_reopen [i915]
+i915_vma_revoke_mmap [i915]
+__i915_vma_move_to_active [i915]
+i915_vma_move_to_active [i915]
+__i915_vma_evict [i915]
+__i915_vma_unbind [i915]
+i915_vma_release [i915]
+i915_vma_parked [i915]
+i915_vma_unbind [i915]
+i915_vma_make_unshrinkable [i915]
+i915_vma_make_shrinkable [i915]
+i915_vma_make_purgeable [i915]
+region_lmem_release [i915]
+region_lmem_init [i915]
+intel_setup_fake_lmem [i915]
+intel_wopcm_init_early [i915]
+intel_wopcm_init [i915]
+__uc_fini [i915]
+__uc_cleanup_firmwares [i915]
+__uc_init [i915]
+uc_is_wopcm_locked [i915]
+__intel_uc_reset_hw [i915]
+__uc_sanitize [i915]
+__uc_fetch_firmwares [i915]
+__uc_check_hw [i915]
+guc_get_mmio_msg [i915]
+guc_disable_communication [i915]
+__uc_fini_hw [i915]
+guc_enable_communication [i915]
+__uc_resume [i915]
+__uc_init_hw [i915]
+intel_uc_init_early [i915]
+intel_uc_driver_late_release [i915]
+intel_uc_init_mmio [i915]
+intel_uc_driver_remove [i915]
+intel_uc_reset_prepare [i915]
+intel_uc_runtime_suspend [i915]
+intel_uc_suspend [i915]
+intel_uc_resume [i915]
+intel_uc_runtime_resume [i915]
+uc_usage_open [i915]
+uc_usage_show [i915]
+intel_uc_debugfs_register [i915]
+uc_fw_bind_ggtt [i915]
+intel_uc_fw_init_early [i915]
+intel_uc_fw_fetch [i915]
+intel_uc_fw_upload [i915]
+intel_uc_fw_init [i915]
+intel_uc_fw_fini [i915]
+intel_uc_fw_cleanup_fetch [i915]
+intel_uc_fw_copy_rsa [i915]
+intel_uc_fw_dump [i915]
+gen11_enable_guc_interrupts [i915]
+gen11_reset_guc_interrupts [i915]
+gen9_reset_guc_interrupts [i915]
+gen9_disable_guc_interrupts [i915]
+gen11_disable_guc_interrupts [i915]
+gen9_enable_guc_interrupts [i915]
+intel_guc_notify [i915]
+intel_guc_init_send_regs [i915]
+intel_guc_init_early [i915]
+intel_guc_write_params [i915]
+intel_guc_init [i915]
+intel_guc_fini [i915]
+intel_guc_send_mmio [i915]
+intel_guc_to_host_process_recv_msg [i915]
+intel_guc_sample_forcewake [i915]
+intel_guc_auth_huc [i915]
+intel_guc_suspend [i915]
+intel_guc_reset_engine [i915]
+intel_guc_resume [i915]
+intel_guc_allocate_vma [i915]
+intel_guc_allocate_and_map_vma [i915]
+intel_guc_load_status [i915]
+__guc_ads_init [i915]
+intel_guc_ads_create [i915]
+intel_guc_ads_destroy [i915]
+intel_guc_ads_reset [i915]
+ct_register_buffer [i915]
+ct_deregister_buffer [i915]
+ct_incoming_request_worker_func [i915]
+intel_guc_ct_init_early [i915]
+intel_guc_ct_init [i915]
+intel_guc_ct_fini [i915]
+intel_guc_ct_enable [i915]
+intel_guc_ct_disable [i915]
+intel_guc_ct_send [i915]
+intel_guc_ct_event_handler [i915]
+guc_info_open [i915]
+guc_info_show [i915]
+intel_guc_debugfs_register [i915]
+guc_xfer_rsa [i915]
+intel_guc_fw_upload [i915]
+remove_buf_file_callback [i915]
+create_buf_file_callback [i915]
+subbuf_start_callback [i915]
+guc_log_capture_logs [i915]
+capture_logs_work [i915]
+intel_guc_log_init_early [i915]
+intel_guc_log_create [i915]
+intel_guc_log_destroy [i915]
+intel_guc_log_set_level [i915]
+intel_guc_log_relay_created [i915]
+intel_guc_log_relay_open [i915]
+intel_guc_log_relay_start [i915]
+intel_guc_log_relay_flush [i915]
+intel_guc_log_relay_close [i915]
+intel_guc_log_handle_flush_event [i915]
+intel_guc_log_info [i915]
+intel_guc_log_dump [i915]
+guc_log_level_fops_open [i915]
+guc_log_level_set [i915]
+guc_log_level_get [i915]
+guc_log_relay_release [i915]
+guc_log_relay_open [i915]
+guc_log_relay_write [i915]
+guc_load_err_log_dump_open [i915]
+guc_log_dump_open [i915]
+guc_load_err_log_dump_show [i915]
+guc_log_dump_show [i915]
+intel_guc_log_debugfs_register [i915]
+guc_reset_finish [i915]
+guc_set_default_submission [i915]
+guc_reset_prepare [i915]
+schedule_out [i915]
+cancel_port_requests [i915]
+guc_reset_rewind [i915]
+schedule_in.isra.0 [i915]
+guc_submission_tasklet [i915]
+guc_reset_cancel [i915]
+intel_guc_submission_init [i915]
+intel_guc_submission_fini [i915]
+intel_guc_submission_enable [i915]
+intel_guc_submission_disable [i915]
+intel_guc_submission_init_early [i915]
+intel_engine_in_guc_submission_mode [i915]
+intel_huc_init_early [i915]
+intel_huc_init [i915]
+intel_huc_fini [i915]
+intel_huc_auth [i915]
+intel_huc_check_status [i915]
+intel_huc_load_status [i915]
+huc_info_open [i915]
+huc_info_show [i915]
+intel_huc_debugfs_register [i915]
+intel_huc_fw_upload [i915]
+intel_digital_connector_atomic_get_property [i915]
+intel_digital_connector_atomic_set_property [i915]
+intel_digital_connector_atomic_check [i915]
+intel_digital_connector_duplicate_state [i915]
+intel_connector_needs_modeset [i915]
+intel_atomic_get_digital_connector_state [i915]
+intel_crtc_duplicate_state [i915]
+intel_crtc_free_hw_state [i915]
+intel_crtc_copy_color_blobs [i915]
+intel_crtc_destroy_state [i915]
+intel_atomic_setup_scalers [i915]
+intel_atomic_state_alloc [i915]
+intel_atomic_state_free [i915]
+intel_atomic_state_clear [i915]
+intel_atomic_get_crtc_state [i915]
+intel_plane_alloc [i915]
+intel_plane_duplicate_state [i915]
+intel_plane_destroy_state [i915]
+intel_plane_free [i915]
+intel_plane_pixel_rate [i915]
+intel_plane_data_rate [i915]
+intel_plane_calc_min_cdclk [i915]
+intel_plane_copy_uapi_to_hw_state [i915]
+intel_plane_set_invisible [i915]
+intel_plane_atomic_check_with_state [i915]
+intel_plane_atomic_check [i915]
+intel_update_plane [i915]
+intel_disable_plane [i915]
+skl_update_planes_on_crtc [i915]
+i9xx_update_planes_on_crtc [i915]
+audio_config_hdmi_pixel_clock [i915]
+hsw_audio_config_update [i915]
+g4x_audio_codec_disable [i915]
+hsw_audio_codec_disable [i915]
+ilk_audio_codec_disable [i915]
+ilk_audio_codec_enable [i915]
+get_saved_enc [i915]
+i915_audio_component_unbind [i915]
+i915_audio_component_bind [i915]
+hsw_audio_codec_enable [i915]
+i915_audio_component_get_eld [i915]
+i915_audio_component_get_cdclk_freq [i915]
+g4x_audio_codec_enable [i915]
+glk_force_audio_cdclk [i915]
+i915_audio_component_put_power [i915]
+i915_audio_component_get_power [i915]
+i915_audio_component_sync_audio_rate [i915]
+i915_audio_component_codec_wake_override [i915]
+intel_audio_codec_enable [i915]
+intel_audio_codec_disable [i915]
+intel_init_audio_hooks [i915]
+intel_audio_init [i915]
+intel_audio_deinit [i915]
+find_section [i915]
+fill_detail_timing_data [i915]
+intel_bios_is_valid_vbt [i915]
+intel_bios_driver_remove [i915]
+intel_bios_is_tv_present [i915]
+intel_bios_is_lvds_present [i915]
+intel_bios_is_port_present [i915]
+intel_bios_is_port_edp [i915]
+intel_bios_is_port_dp_dual_mode [i915]
+intel_bios_is_dsi_present [i915]
+intel_bios_init [i915]
+intel_bios_get_dsc_params [i915]
+intel_bios_is_port_hpd_inverted [i915]
+intel_bios_is_lspcon_present [i915]
+intel_bios_port_aux_ch [i915]
+intel_bios_max_tmds_clock [i915]
+intel_bios_hdmi_level_shift [i915]
+intel_bios_dp_boost_level [i915]
+intel_bios_hdmi_boost_level [i915]
+intel_bios_dp_max_link_rate [i915]
+intel_bios_alternate_ddc_pin [i915]
+intel_bios_port_supports_dvi [i915]
+intel_bios_port_supports_hdmi [i915]
+intel_bios_port_supports_dp [i915]
+intel_bios_port_supports_typec_usb [i915]
+intel_bios_port_supports_tbt [i915]
+icl_calc_bw [i915]
+intel_bw_crtc_num_active_planes [i915]
+icl_get_bw_info [i915]
+intel_bw_destroy_state [i915]
+intel_bw_duplicate_state [i915]
+icl_pcode_restrict_qgv_points [i915]
+intel_bw_init_hw [i915]
+intel_bw_crtc_update [i915]
+intel_atomic_get_old_bw_state [i915]
+intel_atomic_get_new_bw_state [i915]
+intel_atomic_get_bw_state [i915]
+skl_bw_calc_min_cdclk [i915]
+intel_bw_calc_min_cdclk [i915]
+intel_bw_atomic_check [i915]
+intel_bw_init [i915]
+bxt_calc_voltage_level [i915]
+cnl_calc_voltage_level [i915]
+icl_calc_voltage_level [i915]
+ehl_calc_voltage_level [i915]
+tgl_calc_voltage_level [i915]
+intel_cdclk_destroy_state [i915]
+fixed_133mhz_get_cdclk [i915]
+fixed_200mhz_get_cdclk [i915]
+fixed_266mhz_get_cdclk [i915]
+fixed_333mhz_get_cdclk [i915]
+fixed_400mhz_get_cdclk [i915]
+fixed_450mhz_get_cdclk [i915]
+bdw_get_cdclk [i915]
+bxt_calc_cdclk [i915]
+skl_get_cdclk [i915]
+bxt_get_cdclk [i915]
+vlv_program_pfi_credits [i915]
+intel_hpll_vco [i915]
+intel_cdclk_duplicate_state [i915]
+i85x_get_cdclk [i915]
+i915gm_get_cdclk [i915]
+i945gm_get_cdclk [i915]
+pnv_get_cdclk [i915]
+i965gm_get_cdclk [i915]
+g33_get_cdclk [i915]
+gm45_get_cdclk [i915]
+vlv_get_cdclk [i915]
+skl_calc_cdclk [i915]
+hsw_get_cdclk [i915]
+vlv_calc_voltage_level [i915]
+bxt_calc_cdclk_pll_vco [i915]
+intel_cdclk_needs_modeset [i915]
+intel_dump_cdclk_config [i915]
+intel_set_cdclk [i915]
+intel_set_cdclk_pre_plane_update [i915]
+intel_set_cdclk_post_plane_update [i915]
+intel_crtc_compute_min_cdclk [i915]
+intel_compute_min_cdclk [i915]
+fixed_modeset_calc_cdclk [i915]
+vlv_modeset_calc_cdclk [i915]
+bdw_modeset_calc_cdclk [i915]
+skl_modeset_calc_cdclk [i915]
+bxt_modeset_calc_cdclk [i915]
+intel_atomic_get_cdclk_state [i915]
+intel_cdclk_init [i915]
+intel_modeset_calc_cdclk [i915]
+intel_update_max_cdclk [i915]
+intel_update_cdclk [i915]
+bxt_set_cdclk [i915]
+skl_set_cdclk [i915]
+intel_cdclk_init_hw [i915]
+intel_cdclk_uninit_hw [i915]
+vlv_set_cdclk [i915]
+chv_set_cdclk [i915]
+bdw_set_cdclk [i915]
+intel_read_rawclk [i915]
+intel_init_cdclk_hooks [i915]
+intel_color_lut_pack [i915]
+i9xx_color_commit [i915]
+glk_load_degamma_lut [i915]
+intel_color_lut_entries_equal [i915]
+i9xx_lut_8_pack [i915]
+ilk_lut_10_pack [i915]
+ilk_read_lut_8 [i915]
+i9xx_read_lut_8 [i915]
+ivb_load_lut_ext_max [i915]
+check_luts [i915]
+ilk_csc_limited_range [i915]
+ilk_csc_convert_ctm [i915]
+ilk_read_luts [i915]
+i9xx_read_luts [i915]
+i965_read_luts [i915]
+chv_read_luts [i915]
+intel_color_add_affected_planes [i915]
+ivb_color_check [i915]
+icl_color_check [i915]
+i9xx_gamma_precision [i915]
+ilk_color_check.part.0 [i915]
+ilk_color_check [i915]
+i9xx_color_check [i915]
+chv_color_check [i915]
+glk_color_check [i915]
+glk_read_lut_10.constprop.0 [i915]
+glk_read_luts [i915]
+icl_read_luts [i915]
+icl_update_output_csc.constprop.0 [i915]
+ilk_update_pipe_csc.constprop.0 [i915]
+ilk_load_csc_matrix [i915]
+ilk_color_commit [i915]
+hsw_color_commit [i915]
+skl_color_commit [i915]
+i9xx_lut_8 [i915]
+ilk_load_lut_8 [i915]
+i9xx_load_lut_8 [i915]
+i9xx_load_luts [i915]
+i965_load_luts [i915]
+chv_load_luts [i915]
+ilk_lut_10 [i915]
+ilk_load_luts [i915]
+ivb_load_lut_10 [i915]
+ivb_load_luts [i915]
+bdw_load_lut_10 [i915]
+bdw_load_luts [i915]
+glk_load_luts [i915]
+icl_load_luts [i915]
+intel_color_load_luts [i915]
+intel_color_commit [i915]
+intel_color_check [i915]
+intel_color_get_config [i915]
+intel_color_get_gamma_bit_precision [i915]
+intel_color_lut_equal [i915]
+intel_color_init [i915]
+icl_combo_phy_enabled [i915]
+cnl_get_procmon_ref_values [i915]
+cnl_set_procmon_ref_values [i915]
+check_phy_reg [i915]
+cnl_verify_procmon_ref_values [i915]
+ehl_vbt_ddi_d_present [i915]
+icl_combo_phy_verify_state.part.0 [i915]
+icl_combo_phys_init [i915]
+intel_combo_phy_power_up_lanes [i915]
+intel_combo_phy_init [i915]
+intel_combo_phy_uninit [i915]
+intel_connector_init [i915]
+intel_connector_alloc [i915]
+intel_connector_free [i915]
+intel_connector_destroy [i915]
+intel_connector_register [i915]
+intel_connector_unregister [i915]
+intel_connector_attach_encoder [i915]
+intel_connector_get_hw_state [i915]
+intel_connector_get_pipe [i915]
+intel_connector_update_modes [i915]
+intel_ddc_get_modes [i915]
+intel_attach_force_audio_property [i915]
+intel_attach_broadcast_rgb_property [i915]
+intel_attach_aspect_ratio_property [i915]
+intel_attach_colorspace_property [i915]
+intel_csr_runtime_pm_get [i915]
+intel_csr_load_program [i915]
+csr_load_work_fn [i915]
+intel_csr_ucode_init [i915]
+intel_csr_ucode_suspend [i915]
+intel_csr_ucode_resume [i915]
+intel_csr_ucode_fini [i915]
+i845_cursor_max_stride [i915]
+intel_cursor_format_mod_supported [i915]
+wrpll_uses_pch_ssc [i915]
+glk_pipe_scaler_clock_gating_wa [i915]
+intel_crtc_max_vblank_count [i915]
+i9xx_plane_max_stride [i915]
+skl_detach_scaler [i915]
+skl_detach_scalers [i915]
+icl_set_pipe_chicken [i915]
+ilk_pch_transcoder_set_timings [i915]
+intel_encoders_pre_pll_enable [i915]
+intel_encoders_pre_enable [i915]
+intel_encoders_post_disable [i915]
+hsw_set_linetime_wm [i915]
+intel_set_pipe_src_size [i915]
+intel_get_pipe_timings [i915]
+intel_get_pipe_src_size [i915]
+i9xx_get_pipe_color_config [i915]
+intel_cpu_transcoder_get_m_n [i915]
+i9xx_cursor_max_stride [i915]
+intel_get_crtc_new_encoder [i915]
+ilk_get_pfit_config [i915]
+intel_adjust_tile_offset [i915]
+i9xx_calc_dpll_params [i915]
+pnv_calc_dpll_params [i915]
+intel_set_pipe_timings [i915]
+main_to_ccs_plane [i915]
+intel_tile_width_bytes [i915]
+ccs_to_main_plane [i915]
+intel_set_plane_visible [i915]
+fixup_active_planes [i915]
+encoders_cloneable [i915]
+i9xx_plane_get_hw_state [i915]
+i9xx_cursor_get_hw_state [i915]
+i845_cursor_get_hw_state [i915]
+ibx_sanitize_pch_dp_port [i915]
+ibx_sanitize_pch_hdmi_port [i915]
+intel_dump_m_n_config [i915]
+i9xx_crtc_clock_get [i915]
+cpt_set_fdi_bc_bifurcation [i915]
+wait_for_pipe_scanline_moving [i915]
+intel_crtc_state_reset [i915]
+intel_crtc_update_active_timings [i915]
+intel_encoders_enable [i915]
+intel_encoders_disable [i915]
+hsw_crtc_disable [i915]
+ivb_manual_fdi_link_train [i915]
+gen6_fdi_link_train [i915]
+intel_crtc_state_alloc [i915]
+intel_user_framebuffer_dirty [i915]
+intel_user_framebuffer_create_handle [i915]
+intel_user_framebuffer_destroy [i915]
+intel_plane_destroy [i915]
+intel_enable_crtc [i915]
+ilk_get_pipe_config [i915]
+hsw_crtc_compute_clock [i915]
+intel_atomic_commit_fence_wait [i915]
+intel_compare_infoframe [i915]
+pipe_config_mismatch [i915]
+intel_crtc_destroy [i915]
+intel_plane_uses_fence [i915]
+i9xx_plane_ctl_crtc [i915]
+i9xx_disable_plane [i915]
+i9xx_update_plane [i915]
+ilk_pfit_enable [i915]
+intel_cpu_transcoder_set_m_n [i915]
+i845_update_cursor [i915]
+i845_disable_cursor [i915]
+bdw_set_pipemisc [i915]
+i9xx_plane_min_cdclk [i915]
+modeset_get_crtc_power_domains [i915]
+intel_cpu_transcoders_need_modeset [i915]
+assert_plane [i915]
+assert_planes_disabled [i915]
+assert_fdi_tx [i915]
+assert_fdi_rx [i915]
+assert_pch_dp_disabled [i915]
+i9xx_set_pipeconf [i915]
+assert_vblank_disabled [i915]
+verify_connector_state [i915]
+verify_single_dpll_state [i915]
+assert_pch_hdmi_disabled [i915]
+intel_old_crtc_state_disables [i915]
+i9xx_update_cursor [i915]
+i9xx_disable_cursor [i915]
+i8xx_plane_format_mod_supported [i915]
+i965_plane_format_mod_supported [i915]
+skl_wa_827 [i915]
+icl_wa_scalerclkgating [i915]
+intel_pll_is_valid [i915]
+intel_get_format_info [i915]
+intel_panel_use_ssc.part.0 [i915]
+intel_mode_valid [i915]
+skl_max_plane_width.isra.0 [i915]
+intel_connector_primary_encoder.part.0 [i915]
+chv_prepare_pll [i915]
+intel_dump_infoframe.part.0 [i915]
+pipe_config_infoframe_mismatch [i915]
+i9xx_select_p2_div [i915]
+g4x_find_best_dpll.isra.0 [i915]
+intel_atomic_commit_ready [i915]
+pipe_required_fdi_lanes [i915]
+intel_tile_height [i915]
+intel_tile_dims [i915]
+intel_adjust_aligned_offset [i915]
+intel_compute_aligned_offset [i915]
+skl_plane_stride_mult [i915]
+intel_fb_plane_get_subsampling [i915]
+intel_legacy_aux_to_power_domain.part.0 [i915]
+intel_fuzzy_clock_check.part.0 [i915]
+intel_compare_m_n [i915]
+intel_compare_link_m_n [i915]
+intel_pps_unlock_regs_wa.part.0 [i915]
+intel_pipe_config_compare [i915]
+i9xx_update_pll_dividers.constprop.0 [i915]
+i9xx_compute_dpll.constprop.0 [i915]
+g4x_crtc_compute_clock [i915]
+vlv_prepare_pll [i915]
+intel_dump_pipe_config [i915]
+pnv_crtc_compute_clock [i915]
+i9xx_find_best_dpll.constprop.0 [i915]
+i9xx_crtc_compute_clock [i915]
+i8xx_crtc_compute_clock [i915]
+vlv_calc_dpll_params.constprop.0 [i915]
+add_rps_boost_after_vblank [i915]
+i9xx_get_initial_plane_config [i915]
+intel_atomic_helper_free_state [i915]
+intel_atomic_helper_free_state_worker [i915]
+vlv_PLL_is_optimal.part.0 [i915]
+vlv_crtc_compute_clock [i915]
+intel_pipe_config_sanity_check [i915]
+ilk_pipe_pixel_rate [i915]
+compute_m_n [i915]
+intel_atomic_cleanup_work [i915]
+do_rps_boost [i915]
+ilk_crtc_compute_clock [i915]
+vlv_get_hpll_vco [i915]
+vlv_get_cck_clock [i915]
+vlv_get_cck_clock_hpll [i915]
+is_trans_port_sync_mode [i915]
+chv_calc_dpll_params [i915]
+i9xx_get_pipe_config [i915]
+chv_find_best_dpll.isra.0.constprop.0 [i915]
+chv_crtc_compute_clock [i915]
+bxt_find_best_dpll [i915]
+assert_pll [i915]
+assert_dsi_pll [i915]
+assert_fdi_rx_pll [i915]
+assert_panel_unlocked [i915]
+assert_pipe [i915]
+chv_enable_pll [i915]
+vlv_enable_pll [i915]
+chv_disable_pll [i915]
+vlv_disable_pll [i915]
+ilk_fdi_link_train [i915]
+i9xx_pfit_enable [i915]
+assert_pch_transcoder_disabled [i915]
+vlv_wait_port_ready [i915]
+lpt_disable_pch_transcoder [i915]
+intel_crtc_pch_transcoder [i915]
+intel_crtc_vblank_on [i915]
+intel_crtc_vblank_off [i915]
+intel_enable_pipe [i915]
+intel_disable_pipe [i915]
+intel_main_to_aux_plane [i915]
+intel_format_info_is_yuv_semiplanar [i915]
+skl_update_scaler [i915]
+intel_surf_alignment [i915]
+intel_plane_compute_aligned_offset [i915]
+skl_check_main_ccs_coordinates [i915]
+intel_fb_align_height [i915]
+intel_rotation_info_size [i915]
+intel_remapped_info_size [i915]
+intel_pin_and_fence_fb_obj [i915]
+intel_plane_pin_fb [i915]
+intel_unpin_fb_vma [i915]
+intel_legacy_cursor_update [i915]
+intel_fb_xy_to_linear [i915]
+intel_add_fb_offsets [i915]
+is_ccs_modifier [i915]
+intel_plane_fb_max_stride [i915]
+intel_framebuffer_init [i915]
+intel_alloc_initial_plane_obj [i915]
+intel_plane_can_remap [i915]
+intel_plane_compute_gtt [i915]
+intel_check_cursor [i915]
+i9xx_check_cursor [i915]
+i845_check_cursor [i915]
+skl_format_to_fourcc [i915]
+skl_get_initial_plane_config [i915]
+intel_plane_fence_y_offset [i915]
+skl_check_plane_surface [i915]
+i9xx_check_plane_surface [i915]
+i9xx_plane_check [i915]
+skl_plane_stride [i915]
+skl_plane_ctl_crtc [i915]
+skl_plane_ctl [i915]
+glk_plane_color_ctl_crtc [i915]
+glk_plane_color_ctl [i915]
+intel_prepare_reset [i915]
+intel_has_pending_fb_unpin [i915]
+lpt_disable_iclkip [i915]
+lpt_get_iclkip [i915]
+lpt_pch_enable [i915]
+skl_scaler_calc_phase [i915]
+skl_pfit_enable [i915]
+hsw_crtc_enable [i915]
+skl_scaler_disable [i915]
+hsw_enable_ips [i915]
+hsw_disable_ips [i915]
+intel_plane_disable_noatomic [i915]
+intel_pre_plane_update [i915]
+intel_atomic_commit_tail [i915]
+intel_atomic_commit [i915]
+intel_atomic_commit_work [i915]
+ilk_pfit_disable [i915]
+ilk_crtc_disable [i915]
+intel_phy_is_combo [i915]
+intel_phy_is_tc [i915]
+intel_port_to_phy [i915]
+intel_port_to_tc [i915]
+hsw_get_pipe_config [i915]
+intel_port_to_power_domain [i915]
+intel_aux_power_domain [i915]
+intel_legacy_aux_to_power_domain [i915]
+intel_display_suspend [i915]
+intel_encoder_destroy [i915]
+hsw_crtc_state_ips_capable [i915]
+intel_link_compute_m_n [i915]
+intel_dp_set_m_n [i915]
+i9xx_crtc_enable [i915]
+valleyview_crtc_enable [i915]
+ilk_crtc_enable [i915]
+vlv_force_pll_on [i915]
+vlv_force_pll_off [i915]
+intel_mode_from_pipe_config [i915]
+intel_modeset_setup_hw_state [i915]
+__intel_display_resume [i915]
+lpt_disable_clkout_dp [i915]
+intel_init_pch_refclk [i915]
+bdw_get_pipemisc_bpp [i915]
+ilk_get_lanes_required [i915]
+intel_atomic_check [i915]
+intel_dp_get_m_n [i915]
+intel_framebuffer_create [i915]
+intel_user_framebuffer_create [i915]
+intel_get_load_detect_pipe [i915]
+intel_release_load_detect_pipe [i915]
+intel_dotclock_calculate [i915]
+intel_encoder_current_mode [i915]
+intel_plane_atomic_calc_changes [i915]
+intel_fuzzy_clock_check [i915]
+intel_calc_active_pipes [i915]
+intel_crtc_get_vblank_counter [i915]
+intel_crtc_arm_fifo_underrun [i915]
+intel_update_crtc [i915]
+intel_commit_modeset_enables [i915]
+skl_commit_modeset_enables [i915]
+intel_prepare_plane_fb [i915]
+intel_cleanup_plane_fb [i915]
+intel_get_pipe_from_crtc_id_ioctl [i915]
+intel_pps_unlock_regs_wa [i915]
+intel_mode_valid_max_plane_size [i915]
+intel_init_display_hooks [i915]
+intel_modeset_init_hw [i915]
+intel_finish_reset [i915]
+intel_modeset_init_noirq [i915]
+intel_modeset_init_nogem [i915]
+intel_modeset_init [i915]
+i830_enable_pipe [i915]
+i9xx_crtc_disable [i915]
+i830_disable_pipe [i915]
+intel_display_resume [i915]
+intel_modeset_driver_remove [i915]
+intel_modeset_driver_remove_noirq [i915]
+intel_modeset_driver_remove_nogem [i915]
+intel_display_capture_error_state [i915]
+intel_display_print_error_state [i915]
+i9xx_power_well_sync_hw_noop [i915]
+i9xx_always_on_power_well_enabled [i915]
+i830_pipes_power_well_disable [i915]
+vlv_punit_is_power_gated [i915]
+gen9_dc_off_power_well_enabled [i915]
+intel_pch_reset_handshake [i915]
+aux_ch_to_digital_port [i915]
+sanitize_target_dc_state [i915]
+i830_pipes_power_well_enabled [i915]
+chv_pipe_power_well_sync_hw [i915]
+tgl_tc_cold_off_power_well_is_enabled [i915]
+async_put_domains_clear_domain [i915]
+hsw_power_well_enabled [i915]
+hsw_power_well_sync_hw [i915]
+lookup_power_well [i915]
+intel_power_well_enable [i915]
+intel_power_well_disable [i915]
+hsw_wait_for_power_well_enable [i915]
+__intel_display_power_get_domain [i915]
+queue_async_put_domains_work [i915]
+i830_pipes_power_well_enable [i915]
+vlv_power_well_enabled [i915]
+chv_pipe_power_well_enabled [i915]
+vlv_set_power_well [i915]
+vlv_power_well_disable [i915]
+vlv_power_well_enable [i915]
+vlv_dpio_cmn_power_well_enable [i915]
+vlv_dpio_cmn_power_well_disable [i915]
+hsw_wait_for_power_well_disable [i915]
+hsw_power_well_disable [i915]
+bxt_dpio_cmn_power_well_enabled [i915]
+bxt_dpio_cmn_power_well_disable [i915]
+bxt_dpio_cmn_power_well_enable [i915]
+assert_csr_loaded [i915]
+gen9_set_dc_state [i915]
+skl_enable_dc6 [i915]
+gen9_disable_dc_states [i915]
+gen9_dc_off_power_well_enable [i915]
+assert_chv_phy_status [i915]
+chv_dpio_cmn_power_well_disable [i915]
+vlv_display_power_well_init [i915]
+vlv_display_power_well_enable [i915]
+chv_dpio_cmn_power_well_enable [i915]
+bxt_enable_dc9 [i915]
+bxt_disable_dc9 [i915]
+hsw_read_dcomp [i915]
+gen9_wait_for_power_well_fuses [i915]
+hsw_power_well_enable [i915]
+i830_pipes_power_well_sync_hw [i915]
+icl_aux_power_well_disable [i915]
+hsw_write_dcomp [i915]
+icl_aux_power_well_enable [i915]
+tgl_tc_cold_request [i915]
+tgl_tc_cold_off_power_well_disable [i915]
+tgl_tc_cold_off_power_well_enable [i915]
+tgl_tc_cold_off_power_well_sync_hw [i915]
+assert_isp_power_gated [i915]
+hsw_disable_pc8 [i915]
+intel_display_power_domain_str.part.0 [i915]
+__intel_display_power_put_domain [i915]
+__intel_display_power_put [i915]
+hsw_enable_pc8 [i915]
+chv_set_pipe_power_well.constprop.0 [i915]
+chv_pipe_power_well_enable [i915]
+__set_power_wells [i915]
+i9xx_always_on_power_well_noop [i915]
+release_async_put_domains [i915]
+intel_display_power_put_async_work [i915]
+vlv_display_power_well_deinit [i915]
+vlv_display_power_well_disable [i915]
+chv_pipe_power_well_disable [i915]
+intel_display_power_domain_str [i915]
+__intel_display_power_is_enabled [i915]
+intel_display_power_is_enabled [i915]
+intel_display_power_set_target_dc_state [i915]
+chv_phy_powergate_ch [i915]
+chv_phy_powergate_lanes [i915]
+intel_display_power_get [i915]
+intel_display_power_get_if_enabled [i915]
+intel_display_power_put_unchecked [i915]
+__intel_display_power_put_async [i915]
+intel_display_power_flush_work [i915]
+intel_display_power_well_is_enabled [i915]
+gen9_enable_dc5 [i915]
+gen9_dc_off_power_well_disable [i915]
+intel_power_domains_init [i915]
+intel_power_domains_cleanup [i915]
+gen9_dbuf_slices_update [i915]
+gen9_dbuf_enable [i915]
+icl_display_core_init [i915]
+bxt_display_core_init [i915]
+icl_display_core_uninit [i915]
+skl_display_core_uninit [i915]
+intel_power_domains_init_hw [i915]
+intel_power_domains_driver_remove [i915]
+intel_power_domains_enable [i915]
+intel_power_domains_disable [i915]
+intel_power_domains_suspend [i915]
+intel_power_domains_resume [i915]
+intel_display_power_suspend_late [i915]
+intel_display_power_resume_early [i915]
+intel_display_power_suspend [i915]
+intel_display_power_resume [i915]
+__phy_reg_verify_state [i915]
+bxt_port_to_phy_channel [i915]
+bxt_ddi_phy_set_signal_level [i915]
+bxt_ddi_phy_is_enabled [i915]
+bxt_ddi_phy_uninit [i915]
+bxt_ddi_phy_verify_state [i915]
+_bxt_ddi_phy_init [i915]
+bxt_ddi_phy_init [i915]
+bxt_ddi_phy_calc_lane_lat_optim_mask [i915]
+bxt_ddi_phy_set_lane_optim_mask [i915]
+bxt_ddi_phy_get_lane_lat_optim_mask [i915]
+chv_set_phy_signal_level [i915]
+chv_data_lane_soft_reset [i915]
+chv_phy_pre_pll_enable [i915]
+chv_phy_pre_encoder_enable [i915]
+chv_phy_release_cl2_override [i915]
+chv_phy_post_pll_disable [i915]
+vlv_set_phy_signal_level [i915]
+vlv_phy_pre_pll_enable [i915]
+vlv_phy_pre_encoder_enable [i915]
+vlv_phy_reset_lanes [i915]
+hsw_ddi_lcpll_enable [i915]
+hsw_ddi_lcpll_get_hw_state [i915]
+ibx_pch_dpll_prepare [i915]
+hsw_update_dpll_ref_clks [i915]
+skl_ddi_pll_disable [i915]
+skl_update_dpll_ref_clks [i915]
+bxt_update_dpll_ref_clks [i915]
+icl_dpll_write [i915]
+hsw_ddi_lcpll_get_freq [i915]
+hsw_ddi_spll_get_freq [i915]
+icl_ddi_tbt_pll_get_freq [i915]
+ibx_dump_hw_state [i915]
+hsw_dump_hw_state [i915]
+bxt_dump_hw_state [i915]
+skl_dump_hw_state [i915]
+cnl_dump_hw_state [i915]
+icl_dump_hw_state [i915]
+skl_ddi_pll_write_ctrl1 [i915]
+skl_ddi_dpll0_enable [i915]
+icl_update_active_dpll [i915]
+ibx_pch_dpll_get_hw_state [i915]
+hsw_ddi_wrpll_get_hw_state [i915]
+skl_ddi_pll_get_hw_state [i915]
+skl_ddi_dpll0_get_hw_state [i915]
+cnl_ddi_pll_get_hw_state [i915]
+mg_pll_get_hw_state [i915]
+icl_pll_get_hw_state [i915]
+tbt_pll_get_hw_state [i915]
+combo_pll_get_hw_state [i915]
+dkl_pll_get_hw_state [i915]
+ibx_pch_dpll_disable [i915]
+hsw_ddi_spll_enable [i915]
+hsw_ddi_wrpll_enable [i915]
+icl_calc_dpll_state [i915]
+hsw_ddi_spll_disable [i915]
+hsw_ddi_wrpll_disable [i915]
+hsw_ddi_wrpll_get_freq [i915]
+skl_ddi_pll_get_freq [i915]
+__cnl_ddi_wrpll_get_freq [i915]
+icl_ddi_combo_pll_get_freq [i915]
+bxt_ddi_pll_get_freq [i915]
+bxt_ddi_pll_get_hw_state [i915]
+bxt_ddi_pll_disable [i915]
+bxt_ddi_pll_enable [i915]
+skl_ddi_pll_enable [i915]
+cnl_ddi_pll_enable [i915]
+cnl_ddi_pll_disable [i915]
+icl_pll_disable [i915]
+mg_pll_disable [i915]
+tbt_pll_disable [i915]
+ibx_pch_dpll_enable [i915]
+intel_atomic_get_shared_dpll_state [i915]
+intel_unreference_shared_dpll [i915]
+intel_put_dpll [i915]
+icl_put_dplls [i915]
+intel_reference_shared_dpll [i915]
+intel_find_shared_dpll [i915]
+ibx_get_dpll [i915]
+hsw_get_dpll [i915]
+bxt_ddi_set_dpll_hw_state [i915]
+bxt_get_dpll [i915]
+hsw_ddi_spll_get_hw_state [i915]
+cnl_ddi_pll_get_freq [i915]
+icl_pll_power_enable [i915]
+icl_pll_enable [i915]
+mg_pll_enable [i915]
+tbt_pll_enable [i915]
+combo_pll_enable [i915]
+combo_pll_disable [i915]
+hsw_ddi_lcpll_disable [i915]
+skl_ddi_dpll0_disable [i915]
+icl_update_dpll_ref_clks [i915]
+cnl_update_dpll_ref_clks [i915]
+icl_ddi_mg_pll_get_freq [i915]
+__cnl_ddi_calculate_wrpll [i915]
+cnl_get_dpll [i915]
+icl_get_dplls [i915]
+skl_ddi_calculate_wrpll [i915]
+skl_get_dpll [i915]
+intel_get_shared_dpll_by_id [i915]
+intel_get_shared_dpll_id [i915]
+assert_shared_dpll [i915]
+intel_prepare_shared_dpll [i915]
+intel_enable_shared_dpll [i915]
+intel_disable_shared_dpll [i915]
+intel_shared_dpll_swap_state [i915]
+icl_tc_port_to_pll_id [i915]
+icl_set_active_port_dpll [i915]
+intel_shared_dpll_init [i915]
+intel_reserve_shared_dplls [i915]
+intel_release_shared_dplls [i915]
+intel_update_active_dpll [i915]
+intel_dpll_get_freq [i915]
+intel_dpll_readout_hw_state [i915]
+intel_dpll_sanitize_state [i915]
+intel_dpll_dump_hw_state [i915]
+intel_dsb_indexed_reg_write [i915]
+intel_dsb_reg_write [i915]
+intel_dsb_commit [i915]
+intel_dsb_prepare [i915]
+intel_dsb_cleanup [i915]
+intel_fbc_gen9_wa_cfb_stride [i915]
+intel_fbc_update_state_cache [i915]
+intel_fbc_can_enable [i915]
+intel_fbc_can_activate [i915]
+intel_fbc_hw_is_active [i915]
+__intel_fbc_cleanup_cfb [i915]
+__intel_fbc_disable [i915]
+intel_fbc_hw_deactivate [i915]
+intel_fbc_deactivate [i915]
+intel_fbc_underrun_work_fn [i915]
+intel_fbc_recompress [i915]
+__intel_fbc_post_update [i915]
+intel_fbc_is_active [i915]
+intel_fbc_cleanup_cfb [i915]
+intel_fbc_pre_update [i915]
+intel_fbc_post_update [i915]
+intel_fbc_invalidate [i915]
+intel_fbc_flush [i915]
+intel_fbc_choose_crtc [i915]
+intel_fbc_enable [i915]
+intel_fbc_disable [i915]
+intel_fbc_global_disable [i915]
+intel_fbc_reset_underrun [i915]
+intel_fbc_handle_fifo_underrun_irq [i915]
+intel_fbc_init [i915]
+intel_set_cpu_fifo_underrun_reporting [i915]
+intel_set_pch_fifo_underrun_reporting [i915]
+intel_cpu_fifo_underrun_irq_handler [i915]
+intel_pch_fifo_underrun_irq_handler [i915]
+intel_check_cpu_fifo_underruns [i915]
+intel_check_pch_fifo_underruns [i915]
+frontbuffer_active [i915]
+frontbuffer_flush [i915]
+intel_frontbuffer_flip_prepare [i915]
+intel_frontbuffer_flip_complete [i915]
+intel_frontbuffer_flip [i915]
+__intel_fb_invalidate [i915]
+__intel_fb_flush [i915]
+intel_frontbuffer_put [i915]
+frontbuffer_retire [i915]
+intel_frontbuffer_get [i915]
+intel_frontbuffer_track [i915]
+__intel_atomic_global_state_free [i915]
+intel_atomic_global_obj_init [i915]
+intel_atomic_global_obj_cleanup [i915]
+intel_atomic_get_global_obj_state [i915]
+intel_atomic_get_old_global_obj_state [i915]
+intel_atomic_get_new_global_obj_state [i915]
+intel_atomic_swap_global_state [i915]
+intel_atomic_clear_global_state [i915]
+intel_atomic_lock_global_state [i915]
+intel_atomic_serialize_global_state [i915]
+intel_hdcp_read_valid_bksv [i915]
+i915_hdcp_component_unbind [i915]
+i915_hdcp_component_bind [i915]
+hdcp2_close_mei_session [i915]
+intel_hdcp_prop_work [i915]
+_intel_hdcp2_disable [i915]
+hdcp2_enable_encryption [i915]
+intel_hdcp_update_value [i915]
+hdcp2_authenticate_repeater_topology [i915]
+hdcp2_authentication_key_exchange [i915]
+_intel_hdcp2_enable [i915]
+intel_hdcp_get_repeater_ctl [i915]
+_intel_hdcp_disable [i915]
+intel_write_sha_text [i915]
+intel_hdcp_auth [i915]
+_intel_hdcp_enable [i915]
+intel_hdcp_check_work [i915]
+intel_hdcp_capable [i915]
+intel_hdcp2_capable [i915]
+is_hdcp_supported [i915]
+intel_hdcp_component_init [i915]
+intel_hdcp_init [i915]
+intel_hdcp_enable [i915]
+intel_hdcp_disable [i915]
+intel_hdcp_update_pipe [i915]
+intel_hdcp_component_fini [i915]
+intel_hdcp_cleanup [i915]
+intel_hdcp_atomic_check [i915]
+intel_hdcp_handle_cp_irq [i915]
+intel_encoder_has_hpd_pulse [i915]
+i915_hpd_poll_init_work [i915]
+intel_hpd_irq_storm_reenable_work [i915]
+i915_hotplug_work_func [i915]
+i915_digport_work_func [i915]
+intel_hpd_pin_default [i915]
+intel_encoder_hotplug [i915]
+intel_hpd_trigger_irq [i915]
+intel_hpd_irq_handler [i915]
+intel_hpd_init [i915]
+intel_hpd_poll_init [i915]
+intel_hpd_init_work [i915]
+intel_hpd_cancel_work [i915]
+intel_hpd_disable [i915]
+intel_hpd_enable [i915]
+lpe_audio_irq_unmask [i915]
+lpe_audio_irq_mask [i915]
+intel_lpe_audio_irq_handler [i915]
+intel_lpe_audio_init [i915]
+intel_lpe_audio_teardown [i915]
+intel_lpe_audio_notify [i915]
+update_polyphase_filter [i915]
+intel_overlay_last_flip_retire [i915]
+update_reg_attrs [i915]
+alloc_request [i915]
+i830_overlay_clock_gating [i915]
+check_gamma_bounds.part.0 [i915]
+intel_overlay_flip_prepare [i915]
+intel_overlay_release_old_vma [i915]
+intel_overlay_release_old_vid_tail [i915]
+intel_overlay_release_old_vid [i915]
+intel_overlay_off_tail [i915]
+intel_overlay_reset [i915]
+intel_overlay_switch_off [i915]
+intel_overlay_put_image_ioctl [i915]
+intel_overlay_attrs_ioctl [i915]
+intel_overlay_setup [i915]
+intel_overlay_cleanup [i915]
+intel_overlay_capture_error_state [i915]
+intel_overlay_print_error_state [i915]
+psr2_program_idle_frames [i915]
+psr_irq_control [i915]
+psr_compute_idle_frames [i915]
+tgl_psr2_disable_dc3co [i915]
+tgl_dc3co_disable_work [i915]
+intel_psr2_enabled [i915]
+intel_psr_exit [i915]
+psr_force_hw_tracking_exit [i915]
+intel_psr_activate [i915]
+intel_psr_enable_locked [i915]
+intel_psr_disable_locked [i915]
+intel_psr_work [i915]
+intel_psr_irq_handler [i915]
+intel_psr_init_dpcd [i915]
+intel_psr_compute_config [i915]
+intel_psr_enable [i915]
+intel_psr_disable [i915]
+intel_psr2_program_trans_man_trk_ctl [i915]
+intel_psr2_sel_fetch_update [i915]
+intel_psr_update [i915]
+intel_psr_wait_for_idle [i915]
+intel_psr_debug_set [i915]
+intel_psr_invalidate [i915]
+intel_psr_flush [i915]
+intel_psr_init [i915]
+intel_psr_short_pulse [i915]
+intel_psr_enabled [i915]
+intel_psr_atomic_check [i915]
+intel_psr_set_force_mode_changed [i915]
+quirk_invert_brightness [i915]
+quirk_increase_ddi_disabled_time [i915]
+quirk_increase_t12_delay [i915]
+quirk_backlight_present [i915]
+quirk_ssc_force_disable [i915]
+intel_dmi_reverse_brightness [i915]
+intel_init_quirks [i915]
+g4x_sprite_max_stride [i915]
+vlv_disable_plane [i915]
+ivb_disable_plane [i915]
+g4x_disable_plane [i915]
+intel_fb_scalable [i915]
+intel_plane_set_ckey [i915]
+gen12_plane_supports_mc_ccs [i915]
+skl_plane_min_cdclk [i915]
+skl_plane_get_hw_state [i915]
+g4x_plane_get_hw_state [i915]
+ivb_plane_get_hw_state [i915]
+vlv_plane_get_hw_state [i915]
+skl_plane_max_stride [i915]
+skl_disable_plane [i915]
+ivb_update_plane [i915]
+g4x_update_plane [i915]
+vlv_update_plane [i915]
+g4x_sprite_min_cdclk [i915]
+snb_sprite_format_mod_supported [i915]
+vlv_sprite_format_mod_supported [i915]
+skl_update_plane [i915]
+gen12_plane_format_mod_supported [i915]
+skl_plane_format_mod_supported [i915]
+g4x_sprite_format_mod_supported [i915]
+vlv_plane_min_cdclk [i915]
+hsw_plane_min_cdclk [i915]
+ivb_plane_ratio [i915]
+ivb_sprite_min_cdclk [i915]
+intel_usecs_to_scanlines [i915]
+intel_pipe_update_start [i915]
+intel_pipe_update_end [i915]
+intel_plane_check_stride [i915]
+intel_plane_check_src_coordinates [i915]
+g4x_sprite_check [i915]
+skl_plane_check [i915]
+icl_is_nv12_y_plane [i915]
+icl_is_hdr_plane [i915]
+ivb_plane_min_cdclk [i915]
+chv_plane_check_rotation [i915]
+vlv_sprite_check [i915]
+intel_sprite_set_colorkey_ioctl [i915]
+skl_universal_plane_create [i915]
+intel_sprite_plane_create [i915]
+tc_port_mode_name [i915]
+icl_tc_phy_is_in_safe_mode [i915]
+icl_tc_phy_status_complete [i915]
+tc_port_live_status_mask [i915]
+icl_tc_phy_set_safe_mode [i915]
+assert_tc_cold_blocked [i915]
+tc_cold_block [i915]
+tc_cold_unblock [i915]
+intel_tc_port_get_lane_mask [i915]
+intel_tc_port_get_pin_assignment_mask [i915]
+intel_tc_port_fia_max_lane_count [i915]
+icl_tc_phy_connect [i915]
+__intel_tc_port_lock [i915]
+intel_tc_port_set_fia_lane_count [i915]
+intel_tc_port_sanitize [i915]
+intel_tc_port_lock [i915]
+intel_tc_port_unlock [i915]
+intel_tc_port_connected [i915]
+intel_tc_port_ref_held [i915]
+intel_tc_port_get_link [i915]
+intel_tc_port_put_link [i915]
+intel_tc_port_init [i915]
+intel_vga_set_decode [i915]
+intel_vga_cntrl_reg [i915]
+intel_vga_disable [i915]
+intel_vga_redisable_power_on [i915]
+intel_vga_redisable [i915]
+intel_vga_reset_io_mem [i915]
+intel_vga_register [i915]
+intel_vga_unregister [i915]
+intel_dsm_detect [i915]
+intel_register_dsm_handler [i915]
+intel_unregister_dsm_handler [i915]
+intel_acpi_device_id_update [i915]
+intel_use_opregion_panel_type_callback [i915]
+intel_no_opregion_vbt_callback [i915]
+asle_work [i915]
+swsci [i915]
+set_did.part.0 [i915]
+intel_opregion_video_event [i915]
+intel_opregion_notify_adapter.part.0 [i915]
+intel_opregion_notify_encoder [i915]
+intel_opregion_notify_adapter [i915]
+intel_opregion_asle_intr [i915]
+intel_opregion_setup [i915]
+intel_opregion_get_panel_type [i915]
+intel_opregion_resume [i915]
+intel_opregion_register [i915]
+intel_opregion_suspend [i915]
+intel_opregion_unregister [i915]
+intel_fbdev_invalidate [i915]
+intel_fbdev_pan_display [i915]
+intel_fbdev_blank [i915]
+intel_fbdev_set_par [i915]
+intelfb_alloc [i915]
+intelfb_create [i915]
+intel_fbdev_init [i915]
+intel_fbdev_initial_config_async [i915]
+intel_fbdev_unregister [i915]
+intel_fbdev_initial_config [i915]
+intel_fbdev_fini [i915]
+intel_fbdev_set_suspend [i915]
+intel_fbdev_suspend_worker [i915]
+intel_fbdev_output_poll_changed [i915]
+intel_fbdev_restore_mode [i915]
+ch7017_detect [i915]
+ch7017_mode_valid [i915]
+ch7017_read [i915]
+ch7017_dump_regs [i915]
+ch7017_get_hw_state [i915]
+ch7017_write [i915]
+ch7017_dpms [i915]
+ch7017_destroy [i915]
+ch7017_mode_set [i915]
+ch7017_init [i915]
+ch7xxx_mode_valid [i915]
+ch7xxx_destroy [i915]
+ch7xxx_readb [i915]
+ch7xxx_dump_regs [i915]
+ch7xxx_get_hw_state [i915]
+ch7xxx_writeb [i915]
+ch7xxx_detect [i915]
+ch7xxx_mode_set [i915]
+ch7xxx_dpms [i915]
+ch7xxx_init [i915]
+ivch_detect [i915]
+ivch_mode_valid [i915]
+ivch_destroy [i915]
+ivch_read [i915]
+ivch_dump_regs [i915]
+ivch_write [i915]
+ivch_reset [i915]
+ivch_get_hw_state [i915]
+ivch_mode_set [i915]
+ivch_dpms [i915]
+ivch_init [i915]
+ns2501_detect [i915]
+ns2501_destroy [i915]
+ns2501_mode_valid [i915]
+ns2501_readb [i915]
+ns2501_get_hw_state [i915]
+ns2501_writeb [i915]
+ns2501_mode_set [i915]
+ns2501_dpms [i915]
+ns2501_init [i915]
+sil164_mode_valid [i915]
+sil164_mode_set [i915]
+sil164_destroy [i915]
+sil164_readb [i915]
+sil164_dump_regs [i915]
+sil164_get_hw_state [i915]
+sil164_detect [i915]
+sil164_dpms [i915]
+sil164_init [i915]
+tfp410_mode_valid [i915]
+tfp410_mode_set [i915]
+tfp410_destroy [i915]
+tfp410_readb [i915]
+tfp410_dump_regs [i915]
+tfp410_get_hw_state [i915]
+tfp410_detect [i915]
+tfp410_getid [i915]
+tfp410_dpms [i915]
+tfp410_init [i915]
+gen11_dsi_host_attach [i915]
+gen11_dsi_mode_valid [i915]
+gen11_dsi_post_disable [i915]
+gen11_dsi_encoder_destroy [i915]
+gen11_dsi_config_util_pin [i915]
+gen11_dsi_gate_clocks [i915]
+gen11_dsi_config_phy_lanes_sequence [i915]
+dsi_program_swing_and_deemphasis [i915]
+gen11_dsi_voltage_swing_program_seq [i915]
+get_dsi_io_power_domains [i915]
+gen11_dsi_get_hw_state [i915]
+gen11_dsi_get_config [i915]
+gen11_dsi_get_power_domains [i915]
+afe_clk [i915]
+gen11_dsi_pre_pll_enable [i915]
+gen11_dsi_compute_config [i915]
+gen11_dsi_enable [i915]
+gen11_dsi_host_transfer [i915]
+wait_for_header_credits [i915]
+wait_for_cmds_dispatched_to_panel [i915]
+gen11_dsi_disable [i915]
+gen11_dsi_pre_enable [i915]
+gen11_dsi_host_detach [i915]
+icl_dsi_init [i915]
+pch_disable_crt [i915]
+intel_crt_get_flags [i915]
+intel_crt_get_config [i915]
+intel_crt_set_dpms [i915]
+intel_disable_crt [i915]
+intel_enable_crt [i915]
+intel_crt_compute_config [i915]
+pch_crt_compute_config [i915]
+intel_crt_reset [i915]
+intel_crt_mode_valid [i915]
+hsw_crt_get_config [i915]
+intel_spurious_crt_detect_dmi_callback [i915]
+intel_crt_get_hw_state [i915]
+hsw_crt_compute_config [i915]
+hsw_post_disable_crt [i915]
+hsw_disable_crt [i915]
+hsw_pre_pll_enable_crt [i915]
+hsw_pre_enable_crt [i915]
+intel_crt_get_edid [i915]
+intel_crt_ddc_get_modes [i915]
+intel_crt_get_modes [i915]
+intel_crt_detect_ddc [i915]
+intel_crt_detect [i915]
+pch_post_disable_crt [i915]
+hsw_enable_crt [i915]
+intel_crt_port_enabled [i915]
+intel_crt_init [i915]
+intel_ddi_dp_preemph_max [i915]
+_skl_ddi_set_iboost [i915]
+intel_ddi_update_complete [i915]
+intel_ddi_encoder_destroy [i915]
+kbl_get_buf_trans_dp [i915]
+intel_ddi_get_buf_trans_dp [i915]
+intel_ddi_get_buf_trans_hdmi [i915]
+intel_ddi_init_dp_buf_reg [i915]
+intel_ddi_set_link_train [i915]
+bdw_transcoder_master_readout [i915]
+lpt_digital_port_connected [i915]
+hsw_digital_port_connected [i915]
+bdw_digital_port_connected [i915]
+hsw_pll_to_ddi_pll_sel [i915]
+cnl_get_buf_trans_hdmi [i915]
+cnl_get_buf_trans_dp [i915]
+translate_signal_level [i915]
+intel_ddi_compute_output_type [i915]
+intel_ddi_get_encoder_pipes [i915]
+intel_ddi_clk_disable [i915]
+icl_program_mg_dp_mode [i915]
+intel_ddi_set_idle_link_train [i915]
+intel_ddi_pre_pll_enable [i915]
+icl_get_combo_buf_trans [i915]
+ehl_get_combo_buf_trans [i915]
+tgl_get_combo_buf_trans [i915]
+cnl_get_buf_trans_edp [i915]
+cnl_ddi_vswing_program [i915]
+cnl_ddi_vswing_sequence [i915]
+cnl_set_signal_levels [i915]
+intel_ddi_transcoder_func_reg_val_get [i915]
+intel_ddi_get_hw_state [i915]
+intel_ddi_update_prepare [i915]
+intel_ddi_get_power_domains [i915]
+bxt_ddi_vswing_sequence [i915]
+bxt_set_signal_levels [i915]
+intel_dp_sink_set_fec_ready [i915]
+intel_ddi_enable_fec [i915]
+intel_ddi_compute_config_late [i915]
+icl_dpclka_cfgcr0_clk_off [i915]
+intel_ddi_clk_select [i915]
+intel_wait_ddi_buf_idle [i915]
+intel_disable_ddi_buf [i915]
+intel_ddi_prepare_link_retrain [i915]
+intel_ddi_get_buf_trans_edp [i915]
+intel_prepare_dp_ddi_buffers [i915]
+intel_ddi_dp_voltage_max [i915]
+skl_ddi_set_iboost [i915]
+hsw_set_signal_levels [i915]
+intel_disable_ddi [i915]
+icl_ddi_combo_vswing_program [i915]
+icl_combo_phy_ddi_vswing_sequence [i915]
+tgl_ddi_vswing_sequence.isra.0 [i915]
+tgl_set_signal_levels [i915]
+icl_ddi_vswing_sequence [i915]
+icl_set_signal_levels [i915]
+intel_ddi_hotplug [i915]
+hsw_fdi_link_train [i915]
+intel_ddi_set_dp_msa [i915]
+intel_ddi_update_pipe [i915]
+intel_ddi_enable_transcoder_func [i915]
+intel_enable_ddi [i915]
+intel_ddi_disable_transcoder_func [i915]
+intel_ddi_toggle_hdcp_signalling [i915]
+intel_ddi_connector_get_hw_state [i915]
+intel_ddi_enable_pipe_clock [i915]
+intel_ddi_pre_enable [i915]
+intel_ddi_disable_pipe_clock [i915]
+intel_ddi_post_disable [i915]
+icl_sanitize_encoder_pll_mapping [i915]
+intel_ddi_fdi_post_disable [i915]
+intel_ddi_compute_min_voltage_level [i915]
+intel_ddi_get_config [i915]
+intel_ddi_compute_config [i915]
+intel_ddi_init [i915]
+vlv_pipe_any [i915]
+skl_get_aux_clock_divider [i915]
+intel_dp_voltage_max_2 [i915]
+intel_dp_voltage_max_3 [i915]
+intel_dp_pre_empemph_max_2 [i915]
+intel_dp_pre_empemph_max_3 [i915]
+pps_lock [i915]
+vlv_pipe_has_pp_on [i915]
+vlv_pipe_has_vdd_on [i915]
+vlv_initial_pps_pipe [i915]
+g4x_get_aux_send_ctl [i915]
+ibx_digital_port_connected [i915]
+ilk_digital_port_connected [i915]
+g4x_set_signal_levels [i915]
+g4x_set_link_train [i915]
+cpt_set_link_train [i915]
+g4x_get_aux_clock_divider [i915]
+ilk_get_aux_clock_divider [i915]
+intel_dp_compute_vsc_colorimetry [i915]
+intel_dp_set_common_rates [i915]
+g4x_aux_data_reg [i915]
+g4x_aux_ctl_reg [i915]
+ilk_aux_data_reg [i915]
+ilk_aux_ctl_reg [i915]
+skl_aux_data_reg [i915]
+skl_aux_ctl_reg [i915]
+g4x_digital_port_connected [i915]
+gm45_digital_port_connected [i915]
+intel_dp_dsc_get_slice_count [i915]
+intel_pps_dump_state [i915]
+snb_cpu_edp_set_signal_levels [i915]
+ivb_cpu_edp_set_signal_levels [i915]
+intel_dp_get_dsc_sink_cap [i915]
+edp_panel_vdd_schedule_off [i915]
+skl_get_aux_send_ctl [i915]
+intel_dp_unset_edid [i915]
+intel_dp_get_modes [i915]
+intel_dp_connector_unregister [i915]
+intel_dp_connector_register [i915]
+intel_dp_modeset_retry_work_fn [i915]
+vlv_set_signal_levels [i915]
+chv_set_signal_levels [i915]
+chv_dp_post_pll_disable [i915]
+intel_dp_get_config [i915]
+assert_edp_pll [i915]
+intel_dp_set_drrs_state [i915]
+intel_edp_drrs_disable_locked [i915]
+intel_edp_drrs_downclock_work [i915]
+intel_dp_set_edid [i915]
+intel_dp_force [i915]
+edp_panel_vdd_off_sync [i915]
+vlv_detach_power_sequencer [i915]
+vlv_steal_power_sequencer [i915]
+vlv_power_sequencer_pipe [i915]
+intel_pps_get_registers [i915]
+edp_have_panel_power [i915]
+edp_have_panel_vdd [i915]
+intel_edp_panel_vdd_sanitize [i915]
+ilk_get_pp_control [i915]
+intel_pps_readout_hw_state [i915]
+intel_dp_init_panel_power_sequencer [i915]
+wait_panel_status [i915]
+intel_dp_init_panel_power_sequencer_registers [i915]
+edp_panel_vdd_off [i915]
+intel_dp_prepare [i915]
+vlv_dp_pre_pll_enable [i915]
+chv_dp_pre_pll_enable [i915]
+hsw_get_aux_clock_divider [i915]
+pps_unlock.isra.0 [i915]
+edp_panel_vdd_work [i915]
+_intel_edp_backlight_off [i915]
+intel_dp_encoder_suspend [i915]
+edp_notify_handler [i915]
+intel_dp_set_sink_rates [i915]
+intel_dp_get_dpcd [i915]
+intel_dp_connector_atomic_check [i915]
+intel_dp_pps_init [i915]
+intel_edp_panel_off.part.0 [i915]
+intel_dp_vsc_sdp_pack.constprop.0 [i915]
+intel_write_dp_sdp [i915]
+assert_dp_port.constprop.0 [i915]
+snprintf_int_array.constprop.0 [i915]
+intel_dp_print_rates [i915]
+intel_dp_dsc_get_output_bpp [i915]
+intel_dp_needs_link_retrain [i915]
+_intel_edp_backlight_on [i915]
+intel_edp_backlight_power [i915]
+wait_panel_power_cycle [i915]
+edp_panel_vdd_on [i915]
+edp_panel_on [i915]
+intel_dp_link_down [i915]
+vlv_post_disable_dp [i915]
+g4x_post_disable_dp [i915]
+chv_post_disable_dp [i915]
+g4x_pre_enable_dp [i915]
+intel_dp_is_edp [i915]
+intel_dp_max_lane_count [i915]
+intel_dp_link_required [i915]
+intel_dp_max_data_rate [i915]
+intel_dp_get_link_train_fallback_values [i915]
+intel_dp_mode_to_fec_clock [i915]
+intel_dp_pack_aux [i915]
+intel_dp_aux_xfer [i915]
+intel_dp_aux_transfer [i915]
+intel_power_sequencer_reset [i915]
+intel_dp_source_supports_hbr2 [i915]
+intel_dp_source_supports_hbr3 [i915]
+intel_dp_max_link_rate [i915]
+intel_dp_mode_valid [i915]
+intel_dp_rate_select [i915]
+intel_dp_compute_rate [i915]
+intel_dp_adjust_compliance_config [i915]
+intel_dp_min_bpp [i915]
+intel_dp_limited_color_range [i915]
+intel_dp_compute_config [i915]
+intel_dp_compute_psr_vsc_sdp [i915]
+intel_dp_set_link_params [i915]
+intel_edp_panel_vdd_on [i915]
+intel_edp_panel_on [i915]
+intel_edp_panel_off [i915]
+intel_edp_backlight_on [i915]
+vlv_enable_dp [i915]
+intel_edp_backlight_off [i915]
+intel_dp_sink_set_decompression_state [i915]
+intel_dp_sink_dpms [i915]
+intel_disable_dp.isra.0 [i915]
+g4x_disable_dp [i915]
+vlv_disable_dp [i915]
+intel_dp_port_enabled [i915]
+vlv_active_pipe [i915]
+intel_dp_encoder_reset [i915]
+intel_dp_get_hw_state [i915]
+intel_dp_configure_protocol_converter [i915]
+intel_dp_get_link_status [i915]
+intel_dp_set_signal_levels [i915]
+intel_dp_program_link_training_pattern [i915]
+intel_enable_dp.isra.0 [i915]
+g4x_enable_dp [i915]
+vlv_pre_enable_dp [i915]
+chv_pre_enable_dp [i915]
+intel_dp_set_idle_link_train [i915]
+intel_dp_get_colorimetry_status [i915]
+intel_dp_needs_vsc_sdp [i915]
+intel_write_dp_vsc_sdp [i915]
+intel_dp_set_infoframes [i915]
+intel_read_dp_sdp [i915]
+intel_dp_process_phy_request [i915]
+intel_dp_check_service_irq [i915]
+intel_dp_hpd_pulse [i915]
+intel_dp_retrain_link [i915]
+intel_dp_hotplug [i915]
+intel_digital_port_connected [i915]
+intel_dp_detect [i915]
+intel_dp_encoder_flush_work [i915]
+intel_dp_encoder_destroy [i915]
+intel_dp_is_port_edp [i915]
+intel_edp_drrs_enable [i915]
+intel_edp_drrs_disable [i915]
+intel_edp_drrs_update [i915]
+intel_edp_drrs_invalidate [i915]
+intel_edp_drrs_flush [i915]
+intel_dp_init_connector [i915]
+intel_dp_init [i915]
+intel_dp_mst_suspend [i915]
+intel_dp_mst_resume [i915]
+intel_dp_aux_backlight_dpcd_mode [i915]
+intel_dp_aux_get_backlight [i915]
+intel_dp_aux_set_backlight [i915]
+set_aux_backlight_enable [i915]
+intel_dp_aux_disable_backlight [i915]
+intel_dp_aux_enable_backlight [i915]
+intel_dp_aux_setup_backlight [i915]
+intel_dp_aux_init_backlight_funcs [i915]
+intel_dp_hdcp_toggle_signalling [i915]
+intel_dp_hdcp2_capable [i915]
+intel_dp_hdcp2_read_rx_status [i915]
+intel_dp_hdcp2_check_link [i915]
+intel_dp_hdcp_read_bcaps [i915]
+intel_dp_hdcp_capable [i915]
+intel_dp_hdcp_repeater_present [i915]
+intel_dp_hdcp_check_link [i915]
+intel_dp_hdcp_read_v_prime_part [i915]
+intel_dp_hdcp_read_ksv_fifo [i915]
+intel_dp_hdcp_read_ksv_ready [i915]
+intel_dp_hdcp_read_ri_prime [i915]
+intel_dp_hdcp_read_bstatus [i915]
+intel_dp_hdcp_read_bksv [i915]
+intel_dp_hdcp2_write_msg [i915]
+intel_dp_hdcp_write_an_aksv [i915]
+intel_dp_mst_hdcp_toggle_signalling [i915]
+intel_dp_hdcp2_read_msg [i915]
+intel_dp_mst_hdcp_check_link [i915]
+intel_dp_hdcp2_config_stream_type [i915]
+intel_dp_init_hdcp [i915]
+intel_dp_set_link_train [i915]
+intel_dp_get_adjust_train [i915]
+intel_dp_stop_link_train [i915]
+intel_dp_start_link_train [i915]
+intel_dp_mst_poll_hpd_irq [i915]
+intel_dp_mst_encoder_destroy [i915]
+intel_mst_pre_pll_enable_dp [i915]
+intel_dp_mst_enc_get_hw_state [i915]
+intel_mst_atomic_best_encoder [i915]
+intel_dp_mst_get_hw_state [i915]
+intel_dp_add_mst_connector [i915]
+intel_dp_mst_mode_valid_ctx [i915]
+intel_dp_mst_get_modes [i915]
+intel_dp_mst_connector_early_unregister [i915]
+intel_dp_mst_connector_late_register [i915]
+intel_dp_mst_enc_get_config [i915]
+wait_for_act_sent [i915]
+intel_mst_pre_enable_dp [i915]
+intel_mst_post_disable_dp [i915]
+intel_dp_mst_compute_config_late [i915]
+intel_dp_mst_atomic_check [i915]
+intel_dp_mst_detect [i915]
+intel_mst_enable_dp [i915]
+intel_mst_disable_dp [i915]
+intel_dp_mst_compute_config [i915]
+intel_dp_mst_encoder_active_links [i915]
+intel_dp_mst_encoder_init [i915]
+intel_dp_mst_encoder_cleanup [i915]
+intel_dp_mst_is_master_trans [i915]
+intel_dp_mst_is_slave_trans [i915]
+intel_dsi_bitrate [i915]
+intel_dsi_tlpx_ns [i915]
+intel_dsi_get_modes [i915]
+intel_dsi_mode_valid [i915]
+intel_dsi_host_init [i915]
+intel_dsi_get_panel_orientation [i915]
+dcs_setup_backlight [i915]
+dcs_get_backlight [i915]
+dcs_set_backlight [i915]
+dcs_disable_backlight [i915]
+dcs_enable_backlight [i915]
+intel_dsi_dcs_init_backlight_funcs [i915]
+mipi_exec_spi [i915]
+mipi_exec_pmic [i915]
+i2c_adapter_lookup [i915]
+mipi_exec_delay [i915]
+mipi_exec_send_packet [i915]
+mipi_exec_gpio [i915]
+mipi_exec_i2c [i915]
+intel_dsi_vbt_exec_sequence [i915]
+intel_dsi_msleep [i915]
+intel_dsi_log_params [i915]
+intel_dsi_vbt_init [i915]
+intel_dsi_vbt_gpio_init [i915]
+intel_dsi_vbt_gpio_cleanup [i915]
+intel_dvo_connector_get_hw_state [i915]
+intel_dvo_get_hw_state [i915]
+intel_dvo_get_config [i915]
+intel_disable_dvo [i915]
+intel_enable_dvo [i915]
+intel_dvo_mode_valid [i915]
+intel_dvo_pre_enable [i915]
+intel_dvo_get_modes [i915]
+intel_dvo_enc_destroy [i915]
+intel_dvo_compute_config [i915]
+intel_dvo_detect [i915]
+intel_dvo_init [i915]
+gmbus_func [i915]
+pch_gmbus_clock_gating [i915]
+bxt_gmbus_clock_gating [i915]
+pnv_gmbus_clock_gating [i915]
+get_reserved [i915]
+get_clock [i915]
+get_data [i915]
+set_clock [i915]
+set_data [i915]
+intel_gpio_post_xfer [i915]
+gmbus_lock_bus [i915]
+gmbus_unlock_bus [i915]
+gmbus_wait [i915]
+gmbus_xfer_read [i915]
+gmbus_xfer_write [i915]
+gmbus_wait_idle [i915]
+do_gmbus_xfer [i915]
+gmbus_xfer [i915]
+gmbus_trylock_bus [i915]
+get_gmbus_pin [i915]
+intel_gmbus_is_valid_pin [i915]
+intel_gmbus_reset [i915]
+intel_gpio_pre_xfer [i915]
+intel_gmbus_output_aksv [i915]
+intel_gmbus_setup [i915]
+intel_gmbus_get_adapter [i915]
+intel_gmbus_set_speed [i915]
+intel_gmbus_force_bit [i915]
+intel_gmbus_is_forced_bit [i915]
+intel_gmbus_teardown [i915]
+vlv_enable_hdmi [i915]
+g4x_infoframes_enabled [i915]
+ibx_infoframes_enabled [i915]
+cpt_infoframes_enabled [i915]
+vlv_infoframes_enabled [i915]
+hsw_infoframes_enabled [i915]
+hsw_dip_data_reg [i915]
+hsw_read_infoframe [i915]
+hdmi_port_clock_valid [i915]
+assert_hdmi_port_disabled [i915]
+intel_write_infoframe [i915]
+g4x_set_infoframes [i915]
+intel_hdmi_hdcp_read [i915]
+intel_hdmi_hdcp2_check_link [i915]
+intel_hdmi_hdcp2_capable [i915]
+intel_hdmi_hdcp_read_v_prime_part [i915]
+intel_hdmi_hdcp_read_ksv_fifo [i915]
+intel_hdmi_hdcp_read_ksv_ready [i915]
+intel_hdmi_hdcp_read_ri_prime [i915]
+intel_hdmi_hdcp_repeater_present [i915]
+intel_hdmi_hdcp_read_bstatus [i915]
+intel_hdmi_hdcp_read_bksv [i915]
+intel_hdmi_hdcp_check_link [i915]
+intel_hdmi_unset_edid [i915]
+intel_hdmi_hdcp_toggle_signalling [i915]
+intel_hdmi_get_modes [i915]
+intel_hdmi_connector_unregister [i915]
+intel_hdmi_connector_register [i915]
+vlv_hdmi_post_disable [i915]
+chv_hdmi_post_pll_disable [i915]
+chv_hdmi_post_disable [i915]
+intel_hdmi_get_hw_state [i915]
+intel_hdmi_hotplug [i915]
+intel_hdmi_hdcp2_read_msg [i915]
+intel_enable_hdmi_audio [i915]
+pch_disable_hdmi [i915]
+intel_hdmi_set_edid [i915]
+intel_hdmi_force [i915]
+intel_hdmi_detect [i915]
+g4x_enable_hdmi [i915]
+vlv_hdmi_pre_enable [i915]
+chv_hdmi_pre_enable [i915]
+ibx_enable_hdmi [i915]
+cpt_enable_hdmi [i915]
+hsw_infoframe_enable [i915]
+hsw_write_infoframe [i915]
+g4x_infoframe_enable [i915]
+g4x_infoframe_index [i915]
+ibx_read_infoframe [i915]
+cpt_read_infoframe [i915]
+g4x_read_infoframe [i915]
+vlv_read_infoframe [i915]
+cpt_write_infoframe [i915]
+ibx_write_infoframe [i915]
+g4x_write_infoframe [i915]
+vlv_write_infoframe [i915]
+intel_hdmi_set_gcp_infoframe.isra.0 [i915]
+cpt_set_infoframes [i915]
+ibx_set_infoframes [i915]
+hsw_set_infoframes [i915]
+vlv_set_infoframes [i915]
+intel_hdmi_hdcp_write [i915]
+intel_hdmi_hdcp2_write_msg [i915]
+intel_hdmi_hdcp_write_an_aksv [i915]
+intel_hdmi_mode_valid [i915]
+enc_to_intel_hdmi [i915]
+intel_hdmi_infoframe_enable [i915]
+intel_hdmi_infoframes_enabled [i915]
+intel_read_infoframe [i915]
+intel_hdmi_read_gcp_infoframe [i915]
+intel_hdmi_get_config [i915]
+intel_dp_dual_mode_set_tmds_output [i915]
+intel_hdmi_prepare [i915]
+intel_hdmi_pre_enable [i915]
+vlv_hdmi_pre_pll_enable [i915]
+chv_hdmi_pre_pll_enable [i915]
+intel_disable_hdmi.isra.0 [i915]
+g4x_disable_hdmi [i915]
+pch_post_disable_hdmi [i915]
+intel_hdmi_deep_color_possible [i915]
+intel_hdmi_limited_color_range [i915]
+intel_hdmi_compute_config [i915]
+intel_hdmi_handle_sink_scrambling [i915]
+intel_infoframe_init [i915]
+intel_hdmi_init_connector [i915]
+intel_hdmi_init [i915]
+lspcon_wake_native_aux_ch [i915]
+lspcon_mode_name.part.0 [i915]
+lspcon_change_mode.constprop.0 [i915]
+lspcon_wait_mode [i915]
+lspcon_ycbcr420_config [i915]
+lspcon_write_infoframe [i915]
+lspcon_read_infoframe [i915]
+lspcon_set_infoframes [i915]
+lspcon_infoframes_enabled [i915]
+lspcon_resume [i915]
+lspcon_wait_pcon_mode [i915]
+lspcon_init [i915]
+pch_disable_lvds [i915]
+intel_lvds_get_config [i915]
+intel_lvds_mode_valid [i915]
+intel_lvds_get_modes [i915]
+intel_enable_lvds [i915]
+intel_no_lvds_dmi_callback [i915]
+intel_dual_link_lvds_callback [i915]
+intel_lvds_get_hw_state [i915]
+intel_lvds_compute_config [i915]
+intel_pre_enable_lvds [i915]
+intel_disable_lvds.isra.0 [i915]
+gmch_disable_lvds [i915]
+pch_post_disable_lvds [i915]
+intel_lvds_port_enabled [i915]
+intel_get_lvds_encoder [i915]
+intel_is_dual_link_lvds [i915]
+intel_lvds_init [i915]
+bxt_hz_to_pwm [i915]
+scale [i915]
+centre_horizontally [i915]
+centre_vertically [i915]
+lpt_get_backlight [i915]
+pch_get_backlight [i915]
+bxt_get_backlight [i915]
+lpt_set_backlight [i915]
+pch_set_backlight [i915]
+vlv_set_backlight [i915]
+bxt_set_backlight [i915]
+i9xx_hz_to_pwm [i915]
+i965_hz_to_pwm [i915]
+vlv_hz_to_pwm [i915]
+pch_hz_to_pwm [i915]
+cnp_hz_to_pwm [i915]
+__intel_panel_enable_backlight [i915]
+intel_panel_compute_brightness [i915]
+intel_panel_actually_set_backlight [i915]
+i9xx_disable_backlight [i915]
+i965_disable_backlight [i915]
+vlv_disable_backlight [i915]
+pch_disable_backlight [i915]
+lpt_disable_backlight [i915]
+cnp_disable_backlight [i915]
+bxt_disable_backlight [i915]
+get_backlight_min_vbt [i915]
+_vlv_get_backlight [i915]
+vlv_get_backlight [i915]
+pwm_set_backlight [i915]
+pwm_disable_backlight [i915]
+pwm_enable_backlight [i915]
+spt_hz_to_pwm [i915]
+lpt_hz_to_pwm [i915]
+i9xx_enable_backlight [i915]
+i965_enable_backlight [i915]
+vlv_enable_backlight [i915]
+pch_enable_backlight [i915]
+lpt_enable_backlight [i915]
+cnp_enable_backlight [i915]
+bxt_enable_backlight [i915]
+intel_backlight_device_get_brightness [i915]
+intel_backlight_device_update_status [i915]
+i9xx_get_backlight [i915]
+i9xx_set_backlight [i915]
+get_vbt_pwm_freq [i915]
+get_backlight_max_vbt [i915]
+pch_setup_backlight [i915]
+cnp_setup_backlight [i915]
+bxt_setup_backlight [i915]
+vlv_setup_backlight [i915]
+lpt_setup_backlight [i915]
+i9xx_setup_backlight [i915]
+i965_setup_backlight [i915]
+pwm_setup_backlight [i915]
+pwm_get_backlight [i915]
+intel_fixed_panel_mode [i915]
+intel_panel_edid_downclock_mode [i915]
+intel_panel_edid_fixed_mode [i915]
+intel_panel_vbt_fixed_mode [i915]
+intel_pch_panel_fitting [i915]
+intel_gmch_panel_fitting [i915]
+intel_panel_set_backlight_acpi [i915]
+intel_panel_disable_backlight [i915]
+intel_panel_enable_backlight [i915]
+intel_backlight_device_register [i915]
+intel_backlight_device_unregister [i915]
+intel_panel_update_backlight [i915]
+intel_panel_setup_backlight [i915]
+intel_panel_detect [i915]
+intel_panel_init [i915]
+intel_panel_fini [i915]
+pch_disable_sdvo [i915]
+intel_sdvo_write_sdvox [i915]
+intel_sdvo_ddc_proxy_func [i915]
+proxy_lock_bus [i915]
+proxy_trylock_bus [i915]
+proxy_unlock_bus [i915]
+intel_sdvo_read_byte [i915]
+intel_sdvo_read_response [i915]
+intel_sdvo_get_dtd_from_mode [i915]
+intel_sdvo_get_mode_from_dtd [i915]
+intel_sdvo_enc_destroy [i915]
+intel_sdvo_connector_init [i915]
+intel_sdvo_atomic_check [i915]
+intel_sdvo_get_lvds_modes [i915]
+intel_sdvo_get_analog_edid [i915]
+intel_sdvo_connector_atomic_get_property [i915]
+intel_sdvo_connector_duplicate_state [i915]
+intel_sdvo_connector_unregister [i915]
+intel_sdvo_connector_register [i915]
+intel_sdvo_connector_atomic_set_property [i915]
+intel_sdvo_mode_valid [i915]
+intel_sdvo_connector_alloc [i915]
+intel_sdvo_analog_init [i915]
+__intel_sdvo_write_cmd [i915]
+intel_sdvo_ddc_proxy_xfer [i915]
+intel_sdvo_get_value [i915]
+intel_sdvo_get_hbuf_size [i915]
+intel_sdvo_connector_get_hw_state [i915]
+intel_sdvo_create_enhance_property [i915]
+intel_sdvo_lvds_init [i915]
+intel_sdvo_detect [i915]
+intel_sdvo_set_value [i915]
+intel_sdvo_set_timing [i915]
+intel_sdvo_write_infoframe [i915]
+intel_sdvo_set_output_timings_from_mode [i915]
+intel_sdvo_get_preferred_input_mode [i915]
+intel_sdvo_compute_config [i915]
+intel_sdvo_tv_init [i915]
+intel_enable_sdvo [i915]
+intel_sdvo_pre_enable [i915]
+intel_disable_sdvo [i915]
+pch_post_disable_sdvo [i915]
+intel_sdvo_hotplug [i915]
+intel_sdvo_get_modes [i915]
+intel_sdvo_dvi_init [i915]
+intel_sdvo_get_config [i915]
+intel_sdvo_port_enabled [i915]
+intel_sdvo_get_hw_state [i915]
+intel_sdvo_init [i915]
+intel_tv_get_hw_state [i915]
+intel_disable_tv [i915]
+intel_tv_atomic_check [i915]
+intel_tv_mode_valid [i915]
+intel_tv_scale_mode_horiz [i915]
+intel_tv_scale_mode_vert [i915]
+intel_tv_mode_to_mode [i915]
+intel_tv_get_modes [i915]
+intel_tv_get_config [i915]
+intel_tv_compute_config [i915]
+intel_tv_connector_duplicate_state [i915]
+intel_tv_pre_enable [i915]
+intel_enable_tv [i915]
+intel_tv_detect [i915]
+intel_tv_init [i915]
+is_pipe_dsc [i915]
+intel_dsc_dsi_pps_write [i915]
+intel_dsc_dp_pps_write [i915]
+intel_dsc_source_support [i915]
+intel_dsc_compute_params [i915]
+intel_dsc_power_domain [i915]
+intel_dsc_get_config [i915]
+intel_dsc_enable [i915]
+intel_dsc_disable [i915]
+intel_dsi_host_attach [i915]
+txbyteclkhs [i915]
+pixels_from_txbyteclkhs [i915]
+intel_dsi_encoder_destroy [i915]
+intel_dsi_host_transfer [i915]
+intel_dsi_prepare [i915]
+intel_dsi_compute_config [i915]
+intel_dsi_get_hw_state [i915]
+bxt_dsi_enable [i915]
+dpi_send_cmd.constprop.0 [i915]
+intel_dsi_pre_enable [i915]
+intel_dsi_disable [i915]
+intel_dsi_host_detach [i915]
+pixel_format_from_register_bits [i915]
+intel_dsi_get_config [i915]
+vlv_dsi_wait_for_fifo_empty [i915]
+intel_dsi_post_disable [i915]
+vlv_dsi_init [i915]
+vlv_dsi_pll_compute [i915]
+vlv_dsi_pll_enable [i915]
+vlv_dsi_pll_disable [i915]
+bxt_dsi_pll_is_enabled [i915]
+bxt_dsi_pll_disable [i915]
+vlv_dsi_get_pclk [i915]
+bxt_dsi_get_pclk [i915]
+vlv_dsi_reset_clocks [i915]
+bxt_dsi_pll_compute [i915]
+bxt_dsi_pll_enable [i915]
+bxt_dsi_reset_clocks [i915]
+gen8_is_valid_flex_addr [i915]
+gen7_is_valid_b_counter_addr [i915]
+gen8_is_valid_mux_addr [i915]
+gen10_is_valid_mux_addr [i915]
+hsw_is_valid_mux_addr [i915]
+chv_is_valid_mux_addr [i915]
+gen12_is_valid_b_counter_addr [i915]
+gen12_is_valid_mux_addr [i915]
+i915_oa_poll_wait [i915]
+gen12_oa_hw_tail_read [i915]
+gen8_oa_hw_tail_read [i915]
+gen7_oa_hw_tail_read [i915]
+i915_oa_read [i915]
+save_restore_register [i915]
+write_cs_mi_lri [i915]
+gen8_oa_enable [i915]
+gen12_oa_enable [i915]
+oa_buffer_check_unlocked [i915]
+oa_poll_check_timer_cb [i915]
+show_dynamic_id [i915]
+gen12_oa_disable [i915]
+append_oa_sample [i915]
+gen7_oa_enable [i915]
+i915_perf_poll [i915]
+i915_perf_read [i915]
+i915_oa_stream_disable [i915]
+append_oa_status.isra.0 [i915]
+gen8_oa_read [i915]
+gen7_oa_read [i915]
+gen8_oa_disable [i915]
+i915_perf_enable_locked [i915]
+i915_perf_disable_locked [i915]
+i915_oa_wait_unlocked [i915]
+i915_oa_stream_enable [i915]
+alloc_oa_regs.part.0 [i915]
+gen7_oa_disable [i915]
+gen8_modify_context [i915]
+gen8_modify_self [i915]
+gen12_configure_oar_context [i915]
+i915_perf_release [i915]
+hsw_disable_metric_set [i915]
+oa_configure_all_contexts [i915]
+gen12_disable_metric_set [i915]
+lrc_configure_all_contexts [i915]
+gen10_disable_metric_set [i915]
+gen8_disable_metric_set [i915]
+emit_oa_config [i915]
+hsw_enable_metric_set [i915]
+gen8_enable_metric_set [i915]
+gen12_enable_metric_set [i915]
+i915_oa_config_release [i915]
+destroy_config [i915]
+free_oa_configs [i915]
+i915_oa_stream_destroy [i915]
+i915_perf_get_oa_config [i915]
+i915_perf_ioctl [i915]
+i915_perf_open_ioctl_locked [i915]
+i915_oa_init_reg_state [i915]
+i915_perf_open_ioctl [i915]
+i915_perf_register [i915]
+i915_perf_unregister [i915]
+i915_perf_add_config_ioctl [i915]
+i915_perf_remove_config_ioctl [i915]
+i915_perf_init [i915]
+i915_perf_sysctl_register [i915]
+i915_perf_sysctl_unregister [i915]
+i915_perf_fini [i915]
+i915_perf_ioctl_version [i915]
+err_free_sgl [i915]
+i915_vma_coredump_free [i915]
+capture_vma [i915]
+pool_free [i915]
+compress_fini [i915]
+gt_capture_finish [i915]
+pool_alloc.constprop.0 [i915]
+compress_next_page [i915]
+compress_page [i915]
+pool_refill.constprop.0 [i915]
+i915_error_state_store.part.0 [i915]
+__i915_error_grow.part.0 [i915]
+i915_error_vprintf [i915]
+__i915_printfn_error [i915]
+i915_error_puts.part.0 [i915]
+i915_vma_coredump_create [i915]
+i915_error_printf [i915]
+print_error_vma [i915]
+__err_print_to_sgl [i915]
+i915_gpu_coredump_copy_to_buffer [i915]
+__i915_gpu_coredump_free [i915]
+intel_engine_coredump_alloc [i915]
+intel_engine_coredump_add_request [i915]
+intel_engine_coredump_add_vma [i915]
+i915_gpu_coredump_alloc [i915]
+intel_gt_coredump_alloc [i915]
+i915_vma_capture_prepare [i915]
+i915_vma_capture_finish [i915]
+i915_gpu_coredump [i915]
+i915_error_state_store [i915]
+i915_capture_error_state [i915]
+i915_first_error_state [i915]
+i915_reset_error_state [i915]
+i915_disable_error_state [i915]
+vgt_deballoon_space [i915]
+vgt_balloon_space [i915]
+intel_vgpu_detect [i915]
+intel_vgpu_register [i915]
+intel_vgpu_active [i915]
+intel_vgpu_has_full_ppgtt [i915]
+intel_vgpu_has_hwsp_emulation [i915]
+intel_vgpu_has_huge_gtt [i915]
+intel_vgt_deballoon [i915]
+intel_vgt_balloon [i915]
+intel_gvt_sanitize_options [i915]
+intel_gvt_init [i915]
+intel_gvt_driver_remove [i915]
+device_api_show [i915]
+intel_get_gvt_attrs [i915]
+intel_gvt_find_vgpu_type [i915]
+description_show [i915]
+available_instances_show [i915]
+intel_gvt_unregister_hypervisor [i915]
+gvt_service_thread [i915]
+intel_gvt_register_hypervisor [i915]
+intel_gvt_clean_device [i915]
+intel_gvt_init_device [i915]
+free_vgpu_gm [i915]
+alloc_gm [i915]
+intel_vgpu_write_fence [i915]
+intel_vgpu_free_resource [i915]
+intel_vgpu_reset_resource [i915]
+intel_vgpu_alloc_resource [i915]
+fdi_rx_iir_mmio_write [i915]
+dp_tp_status_mmio_write [i915]
+skl_lcpll_write [i915]
+bxt_de_pll_enable_write [i915]
+bxt_port_pll_enable_write [i915]
+bxt_phy_ctl_family_write [i915]
+bxt_pcs_dw12_grp_write [i915]
+bxt_gt_disp_pwron_write [i915]
+edp_psr_imr_iir_write [i915]
+bxt_ppat_low_write [i915]
+read_vreg [i915]
+intel_vgpu_default_mmio_read [i915]
+dpy_reg_mmio_read [i915]
+sbi_data_mmio_read [i915]
+guc_status_read [i915]
+dpll_status_read [i915]
+bxt_port_tx_dw3_read [i915]
+pvinfo_mmio_read [i915]
+write_vreg [i915]
+intel_vgpu_default_mmio_write [i915]
+pch_pp_control_mmio_write [i915]
+transconf_mmio_write [i915]
+power_well_ctl_mmio_write [i915]
+gen9_dbuf_ctl_mmio_write [i915]
+lcpll_ctl_mmio_write [i915]
+ddi_buf_ctl_mmio_write [i915]
+pch_adpa_mmio_write [i915]
+south_chicken2_mmio_write [i915]
+mbctl_write [i915]
+fpga_dbg_mmio_write [i915]
+skl_power_well_ctl_write [i915]
+sbi_ctl_mmio_write [i915]
+dp_tp_ctl_mmio_write [i915]
+ring_reset_ctl_write [i915]
+force_nonpriv_write [i915]
+vga_control_mmio_write [i915]
+gamw_echo_dev_rw_ia_write [i915]
+mailbox_write [i915]
+mmio_read_from_hw [i915]
+gdrst_mmio_write [i915]
+gen9_trtte_write [i915]
+trigger_aux_channel_interrupt [i915]
+dp_aux_ch_ctl_trans_done [i915]
+gmbus_mmio_write [i915]
+gmbus_mmio_read [i915]
+pipeconf_mmio_write [i915]
+hws_pga_write [i915]
+elsp_mmio_write [i915]
+dma_ctrl_write [i915]
+pf_write [i915]
+dp_aux_ch_ctl_mmio_write [i915]
+pri_surf_mmio_write [i915]
+mul_force_wake_write [i915]
+gen9_trtt_chicken_write [i915]
+gvt_reg_tlb_control_handler [i915]
+spr_surf_mmio_write [i915]
+reg50080_mmio_write [i915]
+update_fdi_rx_iir_status [i915]
+intel_gvt_get_device_type [i915]
+new_mmio_info.constprop.0 [i915]
+init_skl_mmio_info [i915]
+init_bdw_mmio_info [i915]
+intel_gvt_match_device [i915]
+intel_gvt_render_mmio_to_engine [i915]
+enter_failsafe_mode [i915]
+pvinfo_mmio_write [i915]
+sanitize_fence_mmio_access [i915]
+fence_mmio_write [i915]
+fence_mmio_read [i915]
+ring_mode_mmio_write [i915]
+csfe_chicken1_mmio_write [i915]
+intel_gvt_clean_mmio_info [i915]
+intel_gvt_setup_mmio_info [i915]
+intel_gvt_for_each_tracked_mmio [i915]
+intel_vgpu_mask_mmio_write [i915]
+intel_gvt_in_force_nonpriv_whitelist [i915]
+intel_vgpu_mmio_reg_rw [i915]
+intel_gvt_update_vgpu_types [i915]
+populate_pvinfo_page [i915]
+intel_gvt_init_vgpu_types [i915]
+intel_gvt_clean_vgpu_types [i915]
+intel_gvt_activate_vgpu [i915]
+intel_gvt_deactivate_vgpu [i915]
+intel_gvt_release_vgpu [i915]
+intel_gvt_destroy_vgpu [i915]
+intel_gvt_create_idle_vgpu [i915]
+intel_gvt_destroy_idle_vgpu [i915]
+intel_gvt_create_vgpu [i915]
+intel_gvt_reset_vgpu_locked [i915]
+intel_gvt_reset_vgpu [i915]
+__traceiter_spt_alloc [i915]
+__traceiter_spt_free [i915]
+__traceiter_gma_index [i915]
+__traceiter_gma_translate [i915]
+__traceiter_spt_refcount [i915]
+__traceiter_spt_change [i915]
+__traceiter_spt_guest_change [i915]
+__traceiter_oos_change [i915]
+__traceiter_oos_sync [i915]
+__traceiter_gvt_command [i915]
+__traceiter_write_ir [i915]
+__traceiter_propagate_event [i915]
+__traceiter_inject_msi [i915]
+__traceiter_render_mmio [i915]
+mmio_snapshot_handler [i915]
+gvt_firmware_read [i915]
+intel_gvt_free_firmware [i915]
+intel_gvt_load_firmware [i915]
+gen8_init_irq [i915]
+update_upstream_irq [i915]
+gen8_check_pending_irq [i915]
+handle_default_event_virt [i915]
+vblank_timer_fn [i915]
+intel_vgpu_reg_imr_handler [i915]
+intel_vgpu_reg_master_irq_handler [i915]
+intel_vgpu_reg_ier_handler [i915]
+intel_vgpu_reg_iir_handler [i915]
+intel_vgpu_trigger_virtual_event [i915]
+intel_gvt_clean_irq [i915]
+intel_gvt_init_irq [i915]
+gen8_gtt_get_pfn [i915]
+gen8_gtt_set_pfn [i915]
+gen8_gtt_test_pse [i915]
+gen8_gtt_test_present [i915]
+gtt_entry_clear_present [i915]
+gtt_entry_set_present [i915]
+gen8_gtt_test_64k_splited [i915]
+gen8_gtt_set_64k_splited [i915]
+gen8_gtt_clear_64k_splited [i915]
+update_entry_type_for_real [i915]
+_ppgtt_get_root_entry [i915]
+ggtt_invalidate_pte [i915]
+gen8_gtt_clear_ips [i915]
+gen8_gtt_test_ips [i915]
+release_scratch_page_tree [i915]
+ggtt_invalidate [i915]
+clean_spt_oos [i915]
+gen8_gtt_clear_pse [i915]
+gen8_gma_to_l4_pdp_index [i915]
+detach_oos_page [i915]
+ppgtt_free_spt [i915]
+gma_to_ggtt_pte_index [i915]
+gen8_gma_to_pml4_index [i915]
+gen8_gma_to_pde_index [i915]
+gen8_gma_to_pte_index [i915]
+gen8_gma_to_l3_pdp_index [i915]
+ppgtt_invalidate_spt [i915]
+ppgtt_invalidate_spt_by_shadow_entry [i915]
+invalidate_ppgtt_mm [i915]
+ppgtt_alloc_spt [i915]
+ppgtt_handle_guest_entry_removal [i915]
+ppgtt_populate_shadow_entry [i915]
+ppgtt_set_guest_page_sync [i915]
+ppgtt_populate_spt [i915]
+ppgtt_populate_spt_by_guest_entry [i915]
+shadow_ppgtt_mm [i915]
+ppgtt_handle_guest_write_page_table [i915]
+ppgtt_write_protection_handler [i915]
+intel_gvt_ggtt_validate_range [i915]
+intel_gvt_ggtt_gmadr_g2h [i915]
+intel_gvt_ggtt_gmadr_h2g [i915]
+intel_gvt_ggtt_index_g2h [i915]
+intel_gvt_ggtt_h2g_index [i915]
+intel_vgpu_sync_oos_pages [i915]
+intel_vgpu_flush_post_shadow [i915]
+intel_vgpu_create_ppgtt_mm [i915]
+_intel_vgpu_mm_release [i915]
+intel_vgpu_unpin_mm [i915]
+intel_vgpu_pin_mm [i915]
+intel_vgpu_gma_to_gpa [i915]
+intel_vgpu_emulate_ggtt_mmio_read [i915]
+intel_vgpu_emulate_ggtt_mmio_write [i915]
+intel_vgpu_destroy_all_ppgtt_mm [i915]
+intel_vgpu_clean_gtt [i915]
+intel_vgpu_find_ppgtt_mm [i915]
+intel_vgpu_get_ppgtt_mm [i915]
+intel_vgpu_put_ppgtt_mm [i915]
+intel_gvt_init_gtt [i915]
+intel_gvt_clean_gtt [i915]
+intel_vgpu_invalidate_ppgtt [i915]
+intel_vgpu_reset_ggtt [i915]
+intel_vgpu_init_gtt [i915]
+intel_vgpu_reset_gtt [i915]
+vgpu_pci_cfg_mem_write [i915]
+map_aperture [i915]
+trap_gttmmio [i915]
+intel_vgpu_emulate_cfg_read [i915]
+intel_vgpu_emulate_cfg_write [i915]
+intel_vgpu_init_cfg_space [i915]
+intel_vgpu_reset_cfg_space [i915]
+map_vgpu_opregion [i915]
+intel_vgpu_init_opregion [i915]
+intel_vgpu_opregion_base_write_handler [i915]
+intel_vgpu_clean_opregion [i915]
+intel_vgpu_emulate_opregion_request [i915]
+failsafe_emulate_mmio_rw.part.0 [i915]
+intel_vgpu_gpa_to_mmio_offset [i915]
+intel_vgpu_emulate_mmio_read [i915]
+intel_vgpu_emulate_mmio_write [i915]
+intel_vgpu_reset_mmio [i915]
+intel_vgpu_init_mmio [i915]
+intel_vgpu_clean_mmio [i915]
+emulate_monitor_status_change [i915]
+setup_virtual_dp_monitor [i915]
+pipe_is_enabled [i915]
+intel_gvt_check_vblank_emulation [i915]
+intel_gvt_emulate_vblank [i915]
+intel_vgpu_emulate_hotplug [i915]
+intel_vgpu_clean_display [i915]
+intel_vgpu_init_display [i915]
+intel_vgpu_reset_display [i915]
+edid_get_byte [i915]
+intel_vgpu_init_i2c_edid [i915]
+intel_gvt_i2c_handle_aux_ch_write [i915]
+intel_gvt_i2c_handle_gmbus_read [i915]
+intel_gvt_i2c_handle_gmbus_write [i915]
+switch_virtual_execlist_slot [i915]
+emulate_execlist_status [i915]
+emulate_csb_update [i915]
+complete_execlist_workload [i915]
+reset_execlist [i915]
+init_execlist [i915]
+clean_execlist [i915]
+prepare_execlist_workload [i915]
+intel_vgpu_submit_execlist [i915]
+sr_oa_regs [i915]
+save_ring_hw_state [i915]
+shadow_context_status_change [i915]
+intel_vgpu_shadow_mm_unpin [i915]
+i915_context_ppgtt_root_restore [i915]
+release_shadow_batch_buffer [i915]
+release_shadow_wa_ctx [i915]
+intel_gvt_scan_and_shadow_workload [i915]
+intel_gvt_wait_vgpu_idle [i915]
+intel_gvt_clean_workload_scheduler [i915]
+intel_gvt_init_workload_scheduler [i915]
+intel_vgpu_setup_submission [i915]
+intel_vgpu_select_submission_ops [i915]
+intel_vgpu_clean_submission [i915]
+intel_vgpu_destroy_workload [i915]
+intel_vgpu_clean_workloads [i915]
+intel_vgpu_reset_submission [i915]
+workload_thread [i915]
+intel_vgpu_create_workload [i915]
+intel_vgpu_queue_workload [i915]
+tbs_sched_stop_schedule [i915]
+tbs_timer_fn [i915]
+tbs_sched_start_schedule [i915]
+tbs_sched_clean [i915]
+tbs_sched_clean_vgpu [i915]
+vgpu_update_timeslice.part.0 [i915]
+tbs_sched_init_vgpu [i915]
+tbs_sched_init [i915]
+intel_gvt_schedule [i915]
+intel_gvt_init_sched_policy [i915]
+intel_gvt_clean_sched_policy [i915]
+intel_vgpu_init_sched_policy [i915]
+intel_vgpu_clean_sched_policy [i915]
+intel_vgpu_start_schedule [i915]
+intel_gvt_kick_schedule [i915]
+intel_vgpu_stop_schedule [i915]
+intel_vgpu_restore_inhibit_context [i915]
+is_inhibit_context [i915]
+intel_gvt_switch_mmio [i915]
+intel_gvt_init_engine_mmio_context [i915]
+cmd_handler_mi_wait_for_event [i915]
+copy_gma_to_hva [i915]
+clean_cmd_table [i915]
+gen8_decode_mi_display_flip [i915]
+parser_exec_state_dump [i915]
+get_gma_bb_from_cmd.constprop.0 [i915]
+cmd_reg_handler [i915]
+cmd_handler_pipe_control [i915]
+cmd_handler_mi_update_gtt [i915]
+cmd_handler_mi_clflush [i915]
+cmd_handler_mi_report_perf_count [i915]
+cmd_handler_mi_conditional_batch_buffer_end [i915]
+cmd_handler_mi_op_2e [i915]
+cmd_handler_mi_semaphore_wait [i915]
+cmd_handler_mi_store_data_index [i915]
+cmd_handler_mi_user_interrupt [i915]
+cmd_handler_mi_batch_buffer_end [i915]
+cmd_handler_lri [i915]
+cmd_handler_lrr [i915]
+cmd_handler_mi_display_flip [i915]
+cmd_handler_srm [i915]
+cmd_handler_lrm [i915]
+cmd_handler_mi_op_2f [i915]
+cmd_handler_mi_store_data_imm [i915]
+command_scan [i915]
+scan_workload [i915]
+scan_wa_ctx [i915]
+cmd_handler_mi_flush_dw [i915]
+cmd_handler_mi_batch_buffer_start [i915]
+intel_gvt_scan_and_shadow_ringbuffer [i915]
+intel_gvt_scan_and_shadow_wa_ctx [i915]
+intel_gvt_clean_cmd_parser [i915]
+intel_gvt_init_cmd_parser [i915]
+vgpu_scan_nonprivbb_fops_open [i915]
+mmio_offset_compare [i915]
+vgpu_scan_nonprivbb_get [i915]
+vgpu_scan_nonprivbb_set [i915]
+vgpu_mmio_diff_open [i915]
+vgpu_mmio_diff_show [i915]
+intel_gvt_debugfs_add_vgpu [i915]
+intel_gvt_debugfs_remove_vgpu [i915]
+intel_gvt_debugfs_init [i915]
+intel_gvt_debugfs_clean [i915]
+intel_vgpu_decode_primary_plane [i915]
+intel_vgpu_decode_cursor_plane [i915]
+intel_vgpu_decode_sprite_plane [i915]
+vgpu_gem_put_pages [i915]
+vgpu_gem_get_pages [i915]
+dmabuf_gem_object_free [i915]
+vgpu_get_plane_info.isra.0 [i915]
+vgpu_gem_release [i915]
+intel_vgpu_query_plane [i915]
+intel_vgpu_get_dmabuf [i915]
+intel_vgpu_dmabuf_cleanup [i915]
+intel_vgpu_find_page_track [i915]
+intel_vgpu_register_page_track [i915]
+intel_vgpu_unregister_page_track [i915]
+intel_vgpu_enable_page_track [i915]
+intel_vgpu_disable_page_track [i915]
+intel_vgpu_page_track_handler [i915]
+vli_is_zero [ecc]
+vli_num_bits [ecc]
+vli_from_be64 [ecc]
+vli_from_le64 [ecc]
+vli_cmp [ecc]
+vli_sub [ecc]
+vli_mod_add [ecc]
+vli_mult [ecc]
+vli_umult [ecc]
+vli_mmod_special [ecc]
+vli_mmod_special2 [ecc]
+vli_mmod_barrett [ecc]
+ecc_point_is_zero [ecc]
+__ecc_is_key_valid [ecc]
+ecc_is_key_valid [ecc]
+vli_mmod_slow [ecc]
+vli_mod_mult_slow [ecc]
+ecc_alloc_digits_space [ecc]
+ecc_alloc_point [ecc]
+vli_mod_sub [ecc]
+vli_mod_inv.part.0 [ecc]
+vli_mod_inv [ecc]
+vli_mmod_fast.part.0 [ecc]
+ecc_free_point.part.0 [ecc]
+vli_lshift.constprop.0 [ecc]
+vli_mmod_fast [ecc]
+vli_mod_square_fast [ecc]
+vli_mod_mult_fast [ecc]
+xycz_add [ecc]
+apply_z [ecc]
+xycz_add_c [ecc]
+ecc_point_double_jacobian.part.0 [ecc]
+ecc_point_double_jacobian [ecc]
+ecc_is_pubkey_valid_partial [ecc]
+ecc_point_mult_shamir [ecc]
+ecc_point_mult [ecc]
+ecc_is_pubkey_valid_full [ecc]
+ecc_make_pub_key [ecc]
+ecc_gen_privkey [ecc]
+crypto_ecdh_shared_secret [ecc]
+host_info [usb_storage]
+write_info [usb_storage]
+usb_stor_host_template_init [usb_storage]
+max_sectors_store [usb_storage]
+max_sectors_show [usb_storage]
+show_info [usb_storage]
+target_alloc [usb_storage]
+slave_configure [usb_storage]
+slave_alloc [usb_storage]
+bus_reset [usb_storage]
+device_reset [usb_storage]
+queuecommand [usb_storage]
+command_abort [usb_storage]
+usb_stor_report_device_reset [usb_storage]
+usb_stor_report_bus_reset [usb_storage]
+usb_stor_transparent_scsi_command [usb_storage]
+usb_stor_access_xfer_buf [usb_storage]
+usb_stor_set_xfer_buf [usb_storage]
+usb_stor_pad12_command [usb_storage]
+usb_stor_ufi_command [usb_storage]
+usb_stor_blocking_completion [usb_storage]
+usb_stor_msg_common [usb_storage]
+usb_stor_control_msg [usb_storage]
+usb_stor_clear_halt [usb_storage]
+last_sector_hacks [usb_storage]
+interpret_urb_result [usb_storage]
+usb_stor_ctrl_transfer [usb_storage]
+usb_stor_bulk_transfer_buf [usb_storage]
+usb_stor_bulk_transfer_sglist [usb_storage]
+usb_stor_bulk_srb [usb_storage]
+usb_stor_Bulk_transport [usb_storage]
+usb_stor_bulk_transfer_sg [usb_storage]
+usb_stor_reset_common.constprop.0 [usb_storage]
+usb_stor_Bulk_reset [usb_storage]
+usb_stor_CB_reset [usb_storage]
+usb_stor_CB_transport [usb_storage]
+usb_stor_stop_transport [usb_storage]
+usb_stor_Bulk_max_lun [usb_storage]
+usb_stor_port_reset [usb_storage]
+usb_stor_invoke_transport [usb_storage]
+usb_stor_pre_reset [usb_storage]
+usb_stor_reset_resume [usb_storage]
+usb_stor_post_reset [usb_storage]
+usb_stor_suspend [usb_storage]
+usb_stor_resume [usb_storage]
+usb_stor_adjust_quirks [usb_storage]
+usb_stor_scan_dwork [usb_storage]
+release_everything [usb_storage]
+usb_stor_probe2 [usb_storage]
+fill_inquiry_response.part.0 [usb_storage]
+fill_inquiry_response [usb_storage]
+storage_probe [usb_storage]
+usb_stor_control_thread [usb_storage]
+usb_stor_disconnect [usb_storage]
+usb_stor_euscsi_init [usb_storage]
+usb_stor_ucr61s2b_init [usb_storage]
+usb_stor_huawei_e220_init [usb_storage]
+debug_swoc [usb_storage]
+sierra_get_swoc_info [usb_storage]
+truinst_show [usb_storage]
+sierra_set_ms_mode.constprop.0 [usb_storage]
+sierra_ms_init [usb_storage]
+option_ms_init [usb_storage]
+usb_usual_ignore_device [usb_storage]
+usb_stor_probe1 [usb_storage]
+hid_lookup_collection [hid]
+hid_concatenate_last_usage_page [hid]
+fetch_item [hid]
+hid_parse_report [hid]
+hid_validate_values [hid]
+hid_setup_resolution_multiplier [hid]
+hid_scan_main [hid]
+hid_close_report [hid]
+hid_device_release [hid]
+hid_get_report [hid]
+read_report_descriptor [hid]
+implement [hid]
+hid_process_event [hid]
+show_country [hid]
+hid_disconnect [hid]
+hid_hw_stop [hid]
+hid_hw_open [hid]
+hid_hw_close [hid]
+hid_compare_device_paths [hid]
+hid_uevent [hid]
+modalias_show [hid]
+hid_add_device [hid]
+hid_destroy_device [hid]
+__hid_bus_driver_added [hid]
+__bus_removed_driver [hid]
+hid_field_extract [hid]
+hid_device_remove [hid]
+hid_check_keys_pressed [hid]
+hid_add_usage [hid]
+hid_parser_local [hid]
+hid_parser_reserved [hid]
+snto32 [hid]
+hid_snto32 [hid]
+hid_parser_global [hid]
+s32ton [hid]
+hid_output_report [hid]
+hid_set_field [hid]
+__hid_register_driver [hid]
+__hid_bus_reprobe_drivers [hid]
+hid_allocate_device [hid]
+hid_register_report [hid]
+hid_unregister_driver [hid]
+new_id_store [hid]
+hid_alloc_report_buf [hid]
+hid_add_field [hid]
+hid_parser_main [hid]
+hid_report_raw_event [hid]
+hid_input_report [hid]
+__hid_request [hid]
+hid_open_report [hid]
+hid_match_one_id [hid]
+hid_connect [hid]
+hid_hw_start [hid]
+hid_match_device [hid]
+hid_device_probe [hid]
+hid_bus_match [hid]
+hid_match_id [hid]
+match_index [hid]
+match_scancode [hid]
+match_keycode [hid]
+hidinput_find_key [hid]
+hidinput_find_field [hid]
+hidinput_get_led_field [hid]
+hidinput_count_leds [hid]
+hidinput_calc_abs_res [hid]
+hidinput_scale_battery_capacity [hid]
+hidinput_report_event [hid]
+hidinput_led_worker [hid]
+hidinput_query_battery_capacity [hid]
+hidinput_close [hid]
+hidinput_open [hid]
+hidinput_get_battery_property [hid]
+hidinput_disconnect [hid]
+hidinput_locate_usage [hid]
+hidinput_getkeycode [hid]
+hidinput_input_event [hid]
+__hidinput_change_resolution_multipliers [hid]
+hidinput_setup_battery [hid]
+hidinput_setkeycode [hid]
+hidinput_connect [hid]
+hidinput_hid_event [hid]
+hid_quirks_exit [hid]
+hid_lookup_quirk [hid]
+hid_ignore [hid]
+hid_quirks_init [hid]
+hid_debug_events_poll [hid]
+hid_debug_event [hid]
+hid_dump_report [hid]
+hid_debug_events_release [hid]
+hid_debug_events_read [hid]
+hid_debug_rdesc_open [hid]
+hid_debug_events_open [hid]
+hid_resolv_usage [hid]
+hid_dump_field [hid]
+hid_dump_device [hid]
+hid_debug_rdesc_show [hid]
+hid_dump_input [hid]
+hid_debug_register [hid]
+hid_debug_unregister [hid]
+hid_debug_init [hid]
+hid_debug_exit [hid]
+hidraw_poll [hid]
+hidraw_report_event [hid]
+hidraw_fasync [hid]
+hidraw_send_report [hid]
+hidraw_write [hid]
+hidraw_read [hid]
+drop_ref.part.0 [hid]
+hidraw_ioctl [hid]
+hidraw_connect [hid]
+hidraw_open [hid]
+hidraw_disconnect [hid]
+hidraw_release [hid]
+hidraw_exit [hid]
+ecdh_max_size [ecdh_generic]
+ecdh_set_secret [ecdh_generic]
+ecdh_compute_value [ecdh_generic]
+ecdh_init [ecdh_generic]
+ecdh_exit [ecdh_generic]
+crypto_ecdh_key_len [ecdh_generic]
+crypto_ecdh_decode_key [ecdh_generic]
+crypto_ecdh_encode_key [ecdh_generic]
+uas_resume [uas]
+uas_find_endpoints [uas]
+uas_wait_for_pending_cmnds [uas]
+uas_suspend [uas]
+uas_free_streams [uas]
+uas_shutdown [uas]
+uas_configure_endpoints [uas]
+uas_post_reset [uas]
+uas_reset_resume [uas]
+uas_pre_reset [uas]
+uas_log_cmd_state [uas]
+uas_free_unsubmitted_urbs [uas]
+uas_scan_work [uas]
+uas_cmd_cmplt [uas]
+uas_add_work [uas]
+uas_target_alloc [uas]
+uas_slave_configure [uas]
+uas_slave_alloc [uas]
+uas_eh_abort_handler [uas]
+uas_try_complete.isra.0 [uas]
+uas_zap_pending [uas]
+uas_disconnect [uas]
+uas_eh_device_reset_handler [uas]
+uas_data_cmplt [uas]
+uas_alloc_data_urb.constprop.0 [uas]
+uas_submit_urbs [uas]
+uas_do_work [uas]
+uas_xfer_data.isra.0 [uas]
+uas_stat_cmplt [uas]
+uas_queuecommand [uas]
+uas_probe [uas]
+hid_start_in [usbhid]
+hid_submit_out [usbhid]
+usbhid_restart_out_queue [usbhid]
+hid_irq_out [usbhid]
+hid_submit_ctrl [usbhid]
+usbhid_restart_ctrl_queue [usbhid]
+usbhid_wait_io [usbhid]
+hid_set_idle [usbhid]
+usbhid_idle [usbhid]
+usbhid_raw_request [usbhid]
+usbhid_output_report [usbhid]
+usbhid_power [usbhid]
+hid_cease_io [usbhid]
+hid_io_error [usbhid]
+usbhid_open [usbhid]
+hid_retry_timeout [usbhid]
+hid_free_buffers [usbhid]
+hid_ctrl [usbhid]
+hid_irq_in [usbhid]
+hid_reset [usbhid]
+hid_resume_common.part.0 [usbhid]
+hid_get_class_descriptor.constprop.0 [usbhid]
+usbhid_parse [usbhid]
+usbhid_probe [usbhid]
+usbhid_submit_report [usbhid]
+usbhid_request [usbhid]
+usbhid_start [usbhid]
+hid_pre_reset [usbhid]
+usbhid_disconnect [usbhid]
+usbhid_close [usbhid]
+usbhid_stop [usbhid]
+hid_restart_io [usbhid]
+hid_resume [usbhid]
+hid_post_reset [usbhid]
+hid_reset_resume [usbhid]
+hid_suspend [usbhid]
+usbhid_init_reports [usbhid]
+usbhid_find_interface [usbhid]
+hiddev_write [usbhid]
+hiddev_lookup_report [usbhid]
+hiddev_poll [usbhid]
+hiddev_send_event [usbhid]
+hiddev_hid_event [usbhid]
+hiddev_fasync [usbhid]
+hiddev_release [usbhid]
+hiddev_open [usbhid]
+hiddev_ioctl_usage [usbhid]
+hiddev_read [usbhid]
+hiddev_devnode [usbhid]
+hiddev_ioctl_string.isra.0 [usbhid]
+hiddev_ioctl [usbhid]
+hiddev_report_event [usbhid]
+hiddev_connect [usbhid]
+hiddev_disconnect [usbhid]
+pidff_needs_set_condition [usbhid]
+pidff_find_special_keys [usbhid]
+pidff_find_reports [usbhid]
+pidff_find_fields [usbhid]
+pidff_rescale [usbhid]
+pidff_set_signed [usbhid]
+pidff_set [usbhid]
+pidff_needs_set_effect.part.0 [usbhid]
+pidff_find_special_field.constprop.0 [usbhid]
+pidff_playback [usbhid]
+pidff_set_gain [usbhid]
+pidff_set_condition_report [usbhid]
+pidff_set_effect_report [usbhid]
+pidff_erase_effect [usbhid]
+pidff_set_envelope_report [usbhid]
+pidff_request_effect_upload [usbhid]
+pidff_autocenter [usbhid]
+pidff_set_autocenter [usbhid]
+pidff_upload_effect [usbhid]
+hid_pidff_init [usbhid]
+bt_sock_register [bluetooth]
+bt_sock_ioctl [bluetooth]
+bt_sock_poll [bluetooth]
+bt_sock_wait_state [bluetooth]
+bt_sock_wait_ready [bluetooth]
+bt_procfs_init [bluetooth]
+bt_seq_stop [bluetooth]
+bt_seq_show [bluetooth]
+bt_seq_next [bluetooth]
+bt_seq_start [bluetooth]
+bt_procfs_cleanup [bluetooth]
+bt_sock_unregister [bluetooth]
+bt_sock_reclassify_lock [bluetooth]
+bt_sock_create [bluetooth]
+bt_sock_recvmsg [bluetooth]
+bt_sock_unlink [bluetooth]
+bt_accept_enqueue [bluetooth]
+bt_accept_unlink [bluetooth]
+bt_accept_dequeue [bluetooth]
+bt_sock_link [bluetooth]
+bt_sock_stream_recvmsg [bluetooth]
+adv_instance_rpa_expired [bluetooth]
+hci_register_cb [bluetooth]
+hci_unregister_cb [bluetooth]
+hci_inq_req [bluetooth]
+hci_reset_req [bluetooth]
+hci_linkpol_req [bluetooth]
+hci_scan_req [bluetooth]
+hci_encrypt_req [bluetooth]
+hci_auth_req [bluetooth]
+hci_free_dev [bluetooth]
+hci_suspend_dev [bluetooth]
+hci_resume_dev [bluetooth]
+hci_debugfs_create_basic [bluetooth]
+vendor_diag_read [bluetooth]
+dut_mode_read [bluetooth]
+hci_init2_req [bluetooth]
+hci_init1_req [bluetooth]
+hci_cmd_timeout [bluetooth]
+hci_prio_recalculate [bluetooth]
+hci_prepare_suspend [bluetooth]
+hci_low_sent [bluetooth]
+hci_chan_sent [bluetooth]
+hci_send_frame [bluetooth]
+hci_cmd_work [bluetooth]
+hci_register_dev [bluetooth]
+hci_recv_frame [bluetooth]
+hci_recv_diag [bluetooth]
+hci_set_hw_info [bluetooth]
+hci_set_fw_info [bluetooth]
+__hci_cmd_send [bluetooth]
+hci_add_acl_hdr [bluetooth]
+vendor_diag_write [bluetooth]
+dut_mode_write [bluetooth]
+hci_suspend_wait_event [bluetooth]
+hci_change_suspend_state [bluetooth]
+hci_init0_req [bluetooth]
+hci_cmd_sync [bluetooth]
+hci_sched_sco [bluetooth]
+hci_sched_esco [bluetooth]
+hci_conn_params_free [bluetooth]
+__check_timeout.part.0 [bluetooth]
+hci_tx_work [bluetooth]
+hci_reset_dev [bluetooth]
+hci_rx_work [bluetooth]
+hci_alloc_dev [bluetooth]
+hci_init4_req [bluetooth]
+hci_suspend_notifier [bluetooth]
+hci_init3_req [bluetooth]
+hci_dev_do_open [bluetooth]
+hci_dev_get [bluetooth]
+hci_discovery_active [bluetooth]
+hci_discovery_set_state [bluetooth]
+hci_inquiry_cache_flush [bluetooth]
+hci_inquiry_cache_lookup [bluetooth]
+hci_inquiry_cache_lookup_unknown [bluetooth]
+hci_inquiry_cache_lookup_resolve [bluetooth]
+hci_inquiry_cache_update_resolve [bluetooth]
+hci_inquiry [bluetooth]
+hci_dev_open [bluetooth]
+hci_dev_do_close [bluetooth]
+hci_power_off [bluetooth]
+hci_rfkill_set_block [bluetooth]
+hci_error_reset [bluetooth]
+hci_power_on [bluetooth]
+hci_dev_close [bluetooth]
+hci_dev_reset [bluetooth]
+hci_dev_reset_stat [bluetooth]
+hci_dev_cmd [bluetooth]
+hci_get_dev_list [bluetooth]
+hci_get_dev_info [bluetooth]
+hci_uuids_clear [bluetooth]
+hci_link_keys_clear [bluetooth]
+hci_smp_ltks_clear [bluetooth]
+hci_smp_irks_clear [bluetooth]
+hci_blocked_keys_clear [bluetooth]
+hci_is_blocked_key [bluetooth]
+hci_find_link_key [bluetooth]
+hci_find_ltk [bluetooth]
+hci_find_irk_by_rpa [bluetooth]
+hci_find_irk_by_addr [bluetooth]
+hci_add_link_key [bluetooth]
+hci_add_ltk [bluetooth]
+hci_add_irk [bluetooth]
+hci_remove_link_key [bluetooth]
+hci_remove_ltk [bluetooth]
+hci_remove_irk [bluetooth]
+hci_bdaddr_is_paired [bluetooth]
+hci_find_remote_oob_data [bluetooth]
+hci_remove_remote_oob_data [bluetooth]
+hci_inquiry_cache_update [bluetooth]
+hci_remote_oob_data_clear [bluetooth]
+hci_add_remote_oob_data [bluetooth]
+hci_find_adv_instance [bluetooth]
+hci_get_next_instance [bluetooth]
+hci_remove_adv_instance [bluetooth]
+hci_adv_instances_set_rpa_expired [bluetooth]
+hci_adv_instances_clear [bluetooth]
+hci_add_adv_instance [bluetooth]
+hci_free_adv_monitor [bluetooth]
+hci_adv_monitors_clear [bluetooth]
+free_adv_monitor [bluetooth]
+hci_add_adv_monitor [bluetooth]
+hci_remove_adv_monitor [bluetooth]
+hci_is_adv_monitoring [bluetooth]
+hci_bdaddr_list_lookup [bluetooth]
+hci_bdaddr_list_lookup_with_irk [bluetooth]
+hci_bdaddr_list_lookup_with_flags [bluetooth]
+hci_bdaddr_list_clear [bluetooth]
+hci_unregister_dev [bluetooth]
+hci_bdaddr_list_add [bluetooth]
+hci_bdaddr_list_add_with_irk [bluetooth]
+hci_bdaddr_list_add_with_flags [bluetooth]
+hci_bdaddr_list_del [bluetooth]
+hci_bdaddr_list_del_with_irk [bluetooth]
+hci_bdaddr_list_del_with_flags [bluetooth]
+hci_conn_params_lookup [bluetooth]
+hci_pend_le_action_lookup [bluetooth]
+hci_conn_params_add [bluetooth]
+hci_conn_params_del [bluetooth]
+hci_conn_params_clear_disabled [bluetooth]
+hci_copy_identity_address [bluetooth]
+hci_send_cmd [bluetooth]
+hci_sent_cmd_data [bluetooth]
+hci_send_acl [bluetooth]
+hci_send_sco [bluetooth]
+hci_req_cmd_complete [bluetooth]
+hci_conn_idle [bluetooth]
+hci_conn_auto_accept [bluetooth]
+get_link_mode [bluetooth]
+set_ext_conn_params [bluetooth]
+hci_conn_timeout [bluetooth]
+hci_connect_le_scan_cleanup [bluetooth]
+hci_conn_check_secure [bluetooth]
+hci_conn_security [bluetooth]
+hci_get_route [bluetooth]
+hci_acl_create_connection [bluetooth]
+hci_conn_switch_role [bluetooth]
+hci_req_add_le_create_conn [bluetooth]
+hci_req_directed_advertising [bluetooth]
+hci_disconnect [bluetooth]
+hci_setup_sync [bluetooth]
+hci_le_conn_update [bluetooth]
+hci_le_start_enc [bluetooth]
+hci_conn_add [bluetooth]
+hci_connect_acl.part.0 [bluetooth]
+hci_connect_acl [bluetooth]
+hci_conn_check_link_mode [bluetooth]
+hci_conn_enter_active_mode [bluetooth]
+hci_conn_check_pending [bluetooth]
+hci_get_conn_list [bluetooth]
+hci_get_conn_info [bluetooth]
+hci_get_auth_info [bluetooth]
+hci_chan_create [bluetooth]
+hci_chan_del [bluetooth]
+hci_chan_list_flush [bluetooth]
+hci_conn_cleanup [bluetooth]
+le_scan_cleanup [bluetooth]
+hci_conn_del [bluetooth]
+hci_sco_setup [bluetooth]
+hci_connect_sco [bluetooth]
+hci_le_conn_failed [bluetooth]
+le_conn_timeout [bluetooth]
+create_le_conn_complete [bluetooth]
+hci_connect_le [bluetooth]
+hci_connect_le_scan [bluetooth]
+hci_conn_hash_flush [bluetooth]
+hci_chan_lookup_handle [bluetooth]
+hci_conn_get_phy [bluetooth]
+conn_set_key [bluetooth]
+hci_cc_read_local_features [bluetooth]
+hci_cc_read_class_of_dev [bluetooth]
+hci_cc_write_scan_enable [bluetooth]
+hci_cc_write_sc_support [bluetooth]
+hci_cc_le_set_adv_enable [bluetooth]
+hci_cc_write_le_host_supported [bluetooth]
+hci_cc_reset [bluetooth]
+hci_cc_write_ssp_mode [bluetooth]
+hci_outgoing_auth_needed.isra.0 [bluetooth]
+has_pending_adv_report [bluetooth]
+hci_cc_le_set_ext_adv_enable [bluetooth]
+hci_reject_conn [bluetooth]
+clear_pending_adv_report [bluetooth]
+le_set_scan_enable_complete [bluetooth]
+hci_resolve_name [bluetooth]
+hci_check_pending_name [bluetooth]
+store_pending_adv_report [bluetooth]
+process_adv_report [bluetooth]
+hci_disconn_complete_evt [bluetooth]
+cs_le_create_conn [bluetooth]
+hci_link_key_request_evt [bluetooth]
+hci_io_capa_request_evt [bluetooth]
+hci_conn_request_evt [bluetooth]
+hci_conn_complete_evt [bluetooth]
+hci_remote_oob_data_request_evt [bluetooth]
+read_enc_key_size_complete [bluetooth]
+le_conn_complete_evt [bluetooth]
+hci_encrypt_change_evt [bluetooth]
+hci_auth_complete_evt [bluetooth]
+hci_le_meta_evt [bluetooth]
+hci_cmd_complete_evt [bluetooth]
+hci_cmd_status_evt [bluetooth]
+hci_event_packet [bluetooth]
+exp_ll_privacy_feature_changed [bluetooth]
+get_supported_phys [bluetooth]
+get_selected_phys [bluetooth]
+get_supported_adv_flags [bluetooth]
+get_supported_settings [bluetooth]
+cmd_status_rsp [bluetooth]
+cmd_complete_rsp [bluetooth]
+pairing_complete_cb [bluetooth]
+generic_cmd_complete [bluetooth]
+remove_advertising_complete [bluetooth]
+service_discovery_cmd_complete [bluetooth]
+addr_cmd_complete [bluetooth]
+set_io_capability [bluetooth]
+mgmt_class_complete [bluetooth]
+remove_uuid_complete [bluetooth]
+add_uuid_complete [bluetooth]
+set_class_complete [bluetooth]
+read_version [bluetooth]
+get_phy_configuration [bluetooth]
+read_local_oob_data_complete [bluetooth]
+clear_eir [bluetooth]
+set_device_id [bluetooth]
+mgmt_init_hdev [bluetooth]
+rpa_expired [bluetooth]
+service_cache_off [bluetooth]
+remove_adv_monitor [bluetooth]
+add_adv_patterns_monitor [bluetooth]
+set_exp_feature [bluetooth]
+read_exp_features_info [bluetooth]
+add_uuid [bluetooth]
+read_local_oob_data [bluetooth]
+adv_expire [bluetooth]
+set_name_complete [bluetooth]
+stop_discovery [bluetooth]
+remove_advertising [bluetooth]
+load_conn_param [bluetooth]
+unblock_device [bluetooth]
+get_clock_info_complete [bluetooth]
+load_irks [bluetooth]
+set_scan_params [bluetooth]
+block_device [bluetooth]
+confirm_name [bluetooth]
+add_remote_oob_data [bluetooth]
+load_long_term_keys [bluetooth]
+remove_uuid [bluetooth]
+read_commands [bluetooth]
+add_advertising_complete [bluetooth]
+discovery_type_is_valid [bluetooth]
+start_service_discovery [bluetooth]
+start_discovery_internal [bluetooth]
+start_limited_discovery [bluetooth]
+start_discovery [bluetooth]
+enable_advertising_instance [bluetooth]
+le_pairing_complete_cb [bluetooth]
+clean_up_hci_complete [bluetooth]
+tlv_data_max_len.part.0 [bluetooth]
+get_adv_size_info [bluetooth]
+tlv_data_is_valid [bluetooth]
+add_advertising [bluetooth]
+set_dev_class [bluetooth]
+user_pairing_resp_complete.constprop.0 [bluetooth]
+set_blocked_keys [bluetooth]
+sk_lookup [bluetooth]
+disconnect_rsp [bluetooth]
+conn_info_refresh_complete [bluetooth]
+eir_has_uuids [bluetooth]
+device_removed [bluetooth]
+unpair_device_rsp [bluetooth]
+is_configured [bluetooth]
+read_security_info [bluetooth]
+get_missing_options [bluetooth]
+new_options [bluetooth]
+read_config_info [bluetooth]
+get_connections [bluetooth]
+remove_remote_oob_data [bluetooth]
+pairing_complete [bluetooth]
+conn_info_cmd_complete [bluetooth]
+get_device_flags [bluetooth]
+remove_device [bluetooth]
+clock_info_cmd_complete [bluetooth]
+append_eir_data_to_buf [bluetooth]
+ext_info_changed [bluetooth]
+set_appearance [bluetooth]
+set_local_name [bluetooth]
+cancel_pair_device [bluetooth]
+get_conn_info [bluetooth]
+set_device_flags [bluetooth]
+get_current_settings [bluetooth]
+new_settings [bluetooth]
+set_advertising_complete [bluetooth]
+load_link_keys [bluetooth]
+le_enable_complete [bluetooth]
+send_settings_rsp [bluetooth]
+set_wideband_speech [bluetooth]
+sc_enable_complete [bluetooth]
+set_static_address [bluetooth]
+set_bredr_complete [bluetooth]
+set_hs [bluetooth]
+fast_connectable_complete [bluetooth]
+settings_rsp [bluetooth]
+set_connectable [bluetooth]
+set_bondable [bluetooth]
+set_secure_conn [bluetooth]
+set_privacy [bluetooth]
+set_debug_keys [bluetooth]
+set_ssp [bluetooth]
+set_link_security [bluetooth]
+set_fast_connectable [bluetooth]
+set_le [bluetooth]
+set_powered [bluetooth]
+set_discoverable [bluetooth]
+set_advertising [bluetooth]
+read_controller_info [bluetooth]
+read_ext_controller_info [bluetooth]
+get_clock_info [bluetooth]
+disconnect [bluetooth]
+pin_code_reply [bluetooth]
+user_pairing_resp [bluetooth]
+user_passkey_neg_reply [bluetooth]
+user_passkey_reply [bluetooth]
+user_confirm_neg_reply [bluetooth]
+user_confirm_reply [bluetooth]
+pin_code_neg_reply [bluetooth]
+set_bredr [bluetooth]
+read_local_oob_ext_data_complete [bluetooth]
+unpair_device [bluetooth]
+add_device [bluetooth]
+pair_device [bluetooth]
+read_adv_mon_features [bluetooth]
+read_unconf_index_list [bluetooth]
+read_index_list [bluetooth]
+read_ext_index_list [bluetooth]
+read_adv_features [bluetooth]
+mgmt_fill_version_info [bluetooth]
+mgmt_get_adv_discov_flags [bluetooth]
+read_local_oob_ext_data [bluetooth]
+mgmt_get_connectable [bluetooth]
+mgmt_advertising_added [bluetooth]
+mgmt_advertising_removed [bluetooth]
+mgmt_new_settings [bluetooth]
+mgmt_set_discoverable_complete [bluetooth]
+mgmt_set_connectable_complete [bluetooth]
+mgmt_smp_complete [bluetooth]
+mgmt_phy_configuration_changed [bluetooth]
+set_phy_configuration [bluetooth]
+set_default_phy_complete [bluetooth]
+mgmt_start_discovery_complete [bluetooth]
+mgmt_stop_discovery_complete [bluetooth]
+mgmt_index_added [bluetooth]
+mgmt_index_removed [bluetooth]
+set_public_address [bluetooth]
+set_external_config [bluetooth]
+mgmt_power_on [bluetooth]
+__mgmt_power_off [bluetooth]
+mgmt_set_powered_failed [bluetooth]
+mgmt_new_link_key [bluetooth]
+mgmt_new_ltk [bluetooth]
+mgmt_new_irk [bluetooth]
+mgmt_new_csrk [bluetooth]
+mgmt_new_conn_param [bluetooth]
+mgmt_device_connected [bluetooth]
+mgmt_powering_down [bluetooth]
+mgmt_device_disconnected [bluetooth]
+mgmt_disconnect_failed [bluetooth]
+mgmt_connect_failed [bluetooth]
+mgmt_pin_code_request [bluetooth]
+mgmt_pin_code_reply_complete [bluetooth]
+mgmt_pin_code_neg_reply_complete [bluetooth]
+mgmt_user_confirm_request [bluetooth]
+mgmt_user_passkey_request [bluetooth]
+mgmt_user_confirm_reply_complete [bluetooth]
+mgmt_user_confirm_neg_reply_complete [bluetooth]
+mgmt_user_passkey_reply_complete [bluetooth]
+mgmt_user_passkey_neg_reply_complete [bluetooth]
+mgmt_user_passkey_notify [bluetooth]
+mgmt_auth_failed [bluetooth]
+mgmt_auth_enable_complete [bluetooth]
+mgmt_ssp_enable_complete [bluetooth]
+mgmt_set_class_of_dev_complete [bluetooth]
+mgmt_set_local_name_complete [bluetooth]
+mgmt_device_found [bluetooth]
+mgmt_remote_name [bluetooth]
+mgmt_discovering [bluetooth]
+mgmt_suspending [bluetooth]
+mgmt_resuming [bluetooth]
+mgmt_init [bluetooth]
+mgmt_exit [bluetooth]
+__hci_send_to_channel [bluetooth]
+hci_mgmt_chan_register [bluetooth]
+hci_mgmt_chan_unregister [bluetooth]
+hci_mgmt_chan_find [bluetooth]
+hci_sock_create [bluetooth]
+hci_sock_getname [bluetooth]
+hci_sock_getsockopt [bluetooth]
+hci_sock_gen_cookie [bluetooth]
+hci_sock_recvmsg [bluetooth]
+send_monitor_note [bluetooth]
+create_monitor_ctrl_close [bluetooth]
+create_monitor_ctrl_open [bluetooth]
+create_monitor_event [bluetooth]
+hci_sock_setsockopt [bluetooth]
+hci_sock_set_flag [bluetooth]
+hci_sock_clear_flag [bluetooth]
+hci_sock_test_flag [bluetooth]
+hci_sock_get_channel [bluetooth]
+hci_sock_get_cookie [bluetooth]
+hci_send_to_sock [bluetooth]
+hci_send_to_channel [bluetooth]
+hci_sock_sendmsg [bluetooth]
+hci_sock_ioctl [bluetooth]
+hci_sock_compat_ioctl [bluetooth]
+hci_sock_bind [bluetooth]
+hci_sock_release [bluetooth]
+hci_send_to_monitor [bluetooth]
+hci_send_monitor_ctrl_event [bluetooth]
+hci_sock_dev_event [bluetooth]
+hci_sock_cleanup [bluetooth]
+bt_link_release [bluetooth]
+bt_host_release [bluetooth]
+__match_tty [bluetooth]
+hci_conn_init_sysfs [bluetooth]
+hci_conn_add_sysfs [bluetooth]
+hci_conn_del_sysfs [bluetooth]
+hci_init_sysfs [bluetooth]
+bt_sysfs_cleanup [bluetooth]
+l2cap_seq_list_append [bluetooth]
+l2cap_chan_set_defaults [bluetooth]
+__pack_extended_control [bluetooth]
+__pack_enhanced_control [bluetooth]
+l2cap_chan_by_pid [bluetooth]
+l2cap_state_change [bluetooth]
+l2cap_build_conf_rsp [bluetooth]
+l2cap_classify_txseq [bluetooth]
+l2cap_get_ident [bluetooth]
+l2cap_register_user [bluetooth]
+l2cap_unregister_user [bluetooth]
+l2cap_get_chan_by_scid [bluetooth]
+l2cap_get_chan_by_dcid [bluetooth]
+l2cap_abort_rx_srej_sent [bluetooth]
+l2cap_do_send [bluetooth]
+l2cap_add_conf_opt [bluetooth]
+l2cap_add_opt_efs [bluetooth]
+l2cap_conn_free [bluetooth]
+l2cap_le_flowctl_send [bluetooth]
+l2cap_le_flowctl_init [bluetooth]
+l2cap_debugfs_open [bluetooth]
+l2cap_debugfs_show [bluetooth]
+l2cap_chan_list.part.0 [bluetooth]
+l2cap_chan_list [bluetooth]
+l2cap_conn_unreliable.constprop.0 [bluetooth]
+l2cap_reassemble_sdu [bluetooth]
+l2cap_seq_list_init [bluetooth]
+l2cap_conn_add [bluetooth]
+l2cap_chan_create [bluetooth]
+l2cap_conn_put [bluetooth]
+l2cap_chan_put [bluetooth]
+l2cap_chan_ready [bluetooth]
+l2cap_move_setup [bluetooth]
+l2cap_process_reqseq [bluetooth]
+l2cap_conn_get [bluetooth]
+l2cap_send_cmd [bluetooth]
+l2cap_send_disconn_req [bluetooth]
+l2cap_ertm_resend [bluetooth]
+l2cap_retransmit_all [bluetooth]
+l2cap_retransmit [bluetooth]
+l2cap_send_move_chan_rsp [bluetooth]
+l2cap_send_efs_conf_rsp [bluetooth]
+l2cap_send_move_chan_cfm_icid [bluetooth]
+l2cap_send_move_chan_cfm_rsp [bluetooth]
+l2cap_request_info [bluetooth]
+l2cap_le_start [bluetooth]
+l2cap_chan_le_send_credits [bluetooth]
+l2cap_ecred_recv [bluetooth]
+l2cap_send_sframe [bluetooth]
+l2cap_send_rr_or_rnr [bluetooth]
+l2cap_ack_timeout [bluetooth]
+l2cap_send_srej_tail [bluetooth]
+l2cap_send_srej [bluetooth]
+l2cap_parse_conf_rsp.constprop.0 [bluetooth]
+l2cap_conn_update_id_addr [bluetooth]
+l2cap_parse_conf_req.constprop.0 [bluetooth]
+__l2cap_global_chan_by_addr [bluetooth]
+l2cap_add_psm [bluetooth]
+l2cap_build_conf_req [bluetooth]
+l2cap_chan_del [bluetooth]
+l2cap_connect_create_rsp [bluetooth]
+l2cap_add_scid [bluetooth]
+l2cap_chan_hold [bluetooth]
+l2cap_global_chan_by_psm [bluetooth]
+l2cap_conn_del [bluetooth]
+l2cap_disconn_cfm [bluetooth]
+l2cap_global_fixed_chan [bluetooth]
+l2cap_send_move_chan_req [bluetooth]
+l2cap_send_move_chan_cfm [bluetooth]
+__set_retrans_timer.part.0 [bluetooth]
+l2cap_ertm_send [bluetooth]
+l2cap_send_i_or_rr_or_rnr [bluetooth]
+__set_monitor_timer [bluetooth]
+l2cap_send_ack [bluetooth]
+l2cap_tx [bluetooth]
+l2cap_chan_send [bluetooth]
+l2cap_monitor_timeout [bluetooth]
+l2cap_retrans_timeout [bluetooth]
+l2cap_move_done [bluetooth]
+l2cap_pass_to_tx [bluetooth]
+l2cap_handle_rej [bluetooth]
+l2cap_handle_srej [bluetooth]
+l2cap_rx_state_recv [bluetooth]
+l2cap_rx [bluetooth]
+l2cap_chan_close [bluetooth]
+l2cap_chan_timeout [bluetooth]
+__l2cap_chan_add [bluetooth]
+l2cap_chan_add [bluetooth]
+l2cap_chan_check_security [bluetooth]
+l2cap_connect [bluetooth]
+l2cap_send_conn_req [bluetooth]
+l2cap_do_create [bluetooth]
+l2cap_start_connection [bluetooth]
+l2cap_conn_start [bluetooth]
+l2cap_info_timeout [bluetooth]
+l2cap_do_start [bluetooth]
+l2cap_chan_connect [bluetooth]
+l2cap_connect_cfm [bluetooth]
+l2cap_security_cfm [bluetooth]
+l2cap_ertm_init [bluetooth]
+l2cap_recv_frame [bluetooth]
+process_pending_rx [bluetooth]
+__l2cap_le_connect_rsp_defer [bluetooth]
+__l2cap_ecred_conn_rsp_defer [bluetooth]
+__l2cap_connect_rsp_defer [bluetooth]
+l2cap_logical_cfm [bluetooth]
+l2cap_move_start [bluetooth]
+__l2cap_physical_cfm [bluetooth]
+l2cap_chan_busy [bluetooth]
+l2cap_chan_reconfigure [bluetooth]
+l2cap_connect_ind [bluetooth]
+l2cap_disconn_ind [bluetooth]
+l2cap_recv_acldata [bluetooth]
+l2cap_exit [bluetooth]
+l2cap_is_socket [bluetooth]
+l2cap_sock_state_change_cb [bluetooth]
+l2cap_sock_resume_cb [bluetooth]
+l2cap_sock_get_sndtimeo_cb [bluetooth]
+l2cap_sock_get_peer_pid_cb [bluetooth]
+l2cap_sock_suspend_cb [bluetooth]
+l2cap_sock_set_shutdown_cb [bluetooth]
+l2cap_sock_defer_cb [bluetooth]
+l2cap_sock_recvmsg [bluetooth]
+l2cap_sock_ready_cb [bluetooth]
+l2cap_sock_sendmsg [bluetooth]
+l2cap_sock_accept [bluetooth]
+l2cap_sock_bind [bluetooth]
+l2cap_sock_destruct [bluetooth]
+l2cap_sock_filter [bluetooth]
+l2cap_sock_recv_cb [bluetooth]
+l2cap_sock_alloc_skb_cb [bluetooth]
+l2cap_sock_listen [bluetooth]
+l2cap_sock_getsockopt [bluetooth]
+l2cap_sock_init [bluetooth]
+l2cap_sock_alloc.constprop.0 [bluetooth]
+l2cap_sock_new_connection_cb [bluetooth]
+l2cap_sock_create [bluetooth]
+l2cap_sock_connect [bluetooth]
+l2cap_sock_shutdown [bluetooth]
+l2cap_sock_kill [bluetooth]
+l2cap_sock_close_cb [bluetooth]
+l2cap_sock_release [bluetooth]
+l2cap_sock_teardown_cb [bluetooth]
+l2cap_skb_msg_name [bluetooth]
+l2cap_sock_getname [bluetooth]
+l2cap_sock_setsockopt [bluetooth]
+l2cap_cleanup_sockets [bluetooth]
+build_bredr_pairing_cmd [bluetooth]
+smp_send_cmd [bluetooth]
+sc_add_ltk [bluetooth]
+smp_ltk_encrypt [bluetooth]
+smp_timeout [bluetooth]
+build_pairing_cmd [bluetooth]
+force_bredr_smp_read [bluetooth]
+smp_del_chan [bluetooth]
+sc_send_public_key [bluetooth]
+smp_chan_destroy [bluetooth]
+smp_failure [bluetooth]
+smp_teardown_cb [bluetooth]
+smp_allow_key_dist [bluetooth]
+get_auth_method.part.0 [bluetooth]
+aes_cmac.part.0 [bluetooth]
+aes_cmac [bluetooth]
+smp_f4 [bluetooth]
+sc_passkey_send_confirm [bluetooth]
+sc_mackey_and_ltk [bluetooth]
+smp_f6 [bluetooth]
+sc_dhkey_check [bluetooth]
+sc_passkey_round [bluetooth]
+smp_g2 [bluetooth]
+tk_request.constprop.0 [bluetooth]
+smp_alloc_skb_cb [bluetooth]
+smp_e [bluetooth]
+smp_ah [bluetooth]
+smp_c1 [bluetooth]
+smp_confirm [bluetooth]
+smp_s1 [bluetooth]
+smp_chan_create [bluetooth]
+bredr_pairing [bluetooth]
+smp_ready_cb [bluetooth]
+smp_add_cid [bluetooth]
+force_bredr_smp_write [bluetooth]
+smp_distribute_keys [bluetooth]
+smp_resume_cb [bluetooth]
+smp_irk_matches [bluetooth]
+smp_generate_rpa [bluetooth]
+smp_generate_oob [bluetooth]
+smp_user_confirm_reply [bluetooth]
+smp_sufficient_security [bluetooth]
+smp_recv_cb [bluetooth]
+smp_conn_security [bluetooth]
+smp_cancel_and_remove_pairing [bluetooth]
+smp_register [bluetooth]
+smp_unregister [bluetooth]
+bt_to_errno [bluetooth]
+bt_warn_ratelimited [bluetooth]
+bt_err_ratelimited [bluetooth]
+baswap [bluetooth]
+ecdh_complete [bluetooth]
+compute_ecdh_secret [bluetooth]
+set_ecdh_privkey [bluetooth]
+generate_ecdh_public_key [bluetooth]
+generate_ecdh_keys [bluetooth]
+suspend_req_complete [bluetooth]
+req_run [bluetooth]
+enable_addr_resolution_complete [bluetooth]
+adv_enable_complete [bluetooth]
+abort_conn_complete [bluetooth]
+is_advertising_allowed [bluetooth]
+get_adv_instance_flags [bluetooth]
+create_instance_adv_data [bluetooth]
+hci_req_sync_complete [bluetooth]
+hci_req_init [bluetooth]
+hci_req_purge [bluetooth]
+hci_req_status_pend [bluetooth]
+hci_req_run [bluetooth]
+hci_req_run_skb [bluetooth]
+hci_req_sync_cancel [bluetooth]
+__hci_req_sync [bluetooth]
+hci_req_sync [bluetooth]
+le_scan_restart_work [bluetooth]
+le_scan_disable_work [bluetooth]
+discov_off [bluetooth]
+discoverable_update_work [bluetooth]
+connectable_update_work [bluetooth]
+scan_update_work [bluetooth]
+bg_scan_update [bluetooth]
+discov_update [bluetooth]
+hci_prepare_cmd [bluetooth]
+hci_req_add_ev [bluetooth]
+__hci_cmd_sync_ev [bluetooth]
+__hci_cmd_sync [bluetooth]
+add_to_white_list [bluetooth]
+hci_req_start_scan [bluetooth]
+set_random_addr [bluetooth]
+bredr_inquiry [bluetooth]
+hci_req_add [bluetooth]
+__hci_req_write_fast_connectable [bluetooth]
+__hci_req_update_name [bluetooth]
+__hci_req_update_eir [bluetooth]
+hci_req_add_le_scan_disable [bluetooth]
+le_scan_restart [bluetooth]
+le_scan_disable [bluetooth]
+append_local_name [bluetooth]
+create_instance_scan_rsp_data [bluetooth]
+__hci_req_update_scan_rsp_data [bluetooth]
+__hci_req_update_adv_data [bluetooth]
+hci_req_update_adv_data [bluetooth]
+hci_req_disable_address_resolution [bluetooth]
+hci_get_random_address [bluetooth]
+__hci_req_clear_ext_adv_sets [bluetooth]
+__hci_req_setup_ext_adv_instance [bluetooth]
+__hci_req_enable_ext_advertising [bluetooth]
+__hci_req_disable_ext_adv_instance [bluetooth]
+__hci_req_disable_advertising [bluetooth]
+__hci_req_remove_ext_adv_instance [bluetooth]
+__hci_req_start_ext_adv [bluetooth]
+hci_update_random_address [bluetooth]
+hci_req_add_le_passive_scan [bluetooth]
+hci_req_config_le_suspend_scan [bluetooth]
+__hci_update_background_scan [bluetooth]
+update_bg_scan [bluetooth]
+__hci_req_enable_advertising [bluetooth]
+__hci_req_schedule_adv_instance [bluetooth]
+hci_req_clear_adv_instance [bluetooth]
+adv_timeout_expire [bluetooth]
+hci_req_reenable_advertising [bluetooth]
+active_scan [bluetooth]
+interleaved_discov [bluetooth]
+__hci_req_update_scan [bluetooth]
+hci_req_clear_event_filter [bluetooth]
+hci_req_prepare_suspend [bluetooth]
+connectable_update [bluetooth]
+update_scan [bluetooth]
+__hci_req_update_class [bluetooth]
+powered_update_hci [bluetooth]
+discoverable_update [bluetooth]
+__hci_abort_conn [bluetooth]
+hci_abort_conn [bluetooth]
+hci_req_stop_discovery [bluetooth]
+stop_discovery [bluetooth]
+__hci_req_hci_power_on [bluetooth]
+hci_request_setup [bluetooth]
+hci_request_cancel_all [bluetooth]
+create_monitor_ctrl_event [bluetooth]
+mgmt_send_event [bluetooth]
+mgmt_cmd_status [bluetooth]
+mgmt_cmd_complete [bluetooth]
+mgmt_pending_find [bluetooth]
+mgmt_pending_find_data [bluetooth]
+mgmt_pending_foreach [bluetooth]
+mgmt_pending_add [bluetooth]
+mgmt_pending_free [bluetooth]
+mgmt_pending_remove [bluetooth]
+read_def_system_config [bluetooth]
+set_def_system_config [bluetooth]
+read_def_runtime_config [bluetooth]
+set_def_runtime_config [bluetooth]
+sco_debugfs_open [bluetooth]
+sco_debugfs_show [bluetooth]
+sco_sock_clear_timer [bluetooth]
+sco_sock_destruct [bluetooth]
+__sco_chan_add [bluetooth]
+sco_sock_sendmsg [bluetooth]
+sco_sock_getsockopt [bluetooth]
+sco_sock_set_timer [bluetooth]
+sco_sock_accept [bluetooth]
+sco_sock_init [bluetooth]
+sco_skb_put_cmsg [bluetooth]
+sco_sock_alloc.constprop.0 [bluetooth]
+sco_sock_create [bluetooth]
+sco_conn_add [bluetooth]
+sco_sock_kill [bluetooth]
+sco_sock_listen [bluetooth]
+sco_sock_getname [bluetooth]
+sco_sock_timeout [bluetooth]
+sco_sock_bind [bluetooth]
+sco_chan_del [bluetooth]
+sco_sock_setsockopt [bluetooth]
+sco_conn_del [bluetooth]
+sco_disconn_cfm [bluetooth]
+sco_sock_connect [bluetooth]
+sco_sock_recvmsg [bluetooth]
+__sco_sock_close [bluetooth]
+sco_sock_shutdown [bluetooth]
+sco_sock_close [bluetooth]
+sco_sock_release [bluetooth]
+sco_connect_cfm [bluetooth]
+sco_connect_ind [bluetooth]
+sco_recv_scodata [bluetooth]
+sco_exit [bluetooth]
+a2mp_chan_close_cb [bluetooth]
+a2mp_chan_alloc_skb_cb [bluetooth]
+amp_mgr_create [bluetooth]
+a2mp_send [bluetooth]
+amp_mgr_get [bluetooth]
+amp_mgr_lookup_by_state [bluetooth]
+amp_mgr_put [bluetooth]
+a2mp_chan_state_change_cb [bluetooth]
+a2mp_channel_create [bluetooth]
+a2mp_send_getinfo_rsp [bluetooth]
+a2mp_chan_recv_cb [bluetooth]
+read_local_amp_info_complete [bluetooth]
+a2mp_send_getampassoc_rsp [bluetooth]
+a2mp_send_create_phy_link_req [bluetooth]
+a2mp_send_create_phy_link_rsp [bluetooth]
+a2mp_discover_amp [bluetooth]
+hmac_sha256.constprop.0 [bluetooth]
+amp_ctrl_get [bluetooth]
+amp_ctrl_put [bluetooth]
+amp_ctrl_add [bluetooth]
+amp_ctrl_list_flush [bluetooth]
+amp_ctrl_lookup [bluetooth]
+amp_write_rem_assoc_frag [bluetooth]
+phylink_add [bluetooth]
+phylink_gen_key [bluetooth]
+amp_read_loc_assoc_frag [bluetooth]
+read_local_amp_assoc_complete [bluetooth]
+amp_read_loc_assoc [bluetooth]
+amp_read_loc_assoc_final_data [bluetooth]
+amp_write_rem_assoc_continue [bluetooth]
+write_remote_amp_assoc_complete [bluetooth]
+amp_write_remote_assoc [bluetooth]
+create_phylink_complete [bluetooth]
+accept_phylink_complete [bluetooth]
+amp_create_phylink [bluetooth]
+amp_accept_phylink [bluetooth]
+amp_physical_cfm [bluetooth]
+amp_create_logical_link [bluetooth]
+amp_disconnect_logical_link [bluetooth]
+amp_destroy_logical_link [bluetooth]
+power_activate [bluetooth]
+hci_leds_update_powered [bluetooth]
+hci_leds_init [bluetooth]
+bt_leds_init [bluetooth]
+bt_leds_cleanup [bluetooth]
+msft_do_open [bluetooth]
+msft_do_close [bluetooth]
+msft_vendor_evt [bluetooth]
+msft_get_features [bluetooth]
+conn_info_max_age_fops_open [bluetooth]
+conn_info_min_age_fops_open [bluetooth]
+sniff_max_interval_fops_open [bluetooth]
+sniff_min_interval_fops_open [bluetooth]
+idle_timeout_fops_open [bluetooth]
+auto_accept_delay_fops_open [bluetooth]
+min_encrypt_key_size_fops_open [bluetooth]
+voice_setting_fops_open [bluetooth]
+auth_payload_timeout_fops_open [bluetooth]
+max_key_size_fops_open [bluetooth]
+min_key_size_fops_open [bluetooth]
+adv_max_interval_fops_open [bluetooth]
+adv_min_interval_fops_open [bluetooth]
+adv_channel_map_fops_open [bluetooth]
+supervision_timeout_fops_open [bluetooth]
+conn_latency_fops_open [bluetooth]
+conn_max_interval_fops_open [bluetooth]
+conn_min_interval_fops_open [bluetooth]
+rpa_timeout_fops_open [bluetooth]
+firmware_info_open [bluetooth]
+hardware_info_open [bluetooth]
+remote_oob_open [bluetooth]
+uuids_open [bluetooth]
+blocked_keys_open [bluetooth]
+blacklist_open [bluetooth]
+device_list_open [bluetooth]
+device_id_open [bluetooth]
+features_open [bluetooth]
+dev_class_open [bluetooth]
+link_keys_open [bluetooth]
+inquiry_cache_open [bluetooth]
+long_term_keys_open [bluetooth]
+identity_resolving_keys_open [bluetooth]
+resolv_list_open [bluetooth]
+white_list_open [bluetooth]
+static_address_open [bluetooth]
+random_address_open [bluetooth]
+identity_open [bluetooth]
+firmware_info_show [bluetooth]
+hardware_info_show [bluetooth]
+conn_info_max_age_set [bluetooth]
+conn_info_max_age_get [bluetooth]
+conn_info_min_age_set [bluetooth]
+conn_info_min_age_get [bluetooth]
+remote_oob_show [bluetooth]
+uuids_show [bluetooth]
+blacklist_show [bluetooth]
+device_list_show [bluetooth]
+device_id_show [bluetooth]
+features_show [bluetooth]
+sniff_max_interval_set [bluetooth]
+sniff_max_interval_get [bluetooth]
+sniff_min_interval_set [bluetooth]
+sniff_min_interval_get [bluetooth]
+idle_timeout_set [bluetooth]
+idle_timeout_get [bluetooth]
+auto_accept_delay_set [bluetooth]
+auto_accept_delay_get [bluetooth]
+min_encrypt_key_size_set [bluetooth]
+min_encrypt_key_size_get [bluetooth]
+voice_setting_get [bluetooth]
+dev_class_show [bluetooth]
+inquiry_cache_show [bluetooth]
+auth_payload_timeout_set [bluetooth]
+auth_payload_timeout_get [bluetooth]
+max_key_size_set [bluetooth]
+max_key_size_get [bluetooth]
+min_key_size_set [bluetooth]
+min_key_size_get [bluetooth]
+adv_max_interval_set [bluetooth]
+adv_max_interval_get [bluetooth]
+adv_min_interval_set [bluetooth]
+adv_min_interval_get [bluetooth]
+adv_channel_map_set [bluetooth]
+adv_channel_map_get [bluetooth]
+supervision_timeout_set [bluetooth]
+supervision_timeout_get [bluetooth]
+conn_latency_set [bluetooth]
+conn_latency_get [bluetooth]
+conn_max_interval_set [bluetooth]
+conn_max_interval_get [bluetooth]
+conn_min_interval_set [bluetooth]
+conn_min_interval_get [bluetooth]
+resolv_list_show [bluetooth]
+white_list_show [bluetooth]
+static_address_show [bluetooth]
+random_address_show [bluetooth]
+rpa_timeout_set [bluetooth]
+rpa_timeout_get [bluetooth]
+ssp_debug_mode_read [bluetooth]
+sc_only_mode_read [bluetooth]
+use_debug_keys_read [bluetooth]
+quirk_simultaneous_discovery_read [bluetooth]
+quirk_strict_duplicate_filter_read [bluetooth]
+force_no_mitm_read [bluetooth]
+force_static_address_read [bluetooth]
+blocked_keys_show [bluetooth]
+link_keys_show [bluetooth]
+long_term_keys_show [bluetooth]
+identity_resolving_keys_show [bluetooth]
+identity_show [bluetooth]
+quirk_simultaneous_discovery_write [bluetooth]
+quirk_strict_duplicate_filter_write [bluetooth]
+force_static_address_write [bluetooth]
+force_no_mitm_write [bluetooth]
+hci_debugfs_create_common [bluetooth]
+hci_debugfs_create_bredr [bluetooth]
+hci_debugfs_create_le [bluetooth]
+hci_debugfs_create_conn [bluetooth]
+bt_info [bluetooth]
+bt_warn [bluetooth]
+bt_err [bluetooth]
+btintel_enter_mfg [btintel]
+btintel_exit_mfg [btintel]
+btintel_set_bdaddr [btintel]
+btintel_set_event_mask [btintel]
+btintel_set_diag [btintel]
+btintel_send_intel_reset [btintel]
+btintel_hw_error [btintel]
+btintel_version_info [btintel]
+btintel_version_info_tlv [btintel]
+btintel_set_debug_features [btintel]
+btintel_read_debug_features [btintel]
+btintel_secure_send [btintel]
+btintel_sfi_rsa_header_secure_send [btintel]
+btintel_read_version [btintel]
+btintel_load_ddc_config [btintel]
+btintel_read_version_tlv [btintel]
+regmap_ibt_free_context [btintel]
+btintel_download_firmware_payload [btintel]
+btintel_download_firmware_newgen [btintel]
+regmap_ibt_read [btintel]
+btintel_read_boot_params [btintel]
+btintel_reset_to_bootloader [btintel]
+regmap_ibt_gather_write [btintel]
+regmap_ibt_write [btintel]
+btintel_set_event_mask_mfg [btintel]
+btintel_set_diag_mfg [btintel]
+btintel_download_firmware [btintel]
+btintel_check_bdaddr [btintel]
+btintel_regmap_init [btintel]
+btbcm_set_bdaddr [btbcm]
+btbcm_write_pcm_int_params [btbcm]
+btbcm_read_verbose_config [btbcm]
+btbcm_read_controller_features [btbcm]
+btbcm_read_local_name [btbcm]
+btbcm_read_usb_product [btbcm]
+btbcm_read_pcm_int_params [btbcm]
+btbcm_patchram [btbcm]
+btbcm_reset [btbcm]
+btbcm_initialize [btbcm]
+btbcm_setup_apple [btbcm]
+btbcm_check_bdaddr [btbcm]
+btbcm_finalize [btbcm]
+btbcm_setup_patchram [btbcm]
+btrtl_shutdown_realtek [btrtl]
+btrtl_free [btrtl]
+btrtl_read_local_version [btrtl]
+rtl_load_file [btrtl]
+rtl_download_firmware [btrtl]
+btrtl_get_uart_settings [btrtl]
+btrtl_download_firmware [btrtl]
+btrtl_initialize [btrtl]
+btrtl_setup_realtek [btrtl]
+btusb_find_altsetting [btusb]
+alloc_bulk_urb [btusb]
+btusb_prevent_wake [btusb]
+btusb_bulk_complete [btusb]
+alloc_ctrl_urb [btusb]
+btusb_submit_bulk_urb [btusb]
+btusb_tx_complete [btusb]
+btusb_isoc_tx_complete [btusb]
+submit_tx_urb [btusb]
+submit_or_queue_tx_urb [btusb]
+btusb_notify [btusb]
+btusb_stop_traffic [btusb]
+btusb_disconnect [btusb]
+btusb_set_bdaddr_ath3012 [btusb]
+btusb_set_bdaddr_marvell [btusb]
+btusb_shutdown_intel_new [btusb]
+btusb_shutdown_intel [btusb]
+btusb_setup_bcm92035 [btusb]
+btusb_setup_csr [btusb]
+btusb_rtl_cmd_timeout [btusb]
+btusb_intel_cmd_timeout [btusb]
+btusb_set_bdaddr_wcn6855 [btusb]
+btusb_qca_cmd_timeout [btusb]
+btusb_setup_qca_download_fw [btusb]
+btusb_setup_intel [btusb]
+btusb_close [btusb]
+btusb_waker [btusb]
+alloc_isoc_urb [btusb]
+btusb_send_frame [btusb]
+btusb_recv_event_intel [btusb]
+btusb_setup_intel_new_get_fw_name.constprop.0 [btusb]
+btusb_send_frame_intel [btusb]
+btusb_intel_download_firmware [btusb]
+btusb_flush [btusb]
+btusb_mtk_hci_wmt_sync [btusb]
+btusb_mtk_shutdown [btusb]
+btusb_mtk_func_query [btusb]
+btusb_mtk_setup [btusb]
+btusb_setup_intel_new [btusb]
+btusb_recv_bulk [btusb]
+btusb_recv_intr [btusb]
+btusb_intr_complete [btusb]
+btusb_recv_bulk_intel [btusb]
+btusb_isoc_complete [btusb]
+btusb_bcm_set_diag [btusb]
+btusb_submit_isoc_urb [btusb]
+btusb_suspend [btusb]
+btusb_mtk_wmt_recv [btusb]
+btusb_diag_complete [btusb]
+btusb_work [btusb]
+btusb_qca_send_vendor_req [btusb]
+btusb_probe [btusb]
+btusb_setup_qca [btusb]
+btusb_submit_intr_urb [btusb]
+btusb_resume [btusb]
+btusb_open [btusb]
+__check_hid_generic [hid_generic]
+hid_generic_probe [hid_generic]
+hid_generic_match [hid_generic]
+llc_sap_close [llc]
+llc_sap_open [llc]
+llc_sap_find [llc]
+llc_add_pack [llc]
+llc_remove_pack [llc]
+llc_set_station_handler [llc]
+llc_rcv [llc]
+llc_mac_hdr_init [llc]
+llc_build_and_send_ui_pkt [llc]
+stp_proto_register [stp]
+stp_pdu_rcv [stp]
+stp_proto_unregister [stp]
+br_switchdev_event [bridge]
+br_net_exit [bridge]
+br_device_event [bridge]
+br_boolopt_toggle.part.0 [bridge]
+br_boolopt_get [bridge]
+br_boolopt_multi_get [bridge]
+br_opt_toggle [bridge]
+br_boolopt_toggle [bridge]
+br_boolopt_multi_toggle [bridge]
+br_dev_set_multicast_list [bridge]
+br_netpoll_cleanup [bridge]
+br_get_link_ksettings [bridge]
+br_getinfo [bridge]
+br_fix_features [bridge]
+br_del_slave [bridge]
+br_add_slave [bridge]
+br_get_stats64 [bridge]
+br_change_mtu [bridge]
+br_set_mac_address [bridge]
+br_dev_change_rx_flags [bridge]
+br_dev_stop [bridge]
+br_dev_open [bridge]
+br_dev_uninit [bridge]
+br_dev_init [bridge]
+br_dev_xmit [bridge]
+__br_netpoll_enable [bridge]
+br_netpoll_setup [bridge]
+br_poll_controller [bridge]
+br_netpoll_enable [bridge]
+br_netpoll_disable [bridge]
+br_dev_setup [bridge]
+fdb_rcu_free [bridge]
+br_fdb_clear_offload [bridge]
+fdb_del_hw_addr [bridge]
+fdb_add_hw_addr [bridge]
+fdb_to_nud [bridge]
+fdb_fill_info [bridge]
+fdb_notify [bridge]
+fdb_find_rcu [bridge]
+br_fdb_find_port [bridge]
+fdb_delete [bridge]
+fdb_delete_local [bridge]
+fdb_delete_by_addr_and_port [bridge]
+fdb_create [bridge]
+fdb_insert [bridge]
+br_fdb_fini [bridge]
+br_fdb_hash_init [bridge]
+br_fdb_hash_fini [bridge]
+br_fdb_find_rcu [bridge]
+br_fdb_find_delete_local [bridge]
+br_fdb_changeaddr [bridge]
+br_fdb_change_mac_address [bridge]
+br_fdb_cleanup [bridge]
+br_fdb_flush [bridge]
+br_fdb_delete_by_port [bridge]
+br_fdb_test_addr [bridge]
+br_fdb_fillbuf [bridge]
+br_fdb_insert [bridge]
+br_fdb_update [bridge]
+br_fdb_dump [bridge]
+br_fdb_get [bridge]
+br_fdb_delete [bridge]
+br_fdb_sync_static [bridge]
+br_fdb_unsync_static [bridge]
+br_fdb_external_learn_add [bridge]
+__br_fdb_add [bridge]
+br_fdb_add [bridge]
+br_fdb_external_learn_del [bridge]
+br_fdb_offloaded_set [bridge]
+br_dev_queue_push_xmit [bridge]
+br_forward_finish [bridge]
+__br_forward [bridge]
+deliver_clone [bridge]
+maybe_deliver [bridge]
+br_forward [bridge]
+br_flood [bridge]
+br_multicast_flood [bridge]
+release_nbp [bridge]
+br_port_flag_is_set [bridge]
+br_port_set_promisc [bridge]
+destroy_nbp_rcu [bridge]
+brport_get_ownership [bridge]
+port_cost.part.0 [bridge]
+port_cost [bridge]
+br_port_carrier_check [bridge]
+br_manage_promisc [bridge]
+nbp_update_port_count [bridge]
+nbp_backup_change [bridge]
+del_nbp [bridge]
+br_dev_delete [bridge]
+br_add_bridge [bridge]
+br_del_bridge [bridge]
+br_mtu_auto_adjust [bridge]
+br_features_recompute [bridge]
+br_add_if [bridge]
+br_del_if [bridge]
+br_port_flags_change [bridge]
+br_handle_frame_dummy [bridge]
+br_netif_receive_skb [bridge]
+__br_handle_local_finish [bridge]
+br_handle_local_finish [bridge]
+br_pass_frame_up [bridge]
+br_handle_frame_finish [bridge]
+br_handle_frame [bridge]
+br_get_rx_handler [bridge]
+add_del_if [bridge]
+old_dev_ioctl.isra.0 [bridge]
+br_ioctl_deviceless_stub [bridge]
+br_dev_ioctl [bridge]
+br_designated_port_selection [bridge]
+br_transmit_config.part.0 [bridge]
+br_set_state [bridge]
+br_root_selection [bridge]
+br_get_port [bridge]
+br_transmit_config [bridge]
+br_transmit_tcn [bridge]
+br_config_bpdu_generation [bridge]
+br_configuration_update [bridge]
+br_become_designated_port [bridge]
+br_set_hello_time [bridge]
+br_set_max_age [bridge]
+__set_ageing_time [bridge]
+br_set_ageing_time [bridge]
+__br_set_topology_change [bridge]
+br_topology_change_detection [bridge]
+br_become_root_bridge [bridge]
+br_make_forwarding [bridge]
+br_received_tcn_bpdu [bridge]
+br_port_state_selection [bridge]
+br_received_config_bpdu [bridge]
+__br_set_forward_delay [bridge]
+br_set_forward_delay [bridge]
+br_send_bpdu_finish [bridge]
+br_send_bpdu.constprop.0 [bridge]
+br_send_config_bpdu [bridge]
+br_send_tcn_bpdu [bridge]
+br_stp_rcv [bridge]
+br_stp_call_user [bridge]
+br_init_port [bridge]
+br_stp_enable_port [bridge]
+br_stp_enable_bridge [bridge]
+br_stp_disable_port [bridge]
+br_stp_disable_bridge [bridge]
+br_stp_set_enabled [bridge]
+br_stp_change_bridge_id [bridge]
+br_stp_recalculate_bridge_id [bridge]
+br_stp_set_bridge_priority [bridge]
+br_stp_set_port_priority [bridge]
+br_stp_set_path_cost [bridge]
+br_show_bridge_id [bridge]
+br_message_age_timer_expired [bridge]
+br_topology_change_timer_expired [bridge]
+br_hold_timer_expired [bridge]
+br_tcn_timer_expired [bridge]
+br_hello_timer_expired [bridge]
+br_forward_delay_timer_expired [bridge]
+br_stp_timer_init [bridge]
+br_stp_port_timer_init [bridge]
+br_timer_value [bridge]
+br_port_get_slave_size [bridge]
+br_get_size [bridge]
+br_validate [bridge]
+br_get_linkxstats_size [bridge]
+br_get_link_af_size_filtered [bridge]
+br_port_fill_attrs [bridge]
+br_port_fill_slave_info [bridge]
+br_set_port_flag [bridge]
+br_set_port_state [bridge]
+br_setport [bridge]
+br_fill_linkxstats [bridge]
+br_fill_info [bridge]
+br_changelink [bridge]
+br_vlan_info [bridge]
+br_fill_ifvlaninfo_range [bridge]
+br_port_slave_changelink [bridge]
+br_dev_newlink [bridge]
+br_fill_ifinfo [bridge]
+br_ifinfo_notify [bridge]
+br_getlink [bridge]
+br_process_vlan_info [bridge]
+br_afspec [bridge]
+br_setlink [bridge]
+br_dellink [bridge]
+br_netlink_fini [bridge]
+br_fill_vlan_tinfo [bridge]
+br_fill_vlan_tinfo_range [bridge]
+vlan_tunid_inrange [bridge]
+br_get_vlan_tunnel_info_size [bridge]
+br_fill_vlan_tunnel_info [bridge]
+br_vlan_tunnel_info [bridge]
+br_parse_vlan_tunnel_info [bridge]
+br_process_vlan_tunnel_info [bridge]
+br_chk_addr_ip [bridge]
+br_chk_addr_ip6 [bridge]
+br_nd_send [bridge]
+br_arp_send [bridge]
+br_recalculate_neigh_suppress_enabled [bridge]
+br_do_proxy_suppress_arp [bridge]
+br_is_nd_neigh_msg [bridge]
+br_do_suppress_nd [bridge]
+store_multicast_router [bridge]
+show_hold_timer [bridge]
+show_forward_delay_timer [bridge]
+show_message_age_timer [bridge]
+show_designated_bridge [bridge]
+show_designated_root [bridge]
+store_group_fwd_mask [bridge]
+brport_show [bridge]
+store_backup_port [bridge]
+show_isolated [bridge]
+show_neigh_suppress [bridge]
+show_group_fwd_mask [bridge]
+show_broadcast_flood [bridge]
+show_multicast_flood [bridge]
+show_proxyarp_wifi [bridge]
+show_proxyarp [bridge]
+show_multicast_to_unicast [bridge]
+show_multicast_fast_leave [bridge]
+show_multicast_router [bridge]
+show_unicast_flood [bridge]
+show_learning [bridge]
+show_root_block [bridge]
+show_bpdu_guard [bridge]
+show_hairpin_mode [bridge]
+show_config_pending [bridge]
+show_change_ack [bridge]
+show_port_state [bridge]
+show_designated_cost [bridge]
+show_designated_port [bridge]
+show_port_no [bridge]
+show_port_id [bridge]
+show_priority [bridge]
+show_path_cost [bridge]
+show_backup_port [bridge]
+store_isolated [bridge]
+store_neigh_suppress [bridge]
+store_broadcast_flood [bridge]
+store_multicast_flood [bridge]
+store_proxyarp_wifi [bridge]
+store_proxyarp [bridge]
+store_multicast_to_unicast [bridge]
+store_multicast_fast_leave [bridge]
+store_unicast_flood [bridge]
+store_learning [bridge]
+store_root_block [bridge]
+store_bpdu_guard [bridge]
+store_hairpin_mode [bridge]
+store_flush [bridge]
+brport_store [bridge]
+br_sysfs_addif [bridge]
+br_sysfs_renameif [bridge]
+brforward_read [bridge]
+hash_elasticity_show [bridge]
+group_addr_show [bridge]
+set_nf_call_arptables [bridge]
+set_nf_call_ip6tables [bridge]
+set_nf_call_iptables [bridge]
+set_stats_enabled [bridge]
+set_query_use_ifaddr [bridge]
+set_no_linklocal_learn [bridge]
+no_linklocal_learn_show [bridge]
+set_flush [bridge]
+gc_timer_show [bridge]
+topology_change_timer_show [bridge]
+tcn_timer_show [bridge]
+hello_timer_show [bridge]
+root_id_show [bridge]
+bridge_id_show [bridge]
+set_priority [bridge]
+set_stp_state [bridge]
+set_ageing_time [bridge]
+vlan_stats_per_port_show [bridge]
+vlan_stats_enabled_show [bridge]
+vlan_filtering_show [bridge]
+nf_call_arptables_show [bridge]
+nf_call_ip6tables_show [bridge]
+nf_call_iptables_show [bridge]
+multicast_stats_enabled_show [bridge]
+multicast_query_use_ifaddr_show [bridge]
+multicast_querier_show [bridge]
+multicast_snooping_show [bridge]
+set_group_fwd_mask [bridge]
+set_hash_max [bridge]
+set_last_member_count [bridge]
+set_startup_query_count [bridge]
+set_elasticity [bridge]
+default_pvid_show [bridge]
+multicast_mld_version_show [bridge]
+multicast_igmp_version_show [bridge]
+multicast_startup_query_count_show [bridge]
+multicast_last_member_count_show [bridge]
+hash_max_show [bridge]
+multicast_router_show [bridge]
+topology_change_detected_show [bridge]
+topology_change_show [bridge]
+root_port_show [bridge]
+root_path_cost_show [bridge]
+priority_show [bridge]
+group_fwd_mask_show [bridge]
+stp_state_show [bridge]
+vlan_protocol_show [bridge]
+set_startup_query_interval [bridge]
+set_query_response_interval [bridge]
+set_query_interval [bridge]
+set_querier_interval [bridge]
+set_membership_interval [bridge]
+set_last_member_interval [bridge]
+multicast_startup_query_interval_show [bridge]
+multicast_query_response_interval_show [bridge]
+multicast_query_interval_show [bridge]
+multicast_querier_interval_show [bridge]
+multicast_membership_interval_show [bridge]
+multicast_last_member_interval_show [bridge]
+ageing_time_show [bridge]
+max_age_show [bridge]
+hello_time_show [bridge]
+forward_delay_show [bridge]
+group_addr_store [bridge]
+store_bridge_parm [bridge]
+vlan_stats_per_port_store [bridge]
+vlan_stats_enabled_store [bridge]
+default_pvid_store [bridge]
+vlan_protocol_store [bridge]
+vlan_filtering_store [bridge]
+nf_call_arptables_store [bridge]
+nf_call_ip6tables_store [bridge]
+nf_call_iptables_store [bridge]
+multicast_mld_version_store [bridge]
+multicast_igmp_version_store [bridge]
+multicast_stats_enabled_store [bridge]
+multicast_startup_query_interval_store [bridge]
+multicast_query_response_interval_store [bridge]
+multicast_query_interval_store [bridge]
+multicast_querier_interval_store [bridge]
+multicast_membership_interval_store [bridge]
+multicast_last_member_interval_store [bridge]
+multicast_startup_query_count_store [bridge]
+multicast_last_member_count_store [bridge]
+hash_max_store [bridge]
+hash_elasticity_store [bridge]
+multicast_query_use_ifaddr_store [bridge]
+multicast_querier_store [bridge]
+multicast_snooping_store [bridge]
+multicast_router_store [bridge]
+no_linklocal_learn_store [bridge]
+flush_store [bridge]
+priority_store [bridge]
+group_fwd_mask_store [bridge]
+stp_state_store [bridge]
+ageing_time_store [bridge]
+max_age_store [bridge]
+hello_time_store [bridge]
+forward_delay_store [bridge]
+br_sysfs_addbr [bridge]
+br_sysfs_delbr [bridge]
+fake_update_pmtu [bridge]
+fake_redirect [bridge]
+fake_cow_metrics [bridge]
+fake_neigh_lookup [bridge]
+fake_mtu [bridge]
+br_netfilter_rtable_init [bridge]
+br_nf_core_fini [bridge]
+br_multicast_enabled [bridge]
+br_multicast_router [bridge]
+br_multicast_gc [bridge]
+br_multicast_gc_work [bridge]
+mcast_stats_add_dir [bridge]
+br_multicast_has_querier_adjacent [bridge]
+br_multicast_destroy_mdb_entry [bridge]
+br_multicast_destroy_port_group [bridge]
+br_multicast_destroy_group_src [bridge]
+br_multicast_list_adjacent [bridge]
+br_multicast_has_querier_anywhere [bridge]
+br_port_mc_router_state_change [bridge]
+__del_port_router [bridge]
+br_mc_disabled_update [bridge]
+br_mc_router_state_change [bridge]
+br_multicast_enable [bridge]
+br_port_group_equal.part.0 [bridge]
+br_multicast_find_port [bridge]
+br_multicast_err_count.part.0 [bridge]
+br_multicast_start_querier [bridge]
+br_multicast_add_router [bridge]
+br_multicast_mark_router [bridge]
+__br_multicast_enable_port [bridge]
+br_multicast_query_received [bridge]
+br_multicast_count.part.0 [bridge]
+br_multicast_new_group_src [bridge]
+br_multicast_find_group_src [bridge]
+__br_multicast_send_query [bridge]
+br_multicast_send_query [bridge]
+br_ip4_multicast_query_expired [bridge]
+br_ip6_multicast_query_expired [bridge]
+br_multicast_querier_expired [bridge]
+br_ip6_multicast_querier_expired [bridge]
+br_ip4_multicast_querier_expired [bridge]
+br_multicast_local_router_expired [bridge]
+br_multicast_router_expired [bridge]
+br_multicast_port_query_expired [bridge]
+br_ip6_multicast_port_query_expired [bridge]
+br_ip4_multicast_port_query_expired [bridge]
+br_multicast_port_group_rexmit [bridge]
+br_mdb_ip_get_rcu [bridge]
+br_multicast_del_mdb_entry [bridge]
+br_mdb_ip_get [bridge]
+br_multicast_star_g_host_state [bridge]
+br_mdb_ip6_get [bridge]
+br_mdb_get [bridge]
+br_multicast_new_group [bridge]
+br_multicast_new_port_group [bridge]
+br_multicast_host_join [bridge]
+__br_multicast_add_group [bridge]
+br_multicast_star_g_handle_mode [bridge]
+br_multicast_del_pg [bridge]
+br_multicast_find_del_pg [bridge]
+br_multicast_del_group_src [bridge]
+__grp_src_delete_marked [bridge]
+br_multicast_leave_group [bridge]
+br_ip4_multicast_leave_group [bridge]
+br_ip6_multicast_leave_group.part.0 [bridge]
+br_multicast_port_group_expired [bridge]
+br_multicast_sg_add_exclude_ports [bridge]
+br_ip6_multicast_add_group.part.0 [bridge]
+br_multicast_fwd_src_handle [bridge]
+br_multicast_group_src_expired [bridge]
+br_multicast_isinc_allow [bridge]
+br_multicast_isexc [bridge]
+__grp_src_query_marked_and_rexmit [bridge]
+br_multicast_toex [bridge]
+br_multicast_block [bridge]
+br_multicast_toin [bridge]
+br_ip4_multicast_add_group.part.0 [bridge]
+br_multicast_host_leave [bridge]
+br_multicast_group_expired [bridge]
+br_multicast_add_port [bridge]
+br_multicast_del_port [bridge]
+br_multicast_enable_port [bridge]
+br_multicast_disable_port [bridge]
+br_multicast_rcv [bridge]
+br_multicast_init [bridge]
+br_multicast_join_snoopers [bridge]
+br_multicast_leave_snoopers [bridge]
+br_multicast_open [bridge]
+br_multicast_stop [bridge]
+br_multicast_dev_del [bridge]
+br_multicast_set_router [bridge]
+br_multicast_set_port_router [bridge]
+br_multicast_toggle [bridge]
+br_multicast_set_querier [bridge]
+br_multicast_set_igmp_version [bridge]
+br_multicast_set_mld_version [bridge]
+br_multicast_count [bridge]
+br_multicast_init_stats [bridge]
+br_multicast_uninit_stats [bridge]
+br_multicast_get_stats [bridge]
+br_mdb_hash_init [bridge]
+br_mdb_hash_fini [bridge]
+br_mdb_complete [bridge]
+__mdb_entry_to_br_ip [bridge]
+br_mdb_parse [bridge]
+__mdb_fill_info [bridge]
+br_mdb_dump [bridge]
+br_mdb_notify [bridge]
+__br_mdb_del [bridge]
+br_mdb_del [bridge]
+br_mdb_add_group [bridge]
+br_mdb_add [bridge]
+br_rtr_notify [bridge]
+br_mdb_init [bridge]
+br_mdb_uninit [bridge]
+br_vlan_enabled [bridge]
+__vlan_add_flags [bridge]
+recalculate_group_addr [bridge]
+br_vlan_get_proto [bridge]
+br_master_vlan_rcu_free [bridge]
+nbp_vlan_rcu_free [bridge]
+br_vlan_get_upper_bind_vlan_dev [bridge]
+__vlan_vid_del [bridge]
+__vlan_group_free [bridge]
+br_vlan_get_pvid_rcu [bridge]
+br_recalculate_fwd_mask.part.0 [bridge]
+br_vlan_is_bind_vlan_dev_fn [bridge]
+br_vlan_get_pvid [bridge]
+br_vlan_match_bind_vlan_dev_fn [bridge]
+br_vlan_set_vlan_dev_state [bridge]
+nbp_vlan_set_vlan_dev_state [bridge]
+br_vlan_link_state_change_fn [bridge]
+vlan_default_pvid.part.0 [bridge]
+br_vlan_get_info [bridge]
+br_vlan_put_master.part.0 [bridge]
+__vlan_del [bridge]
+br_vlan_rtm_process [bridge]
+br_handle_vlan [bridge]
+br_allowed_ingress [bridge]
+br_allowed_egress [bridge]
+br_should_learn [bridge]
+br_vlan_delete [bridge]
+br_vlan_find [bridge]
+br_recalculate_fwd_mask [bridge]
+__br_vlan_filter_toggle [bridge]
+br_vlan_filter_toggle [bridge]
+__br_vlan_set_proto [bridge]
+br_vlan_set_proto [bridge]
+br_vlan_set_stats [bridge]
+br_vlan_set_stats_per_port [bridge]
+br_vlan_init [bridge]
+nbp_vlan_delete [bridge]
+br_vlan_get_stats [bridge]
+br_vlan_fill_vids [bridge]
+br_vlan_port_event [bridge]
+br_vlan_notify [bridge]
+__vlan_add [bridge]
+br_vlan_add [bridge]
+nbp_vlan_add [bridge]
+__vlan_flush [bridge]
+br_vlan_flush [bridge]
+nbp_vlan_flush [bridge]
+br_vlan_disable_default_pvid [bridge]
+__br_vlan_set_default_pvid.part.0 [bridge]
+__br_vlan_set_default_pvid [bridge]
+br_vlan_set_default_pvid [bridge]
+nbp_vlan_init [bridge]
+br_vlan_bridge_event [bridge]
+br_vlan_can_enter_range [bridge]
+br_vlan_dump_dev [bridge]
+br_vlan_rtm_dump [bridge]
+br_vlan_rtnl_init [bridge]
+br_vlan_rtnl_uninit [bridge]
+vlan_tunnel_info_del [bridge]
+nbp_vlan_tunnel_info_add [bridge]
+nbp_vlan_tunnel_info_delete [bridge]
+nbp_vlan_tunnel_info_flush [bridge]
+vlan_tunnel_init [bridge]
+vlan_tunnel_deinit [bridge]
+br_handle_ingress_vlan_tunnel [bridge]
+br_handle_egress_vlan_tunnel [bridge]
+br_vlan_opts_eq_range [bridge]
+br_vlan_opts_fill [bridge]
+br_vlan_opts_nl_size [bridge]
+br_vlan_process_options [bridge]
+nbp_switchdev_mark_set [bridge]
+nbp_switchdev_frame_mark [bridge]
+nbp_switchdev_allowed_egress [bridge]
+br_switchdev_set_port_flag [bridge]
+br_switchdev_fdb_notify [bridge]
+br_switchdev_port_vlan_add [bridge]
+br_switchdev_port_vlan_del [bridge]
+br_mrp_switchdev_add [bridge]
+br_mrp_switchdev_del [bridge]
+br_mrp_switchdev_set_ring_role [bridge]
+br_mrp_switchdev_send_ring_test [bridge]
+br_mrp_switchdev_set_ring_state [bridge]
+br_mrp_switchdev_set_in_role [bridge]
+br_mrp_switchdev_set_in_state [bridge]
+br_mrp_switchdev_send_in_test [bridge]
+br_mrp_port_switchdev_set_state [bridge]
+br_mrp_port_switchdev_set_role [bridge]
+br_mrp_unique_ifindex [bridge]
+br_mrp_skb_alloc [bridge]
+br_mrp_skb_common [bridge]
+br_mrp_alloc_in_test_skb [bridge]
+br_mrp_alloc_test_skb [bridge]
+br_mrp_in_test_work_expired [bridge]
+br_mrp_del_impl [bridge]
+br_mrp_test_work_expired [bridge]
+br_mrp_mrm_process [bridge]
+br_mrp_add [bridge]
+br_mrp_port_del [bridge]
+br_mrp_del [bridge]
+br_mrp_set_port_state [bridge]
+br_mrp_set_port_role [bridge]
+br_mrp_set_ring_state [bridge]
+br_mrp_set_ring_role [bridge]
+br_mrp_start_test [bridge]
+br_mrp_set_in_state [bridge]
+br_mrp_set_in_role [bridge]
+br_mrp_start_in_test [bridge]
+br_mrp_process [bridge]
+br_mrp_enabled [bridge]
+br_mrp_start_in_test_parse [bridge]
+br_mrp_in_role_parse [bridge]
+br_mrp_instance_parse [bridge]
+br_mrp_start_test_parse [bridge]
+br_mrp_parse [bridge]
+br_mrp_fill_info [bridge]
+br_mrp_ring_port_open [bridge]
+br_mrp_in_port_open [bridge]
+bpfilter_send_req [bpfilter]
+bpfilter_process_sockopt [bpfilter]
+start_umh [bpfilter]
+shutdown_umh [bpfilter]
+__bnep_get_session [bnep]
+bnep_send_rsp [bnep]
+__bnep_copy_ci [bnep]
+bnep_rx_control [bnep]
+bnep_session [bnep]
+bnep_add_connection [bnep]
+bnep_del_connection [bnep]
+bnep_get_connlist [bnep]
+bnep_get_conninfo [bnep]
+bnep_sock_create [bnep]
+do_bnep_sock_ioctl.isra.0 [bnep]
+bnep_sock_compat_ioctl [bnep]
+bnep_sock_ioctl [bnep]
+bnep_sock_release [bnep]
+bnep_net_open [bnep]
+bnep_net_close [bnep]
+bnep_net_timeout [bnep]
+bnep_net_xmit [bnep]
+bnep_net_set_mac_addr [bnep]
+bnep_net_set_mc_list [bnep]
+bnep_net_setup [bnep]
+iptable_filter_net_exit [iptable_filter]
+iptable_filter_net_pre_exit [iptable_filter]
+iptable_filter_hook [iptable_filter]
+iptable_filter_table_init [iptable_filter]
+iptable_filter_net_init [iptable_filter]
+icmp6_checkentry [ip6_tables]
+cleanup_match [ip6_tables]
+cleanup_entry [ip6_tables]
+__ip6t_unregister_table [ip6_tables]
+ip6t_unregister_table_exit [ip6_tables]
+ip6t_unregister_table_pre_exit [ip6_tables]
+ip6t_unregister_table [ip6_tables]
+compat_table_info [ip6_tables]
+compat_standard_to_user [ip6_tables]
+compat_standard_from_user [ip6_tables]
+ip6_tables_net_exit [ip6_tables]
+ip6_tables_net_init [ip6_tables]
+alloc_counters [ip6_tables]
+compat_get_entries [ip6_tables]
+find_check_entry.isra.0 [ip6_tables]
+ip6t_error [ip6_tables]
+ip6t_do_table [ip6_tables]
+icmp6_match [ip6_tables]
+ip6t_alloc_initial_table [ip6_tables]
+__do_replace [ip6_tables]
+get_info [ip6_tables]
+do_ip6t_get_ctl [ip6_tables]
+translate_table [ip6_tables]
+ip6t_register_table [ip6_tables]
+translate_compat_table [ip6_tables]
+compat_do_replace.isra.0 [ip6_tables]
+do_ip6t_set_ctl [ip6_tables]
+ip6table_filter_net_exit [ip6table_filter]
+ip6table_filter_net_pre_exit [ip6table_filter]
+ip6table_filter_hook [ip6table_filter]
+ip6table_filter_table_init [ip6table_filter]
+ip6table_filter_net_init [ip6table_filter]
+nfnl_lock [nfnetlink]
+nfnl_unlock [nfnetlink]
+nfnetlink_subsys_unregister [nfnetlink]
+nfnetlink_has_listeners [nfnetlink]
+nfnetlink_send [nfnetlink]
+nfnetlink_set_err [nfnetlink]
+nfnetlink_unicast [nfnetlink]
+nfnetlink_net_exit_batch [nfnetlink]
+nfnetlink_rcv_msg [nfnetlink]
+nfnl_err_reset [nfnetlink]
+nfnetlink_net_init [nfnetlink]
+nfnetlink_bind [nfnetlink]
+nfnetlink_subsys_register [nfnetlink]
+nfnetlink_rcv_batch [nfnetlink]
+nfnetlink_rcv [nfnetlink]
+nft_update_chain_stats [nf_tables]
+__nft_trace_packet [nf_tables]
+nft_do_chain [nf_tables]
+nf_tables_core_module_exit [nf_tables]
+nft_validate_register_load [nf_tables]
+nft_register_flowtable_type [nf_tables]
+nft_unregister_expr [nf_tables]
+nft_unregister_obj [nf_tables]
+nft_unregister_flowtable_type [nf_tables]
+nft_rule_expr_deactivate [nf_tables]
+nf_tables_deactivate_flowtable [nf_tables]
+nf_tables_cleanup [nf_tables]
+nft_register_chain_type [nf_tables]
+nft_unregister_chain_type [nf_tables]
+nft_register_expr [nf_tables]
+nft_register_obj [nf_tables]
+nft_flowtable_hooks_destroy [nf_tables]
+nf_tables_expr_destroy [nf_tables]
+nf_tables_rule_destroy [nf_tables]
+nft_set_elem_expr_destroy [nf_tables]
+nf_tables_set_elem_destroy [nf_tables]
+nft_obj_destroy [nf_tables]
+nf_tables_flowtable_destroy [nf_tables]
+nft_flowtable_hook_release [nf_tables]
+nf_tables_dump_flowtable_done [nf_tables]
+nf_tables_dump_obj_done [nf_tables]
+nf_tables_dump_sets_done [nf_tables]
+nf_tables_dump_rules_done [nf_tables]
+nft_chain_release_hook [nf_tables]
+__nf_tables_commit_chain_free_rules_old [nf_tables]
+nft_chain_validate [nf_tables]
+nft_table_validate [nf_tables]
+nf_tables_bind_set [nf_tables]
+nft_set_destroy [nf_tables]
+nft_set_lookup [nf_tables]
+nft_flowtable_lookup [nf_tables]
+nft_table_lookup [nf_tables]
+nft_ctx_init_from_elemattr [nf_tables]
+nft_set_lookup_global [nf_tables]
+nft_parse_u32_check [nf_tables]
+nft_parse_register [nf_tables]
+nft_dump_register [nf_tables]
+nft_chain_hash_cmp [nf_tables]
+nft_objname_hash_cmp [nf_tables]
+nf_tables_check_loops [nf_tables]
+nf_tables_loop_check_setelem [nf_tables]
+nf_tables_trans_destroy_flush_work [nf_tables]
+nf_tables_table_destroy [nf_tables]
+nf_tables_valid_genid [nf_tables]
+nf_tables_commit_chain_free_rules_old [nf_tables]
+nft_netdev_hook_alloc [nf_tables]
+nft_register_flowtable_net_hooks [nf_tables]
+nf_tables_dump_sets_start [nf_tables]
+nf_tables_dump_set_start [nf_tables]
+nft_stats_alloc [nf_tables]
+nf_tables_init_net [nf_tables]
+nf_tables_module_autoload_cleanup [nf_tables]
+nft_request_module [nf_tables]
+nf_tables_expr_parse [nf_tables]
+nft_chain_validate_dependency [nf_tables]
+nf_tables_validate [nf_tables]
+nft_chain_validate_hooks [nf_tables]
+nft_rule_lookup.part.0 [nf_tables]
+nft_validate_register_store [nf_tables]
+nf_tables_bind_check_setelem [nf_tables]
+nf_tables_unregister_hook [nf_tables]
+nft_table_disable [nf_tables]
+nf_tables_flowtable_event [nf_tables]
+nf_tables_register_hook.part.0 [nf_tables]
+nf_tables_destroy_set [nf_tables]
+nft_data_release.part.0 [nf_tables]
+nft_netlink_dump_start_rcu.constprop.0 [nf_tables]
+nf_tables_dump_set_done [nf_tables]
+nf_tables_set_desc_parse [nf_tables]
+nf_tables_parse_netdev_hooks [nf_tables]
+nft_flowtable_parse_hook [nf_tables]
+nft_chain_parse_hook [nf_tables]
+nf_tables_dump_obj_start [nf_tables]
+nf_tables_dump_flowtable_start [nf_tables]
+nf_tables_dump_rules_start [nf_tables]
+nft_chain_lookup.part.0 [nf_tables]
+nft_data_init [nf_tables]
+nft_obj_lookup [nf_tables]
+nf_tables_fill_expr_info [nf_tables]
+nf_tables_fill_gen_info [nf_tables]
+nf_tables_getgen [nf_tables]
+nf_tables_fill_table_info [nf_tables]
+nf_tables_dump_tables [nf_tables]
+nf_tables_gettable [nf_tables]
+nf_tables_table_notify [nf_tables]
+nf_tables_fill_obj_info [nf_tables]
+nft_obj_notify [nf_tables]
+nf_tables_obj_notify [nf_tables]
+nf_tables_dump_obj [nf_tables]
+nf_tables_getobj [nf_tables]
+nf_tables_dump_set [nf_tables]
+nf_tables_fill_flowtable_info [nf_tables]
+nf_tables_dump_flowtable [nf_tables]
+nf_tables_getflowtable [nf_tables]
+nf_tables_flowtable_notify [nf_tables]
+nf_tables_fill_set [nf_tables]
+nf_tables_getset [nf_tables]
+nf_tables_dump_sets [nf_tables]
+nf_tables_set_notify.constprop.0 [nf_tables]
+nf_tables_deactivate_set [nf_tables]
+nf_tables_fill_chain_info [nf_tables]
+nf_tables_dump_chains [nf_tables]
+nf_tables_getchain [nf_tables]
+nf_tables_chain_notify [nf_tables]
+nft_chain_hash [nf_tables]
+nft_chain_hash_obj [nf_tables]
+nft_objname_hash [nf_tables]
+nft_objname_hash_obj [nf_tables]
+nft_trans_alloc_gfp [nf_tables]
+nft_trans_rule_add [nf_tables]
+nft_delrule [nf_tables]
+nft_delrule_by_chain [nf_tables]
+nf_tables_delrule [nf_tables]
+nf_tables_newrule [nf_tables]
+nf_tables_newflowtable [nf_tables]
+nf_tables_newtable [nf_tables]
+nft_delset [nf_tables]
+nf_tables_delset [nf_tables]
+nft_delobj [nf_tables]
+nf_tables_delobj [nf_tables]
+nft_delflowtable [nf_tables]
+nf_tables_delflowtable [nf_tables]
+nft_delchain [nf_tables]
+nft_flush_table [nf_tables]
+nf_tables_deltable [nf_tables]
+nf_tables_delchain [nf_tables]
+nft_expr_init [nf_tables]
+nft_obj_del [nf_tables]
+nft_obj_init [nf_tables]
+nf_tables_newobj [nf_tables]
+nft_chain_add [nf_tables]
+nft_data_hold.part.0 [nf_tables]
+nf_tables_chain_destroy [nf_tables]
+nf_tables_trans_destroy_work [nf_tables]
+nf_tables_addchain.constprop.0 [nf_tables]
+nf_tables_newchain [nf_tables]
+nft_expr_dump [nf_tables]
+nf_tables_fill_rule_info [nf_tables]
+nf_tables_rule_notify [nf_tables]
+nf_tables_getrule [nf_tables]
+__nf_tables_dump_rules [nf_tables]
+nf_tables_dump_rules [nf_tables]
+nft_expr_clone [nf_tables]
+nft_expr_destroy [nf_tables]
+nf_tables_rule_release [nf_tables]
+nf_msecs_to_jiffies64 [nf_tables]
+nf_jiffies64_to_msecs [nf_tables]
+nft_set_elem_expr_alloc [nf_tables]
+nf_tables_newset [nf_tables]
+nft_set_elem_init [nf_tables]
+nft_data_hold [nf_tables]
+nft_set_gc_batch_alloc [nf_tables]
+nft_chain_del [nf_tables]
+nft_verdict_uninit [nf_tables]
+nft_data_release [nf_tables]
+nft_set_elem_destroy [nf_tables]
+nft_set_gc_batch_release [nf_tables]
+nft_set_elem_deactivate.isra.0 [nf_tables]
+nft_flush_set [nf_tables]
+nft_setelem_parse_key [nf_tables]
+nft_del_setelem [nf_tables]
+nf_tables_delsetelem [nf_tables]
+nft_add_set_elem [nf_tables]
+nf_tables_newsetelem [nf_tables]
+__nft_release_basechain [nf_tables]
+__nf_tables_abort [nf_tables]
+nf_tables_abort [nf_tables]
+nf_tables_exit_net [nf_tables]
+nft_verdict_dump [nf_tables]
+nft_data_dump [nf_tables]
+nf_tables_fill_setelem [nf_tables]
+nf_tables_fill_setelem_info [nf_tables]
+nft_get_set_elem [nf_tables]
+nf_tables_getsetelem [nf_tables]
+nf_tables_setelem_notify.constprop.0 [nf_tables]
+nf_tables_commit [nf_tables]
+nf_tables_dump_setelem [nf_tables]
+nft_do_chain_arp [nf_tables]
+nf_tables_netdev_event [nf_tables]
+nft_do_chain_ipv4 [nf_tables]
+nft_do_chain_inet [nf_tables]
+nft_do_chain_bridge [nf_tables]
+nft_do_chain_inet_ingress [nf_tables]
+nft_do_chain_netdev [nf_tables]
+nft_do_chain_ipv6 [nf_tables]
+nft_chain_filter_fini [nf_tables]
+trace_fill_header.part.0 [nf_tables]
+nft_trace_notify [nf_tables]
+nft_trace_init [nf_tables]
+nft_immediate_eval [nf_tables]
+nft_immediate_dump [nf_tables]
+nft_immediate_destroy [nf_tables]
+nft_immediate_deactivate [nf_tables]
+nft_immediate_activate [nf_tables]
+nft_immediate_init [nf_tables]
+nft_immediate_offload [nf_tables]
+nft_immediate_validate [nf_tables]
+nft_cmp_eval [nf_tables]
+__nft_cmp_offload [nf_tables]
+nft_cmp_offload [nf_tables]
+nft_cmp_dump [nf_tables]
+nft_cmp_fast_init [nf_tables]
+nft_cmp_select_ops [nf_tables]
+nft_cmp_init [nf_tables]
+nft_cmp_fast_offload [nf_tables]
+nft_cmp_fast_dump [nf_tables]
+nft_range_eval [nf_tables]
+nft_range_dump [nf_tables]
+nft_range_init [nf_tables]
+nft_bitwise_fast_offload [nf_tables]
+nft_bitwise_eval [nf_tables]
+nft_bitwise_fast_dump [nf_tables]
+nft_bitwise_extract_u32_data [nf_tables]
+nft_bitwise_dump [nf_tables]
+nft_bitwise_init [nf_tables]
+nft_bitwise_offload [nf_tables]
+nft_bitwise_fast_init [nf_tables]
+nft_bitwise_select_ops [nf_tables]
+nft_byteorder_eval [nf_tables]
+nft_byteorder_dump [nf_tables]
+nft_byteorder_init [nf_tables]
+nft_payload_select_ops [nf_tables]
+nft_payload_offload_mask [nf_tables]
+nft_payload_dump [nf_tables]
+nft_payload_set_dump [nf_tables]
+nft_payload_init [nf_tables]
+nft_payload_set_init [nf_tables]
+nft_payload_eval [nf_tables]
+nft_payload_offload_tcp.isra.0 [nf_tables]
+nft_payload_offload [nf_tables]
+nft_payload_set_eval [nf_tables]
+nft_lookup_activate [nf_tables]
+nft_lookup_validate [nf_tables]
+nft_lookup_validate_setelem [nf_tables]
+nft_lookup_destroy [nf_tables]
+nft_lookup_deactivate [nf_tables]
+nft_lookup_eval [nf_tables]
+nft_lookup_init [nf_tables]
+nft_lookup_dump [nf_tables]
+nft_dynset_activate [nf_tables]
+nft_dynset_new [nf_tables]
+nft_dynset_destroy [nf_tables]
+nft_dynset_deactivate [nf_tables]
+nft_dynset_eval [nf_tables]
+nft_dynset_dump [nf_tables]
+nft_dynset_init [nf_tables]
+nft_meta_get_eval_sdif [nf_tables]
+nft_secmark_obj_eval [nf_tables]
+nft_meta_get_eval_rtclassid [nf_tables]
+nft_meta_store_ifname [nf_tables]
+nft_meta_get_eval_kind [nf_tables]
+nft_meta_get_eval_skugid [nf_tables]
+nft_meta_get_eval_cgroup [nf_tables]
+nft_prandom_u32 [nf_tables]
+nft_meta_get_eval_sdifname [nf_tables]
+nft_meta_get_init [nf_tables]
+nft_meta_get_validate [nf_tables]
+nft_meta_set_init [nf_tables]
+nft_meta_get_dump [nf_tables]
+nft_meta_set_dump [nf_tables]
+nft_meta_set_destroy [nf_tables]
+nft_meta_get_offload [nf_tables]
+nft_secmark_compute_secid [nf_tables]
+nft_secmark_obj_destroy [nf_tables]
+nft_secmark_obj_init [nf_tables]
+nft_meta_select_ops [nf_tables]
+nft_meta_set_eval [nf_tables]
+nft_meta_set_validate [nf_tables]
+nft_secmark_obj_dump [nf_tables]
+nft_meta_get_eval_pkttype_lo [nf_tables]
+nft_meta_get_eval_time [nf_tables]
+nft_meta_get_eval [nf_tables]
+nft_rt_get_eval [nf_tables]
+nft_rt_get_dump [nf_tables]
+nft_rt_get_init [nf_tables]
+nft_rt_validate [nf_tables]
+nft_exthdr_dump_common [nf_tables]
+nft_exthdr_dump [nf_tables]
+nft_exthdr_dump_set [nf_tables]
+nft_exthdr_init [nf_tables]
+nft_exthdr_ipv4_init [nf_tables]
+nft_exthdr_tcp_set_init [nf_tables]
+nft_exthdr_ipv6_eval [nf_tables]
+nft_exthdr_select_ops [nf_tables]
+nft_exthdr_ipv4_eval [nf_tables]
+nft_tcp_header_pointer.constprop.0 [nf_tables]
+nft_exthdr_tcp_set_eval [nf_tables]
+nft_exthdr_tcp_eval [nf_tables]
+nf_route_table_hook4 [nf_tables]
+nf_route_table_hook6 [nf_tables]
+nf_route_table_inet [nf_tables]
+nft_flow_offload_rule [nf_tables]
+nft_flow_block_offload_init [nf_tables]
+nft_flow_offload_unbind [nf_tables]
+nft_block_setup [nf_tables]
+nft_block_offload_cmd [nf_tables]
+nft_indr_block_offload_cmd [nf_tables]
+nft_chain_offload_cmd [nf_tables]
+nft_flow_block_chain [nf_tables]
+nft_flow_offload_chain [nf_tables]
+nft_offload_netdev_event [nf_tables]
+nft_indr_block_cleanup [nf_tables]
+nft_flow_rule_set_addr_type [nf_tables]
+nft_flow_rule_destroy [nf_tables]
+nft_flow_rule_create [nf_tables]
+nft_offload_set_dependency [nf_tables]
+nft_offload_update_dependency [nf_tables]
+nft_chain_offload_priority [nf_tables]
+nft_flow_rule_offload_commit [nf_tables]
+nft_offload_init [nf_tables]
+nft_offload_exit [nf_tables]
+nft_rhash_privsize [nf_tables]
+nft_rhash_destroy [nf_tables]
+nft_rhash_elem_destroy [nf_tables]
+nft_hash_buckets [nf_tables]
+nft_rhash_estimate [nf_tables]
+nft_hash_remove [nf_tables]
+nft_hash_walk [nf_tables]
+nft_hash_destroy [nf_tables]
+nft_rhash_walk [nf_tables]
+nft_hash_flush [nf_tables]
+nft_rhash_flush [nf_tables]
+nft_rhash_activate [nf_tables]
+nft_hash_activate [nf_tables]
+nft_hash_estimate [nf_tables]
+nft_hash_privsize [nf_tables]
+nft_hash_fast_estimate [nf_tables]
+nft_hash_init [nf_tables]
+nft_rhash_gc_init [nf_tables]
+nft_rhash_init [nf_tables]
+nft_hash_lookup_fast [nf_tables]
+nft_rhash_get [nf_tables]
+nft_rhash_lookup [nf_tables]
+nft_rhash_deactivate [nf_tables]
+nft_hash_get [nf_tables]
+nft_hash_lookup [nf_tables]
+nft_jhash [nf_tables]
+nft_hash_deactivate [nf_tables]
+nft_hash_insert [nf_tables]
+nft_rhash_delete [nf_tables]
+nft_rhash_gc [nf_tables]
+nft_rhash_remove [nf_tables]
+nft_rhash_insert [nf_tables]
+nft_rhash_update [nf_tables]
+nft_bitmap_walk [nf_tables]
+nft_bitmap_destroy [nf_tables]
+nft_bitmap_remove [nf_tables]
+nft_bitmap_flush [nf_tables]
+nft_bitmap_activate [nf_tables]
+nft_bitmap_lookup [nf_tables]
+nft_bitmap_elem_find [nf_tables]
+nft_bitmap_deactivate [nf_tables]
+nft_bitmap_insert [nf_tables]
+nft_bitmap_get [nf_tables]
+nft_bitmap_estimate [nf_tables]
+nft_bitmap_init [nf_tables]
+nft_bitmap_privsize [nf_tables]
+nft_rbtree_privsize [nf_tables]
+nft_rbtree_remove [nf_tables]
+nft_rbtree_destroy [nf_tables]
+nft_rbtree_walk [nf_tables]
+nft_rbtree_flush [nf_tables]
+nft_rbtree_activate [nf_tables]
+nft_rbtree_deactivate [nf_tables]
+__nft_rbtree_lookup [nf_tables]
+nft_rbtree_lookup [nf_tables]
+nft_rbtree_insert [nf_tables]
+nft_rbtree_estimate [nf_tables]
+__nft_rbtree_get.constprop.0 [nf_tables]
+nft_rbtree_get [nf_tables]
+nft_rbtree_gc [nf_tables]
+nft_rbtree_init [nf_tables]
+nft_pipapo_privsize [nf_tables]
+pipapo_rules_same_key [nf_tables]
+nft_pipapo_gc_init [nf_tables]
+pipapo_free_fields [nf_tables]
+nft_pipapo_destroy [nf_tables]
+pipapo_reclaim_match [nf_tables]
+pipapo_bucket_set [nf_tables]
+pipapo_lt_bits_adjust [nf_tables]
+pipapo_resize [nf_tables]
+pipapo_insert [nf_tables]
+nft_pipapo_walk [nf_tables]
+pipapo_drop [nf_tables]
+pipapo_gc [nf_tables]
+nft_pipapo_estimate [nf_tables]
+pipapo_clone [nf_tables]
+nft_pipapo_init [nf_tables]
+pipapo_commit [nf_tables]
+pipapo_refill [nf_tables]
+nft_pipapo_lookup [nf_tables]
+pipapo_get.constprop.0 [nf_tables]
+nft_pipapo_insert [nf_tables]
+nft_pipapo_activate [nf_tables]
+pipapo_deactivate.isra.0 [nf_tables]
+nft_pipapo_flush [nf_tables]
+nft_pipapo_deactivate [nf_tables]
+nft_pipapo_remove [nf_tables]
+nft_pipapo_get [nf_tables]
+nft_pipapo_avx2_fill [nf_tables]
+nft_pipapo_avx2_refill [nf_tables]
+nft_pipapo_avx2_lookup_slow [nf_tables]
+nft_pipapo_avx2_estimate [nf_tables]
+nft_pipapo_avx2_lookup [nf_tables]
+input_leds_event [input_leds]
+input_leds_disconnect [input_leds]
+input_leds_brightness_set [input_leds]
+input_leds_brightness_get [input_leds]
+input_leds_connect [input_leds]
+joydev_correct [joydev]
+joydev_fasync [joydev]
+joydev_free [joydev]
+joydev_ioctl_common [joydev]
+joydev_compat_ioctl [joydev]
+joydev_ioctl [joydev]
+joydev_poll [joydev]
+joydev_read [joydev]
+joydev_event [joydev]
+joydev_release [joydev]
+joydev_cleanup [joydev]
+joydev_disconnect [joydev]
+joydev_connect [joydev]
+joydev_match [joydev]
+joydev_open [joydev]
+ipv4_conntrack_defrag [nf_defrag_ipv4]
+nf_defrag_ipv4_enable [nf_defrag_ipv4]
+defrag4_net_exit [nf_defrag_ipv4]
+ipv6_defrag [nf_defrag_ipv6]
+nf_defrag_ipv6_enable [nf_defrag_ipv6]
+defrag6_net_exit [nf_defrag_ipv6]
+nf_ct_net_pre_exit [nf_defrag_ipv6]
+nf_ct_net_exit [nf_defrag_ipv6]
+nf_ct_net_init [nf_defrag_ipv6]
+nf_ct_frag6_gather [nf_defrag_ipv6]
+nf_ct_frag6_expire [nf_defrag_ipv6]
+nf_ct_frag6_init [nf_defrag_ipv6]
+nf_ct_frag6_cleanup [nf_defrag_ipv6]
+kill_all [nf_conntrack]
+__nf_conntrack_hash_insert [nf_conntrack]
+nf_conntrack_attach [nf_conntrack]
+nf_ct_acct_add [nf_conntrack]
+iter_net_only [nf_conntrack]
+nf_ct_invert_tuple [nf_conntrack]
+nf_ct_tmpl_free [nf_conntrack]
+__nf_conntrack_insert_prepare [nf_conntrack]
+nf_conntrack_free [nf_conntrack]
+nf_conntrack_alter_reply [nf_conntrack]
+nf_ct_port_tuple_to_nlattr [nf_conntrack]
+nf_ct_port_nlattr_tuple_size [nf_conntrack]
+__nf_ct_unconfirmed_destroy [nf_conntrack]
+nf_ct_alloc_hashtable [nf_conntrack]
+nf_ct_port_nlattr_to_tuple [nf_conntrack]
+__nf_ct_refresh_acct [nf_conntrack]
+nf_ct_unconfirmed_destroy [nf_conntrack]
+hash_conntrack_raw [nf_conntrack]
+nf_ct_get_id [nf_conntrack]
+nf_ct_tmpl_alloc [nf_conntrack]
+get_l4proto [nf_conntrack]
+nf_ct_add_to_dying_list [nf_conntrack]
+nf_ct_del_from_dying_or_unconfirmed_list [nf_conntrack]
+nf_conntrack_double_unlock [nf_conntrack]
+destroy_conntrack [nf_conntrack]
+nf_ct_get_tuple [nf_conntrack]
+nf_ct_get_tuplepr [nf_conntrack]
+nf_conntrack_lock [nf_conntrack]
+nf_conntrack_double_lock.isra.0 [nf_conntrack]
+nf_ct_delete_from_lists [nf_conntrack]
+nf_ct_delete [nf_conntrack]
+nf_ct_gc_expired [nf_conntrack]
+__nf_conntrack_find_get [nf_conntrack]
+nf_conntrack_find_get [nf_conntrack]
+nf_conntrack_get_tuple_skb [nf_conntrack]
+nf_conntrack_tuple_taken [nf_conntrack]
+nf_ct_kill_acct [nf_conntrack]
+early_drop [nf_conntrack]
+__nf_conntrack_alloc [nf_conntrack]
+nf_conntrack_alloc [nf_conntrack]
+gc_worker [nf_conntrack]
+nf_conntrack_hash_check_insert [nf_conntrack]
+__nf_conntrack_confirm [nf_conntrack]
+nf_conntrack_update [nf_conntrack]
+nf_ct_iterate_cleanup [nf_conntrack]
+nf_ct_iterate_cleanup_net [nf_conntrack]
+nf_ct_iterate_destroy [nf_conntrack]
+init_conntrack.isra.0 [nf_conntrack]
+nf_conntrack_in [nf_conntrack]
+nf_conntrack_cleanup_start [nf_conntrack]
+nf_conntrack_cleanup_end [nf_conntrack]
+nf_conntrack_cleanup_net_list [nf_conntrack]
+nf_conntrack_cleanup_net [nf_conntrack]
+nf_conntrack_hash_resize [nf_conntrack]
+nf_conntrack_set_hashsize [nf_conntrack]
+nf_conntrack_init_start [nf_conntrack]
+nf_conntrack_init_end [nf_conntrack]
+nf_conntrack_init_net [nf_conntrack]
+nf_conntrack_pernet_exit [nf_conntrack]
+nf_conntrack_hash_sysctl [nf_conntrack]
+nf_conntrack_pernet_init [nf_conntrack]
+nf_ct_expect_alloc [nf_conntrack]
+nf_ct_expect_init [nf_conntrack]
+nf_ct_expect_free_rcu [nf_conntrack]
+nf_ct_expect_dst_hash [nf_conntrack]
+nf_ct_expect_put [nf_conntrack]
+nf_ct_unlink_expect_report [nf_conntrack]
+nf_ct_remove_expect [nf_conntrack]
+nf_ct_remove_expectations [nf_conntrack]
+nf_ct_unexpect_related [nf_conntrack]
+nf_ct_expectation_timed_out [nf_conntrack]
+nf_ct_expect_iterate_destroy [nf_conntrack]
+nf_ct_expect_iterate_net [nf_conntrack]
+__nf_ct_expect_find [nf_conntrack]
+nf_ct_expect_find_get [nf_conntrack]
+nf_ct_expect_related_report [nf_conntrack]
+nf_ct_find_expectation [nf_conntrack]
+nf_conntrack_expect_pernet_init [nf_conntrack]
+nf_conntrack_expect_pernet_fini [nf_conntrack]
+nf_conntrack_expect_init [nf_conntrack]
+nf_conntrack_expect_fini [nf_conntrack]
+nf_ct_helper_expectfn_register [nf_conntrack]
+nf_nat_helper_register [nf_conntrack]
+nf_ct_helper_expectfn_unregister [nf_conntrack]
+nf_nat_helper_unregister [nf_conntrack]
+nf_ct_helper_expectfn_find_by_symbol [nf_conntrack]
+expect_iter_me [nf_conntrack]
+__nf_conntrack_helper_find [nf_conntrack]
+nf_conntrack_nat_helper_find [nf_conntrack]
+nf_ct_helper_expectfn_find_by_name [nf_conntrack]
+nf_nat_helper_put [nf_conntrack]
+nf_nat_helper_try_module_get [nf_conntrack]
+helper_hash [nf_conntrack]
+nf_ct_helper_log [nf_conntrack]
+nf_conntrack_helper_unregister [nf_conntrack]
+nf_conntrack_helpers_unregister [nf_conntrack]
+nf_conntrack_helper_register [nf_conntrack]
+nf_conntrack_helpers_register [nf_conntrack]
+nf_ct_helper_ext_add [nf_conntrack]
+nf_ct_helper_init [nf_conntrack]
+unhelp [nf_conntrack]
+nf_conntrack_helper_put [nf_conntrack]
+nf_conntrack_helper_try_module_get [nf_conntrack]
+__nf_ct_helper_find [nf_conntrack]
+__nf_ct_try_assign_helper [nf_conntrack]
+nf_ct_helper_destroy [nf_conntrack]
+nf_conntrack_helper_pernet_init [nf_conntrack]
+nf_conntrack_helper_init [nf_conntrack]
+nf_conntrack_helper_fini [nf_conntrack]
+nf_ct_l4proto_find [nf_conntrack]
+nf_ct_bridge_register [nf_conntrack]
+nf_ct_bridge_unregister [nf_conntrack]
+ipv4_conntrack_in [nf_conntrack]
+nf_ct_netns_do_get [nf_conntrack]
+nf_ct_netns_do_put [nf_conntrack]
+nf_ct_tcp_fixup [nf_conntrack]
+ipv4_conntrack_local [nf_conntrack]
+nf_ct_netns_put [nf_conntrack]
+ipv6_conntrack_local [nf_conntrack]
+ipv6_conntrack_in [nf_conntrack]
+nf_ct_netns_get [nf_conntrack]
+ipv6_getorigdst [nf_conntrack]
+getorigdst [nf_conntrack]
+nf_confirm [nf_conntrack]
+ipv4_confirm [nf_conntrack]
+ipv6_confirm [nf_conntrack]
+nf_conntrack_proto_init [nf_conntrack]
+nf_conntrack_proto_fini [nf_conntrack]
+nf_conntrack_proto_pernet_init [nf_conntrack]
+nf_conntrack_proto_pernet_fini [nf_conntrack]
+generic_timeout_nlattr_to_obj [nf_conntrack]
+generic_timeout_obj_to_nlattr [nf_conntrack]
+nf_conntrack_generic_init_net [nf_conntrack]
+tcp_can_early_drop [nf_conntrack]
+tcp_timeout_nlattr_to_obj [nf_conntrack]
+tcp_timeout_obj_to_nlattr [nf_conntrack]
+tcp_to_nlattr [nf_conntrack]
+tcp_nlattr_tuple_size [nf_conntrack]
+nlattr_to_tcp [nf_conntrack]
+tcp_options [nf_conntrack]
+tcp_new [nf_conntrack]
+nf_conntrack_tcp_packet [nf_conntrack]
+nf_conntrack_tcp_init_net [nf_conntrack]
+udp_timeout_nlattr_to_obj [nf_conntrack]
+udp_timeout_obj_to_nlattr [nf_conntrack]
+nf_conntrack_udp_packet [nf_conntrack]
+nf_conntrack_udplite_packet [nf_conntrack]
+nf_conntrack_udp_init_net [nf_conntrack]
+icmp_timeout_nlattr_to_obj [nf_conntrack]
+icmp_timeout_obj_to_nlattr [nf_conntrack]
+icmp_tuple_to_nlattr [nf_conntrack]
+icmp_nlattr_tuple_size [nf_conntrack]
+icmp_nlattr_to_tuple [nf_conntrack]
+icmp_pkt_to_tuple [nf_conntrack]
+nf_conntrack_invert_icmp_tuple [nf_conntrack]
+nf_conntrack_icmp_packet [nf_conntrack]
+nf_conntrack_inet_error [nf_conntrack]
+nf_conntrack_icmpv4_error [nf_conntrack]
+nf_conntrack_icmp_init_net [nf_conntrack]
+nf_ct_ext_add [nf_conntrack]
+nf_ct_extend_register [nf_conntrack]
+nf_ct_extend_unregister [nf_conntrack]
+nf_ct_ext_destroy [nf_conntrack]
+nf_conntrack_acct_pernet_init [nf_conntrack]
+nf_conntrack_acct_init [nf_conntrack]
+nf_conntrack_acct_fini [nf_conntrack]
+nf_ct_seqadj_init [nf_conntrack]
+nf_ct_seq_offset [nf_conntrack]
+nf_ct_seq_adjust [nf_conntrack]
+nf_ct_seqadj_set [nf_conntrack]
+nf_ct_tcp_seqadj_set [nf_conntrack]
+nf_conntrack_seqadj_init [nf_conntrack]
+nf_conntrack_seqadj_fini [nf_conntrack]
+icmpv6_timeout_nlattr_to_obj [nf_conntrack]
+icmpv6_timeout_obj_to_nlattr [nf_conntrack]
+icmpv6_tuple_to_nlattr [nf_conntrack]
+icmpv6_nlattr_tuple_size [nf_conntrack]
+icmpv6_nlattr_to_tuple [nf_conntrack]
+icmpv6_pkt_to_tuple [nf_conntrack]
+nf_conntrack_invert_icmpv6_tuple [nf_conntrack]
+nf_conntrack_icmpv6_packet [nf_conntrack]
+nf_conntrack_icmpv6_error [nf_conntrack]
+nf_conntrack_icmpv6_init_net [nf_conntrack]
+nf_ct_untimeout [nf_conntrack]
+untimeout [nf_conntrack]
+nf_ct_set_timeout [nf_conntrack]
+nf_ct_destroy_timeout [nf_conntrack]
+nf_conntrack_timeout_init [nf_conntrack]
+nf_conntrack_timeout_fini [nf_conntrack]
+nf_conntrack_tstamp_pernet_init [nf_conntrack]
+nf_conntrack_tstamp_init [nf_conntrack]
+nf_conntrack_tstamp_fini [nf_conntrack]
+nf_conntrack_eventmask_report [nf_conntrack]
+nf_ct_deliver_cached_events [nf_conntrack]
+nf_conntrack_register_notifier [nf_conntrack]
+nf_ct_expect_register_notifier [nf_conntrack]
+nf_conntrack_unregister_notifier [nf_conntrack]
+nf_ct_expect_unregister_notifier [nf_conntrack]
+ecache_work_evict_list [nf_conntrack]
+ecache_work [nf_conntrack]
+nf_ct_expect_event_report [nf_conntrack]
+nf_conntrack_ecache_pernet_init [nf_conntrack]
+nf_conntrack_ecache_pernet_fini [nf_conntrack]
+nf_conntrack_ecache_init [nf_conntrack]
+nf_conntrack_ecache_fini [nf_conntrack]
+nf_connlabels_replace [nf_conntrack]
+nf_connlabels_get [nf_conntrack]
+nf_connlabels_put [nf_conntrack]
+nf_conntrack_labels_init [nf_conntrack]
+nf_conntrack_labels_fini [nf_conntrack]
+dccp_can_early_drop [nf_conntrack]
+dccp_new [nf_conntrack]
+dccp_timeout_nlattr_to_obj [nf_conntrack]
+dccp_timeout_obj_to_nlattr [nf_conntrack]
+nlattr_to_dccp [nf_conntrack]
+dccp_to_nlattr [nf_conntrack]
+nf_conntrack_dccp_packet [nf_conntrack]
+nf_conntrack_dccp_init_net [nf_conntrack]
+sctp_new_state [nf_conntrack]
+sctp_can_early_drop [nf_conntrack]
+sctp_timeout_nlattr_to_obj [nf_conntrack]
+sctp_timeout_obj_to_nlattr [nf_conntrack]
+sctp_to_nlattr [nf_conntrack]
+nlattr_to_sctp [nf_conntrack]
+sctp_new [nf_conntrack]
+nf_conntrack_sctp_packet [nf_conntrack]
+nf_conntrack_sctp_init_net [nf_conntrack]
+nf_ct_gre_keymap_destroy [nf_conntrack]
+gre_timeout_nlattr_to_obj [nf_conntrack]
+gre_timeout_obj_to_nlattr [nf_conntrack]
+nf_ct_gre_keymap_add [nf_conntrack]
+nf_ct_gre_keymap_flush [nf_conntrack]
+gre_pkt_to_tuple [nf_conntrack]
+nf_conntrack_gre_packet [nf_conntrack]
+nf_conntrack_gre_init_net [nf_conntrack]
+__nf_ct_resolve_clash [nf_conntrack]
+nf_ct_resolve_clash [nf_conntrack]
+nf_l4proto_log_invalid [nf_conntrack]
+nf_ct_l4proto_log_invalid [nf_conntrack]
+nf_xfrm_me_harder [nf_nat]
+nf_nat_packet [nf_nat]
+nf_ct_nat_ext_add [nf_nat]
+__nf_nat_decode_session [nf_nat]
+l4proto_in_range [nf_nat]
+nfnetlink_parse_nat [nf_nat]
+in_range [nf_nat]
+hash_by_src [nf_nat]
+get_unique_tuple [nf_nat]
+nf_nat_setup_info [nf_nat]
+__nf_nat_alloc_null_binding [nf_nat]
+nf_nat_alloc_null_binding [nf_nat]
+nf_nat_inet_fn [nf_nat]
+nfnetlink_parse_nat_setup [nf_nat]
+__nf_nat_cleanup_conntrack [nf_nat]
+nf_nat_cleanup_conntrack [nf_nat]
+nf_nat_proto_clean [nf_nat]
+nf_nat_register_fn [nf_nat]
+nf_nat_unregister_fn [nf_nat]
+nf_nat_inet_unregister_fn [nf_nat]
+nf_nat_ipv4_register_fn [nf_nat]
+nf_nat_ipv6_register_fn [nf_nat]
+nf_nat_ipv4_unregister_fn [nf_nat]
+nf_nat_ipv6_unregister_fn [nf_nat]
+nf_csum_update [nf_nat]
+__udp_manip_pkt [nf_nat]
+l4proto_manip_pkt [nf_nat]
+nf_nat_ipv6_manip_pkt [nf_nat]
+nf_nat_icmpv6_reply_translation [nf_nat]
+nf_nat_ipv6_fn [nf_nat]
+nf_nat_ipv4_manip_pkt [nf_nat]
+nf_nat_icmp_reply_translation [nf_nat]
+nf_nat_ipv4_fn [nf_nat]
+nf_nat_ipv4_local_fn [nf_nat]
+nf_nat_ipv4_out [nf_nat]
+nf_nat_ipv4_in.part.0 [nf_nat]
+nf_nat_ipv4_in [nf_nat]
+nf_nat_inet_register_fn [nf_nat]
+nf_nat_ipv6_out [nf_nat]
+nf_nat_ipv6_in [nf_nat]
+nf_nat_ipv6_local_fn [nf_nat]
+nf_nat_manip_pkt [nf_nat]
+nf_nat_csum_recalc [nf_nat]
+mangle_contents [nf_nat]
+nf_nat_follow_master [nf_nat]
+enlarge_skb.part.0 [nf_nat]
+__nf_nat_mangle_tcp_packet [nf_nat]
+nf_nat_mangle_udp_packet [nf_nat]
+nf_nat_redirect_ipv6 [nf_nat]
+nf_nat_redirect_ipv4 [nf_nat]
+device_cmp [nf_nat]
+inet_cmp [nf_nat]
+nf_nat_masquerade_ipv4 [nf_nat]
+nf_nat_masquerade_ipv6 [nf_nat]
+masq_inet_event [nf_nat]
+masq_device_event [nf_nat]
+nf_nat_masquerade_inet_register_notifiers [nf_nat]
+nf_nat_masquerade_inet_unregister_notifiers [nf_nat]
+inet6_cmp [nf_nat]
+masq_inet6_event [nf_nat]
+iterate_cleanup_work [nf_nat]
+iptable_nat_net_exit [iptable_nat]
+iptable_nat_do_chain [iptable_nat]
+iptable_nat_table_init [iptable_nat]
+iptable_nat_net_pre_exit [iptable_nat]
+iptable_mangle_net_exit [iptable_mangle]
+iptable_mangle_net_pre_exit [iptable_mangle]
+iptable_mangle_hook [iptable_mangle]
+iptable_mangle_table_init [iptable_mangle]
+ip6table_nat_net_exit [ip6table_nat]
+ip6table_nat_do_chain [ip6table_nat]
+ip6table_nat_table_init [ip6table_nat]
+ip6table_nat_net_pre_exit [ip6table_nat]
+ip6table_mangle_net_exit [ip6table_mangle]
+ip6table_mangle_net_pre_exit [ip6table_mangle]
+ip6table_mangle_hook [ip6table_mangle]
+ip6table_mangle_table_init [ip6table_mangle]
+af_alg_count_tsgl [af_alg]
+af_alg_register_type [af_alg]
+af_alg_unregister_type [af_alg]
+alg_create [af_alg]
+af_alg_alloc_tsgl [af_alg]
+af_alg_alloc_areq [af_alg]
+alg_sock_destruct [af_alg]
+alg_get_type [af_alg]
+alg_bind [af_alg]
+af_alg_poll [af_alg]
+af_alg_data_wakeup.part.0 [af_alg]
+alg_setsockopt [af_alg]
+af_alg_release_parent [af_alg]
+af_alg_accept [af_alg]
+alg_accept [af_alg]
+af_alg_wait_for_data [af_alg]
+af_alg_wait_for_wmem [af_alg]
+af_alg_sendpage [af_alg]
+af_alg_wmem_wakeup [af_alg]
+af_alg_release [af_alg]
+af_alg_make_sg [af_alg]
+af_alg_get_rsgl [af_alg]
+af_alg_free_resources [af_alg]
+af_alg_async_cb [af_alg]
+af_alg_free_sg [af_alg]
+af_alg_pull_tsgl [af_alg]
+af_alg_sendmsg [af_alg]
+skcipher_check_key [algif_skcipher]
+skcipher_sendpage_nokey [algif_skcipher]
+skcipher_sendmsg [algif_skcipher]
+skcipher_sock_destruct [algif_skcipher]
+skcipher_accept_parent_nokey [algif_skcipher]
+skcipher_accept_parent [algif_skcipher]
+skcipher_setkey [algif_skcipher]
+skcipher_release [algif_skcipher]
+skcipher_bind [algif_skcipher]
+skcipher_sendmsg_nokey [algif_skcipher]
+skcipher_recvmsg [algif_skcipher]
+skcipher_recvmsg_nokey [algif_skcipher]
+hash_check_key [algif_hash]
+hash_alloc_result [algif_hash]
+hash_free_result [algif_hash]
+hash_sock_destruct [algif_hash]
+hash_accept_parent_nokey [algif_hash]
+hash_accept_parent [algif_hash]
+hash_setkey [algif_hash]
+hash_release [algif_hash]
+hash_bind [algif_hash]
+hash_accept [algif_hash]
+hash_accept_nokey [algif_hash]
+hash_recvmsg [algif_hash]
+hash_recvmsg_nokey [algif_hash]
+hash_sendpage [algif_hash]
+hash_sendpage_nokey [algif_hash]
+hash_sendmsg [algif_hash]
+hash_sendmsg_nokey [algif_hash]
+crypto_cmac_digest_init [cmac]
+crypto_cmac_digest_setkey [cmac]
+cmac_exit_tfm [cmac]
+cmac_init_tfm [cmac]
+cmac_create [cmac]
+crypto_cmac_digest_update [cmac]
+crypto_cmac_digest_final [cmac]
+tcp_mt_check [xt_tcpudp]
+udp_mt_check [xt_tcpudp]
+udp_mt [xt_tcpudp]
+tcp_mt [xt_tcpudp]
+nf_reject_iphdr_put [nf_reject_ipv4]
+nf_reject_fill_skb_dst [nf_reject_ipv4]
+nf_send_unreach [nf_reject_ipv4]
+nf_reject_ip_tcphdr_get [nf_reject_ipv4]
+nf_reject_ip_tcphdr_put [nf_reject_ipv4]
+nf_send_reset [nf_reject_ipv4]
+reject_tg [ipt_REJECT]
+reject_tg_check [ipt_REJECT]
+conntrack_mt_destroy [xt_conntrack]
+conntrack_mt_check [xt_conntrack]
+conntrack_addrcmp [xt_conntrack]
+conntrack_mt [xt_conntrack]
+conntrack_mt_v3 [xt_conntrack]
+conntrack_mt_v2 [xt_conntrack]
+conntrack_mt_v1 [xt_conntrack]
+masquerade_tg6_checkentry [xt_MASQUERADE]
+masquerade_tg [xt_MASQUERADE]
+masquerade_tg_destroy [xt_MASQUERADE]
+masquerade_tg6 [xt_MASQUERADE]
+masquerade_tg_check [xt_MASQUERADE]
+checksum_tg_check [xt_CHECKSUM]
+checksum_tg [xt_CHECKSUM]
+rfcomm_l2data_ready [rfcomm]
+rfcomm_dlc_clear_state [rfcomm]
+rfcomm_apply_pn [rfcomm]
+rfcomm_l2state_change [rfcomm]
+rfcomm_session_timeout [rfcomm]
+rfcomm_session_clear_timer [rfcomm]
+rfcomm_session_del [rfcomm]
+rfcomm_check_security [rfcomm]
+rfcomm_send_frame [rfcomm]
+rfcomm_send_pn [rfcomm]
+rfcomm_send_msc [rfcomm]
+rfcomm_make_uih [rfcomm]
+rfcomm_dlc_debugfs_open [rfcomm]
+rfcomm_dlc_debugfs_show [rfcomm]
+rfcomm_l2sock_create [rfcomm]
+rfcomm_send_test.constprop.0 [rfcomm]
+rfcomm_send_cmd.constprop.0 [rfcomm]
+rfcomm_send_dm [rfcomm]
+rfcomm_send_sabm [rfcomm]
+rfcomm_send_ua [rfcomm]
+rfcomm_send_disc [rfcomm]
+rfcomm_dlc_set_timer [rfcomm]
+rfcomm_process_connect [rfcomm]
+__rfcomm_dlc_disconn [rfcomm]
+rfcomm_session_add [rfcomm]
+rfcomm_session_get [rfcomm]
+rfcomm_dlc_link [rfcomm]
+rfcomm_dlc_alloc [rfcomm]
+rfcomm_dlc_free [rfcomm]
+rfcomm_dlc_timeout [rfcomm]
+rfcomm_dlc_clear_timer [rfcomm]
+rfcomm_security_cfm [rfcomm]
+__rfcomm_dlc_close [rfcomm]
+rfcomm_session_close [rfcomm]
+rfcomm_dlc_open [rfcomm]
+rfcomm_dlc_close [rfcomm]
+rfcomm_dlc_exists [rfcomm]
+rfcomm_dlc_send [rfcomm]
+rfcomm_dlc_send_noerror [rfcomm]
+__rfcomm_dlc_throttle [rfcomm]
+__rfcomm_dlc_unthrottle [rfcomm]
+rfcomm_dlc_set_modem_status [rfcomm]
+rfcomm_dlc_get_modem_status [rfcomm]
+rfcomm_session_getaddr [rfcomm]
+rfcomm_send_rpn [rfcomm]
+rfcomm_dlc_accept [rfcomm]
+rfcomm_check_accept [rfcomm]
+rfcomm_run [rfcomm]
+rfcomm_sk_data_ready [rfcomm]
+rfcomm_sock_init [rfcomm]
+rfcomm_sock_debugfs_open [rfcomm]
+rfcomm_sock_debugfs_show [rfcomm]
+rfcomm_sock_recvmsg [rfcomm]
+rfcomm_sock_getsockopt [rfcomm]
+rfcomm_sock_ioctl [rfcomm]
+rfcomm_sock_compat_ioctl [rfcomm]
+rfcomm_sock_accept [rfcomm]
+rfcomm_sock_alloc.constprop.0 [rfcomm]
+rfcomm_sock_create [rfcomm]
+rfcomm_sock_kill [rfcomm]
+rfcomm_sk_state_change [rfcomm]
+__rfcomm_sock_close [rfcomm]
+rfcomm_sock_shutdown [rfcomm]
+rfcomm_sock_release [rfcomm]
+rfcomm_sock_destruct [rfcomm]
+__rfcomm_get_listen_sock_by_addr [rfcomm]
+rfcomm_sock_listen [rfcomm]
+rfcomm_sock_bind [rfcomm]
+rfcomm_sock_sendmsg [rfcomm]
+rfcomm_sock_getname [rfcomm]
+rfcomm_sock_connect [rfcomm]
+rfcomm_sock_setsockopt [rfcomm]
+rfcomm_connect_ind [rfcomm]
+rfcomm_dev_carrier_raised [rfcomm]
+rfcomm_tty_tiocmget [rfcomm]
+rfcomm_tty_chars_in_buffer [rfcomm]
+rfcomm_tty_write_room [rfcomm]
+rfcomm_tty_ioctl [rfcomm]
+show_channel [rfcomm]
+show_address [rfcomm]
+rfcomm_dev_modem_status [rfcomm]
+rfcomm_dev_data_ready [rfcomm]
+rfcomm_dev_shutdown [rfcomm]
+rfcomm_tty_tiocmset [rfcomm]
+rfcomm_tty_cleanup [rfcomm]
+rfcomm_tty_flush_buffer [rfcomm]
+rfcomm_tty_hangup [rfcomm]
+rfcomm_tty_set_termios [rfcomm]
+rfcomm_wfree [rfcomm]
+rfcomm_tty_close [rfcomm]
+rfcomm_tty_open [rfcomm]
+rfcomm_tty_send_xchar [rfcomm]
+rfcomm_tty_wait_until_sent [rfcomm]
+rfcomm_dev_activate [rfcomm]
+rfcomm_reparent_device [rfcomm]
+rfcomm_dev_state_change [rfcomm]
+rfcomm_dev_get [rfcomm]
+rfcomm_tty_install [rfcomm]
+rfcomm_dev_destruct [rfcomm]
+rfcomm_tty_throttle [rfcomm]
+rfcomm_tty_unthrottle [rfcomm]
+rfcomm_tty_write [rfcomm]
+rfcomm_dev_ioctl [rfcomm]
+rfcomm_cleanup_ttys [rfcomm]
+ledtrig_audio_get [ledtrig_audio]
+ledtrig_audio_set [ledtrig_audio]
+snd_hda_gen_spec_init [snd_hda_codec_generic]
+get_nid_path [snd_hda_codec_generic]
+snd_hda_get_path_idx [snd_hda_codec_generic]
+snd_hda_get_path_from_idx [snd_hda_codec_generic]
+is_active_nid [snd_hda_codec_generic]
+get_default_ch_nums [snd_hda_codec_generic]
+get_line_out_pfx [snd_hda_codec_generic]
+indep_hp_possible [snd_hda_codec_generic]
+refill_shared_dacs [snd_hda_codec_generic]
+indep_hp_get [snd_hda_codec_generic]
+ch_mode_get [snd_hda_codec_generic]
+get_input_path [snd_hda_codec_generic]
+mux_enum_get [snd_hda_codec_generic]
+micmute_led_mode_get [snd_hda_codec_generic]
+automute_mode_get [snd_hda_codec_generic]
+compare_attr [snd_hda_codec_generic]
+capture_pcm_open [snd_hda_codec_generic]
+capture_pcm_close [snd_hda_codec_generic]
+setup_pcm_stream [snd_hda_codec_generic]
+snd_hda_gen_add_kctl [snd_hda_codec_generic]
+invalidate_nid_path [snd_hda_codec_generic]
+snd_hda_gen_fix_pin_power [snd_hda_codec_generic]
+add_fake_paths [snd_hda_codec_generic]
+__parse_nid_path [snd_hda_codec_generic]
+path_power_update [snd_hda_codec_generic]
+set_path_power [snd_hda_codec_generic]
+snd_hda_gen_stream_pm [snd_hda_codec_generic]
+beep_power_hook [snd_hda_codec_generic]
+is_stereo_amps [snd_hda_codec_generic]
+init_amp [snd_hda_codec_generic]
+update_amp [snd_hda_codec_generic]
+activate_amp [snd_hda_codec_generic]
+vmaster_update_mute_led [snd_hda_codec_generic]
+call_micmute_led_update [snd_hda_codec_generic]
+micmute_led_mode_put [snd_hda_codec_generic]
+create_mute_led_cdev [snd_hda_codec_generic]
+snd_hda_gen_add_mute_led_cdev [snd_hda_codec_generic]
+snd_hda_gen_add_micmute_led_cdev [snd_hda_codec_generic]
+micmute_led_mode_info [snd_hda_codec_generic]
+sync_auto_mute_bits [snd_hda_codec_generic]
+update_micmute_led [snd_hda_codec_generic]
+out_jack_mode_get [snd_hda_codec_generic]
+set_pin_eapd [snd_hda_codec_generic]
+in_jack_mode_get [snd_hda_codec_generic]
+detect_pin_state [snd_hda_codec_generic]
+detect_jacks [snd_hda_codec_generic]
+in_jack_mode_put [snd_hda_codec_generic]
+out_jack_mode_put [snd_hda_codec_generic]
+alt_capture_pcm_cleanup [snd_hda_codec_generic]
+alt_playback_pcm_cleanup [snd_hda_codec_generic]
+capture_pcm_cleanup [snd_hda_codec_generic]
+dyn_adc_capture_pcm_cleanup [snd_hda_codec_generic]
+alt_capture_pcm_prepare [snd_hda_codec_generic]
+alt_playback_pcm_prepare [snd_hda_codec_generic]
+capture_pcm_prepare [snd_hda_codec_generic]
+dyn_adc_capture_pcm_prepare [snd_hda_codec_generic]
+free_kctls [snd_hda_codec_generic]
+look_for_out_vol_nid [snd_hda_codec_generic]
+assign_out_path_ctls [snd_hda_codec_generic]
+check_boost_vol [snd_hda_codec_generic]
+can_be_multiio_pin [snd_hda_codec_generic]
+count_multiio_pins [snd_hda_codec_generic]
+print_nid_path [snd_hda_codec_generic]
+ch_mode_info [snd_hda_codec_generic]
+add_single_cap_ctl [snd_hda_codec_generic]
+hda_gen_mixer_mute_put [snd_hda_codec_generic]
+cap_single_sw_put [snd_hda_codec_generic]
+hda_gen_bind_mute_put [snd_hda_codec_generic]
+hda_gen_bind_mute_get [snd_hda_codec_generic]
+cap_put_caller [snd_hda_codec_generic]
+cap_sw_put [snd_hda_codec_generic]
+cap_vol_put [snd_hda_codec_generic]
+alt_playback_pcm_close [snd_hda_codec_generic]
+alt_playback_pcm_open [snd_hda_codec_generic]
+playback_pcm_close [snd_hda_codec_generic]
+indep_hp_info [snd_hda_codec_generic]
+out_jack_mode_info [snd_hda_codec_generic]
+in_jack_mode_info [snd_hda_codec_generic]
+add_pin_power_ctls [snd_hda_codec_generic]
+add_all_pin_power_ctls [snd_hda_codec_generic]
+mux_enum_info [snd_hda_codec_generic]
+snd_hda_gen_build_controls [snd_hda_codec_generic]
+dig_playback_pcm_cleanup [snd_hda_codec_generic]
+dig_playback_pcm_prepare [snd_hda_codec_generic]
+dig_playback_pcm_close [snd_hda_codec_generic]
+dig_playback_pcm_open [snd_hda_codec_generic]
+playback_pcm_cleanup [snd_hda_codec_generic]
+playback_pcm_prepare [snd_hda_codec_generic]
+playback_pcm_open [snd_hda_codec_generic]
+snd_hda_gen_free [snd_hda_codec_generic]
+snd_hda_gen_reboot_notify [snd_hda_codec_generic]
+snd_hda_gen_check_power_status [snd_hda_codec_generic]
+loopback_mixing_get [snd_hda_codec_generic]
+is_reachable_path.part.0 [snd_hda_codec_generic]
+get_dac_if_single [snd_hda_codec_generic]
+look_for_dac [snd_hda_codec_generic]
+snd_hda_add_new_path [snd_hda_codec_generic]
+map_singles [snd_hda_codec_generic]
+check_aamix_out_path [snd_hda_codec_generic]
+fill_multi_ios [snd_hda_codec_generic]
+try_assign_dacs [snd_hda_codec_generic]
+fill_and_eval_dacs [snd_hda_codec_generic]
+parse_capture_source [snd_hda_codec_generic]
+snd_hda_gen_path_power_filter [snd_hda_codec_generic]
+get_in_jack_num_items.part.0 [snd_hda_codec_generic]
+get_out_jack_num_items.part.0 [snd_hda_codec_generic]
+get_cur_hp_mic_jack_mode [snd_hda_codec_generic]
+hp_mic_jack_mode_get [snd_hda_codec_generic]
+hp_mic_jack_mode_info [snd_hda_codec_generic]
+set_pin_target.part.0 [snd_hda_codec_generic]
+set_pin_targets [snd_hda_codec_generic]
+pin_power_callback [snd_hda_codec_generic]
+pin_power_down_callback [snd_hda_codec_generic]
+pin_power_up_callback [snd_hda_codec_generic]
+automute_mode_info [snd_hda_codec_generic]
+is_inv_dmic_pin [snd_hda_codec_generic]
+fill_pcm_stream_name.part.0.constprop.0 [snd_hda_codec_generic]
+snd_hda_gen_build_pcms [snd_hda_codec_generic]
+get_jack_mode_name.constprop.0 [snd_hda_codec_generic]
+create_out_jack_modes [snd_hda_codec_generic]
+do_automute.constprop.0 [snd_hda_codec_generic]
+snd_hda_gen_update_outputs [snd_hda_codec_generic]
+call_update_outputs [snd_hda_codec_generic]
+snd_hda_gen_hp_automute [snd_hda_codec_generic]
+call_hp_automute [snd_hda_codec_generic]
+hp_mic_jack_mode_put [snd_hda_codec_generic]
+update_hp_mic [snd_hda_codec_generic]
+snd_hda_gen_line_automute [snd_hda_codec_generic]
+call_line_automute [snd_hda_codec_generic]
+automute_mode_put [snd_hda_codec_generic]
+add_control_with_pfx.constprop.0 [snd_hda_codec_generic]
+add_sw_ctl [snd_hda_codec_generic]
+add_vol_ctl [snd_hda_codec_generic]
+same_amp_caps.constprop.0 [snd_hda_codec_generic]
+sync_pin_power_ctls [snd_hda_codec_generic]
+create_extra_outs [snd_hda_codec_generic]
+snd_hda_activate_path [snd_hda_codec_generic]
+resume_path_from_idx [snd_hda_codec_generic]
+set_output_and_unmute [snd_hda_codec_generic]
+update_output_paths [snd_hda_codec_generic]
+path_power_down_sync [snd_hda_codec_generic]
+mux_select [snd_hda_codec_generic]
+snd_hda_gen_mic_autoswitch [snd_hda_codec_generic]
+call_mic_autoswitch [snd_hda_codec_generic]
+update_automute_all [snd_hda_codec_generic]
+mux_enum_put [snd_hda_codec_generic]
+update_aamix_paths [snd_hda_codec_generic]
+loopback_mixing_put [snd_hda_codec_generic]
+indep_hp_put [snd_hda_codec_generic]
+ch_mode_put [snd_hda_codec_generic]
+snd_hda_gen_init [snd_hda_codec_generic]
+debug_show_configs [snd_hda_codec_generic]
+snd_hda_gen_parse_auto_config [snd_hda_codec_generic]
+snd_hda_parse_generic_codec [snd_hda_codec_generic]
+alc225_fixup_s3_pop_noise [snd_hda_codec_realtek]
+alc_fixup_no_jack_detect [snd_hda_codec_realtek]
+alc880_unsol_event [snd_hda_codec_realtek]
+alc_read_coefex_idx [snd_hda_codec_realtek]
+alc_write_coefex_idx [snd_hda_codec_realtek]
+alc_update_coefex_idx [snd_hda_codec_realtek]
+alc5505_coef_get [snd_hda_codec_realtek]
+alc5505_coef_set [snd_hda_codec_realtek]
+alc5505_dsp_halt [snd_hda_codec_realtek]
+alc5505_dsp_init [snd_hda_codec_realtek]
+alc_build_controls [snd_hda_codec_realtek]
+alc_update_headset_jack_cb [snd_hda_codec_realtek]
+alc269_quanta_automute [snd_hda_codec_realtek]
+set_eapd [snd_hda_codec_realtek]
+alc_fixup_sku_ignore [snd_hda_codec_realtek]
+alc_fixup_no_depop_delay [snd_hda_codec_realtek]
+alc_fixup_inv_dmic [snd_hda_codec_realtek]
+alc260_fixup_fsc_s7020 [snd_hda_codec_realtek]
+alc260_fixup_fsc_s7020_jwse [snd_hda_codec_realtek]
+alc882_fixup_no_primary_hp [snd_hda_codec_realtek]
+alc_headset_btn_callback [snd_hda_codec_realtek]
+alc269_fixup_pincfg_no_hp_to_lineout [snd_hda_codec_realtek]
+alc269_fixup_headset_mic [snd_hda_codec_realtek]
+alc269_fixup_pcm_44k [snd_hda_codec_realtek]
+alc269_fixup_quanta_mute [snd_hda_codec_realtek]
+alc269_fixup_x101_headset_mic [snd_hda_codec_realtek]
+alc_fixup_auto_mute_via_amp [snd_hda_codec_realtek]
+alc_fixup_no_shutup [snd_hda_codec_realtek]
+alc_fixup_disable_aamix [snd_hda_codec_realtek]
+alc_fixup_tpt470_dacs [snd_hda_codec_realtek]
+alc275_fixup_gpio4_off [snd_hda_codec_realtek]
+alc274_fixup_bind_dacs [snd_hda_codec_realtek]
+alc289_fixup_asus_ga401 [snd_hda_codec_realtek]
+alc_fixup_bass_chmap [snd_hda_codec_realtek]
+gpio_led_power_filter [snd_hda_codec_realtek]
+alc662_fixup_usi_headset_mic [snd_hda_codec_realtek]
+alc260_fixup_gpio1_toggle [snd_hda_codec_realtek]
+find_ext_mic_pin [snd_hda_codec_realtek]
+alc_shutup_pins [snd_hda_codec_realtek]
+alc_reboot_notify [snd_hda_codec_realtek]
+alc_resume [snd_hda_codec_realtek]
+alc_get_coef0 [snd_hda_codec_realtek]
+alc_fix_pll [snd_hda_codec_realtek]
+alc_fill_eapd_coef [snd_hda_codec_realtek]
+coef_mute_led_set [snd_hda_codec_realtek]
+alc269_shutup [snd_hda_codec_realtek]
+alc_process_coef_fw [snd_hda_codec_realtek]
+alc668_restore_default_value [snd_hda_codec_realtek]
+alc255_set_default_jack_type [snd_hda_codec_realtek]
+alc_update_gpio_data [snd_hda_codec_realtek]
+micmute_led_set [snd_hda_codec_realtek]
+gpio_mute_led_set [snd_hda_codec_realtek]
+alc260_gpio1_automute [snd_hda_codec_realtek]
+alc269_resume [snd_hda_codec_realtek]
+alc_power_eapd [snd_hda_codec_realtek]
+alc_eapd_shutup [snd_hda_codec_realtek]
+alc288_update_headset_jack_cb [snd_hda_codec_realtek]
+alc662_usi_automute_hook [snd_hda_codec_realtek]
+alc280_hp_gpio4_automute_hook [snd_hda_codec_realtek]
+alc283_hp_automute_hook [snd_hda_codec_realtek]
+alc269_x101_hp_automute_hook [snd_hda_codec_realtek]
+alc887_asus_hp_automute_hook [snd_hda_codec_realtek]
+alc887_fixup_asus_jack [snd_hda_codec_realtek]
+asus_tx300_automute [snd_hda_codec_realtek]
+rename_ctl [snd_hda_codec_realtek]
+alc889_fixup_mac_pins [snd_hda_codec_realtek]
+alc889_fixup_mbp_vref [snd_hda_codec_realtek]
+alc861_fixup_asus_amp_vref_0f [snd_hda_codec_realtek]
+alc_auto_parse_customize_define [snd_hda_codec_realtek]
+alc260_fixup_kn1 [snd_hda_codec_realtek]
+alc_fixup_tpt440_dock [snd_hda_codec_realtek]
+alc_fixup_dell_xps13 [snd_hda_codec_realtek]
+alc269_fixup_limit_int_mic_boost [snd_hda_codec_realtek]
+alc269_fixup_hp_mute_led_mic3 [snd_hda_codec_realtek]
+alc269_fixup_hp_mute_led_mic2 [snd_hda_codec_realtek]
+alc269_fixup_hp_mute_led_mic1 [snd_hda_codec_realtek]
+alc_fixup_micmute_led [snd_hda_codec_realtek]
+alc269_fixup_hp_line1_mic1_led [snd_hda_codec_realtek]
+alc268_beep_switch_put [snd_hda_codec_realtek]
+gpio2_mic_hotkey_event [snd_hda_codec_realtek]
+alc_register_micmute_input_device [snd_hda_codec_realtek]
+alc269_fixup_hp_mute_led [snd_hda_codec_realtek]
+alc269_fixup_pincfg_U7x7_headset_mic [snd_hda_codec_realtek]
+alc271_fixup_dmic [snd_hda_codec_realtek]
+alc_init [snd_hda_codec_realtek]
+alc880_fixup_vol_knob [snd_hda_codec_realtek]
+alc889_fixup_coef [snd_hda_codec_realtek]
+alc269_fixup_stereo_dmic [snd_hda_codec_realtek]
+alc269_fixup_hweq [snd_hda_codec_realtek]
+alc285_fixup_hp_gpio_amp_init [snd_hda_codec_realtek]
+alc662_aspire_ethos_mute_speakers [snd_hda_codec_realtek]
+alc294_gx502_toggle_output [snd_hda_codec_realtek]
+alc1220_fixup_clevo_p950.part.0 [snd_hda_codec_realtek]
+alc1220_fixup_clevo_p950 [snd_hda_codec_realtek]
+alc889_fixup_dac_route [snd_hda_codec_realtek]
+alc298_fixup_speaker_volume [snd_hda_codec_realtek]
+alc285_fixup_speaker2_to_dac1 [snd_hda_codec_realtek]
+alc290_fixup_mono_speakers [snd_hda_codec_realtek]
+alc285_fixup_invalidate_dacs [snd_hda_codec_realtek]
+alc_fixup_gpio.part.0 [snd_hda_codec_realtek]
+alc_fixup_gpio1 [snd_hda_codec_realtek]
+alc_fixup_gpio2 [snd_hda_codec_realtek]
+alc_fixup_gpio3 [snd_hda_codec_realtek]
+alc_fixup_gpio4 [snd_hda_codec_realtek]
+alc885_fixup_macpro_gpio [snd_hda_codec_realtek]
+alc660vd_fixup_asus_gpio1 [snd_hda_codec_realtek]
+alc_fixup_hp_gpio_led [snd_hda_codec_realtek]
+alc662_fixup_led_gpio1 [snd_hda_codec_realtek]
+alc287_fixup_hp_gpio_led [snd_hda_codec_realtek]
+alc285_fixup_hp_gpio_led [snd_hda_codec_realtek]
+alc280_fixup_hp_9480m [snd_hda_codec_realtek]
+alc286_fixup_hp_gpio_led [snd_hda_codec_realtek]
+alc269_fixup_hp_gpio_led [snd_hda_codec_realtek]
+alc280_fixup_hp_gpio4 [snd_hda_codec_realtek]
+alc269_fixup_hp_gpio_mic1_led [snd_hda_codec_realtek]
+alc280_fixup_hp_gpio2_mic_hotkey [snd_hda_codec_realtek]
+alc_shutup_dell_xps13 [snd_hda_codec_realtek]
+alc1220_fixup_gb_dual_codecs.part.0 [snd_hda_codec_realtek]
+alc1220_fixup_gb_dual_codecs [snd_hda_codec_realtek]
+alc233_alc662_fixup_lenovo_dual_codecs [snd_hda_codec_realtek]
+alc_combo_jack_hp_jd_restart [snd_hda_codec_realtek]
+alc274_fixup_hp_headset_mic [snd_hda_codec_realtek]
+alc_fixup_no_int_mic [snd_hda_codec_realtek]
+alc295_fixup_chromebook [snd_hda_codec_realtek]
+alc283_fixup_sense_combo_jack [snd_hda_codec_realtek]
+alc283_fixup_chromebook [snd_hda_codec_realtek]
+alc_enable_headset_jack_key [snd_hda_codec_realtek]
+alc_fixup_headset_jack [snd_hda_codec_realtek]
+alc269_fill_coef.part.0 [snd_hda_codec_realtek]
+alc269_fill_coef [snd_hda_codec_realtek]
+alc298_fixup_huawei_mbx_stereo [snd_hda_codec_realtek]
+alc285_fixup_thinkpad_x1_gen7 [snd_hda_codec_realtek]
+alc889_fixup_mba21_vref [snd_hda_codec_realtek]
+alc889_fixup_mba11_vref [snd_hda_codec_realtek]
+alc889_fixup_imac91_vref [snd_hda_codec_realtek]
+alc861vd_fixup_dallas [snd_hda_codec_realtek]
+alc671_fixup_hp_headset_mic2 [snd_hda_codec_realtek]
+alc295_fixup_hp_top_speakers [snd_hda_codec_realtek]
+alc_fixup_tpt470_dock [snd_hda_codec_realtek]
+alc282_fixup_asus_tx300 [snd_hda_codec_realtek]
+alc662_fixup_aspire_ethos_hp [snd_hda_codec_realtek]
+alc294_fixup_gx502_hp [snd_hda_codec_realtek]
+alc_fixup_disable_mic_vref [snd_hda_codec_realtek]
+alc272_fixup_mario [snd_hda_codec_realtek]
+alc236_fixup_hp_mute_led [snd_hda_codec_realtek]
+alc285_fixup_hp_mute_led [snd_hda_codec_realtek]
+alc233_fixup_lenovo_line2_mic_hotkey [snd_hda_codec_realtek]
+led_power_filter [snd_hda_codec_realtek]
+alc_update_vref_led.part.0 [snd_hda_codec_realtek]
+vref_micmute_led_set [snd_hda_codec_realtek]
+vref_mute_led_set [snd_hda_codec_realtek]
+alc_fixup_thinkpad_acpi [snd_hda_codec_realtek]
+alc271_hp_gate_mic_jack [snd_hda_codec_realtek]
+alc_parse_auto_config [snd_hda_codec_realtek]
+alc282_init [snd_hda_codec_realtek]
+alc282_shutup [snd_hda_codec_realtek]
+alc283_init [snd_hda_codec_realtek]
+alc283_shutup [snd_hda_codec_realtek]
+alc256_init [snd_hda_codec_realtek]
+alc256_shutup [snd_hda_codec_realtek]
+alc225_init [snd_hda_codec_realtek]
+alc225_shutup [snd_hda_codec_realtek]
+alc_default_init [snd_hda_codec_realtek]
+alc_default_shutup [snd_hda_codec_realtek]
+alc294_init [snd_hda_codec_realtek]
+alc_update_headset_mode [snd_hda_codec_realtek]
+alc_update_headset_mode_hook [snd_hda_codec_realtek]
+alc_fixup_headset_mode [snd_hda_codec_realtek]
+alc_fixup_headset_mode_alc668 [snd_hda_codec_realtek]
+alc_fixup_headset_mode_alc255 [snd_hda_codec_realtek]
+alc1220_fixup_clevo_pb51ed [snd_hda_codec_realtek]
+alc_fixup_headset_mode_alc662 [snd_hda_codec_realtek]
+alc_fixup_headset_mode_dell_alc288 [snd_hda_codec_realtek]
+alc_fixup_headset_mode_alc255_no_hp_mic [snd_hda_codec_realtek]
+alc_fixup_headset_mode_no_hp_mic [snd_hda_codec_realtek]
+alc_alloc_spec [snd_hda_codec_realtek]
+patch_alc680 [snd_hda_codec_realtek]
+patch_alc880 [snd_hda_codec_realtek]
+patch_alc260 [snd_hda_codec_realtek]
+patch_alc882 [snd_hda_codec_realtek]
+patch_alc861vd [snd_hda_codec_realtek]
+patch_alc861 [snd_hda_codec_realtek]
+patch_alc262 [snd_hda_codec_realtek]
+patch_alc662 [snd_hda_codec_realtek]
+patch_alc269 [snd_hda_codec_realtek]
+patch_alc268 [snd_hda_codec_realtek]
+alc_update_knob_master [snd_hda_codec_realtek]
+alc295_fixup_disable_dac3 [snd_hda_codec_realtek]
+coef_micmute_led_set [snd_hda_codec_realtek]
+alc_suspend [snd_hda_codec_realtek]
+alc269_suspend [snd_hda_codec_realtek]
+nvhdmi_pin2port [snd_hda_codec_hdmi]
+nvhdmi_port2pin [snd_hda_codec_hdmi]
+atihdmi_pin2port [snd_hda_codec_hdmi]
+atihdmi_port2pin [snd_hda_codec_hdmi]
+nvhdmi_8ch_7x_set_info_frame_parameters [snd_hda_codec_hdmi]
+atihdmi_pin_setup_infoframe [snd_hda_codec_hdmi]
+haswell_verify_D0 [snd_hda_codec_hdmi]
+tegra_hdmi_set_format [snd_hda_codec_hdmi]
+atihdmi_pin_hbr_setup [snd_hda_codec_hdmi]
+hdmi_choose_cvt [snd_hda_codec_hdmi]
+hdmi_get_spk_alloc [snd_hda_codec_hdmi]
+is_hdmi_pcm_attached [snd_hda_codec_hdmi]
+free_hdmi_jack_priv [snd_hda_codec_hdmi]
+match_bound_vga [snd_hda_codec_hdmi]
+nvhdmi_chmap_cea_alloc_validate_get_type [snd_hda_codec_hdmi]
+atihdmi_pin_set_slot_channel [snd_hda_codec_hdmi]
+atihdmi_pin_get_slot_channel [snd_hda_codec_hdmi]
+intel_not_share_assigned_cvt [snd_hda_codec_hdmi]
+check_non_pcm_per_cvt [snd_hda_codec_hdmi]
+nvhdmi_8ch_7x_pcm_prepare [snd_hda_codec_hdmi]
+hdmi_get_chmap [snd_hda_codec_hdmi]
+hinfo_to_pcm_index [snd_hda_codec_hdmi]
+generic_spec_free [snd_hda_codec_hdmi]
+simple_playback_free [snd_hda_codec_hdmi]
+generic_hdmi_build_pcms [snd_hda_codec_hdmi]
+tegra_hdmi_build_pcms [snd_hda_codec_hdmi]
+simple_playback_build_pcms [snd_hda_codec_hdmi]
+nvhdmi_7x_8ch_build_pcms [snd_hda_codec_hdmi]
+generic_hdmi_playback_pcm_cleanup [snd_hda_codec_hdmi]
+tegra_hdmi_pcm_cleanup [snd_hda_codec_hdmi]
+hdmi_pin_hbr_setup [snd_hda_codec_hdmi]
+hdmi_pin_get_eld [snd_hda_codec_hdmi]
+generic_acomp_notifier_set [snd_hda_codec_hdmi]
+generic_acomp_master_unbind [snd_hda_codec_hdmi]
+generic_acomp_master_bind [snd_hda_codec_hdmi]
+write_eld_info [snd_hda_codec_hdmi]
+print_eld_info [snd_hda_codec_hdmi]
+generic_hdmi_init_per_pins [snd_hda_codec_hdmi]
+intel_haswell_enable_all_pins [snd_hda_codec_hdmi]
+intel_haswell_fixup_enable_dp12 [snd_hda_codec_hdmi]
+haswell_set_power_state [snd_hda_codec_hdmi]
+simple_hdmi_unsol_event [snd_hda_codec_hdmi]
+simple_playback_init [snd_hda_codec_hdmi]
+simple_playback_pcm_prepare [snd_hda_codec_hdmi]
+simple_playback_pcm_close [snd_hda_codec_hdmi]
+nvhdmi_8ch_7x_pcm_close [snd_hda_codec_hdmi]
+simple_playback_pcm_open [snd_hda_codec_hdmi]
+nvhdmi_7x_init_8ch [snd_hda_codec_hdmi]
+nvhdmi_7x_init_2ch [snd_hda_codec_hdmi]
+atihdmi_paired_chmap_validate [snd_hda_codec_hdmi]
+atihdmi_paired_cea_alloc_to_tlv_chmap [snd_hda_codec_hdmi]
+atihdmi_pin_get_eld [snd_hda_codec_hdmi]
+generic_hdmi_init [snd_hda_codec_hdmi]
+atihdmi_init [snd_hda_codec_hdmi]
+hdmi_eld_ctl_get [snd_hda_codec_hdmi]
+hdmi_eld_ctl_info [snd_hda_codec_hdmi]
+hdmi_setup_audio_infoframe [snd_hda_codec_hdmi]
+hdmi_set_chmap [snd_hda_codec_hdmi]
+generic_hdmi_free [snd_hda_codec_hdmi]
+hdmi_setup_stream [snd_hda_codec_hdmi]
+i915_hsw_setup_stream [snd_hda_codec_hdmi]
+atihdmi_setup_stream [snd_hda_codec_hdmi]
+generic_hdmi_build_jack [snd_hda_codec_hdmi]
+hdmi_parse_codec [snd_hda_codec_hdmi]
+parse_intel_hdmi [snd_hda_codec_hdmi]
+generic_acomp_init [snd_hda_codec_hdmi]
+update_eld [snd_hda_codec_hdmi]
+hdmi_present_sense [snd_hda_codec_hdmi]
+generic_hdmi_resume [snd_hda_codec_hdmi]
+check_presence_and_report [snd_hda_codec_hdmi]
+hdmi_unsol_event [snd_hda_codec_hdmi]
+generic_acomp_pin_eld_notify [snd_hda_codec_hdmi]
+hdmi_repoll_eld [snd_hda_codec_hdmi]
+intel_port2pin [snd_hda_codec_hdmi]
+intel_pin_eld_notify [snd_hda_codec_hdmi]
+nvhdmi_chmap_validate [snd_hda_codec_hdmi]
+atihdmi_paired_chmap_cea_alloc_validate_get_type [snd_hda_codec_hdmi]
+intel_pin2port [snd_hda_codec_hdmi]
+hinfo_to_pin_index [snd_hda_codec_hdmi]
+generic_hdmi_playback_pcm_prepare [snd_hda_codec_hdmi]
+tegra_hdmi_pcm_prepare [snd_hda_codec_hdmi]
+jack_callback [snd_hda_codec_hdmi]
+simple_playback_build_controls [snd_hda_codec_hdmi]
+nvhdmi_7x_8ch_build_controls [snd_hda_codec_hdmi]
+i915_pin_cvt_fixup [snd_hda_codec_hdmi]
+hdmi_pin_setup_infoframe [snd_hda_codec_hdmi]
+patch_simple_hdmi [snd_hda_codec_hdmi]
+patch_via_hdmi [snd_hda_codec_hdmi]
+patch_nvhdmi_2ch [snd_hda_codec_hdmi]
+patch_nvhdmi_8ch_7x [snd_hda_codec_hdmi]
+alloc_generic_hdmi [snd_hda_codec_hdmi]
+alloc_intel_hdmi [snd_hda_codec_hdmi]
+patch_i915_byt_hdmi [snd_hda_codec_hdmi]
+patch_i915_cpt_hdmi [snd_hda_codec_hdmi]
+intel_hsw_common_init [snd_hda_codec_hdmi]
+patch_i915_tgl_hdmi [snd_hda_codec_hdmi]
+patch_i915_icl_hdmi [snd_hda_codec_hdmi]
+patch_i915_hsw_hdmi [snd_hda_codec_hdmi]
+patch_i915_glk_hdmi [snd_hda_codec_hdmi]
+patch_generic_hdmi [snd_hda_codec_hdmi]
+patch_tegra_hdmi [snd_hda_codec_hdmi]
+patch_nvhdmi_legacy [snd_hda_codec_hdmi]
+patch_atihdmi [snd_hda_codec_hdmi]
+patch_nvhdmi [snd_hda_codec_hdmi]
+hdmi_pcm_close [snd_hda_codec_hdmi]
+generic_hdmi_build_controls [snd_hda_codec_hdmi]
+hdmi_pcm_open [snd_hda_codec_hdmi]
+hdmi_print_pcm_rates.constprop.0 [snd_hda_codec_hdmi]
+hdmi_print_sad_info [snd_hda_codec_hdmi]
+hdmi_show_short_audio_desc [snd_hda_codec_hdmi]
+snd_hdmi_parse_eld [snd_hda_codec_hdmi]
+snd_hdmi_get_eld_size [snd_hda_codec_hdmi]
+snd_hdmi_get_eld [snd_hda_codec_hdmi]
+snd_hdmi_show_eld [snd_hda_codec_hdmi]
+snd_hdmi_print_eld_info [snd_hda_codec_hdmi]
+snd_hdmi_write_eld_info [snd_hda_codec_hdmi]
+snd_hdmi_eld_update_pcm_info [snd_hda_codec_hdmi]
+snd_hdmi_get_eld_ati [snd_hda_codec_hdmi]
diff --color -ruN -w -B '--exclude-from=.diff-exclude' linux-5.10/ftrace-pgfault-latency-tracker/.gitignore HawkEye-5.10-cow/ftrace-pgfault-latency-tracker/.gitignore
--- linux-5.10/ftrace-pgfault-latency-tracker/.gitignore	1970-01-01 00:00:00.000000000 +0000
+++ HawkEye-5.10-cow/ftrace-pgfault-latency-tracker/.gitignore	2025-03-23 07:54:12.348209908 +0000
@@ -0,0 +1,3 @@
+faultpages
+log
+tracer
diff --color -ruN -w -B '--exclude-from=.diff-exclude' linux-5.10/ftrace-pgfault-latency-tracker/log HawkEye-5.10-cow/ftrace-pgfault-latency-tracker/log
--- linux-5.10/ftrace-pgfault-latency-tracker/log	1970-01-01 00:00:00.000000000 +0000
+++ HawkEye-5.10-cow/ftrace-pgfault-latency-tracker/log	2025-03-23 07:54:12.293894518 +0000
@@ -0,0 +1,685 @@
+            |  handle_mm_fault() {
+648.086 us  |  } /* handle_mm_fault */
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
+            |  handle_mm_fault() {
diff --color -ruN -w -B '--exclude-from=.diff-exclude' linux-5.10/ftrace-pgfault-latency-tracker/Makefile HawkEye-5.10-cow/ftrace-pgfault-latency-tracker/Makefile
--- linux-5.10/ftrace-pgfault-latency-tracker/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ HawkEye-5.10-cow/ftrace-pgfault-latency-tracker/Makefile	2025-03-23 07:54:12.347892657 +0000
@@ -0,0 +1,10 @@
+CONFIG_MODULE_SIG=n
+all: vm-pgfault
+
+vm-pgfault: vm-pgfault.c vm-pgfault-tracer.c
+	gcc -o faultpages vm-pgfault.c -lpthread
+	gcc -o tracer vm-pgfault-tracer.c -lpthread
+
+clean:
+	@rm -f vm-pagefault
+	@rm -f tracer
diff --color -ruN -w -B '--exclude-from=.diff-exclude' linux-5.10/ftrace-pgfault-latency-tracker/README HawkEye-5.10-cow/ftrace-pgfault-latency-tracker/README
--- linux-5.10/ftrace-pgfault-latency-tracker/README	1970-01-01 00:00:00.000000000 +0000
+++ HawkEye-5.10-cow/ftrace-pgfault-latency-tracker/README	2025-03-23 07:54:12.350209822 +0000
@@ -0,0 +1,7 @@
+This program is designed to stress the page fault handling routine of the
+underlying OS. This can be configure with the following command-line
+arguments -
+
+m: total memory to be allocated (in GB)
+t: number of threads
+i: iterations (this will influence the total runtime).
Binary files linux-5.10/ftrace-pgfault-latency-tracker/tracer and HawkEye-5.10-cow/ftrace-pgfault-latency-tracker/tracer differ
diff --color -ruN -w -B '--exclude-from=.diff-exclude' linux-5.10/ftrace-pgfault-latency-tracker/vm-pgfault.c HawkEye-5.10-cow/ftrace-pgfault-latency-tracker/vm-pgfault.c
--- linux-5.10/ftrace-pgfault-latency-tracker/vm-pgfault.c	1970-01-01 00:00:00.000000000 +0000
+++ HawkEye-5.10-cow/ftrace-pgfault-latency-tracker/vm-pgfault.c	2025-03-23 07:54:12.296526190 +0000
@@ -0,0 +1,92 @@
+#include <pthread.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/mman.h>
+
+int nr_threads = 1;
+int iterations = 1;
+unsigned long memory = 1;
+unsigned long bytes_per_thread = 1;
+
+void *alloc_mem(void *arg)
+{
+	int fd, nr_pages, iter = 0;
+	char *tmp, *start;
+
+	while(iter < iterations) {
+		/* Allocate required bytes */
+#if 0
+		tmp = mmap(NULL, bytes_per_thread, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
+		if (tmp == MAP_FAILED) {
+			printf("mmap failed\n");
+			return NULL;
+		}
+#endif
+		tmp = malloc(bytes_per_thread);
+		if (!tmp)
+			exit(EXIT_FAILURE);
+
+		start = tmp;
+		nr_pages = bytes_per_thread/4096;
+		/* access page to force memory allocation via page-fault */
+		while(nr_pages--) {
+			*start = 'A';
+			/* move to the next page. */
+			start += 4096;
+		}
+#if 0
+		if (munmap(tmp, bytes_per_thread) == 1)
+			perror("error unmapping the file\n");
+#endif
+		free(tmp);
+
+		iter++;
+	}
+	return NULL;
+}
+
+int main(int argc, char *argv[])
+{
+	int i, c;
+	pthread_t *pthread;
+
+	while ((c = getopt(argc, argv, "m:t:i:")) != -1) {
+		switch(c) {
+			case 'm':
+				memory = atoi(optarg);
+				break;
+			case 't':
+				nr_threads = atoi(optarg);
+				break;
+			case 'i':
+				iterations = atoi(optarg);
+				break;
+			default:
+				printf("Usage: %s [-m memoryGB] [-t nr_threads] [-i iterations]\n", argv[0]);
+				exit(EXIT_FAILURE);
+		}
+	}
+
+	pthread = (pthread_t *)malloc(sizeof(pthread_t) * nr_threads);
+	if (!pthread) {
+		printf("Error while allocating pthreads\n");
+		exit(EXIT_FAILURE);
+	}
+	bytes_per_thread = (memory*1024*1024*1024) / nr_threads;
+	printf("Running with the following configuration...\n");
+	printf("Memory: \t\t%ldGB\n", memory);
+	printf("Threads: \t\t%d\n", nr_threads);
+	printf("Iterations: \t\t%d\n", iterations);
+	printf("Bytes Per Thread: \t%ld\n", bytes_per_thread);
+
+	for (i=0; i < nr_threads; i++)
+		pthread_create(&pthread[i], NULL, alloc_mem, NULL);
+
+	for (i=0; i < nr_threads; i++)
+		pthread_join(pthread[i],NULL);
+
+	printf("Exiting successfully...\n");
+	return 0;
+}
diff --color -ruN -w -B '--exclude-from=.diff-exclude' linux-5.10/ftrace-pgfault-latency-tracker/vm-pgfault-tracer.c HawkEye-5.10-cow/ftrace-pgfault-latency-tracker/vm-pgfault-tracer.c
--- linux-5.10/ftrace-pgfault-latency-tracker/vm-pgfault-tracer.c	1970-01-01 00:00:00.000000000 +0000
+++ HawkEye-5.10-cow/ftrace-pgfault-latency-tracker/vm-pgfault-tracer.c	2025-03-23 07:54:12.297081023 +0000
@@ -0,0 +1,204 @@
+#include <pthread.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/mman.h>
+
+int nr_threads = 1;
+int iterations = 1;
+int ftrace = 1;
+unsigned long memory = 1;
+unsigned long bytes_per_thread = 1;
+
+void set_ftrace_parameters()
+{
+	int ret;
+	int pid = getpid();
+	char buff[200];
+
+	printf("Setting ftrace parameters ...\n");
+	ret = system("rm -f log");
+	if (ret)
+		goto error;
+
+	printf("Disabling trace ...\n");
+	ret = system("echo 0 > /sys/kernel/debug/tracing/tracing_on");
+	if (ret)
+		goto error;
+
+	printf("Clearing trace file ...\n");
+	ret = system("> /sys/kernel/debug/tracing/trace");
+	if (ret)
+		goto error;
+
+	printf("Selecting current tracer ...\n");
+	ret = system("echo function_graph > /sys/kernel/debug/tracing/current_tracer");
+	if (ret)
+		goto error;
+
+	printf("Selecting ftrace filter ...\n");
+	ret = system("echo handle_mm_fault > /sys/kernel/debug/tracing/set_ftrace_filter");
+	if (ret)
+		goto error;
+
+	printf("Enabling trace for forked pidsi ...\n");
+	ret = system("echo 1 > /sys/kernel/debug/tracing/options/function-fork");
+	if (ret)
+		goto error;
+
+	/* set buffer to 1GB. Make sure to clean it up while exiting. */
+	printf("Increasing trace buffer size ...\n");
+	ret = system("echo 1048576 > /sys/kernel/debug/tracing/buffer_size_kb");
+	/* copy pid into the buffer */
+	printf("Configuring ftrace PID ...\n");
+	sprintf(buff, "echo %d > /sys/kernel/debug/tracing/set_ftrace_pid", pid);
+	ret = system(buff);
+	if (ret)
+		goto error;
+
+	printf("Enabling tracing ...\n");
+	ret = system("echo 1 > /sys/kernel/debug/tracing/tracing_on");
+	if (ret)
+		goto error;
+
+	printf("ftrace configured. Executing the workload...\n ");
+	return;
+
+error:
+	printf("Error occured while setting ftrace parameters\n");
+	exit(EXIT_FAILURE);
+}
+
+void collect_and_clear_ftrace()
+{
+	int ret;
+
+	//system("tail -n+5 /sys/kernel/debug/tracing/trace > log");
+	ret = system("echo 0 > /sys/kernel/debug/tracing/tracing_on");
+	if (ret)
+		goto error;
+	ret = system("> /sys/kernel/debug/tracing/trace");
+	if (ret)
+		goto error;
+	ret = system("echo 1408 > /sys/kernel/debug/tracing/buffer_size_kb");
+	if (ret)
+		goto error;
+	system("sed 's/^.......//' log > tmp; rm -r log;\
+			cat tmp | grep handle_mm_fault > log; rm -f tmp");
+	printf("\n");
+	system("total=$(awk '{sum+=$1;n++} END { if(n>0) print(sum)}' log);\
+				echo Total Page Fault Time: $total microsecs");
+	system("avg=$(awk '{sum+=$1;n++} END { if(n>0) print(sum/n)}' log);\
+				echo Average Page Fault Time: $avg microsecs");
+
+	printf("\n");
+	printf("ftrace parameters cleared successfully...\n");
+	return;
+error:
+	printf("Error occured while clearing ftrace parameters");
+	exit(EXIT_FAILURE);
+}
+
+void print_ftrace_summary()
+{
+
+}
+
+void *alloc_mem(void *arg)
+{
+	int fd, nr_pages, iter = 0, j;
+	char *tmp, *start;
+
+	while(iter < iterations) {
+		/* Allocate required bytes */
+#if 0
+		tmp = mmap(NULL, bytes_per_thread, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
+		if (tmp == MAP_FAILED) {
+			printf("mmap failed\n");
+			return NULL;
+		}
+#endif
+		tmp = malloc(bytes_per_thread);
+		if (!tmp)
+			exit(EXIT_FAILURE);
+
+		/* access page to force memory allocation via page-fault */
+		for (j = 0; j < 10; j++) {
+			start = tmp;
+			nr_pages = bytes_per_thread/4096;
+			while(nr_pages--) {
+				*start = 'A';
+				/* move to the next page. */
+				start += 4096;
+			}
+		}
+#if 0
+		if (munmap(tmp, bytes_per_thread) == 1)
+			perror("error unmapping the file\n");
+#endif
+		free(tmp);
+		iter++;
+		if (ftrace) {
+			printf("dumping and clearing trace");
+			system("tail -n+5 /sys/kernel/debug/tracing/trace >> log");
+			system("> /sys/kernel/debug/tracing/trace");
+		}
+	}
+	return NULL;
+}
+
+int main(int argc, char *argv[])
+{
+	int i, c, pid, ret;
+	pthread_t *pthread;
+
+	printf("PID: %d\n", getpid());
+	while ((c = getopt(argc, argv, "m:t:i:f:")) != -1) {
+		switch(c) {
+			case 'm':
+				memory = atoi(optarg);
+				break;
+			case 't':
+				nr_threads = atoi(optarg);
+				break;
+			case 'i':
+				iterations = atoi(optarg);
+				break;
+			case 'f':
+				ftrace = atoi(optarg);
+				break;
+			default:
+				printf("Usage: %s [-m memoryGB] [-t nr_threads] [-i iterations] [-t trace]\n", argv[0]);
+				exit(EXIT_FAILURE);
+		}
+	}
+
+	pthread = (pthread_t *)malloc(sizeof(pthread_t) * nr_threads);
+	if (!pthread) {
+		printf("Error while allocating pthreads\n");
+		exit(EXIT_FAILURE);
+	}
+	bytes_per_thread = (memory*1024*1024*1024) / nr_threads;
+	printf("Running with the following configuration...\n");
+	printf("Memory: \t\t%ldGB\n", memory);
+	printf("Threads: \t\t%d\n", nr_threads);
+	printf("Iterations: \t\t%d\n", iterations);
+	printf("Bytes Per Thread: \t%ld\n", bytes_per_thread);
+	if (ftrace)
+		set_ftrace_parameters();
+
+	for (i=0; i < nr_threads; i++)
+		pthread_create(&pthread[i], NULL, alloc_mem, NULL);
+
+	for (i=0; i < nr_threads; i++)
+		pthread_join(pthread[i],NULL);
+	if (ftrace) {
+		collect_and_clear_ftrace();
+		print_ftrace_summary();
+		/* This is precautionary. */
+		system("echo 1408 > /sys/kernel/debug/tracing/buffer_size_kb");
+	}
+	printf("Exiting successfully.\n");
+	return 0;
+}
diff --color -ruN -w -B '--exclude-from=.diff-exclude' linux-5.10/hawkeye_modules/async-zero/asynczero.c HawkEye-5.10-cow/hawkeye_modules/async-zero/asynczero.c
--- linux-5.10/hawkeye_modules/async-zero/asynczero.c	1970-01-01 00:00:00.000000000 +0000
+++ HawkEye-5.10-cow/hawkeye_modules/async-zero/asynczero.c	2025-03-23 07:54:15.619071047 +0000
@@ -0,0 +1,169 @@
+#include <linux/module.h>	/* Needed by all modules */
+#include <linux/kernel.h>	/* Needed for KERN_INFO */
+#include <linux/mmzone.h>
+#include <linux/mm.h>
+#include <linux/delay.h>
+#include <linux/highmem.h>
+#include <asm/page_64.h>
+
+int sleep = 20;
+module_param(sleep, int, 0);
+int count = 10000;
+module_param(count, int, 0);
+
+/* clear the largest order blocks in the buddy allocator */
+int zero_fill_order = MAX_ORDER - 1;
+unsigned long pages_zeroed;
+
+static inline bool skip_zone(struct zone *zone)
+{
+	return false;
+}
+
+/*
+ * preferrably use the architecture specific extensions to zero-fill a page.
+ * use memset as a fallback option.
+ */
+static inline void zero_fill_page_ntstores(struct page *page)
+{
+	void *kaddr;
+	kaddr = kmap_atomic(page);
+	__asm__ (
+		"push %%rax;"
+		"push %%rcx;"
+		"push %%rdi;"
+		"movq	%0, %%rdi;"
+		"xorq    %%rax, %%rax;"
+		"movl    $4096/64, %%ecx;"
+		".p2align 4;"
+		"1:;"
+		"decl    %%ecx;"
+		"movnti  %%rax,(%%rdi);"
+		"movnti  %%rax,0x8(%%rdi);"
+		"movnti  %%rax,0x10(%%rdi);"
+		"movnti  %%rax,0x18(%%rdi);"
+		"movnti  %%rax,0x20(%%rdi);"
+		"movnti  %%rax,0x28(%%rdi);"
+		"movnti  %%rax,0x30(%%rdi);"
+		"movnti  %%rax,0x38(%%rdi);"
+		"leaq    64(%%rdi),%%rdi;"
+		"jnz     1b;"
+		"nop;"
+		"pop %%rdi;"
+		"pop %%rcx;"
+		"pop %%rax;"
+		:: "a" (kaddr)
+	);
+	kunmap_atomic(kaddr);
+}
+
+/* the core logic to zero-fill a compound page */
+static inline void zero_fill_compound_page(struct page *page, int order)
+{
+	int i;
+
+	if (PageZeroed(page))
+		return;
+
+	for (i = 0; i < (1 << order); i++) {
+		/* kernel's in-built zeroing function */
+		//clear_highpage(page + i);
+
+		/* custom zero-filling logic */
+		zero_fill_page_ntstores(page + i);
+	}
+	//pages_zeroed += (1 << order);
+	pages_zeroed++;
+	SetPageZeroed(page);
+}
+
+static void zero_fill_zone_pages(struct zone *zone)
+{
+	struct page *page;
+	struct free_area *area;
+	unsigned long flags;
+	unsigned long retries = 0;
+
+	while (retries < 100) {
+		/* remove one page with the lock held */
+		spin_lock_irqsave(&zone->lock, flags);
+		area = &(zone->free_area[zero_fill_order]);
+		page = list_first_entry_or_null(&area->free_list[MIGRATE_MOVABLE],
+				struct page, lru);
+		if (!page) {
+			//printk(KERN_ERR"no suitable page found for zeroing\n");
+			spin_unlock_irqrestore(&zone->lock, flags);
+			break;;
+		}
+		if (PageZeroed(page)) {
+			retries++;
+			/* move this page to the tail */
+			list_del(&page->lru);
+			list_add_tail(&page->lru, &area->free_list[MIGRATE_MOVABLE]);
+			spin_unlock_irqrestore(&zone->lock, flags);
+			continue;
+		}
+		list_del(&page->lru);
+		area->nr_free--;
+		spin_unlock_irqrestore(&zone->lock, flags);
+
+		/* take the desired action here (zero fill in this case) */
+		zero_fill_compound_page(page, zero_fill_order);
+
+		/* add the page back to free list but at the tail */
+		spin_lock_irqsave(&zone->lock, flags);
+		list_add_tail(&page->lru, &area->free_list[MIGRATE_MOVABLE]);
+		area->nr_free++;
+		spin_unlock_irqrestore(&zone->lock, flags);
+		if (pages_zeroed % count == 0)
+			msleep(sleep);
+	}
+	/* sleep unconditionally to avoid unnnecessary looping */
+	msleep(sleep);
+}
+
+static int zero_pages_async(void)
+{
+	struct zone *zone;
+
+	pages_zeroed = 0;
+	int k = 0;
+	/* loop forever to check for zeroing opportunity */
+	while (k<=128000) {
+		for_each_zone(zone) {
+			if (!populated_zone(zone) || skip_zone(zone))
+				continue;
+
+			zero_fill_zone_pages(zone);
+			k++;
+		}
+		trace_printk("Pages zeroed: %ld\n", pages_zeroed);
+	}
+	return 0;
+}
+
+// int init_module(void)
+// {
+// 	return 0;
+// }
+
+// void cleanup_module(void)
+// {
+// 	printk(KERN_INFO"Exiting from zeroing loop\n");
+// }
+
+static int __init my_module_init(void) {
+	zero_pages_async();
+    printk(KERN_INFO "zeroing loaded\n");
+    return 0;
+}
+
+static void __exit my_module_exit(void) {
+    printk(KERN_INFO"Exiting from zeroing loop\n");
+}
+
+module_init(my_module_init);
+module_exit(my_module_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Ashish Panwar");
diff --color -ruN -w -B '--exclude-from=.diff-exclude' linux-5.10/hawkeye_modules/async-zero/Makefile HawkEye-5.10-cow/hawkeye_modules/async-zero/Makefile
--- linux-5.10/hawkeye_modules/async-zero/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ HawkEye-5.10-cow/hawkeye_modules/async-zero/Makefile	2025-03-23 07:54:15.620641340 +0000
@@ -0,0 +1,9 @@
+CONFIG_MODULE_SIG=n
+
+obj-m += asynczero.o
+
+all:
+	 make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules
+
+clean:
+	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
Binary files linux-5.10/hawkeye_modules/async-zero/mycert.der and HawkEye-5.10-cow/hawkeye_modules/async-zero/mycert.der differ
Binary files linux-5.10/hawkeye_modules/async-zero/mykey.der and HawkEye-5.10-cow/hawkeye_modules/async-zero/mykey.der differ
diff --color -ruN -w -B '--exclude-from=.diff-exclude' linux-5.10/hawkeye_modules/bloat_recovery/detect.c HawkEye-5.10-cow/hawkeye_modules/bloat_recovery/detect.c
--- linux-5.10/hawkeye_modules/bloat_recovery/detect.c	1970-01-01 00:00:00.000000000 +0000
+++ HawkEye-5.10-cow/hawkeye_modules/bloat_recovery/detect.c	2025-03-23 07:54:15.624456311 +0000
@@ -0,0 +1,212 @@
+#include <linux/module.h>	/* Needed by all modules */
+#include <linux/kernel.h>	/* Needed for KERN_INFO */
+#include <linux/pid.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <asm/pgtable.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/highmem.h>
+#include <linux/sched/mm.h>
+#define BUFF_LEN	1024
+
+struct tty_struct *out = NULL;
+char *buff;
+
+int pid = 0;
+module_param(pid, int, 0);
+int gap = 5000;
+module_param(gap, int, 0);
+int sleep = 5000;
+module_param(sleep, int, 0);
+
+unsigned long distance = 0;
+
+struct page *follow_page_custom(struct vm_area_struct *vma,
+		unsigned long addr, unsigned int foll_flags);
+
+static inline void write_output(void)
+{
+	out->driver->ops->write(out, buff, strlen(buff));
+	out->driver->ops->write(out, "\015\012", 2);
+}
+
+static inline void write_output_nonewline(void)
+{
+	out->driver->ops->write(out, buff, strlen(buff));
+}
+
+static void print_bloat_info(unsigned long nr_total, unsigned long nr_zero)
+{
+	unsigned long nr_non_zero = nr_total - nr_zero;
+
+	if (nr_total == 0)
+		nr_total = 1;
+
+	snprintf(buff, BUFF_LEN, "total: %ld zero: %ld fraction: %ld \
+		distance: %ld non-zero: %ld", nr_total, nr_zero,
+		(nr_zero * 100) / nr_total, distance, nr_non_zero);
+
+	write_output();
+}
+
+static bool is_page_zero(u8 *addr)
+{
+	u8 *ptr_curr = (u8 *)addr;
+	u8 *ptr_end = ptr_curr + PAGE_SIZE;
+	u8 val;
+
+	while (ptr_curr < ptr_end) {
+		val = *ptr_curr;
+		if (val)
+			return false;
+		ptr_curr++;
+	}
+	return true;
+}
+
+static int non_zero_distance(u8 *start)
+{
+	u8 *curr = start;
+	u8 *end = curr + PAGE_SIZE;
+	int val;
+
+	while (curr < end)
+	{
+		val = *curr;
+		if (val)
+			break;
+		else
+			curr++;
+	}
+	/* we need to read atleast 1 byte and hence
+	 * the cost is never zero
+	 * */
+	return (curr - start) + 1;
+}
+
+/*
+ * hpage must be a transparent huge page
+ */
+static int count_zero_pages(struct page *hpage)
+{
+	void *haddr;
+	u8 *hstart, *hend, *addr;
+	int nr_zero_pages = 0;
+
+	haddr = kmap_atomic(hpage);
+	hstart = (u8 *)haddr;
+	hend = hstart + HPAGE_PMD_SIZE;
+	/* zero checking logic */
+	for (addr = hstart; addr < hend; addr += PAGE_SIZE) {
+		if (is_page_zero(addr))
+			nr_zero_pages += 1;
+		else
+			distance += non_zero_distance(addr);
+	}
+	kunmap_atomic(haddr);
+	return nr_zero_pages;
+}
+
+/*
+ * Traverse each page of given task and see how many pages
+ * contain only-zeroes---this gives us a good enough indication.
+ * on the upper bound of memory bloat.
+ */
+static bool calc_bloat(struct task_struct *task)
+{
+	struct vm_area_struct *vma = NULL;
+	struct mm_struct *mm = NULL;
+	struct page *page;
+	unsigned long nr_total = 0;
+	unsigned long nr_zero = 0;
+	unsigned long start, end, addr;
+
+	mm = get_task_mm(task);
+	if (!mm)
+		goto out;
+
+	/* traverse the list of all vma regions */
+	for(vma = mm->mmap; vma; vma = vma->vm_next) {
+		start = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;
+		end = vma->vm_end & HPAGE_PMD_MASK;
+
+		/* examine each huge page region */
+		for (addr = start; addr < end;) {
+			page = follow_page_custom(vma, addr, FOLL_GET);
+			if (!page) {
+				addr += PAGE_SIZE;
+				continue;
+			}
+			if (!PageTransHuge(page)) {
+				put_page(page);
+				addr += PAGE_SIZE;
+				continue;
+			}
+			nr_zero += count_zero_pages(page);
+			nr_total += 512;
+			put_page(page);
+			addr += HPAGE_PMD_SIZE;
+		}
+	}
+	print_bloat_info(nr_total, nr_zero);
+	mmput(mm);
+	return true;
+
+out:
+	snprintf(buff, BUFF_LEN, "Unable to locate task mm for pid: %d", task->pid);
+	write_output();
+	return  false;
+}
+
+static int check_process_bloat(void)
+{
+	struct task_struct *task = NULL;
+	struct pid *pid_struct = NULL;
+
+	/*
+	 * This is a one time operation. Hence, not performance critical.
+	 * Moreover, we may need to allocate large buffer than kmalloc can
+	 * provide. Hence, it is safe to use vmalloc here.
+	 */
+	buff = vmalloc(BUFF_LEN);
+	if (!buff) {
+		printk(KERN_INFO"Unable to allocate vmalloc buffer\n");
+		return -ENOMEM;
+	}
+
+	memset(buff, 0, BUFF_LEN);
+	pid_struct = find_get_pid(pid);
+	if (!pid_struct)
+		goto out;
+
+	task = pid_task(pid_struct, PIDTYPE_PID);
+	if (!task)
+		goto out;
+
+	/* Calculate bloat. */
+	calc_bloat(task);
+	write_output();
+	vfree(buff);
+	return 0;
+out:
+	printk("Unable to find task: %d\n", pid);
+	vfree(buff);
+	return -1;
+}
+
+int init_module(void)
+{
+	out = current->signal->tty;
+	check_process_bloat();
+	return 0;
+}
+
+void cleanup_module(void)
+{
+	printk(KERN_INFO"Module Exiting\n");
+}
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Ashish Panwar");
diff --color -ruN -w -B '--exclude-from=.diff-exclude' linux-5.10/hawkeye_modules/bloat_recovery/Makefile HawkEye-5.10-cow/hawkeye_modules/bloat_recovery/Makefile
--- linux-5.10/hawkeye_modules/bloat_recovery/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ HawkEye-5.10-cow/hawkeye_modules/bloat_recovery/Makefile	2025-03-23 07:54:15.623374129 +0000
@@ -0,0 +1,8 @@
+obj-m += detect.o
+obj-m += remove.o
+
+all:
+	 make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules
+
+clean:
+	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
diff --color -ruN -w -B '--exclude-from=.diff-exclude' linux-5.10/hawkeye_modules/bloat_recovery/remove.c HawkEye-5.10-cow/hawkeye_modules/bloat_recovery/remove.c
--- linux-5.10/hawkeye_modules/bloat_recovery/remove.c	1970-01-01 00:00:00.000000000 +0000
+++ HawkEye-5.10-cow/hawkeye_modules/bloat_recovery/remove.c	2025-03-23 07:54:15.623882558 +0000
@@ -0,0 +1,220 @@
+#include <linux/module.h>	/* Needed by all modules */
+#include <linux/kernel.h>	/* Needed for KERN_INFO */
+#include <linux/pid.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <asm/pgtable.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/highmem.h>
+#include <linux/sched/mm.h>
+#include <linux/mmzone.h>
+
+#define BUFF_LEN	1024
+
+struct tty_struct *out = NULL;
+char *buff;
+
+int pid = 0;
+module_param(pid, int, 0);
+int gap = 5000;
+module_param(gap, int, 0);
+int sleep = 120000;
+module_param(sleep, int, 0);
+
+unsigned long distance = 0;
+
+/* declaration for kernel functions exported manually */
+struct page *follow_page_custom(struct vm_area_struct *vma,
+		unsigned long addr, unsigned int foll_flags);
+// void zap_page_range(struct vm_area_struct *vma, unsigned long start,
+//                 unsigned long size, struct zap_details *details);
+void zap_page_range(struct vm_area_struct *vma, unsigned long start,
+		unsigned long size);
+
+static inline void write_output(void)
+{
+	out->driver->ops->write(out, buff, strlen(buff));
+	out->driver->ops->write(out, "\015\012", 2);
+}
+
+static inline void write_output_nonewline(void)
+{
+	out->driver->ops->write(out, buff, strlen(buff));
+}
+
+static void print_recovery_info(unsigned long nr_to_free, unsigned long nr_recovered)
+{
+	snprintf(buff, BUFF_LEN, "target: %ld recovered: %ld", nr_to_free, nr_recovered);
+	write_output();
+}
+
+static unsigned long count_pages_to_free(void)
+{
+	struct pglist_data *pgdat;
+	struct zone *zone;
+	unsigned long managed = 0, free = 0;
+
+	pgdat = first_online_pgdat();
+	for_each_zone(zone) {
+		if (zone->zone_pgdat != pgdat)
+			continue;
+		// managed += zone->managed_pages;
+        managed += zone_managed_pages(zone);
+		free += atomic_long_read(&zone->vm_stat[0]);
+	}
+
+	if (free < ((managed*15)/100))
+		return (managed*30)/100 - free;
+	return 0;
+}
+
+static bool is_page_zero(u8 *addr)
+{
+	u8 *ptr_curr = (u8 *)addr;
+	u8 *ptr_end = ptr_curr + PAGE_SIZE;
+	u8 val;
+
+	while (ptr_curr < ptr_end) {
+		val = *ptr_curr;
+		if (val)
+			return false;
+		ptr_curr++;
+	}
+	return true;
+}
+
+/*
+ * hpage must be a transparent huge page
+ */
+static int remove_zero_pages(struct page *hpage, struct vm_area_struct *vma,
+					unsigned long start)
+{
+	void *haddr;
+	u8 *hstart, *hend, *addr;
+	int nr_recovered = 0;
+
+	haddr = kmap_atomic(hpage);
+	hstart = (u8 *)haddr;
+	hend = hstart + HPAGE_PMD_SIZE;
+	/* zero checking logic */
+	for (addr = hstart; addr < hend; addr += PAGE_SIZE, start += PAGE_SIZE) {
+		if (is_page_zero(addr)) {
+			zap_page_range(vma, start, PAGE_SIZE);
+			nr_recovered++;
+		}
+	}
+	kunmap_atomic(haddr);
+	return nr_recovered;
+}
+
+/*
+ * Traverse each page of given task and see how many pages
+ * contain only-zeroes---this gives us a good enough indication.
+ * on the upper bound of memory bloat.
+ */
+static bool remove_bloat(struct task_struct *task)
+{
+	struct vm_area_struct *vma = NULL;
+	struct mm_struct *mm = NULL;
+	struct page *page;
+	unsigned long nr_recovered = 0, nr_to_free = 0;
+	unsigned long start, end, addr;
+
+	mm = get_task_mm(task);
+	if (!mm)
+		goto out;
+
+	nr_to_free = count_pages_to_free();
+	/* traverse the list of all vma regions */
+	for(vma = mm->mmap; vma && nr_to_free; vma = vma->vm_next) {
+		start = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;
+		end = vma->vm_end & HPAGE_PMD_MASK;
+
+		/* examine each huge page region */
+		for (addr = start; addr < end;) {
+			page = follow_page_custom(vma, addr, FOLL_GET);
+			if (!page) {
+				addr += PAGE_SIZE;
+				continue;
+			}
+			if (!PageTransHuge(page)) {
+				put_page(page);
+				addr += PAGE_SIZE;
+				continue;
+			}
+			nr_recovered += remove_zero_pages(page, vma, addr);
+			put_page(page);
+			addr += PAGE_SIZE * 512;
+			if (nr_recovered > nr_to_free)
+				goto inner_break;
+			
+		}
+	}
+inner_break:
+	mmput(mm);
+	print_recovery_info(nr_to_free, nr_recovered);
+	return true;
+
+out:
+	snprintf(buff, BUFF_LEN, "Unable to locate task mm for pid: %d", task->pid);
+	write_output();
+	return  false;
+}
+
+static int check_process_bloat(void)
+{
+	struct task_struct *task = NULL;
+	struct pid *pid_struct = NULL;
+
+	/*
+	 * This is a one time operation. Hence, not performance critical.
+	 * Moreover, we may need to allocate large buffer than kmalloc can
+	 * provide. Hence, it is safe to use vmalloc here.
+	 */
+	buff = vmalloc(BUFF_LEN);
+	if (!buff) {
+		snprintf(buff, BUFF_LEN, "Unable to allocate vmalloc buffer");
+		write_output();
+		return -ENOMEM;
+	}
+
+	memset(buff, 0, BUFF_LEN);
+	while (true) {
+		pid_struct = find_get_pid(pid);
+		if (!pid_struct)
+			goto out;
+
+		task = pid_task(pid_struct, PIDTYPE_PID);
+		if (!task)
+			goto out;
+
+		/* Calculate bloat. */
+		remove_bloat(task);
+		msleep(sleep);
+	}
+	write_output();
+	vfree(buff);
+	return 0;
+out:
+	snprintf(buff, BUFF_LEN, "Unable to find task: %d\n", pid);
+	write_output();
+	vfree(buff);
+	return -1;
+}
+
+int init_module(void)
+{
+	out = current->signal->tty;
+	check_process_bloat();
+	return 0;
+}
+
+void cleanup_module(void)
+{
+	printk(KERN_INFO"Module Exiting\n");
+}
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Ashish Panwar");
diff --color -ruN -w -B '--exclude-from=.diff-exclude' linux-5.10/include/linux/ksm.h HawkEye-5.10-cow/include/linux/ksm.h
--- linux-5.10/include/linux/ksm.h	2020-12-13 22:41:30.000000000 +0000
+++ HawkEye-5.10-cow/include/linux/ksm.h	2025-03-23 07:53:49.061045404 +0000
@@ -15,6 +15,11 @@
 #include <linux/sched.h>
 #include <linux/sched/coredump.h>
 
+//zhehua
+extern unsigned long nr_ksm_cows;
+extern unsigned long nr_ksm_shares;
+extern unsigned int runksm;
+
 struct stable_node;
 struct mem_cgroup;
 
diff --color -ruN -w -B '--exclude-from=.diff-exclude' linux-5.10/include/linux/mm_types.h HawkEye-5.10-cow/include/linux/mm_types.h
--- linux-5.10/include/linux/mm_types.h	2020-12-13 22:41:30.000000000 +0000
+++ HawkEye-5.10-cow/include/linux/mm_types.h	2025-03-23 07:53:49.501809907 +0000
@@ -7,6 +7,7 @@
 #include <linux/auxvec.h>
 #include <linux/list.h>
 #include <linux/spinlock.h>
+#include <linux/mutex.h>
 #include <linux/rbtree.h>
 #include <linux/rwsem.h>
 #include <linux/completion.h>
@@ -65,7 +65,8 @@
 #define _struct_page_alignment
 #endif
 
-struct page {
+struct page
+{
 	unsigned long flags;		/* Atomic flags, some possibly
 					 * updated asynchronously */
 	/*
@@ -74,8 +75,10 @@
 	 * means the other users of this union MUST NOT use the bit to
 	 * avoid collision and false-positive PageTail().
 	 */
-	union {
-		struct {	/* Page cache and anonymous pages */
+    union
+    {
+        struct
+        { /* Page cache and anonymous pages */
 			/**
 			 * @lru: Pageout list, eg. active_list protected by
 			 * pgdat->lru_lock.  Sometimes used as a generic list
@@ -93,17 +96,21 @@
 			 */
 			unsigned long private;
 		};
-		struct {	/* page_pool used by netstack */
+        struct
+        { /* page_pool used by netstack */
 			/**
 			 * @dma_addr: might require a 64-bit value even on
 			 * 32-bit architectures.
 			 */
 			dma_addr_t dma_addr;
 		};
-		struct {	/* slab, slob and slub */
-			union {
+        struct
+        { /* slab, slob and slub */
+            union
+            {
 				struct list_head slab_list;
-				struct {	/* Partial pages */
+                struct
+                { /* Partial pages */
 					struct page *next;
 #ifdef CONFIG_64BIT
 					int pages;	/* Nr of pages left */
@@ -117,17 +124,20 @@
 			struct kmem_cache *slab_cache; /* not slob */
 			/* Double-word boundary */
 			void *freelist;		/* first free object */
-			union {
+            union
+            {
 				void *s_mem;	/* slab: first object */
 				unsigned long counters;		/* SLUB */
-				struct {			/* SLUB */
+                struct
+                { /* SLUB */
 					unsigned inuse:16;
 					unsigned objects:15;
 					unsigned frozen:1;
 				};
 			};
 		};
-		struct {	/* Tail pages of compound page */
+        struct
+        {                                /* Tail pages of compound page */
 			unsigned long compound_head;	/* Bit zero is set */
 
 			/* First tail page only */
@@ -136,17 +146,20 @@
 			atomic_t compound_mapcount;
 			unsigned int compound_nr; /* 1 << compound_order */
 		};
-		struct {	/* Second tail page of compound page */
+        struct
+        {                                  /* Second tail page of compound page */
 			unsigned long _compound_pad_1;	/* compound_head */
 			atomic_t hpage_pinned_refcount;
 			/* For both global and memcg */
 			struct list_head deferred_list;
 		};
-		struct {	/* Page table pages */
+        struct
+        {                            /* Page table pages */
 			unsigned long _pt_pad_1;	/* compound_head */
 			pgtable_t pmd_huge_pte; /* protected by page->ptl */
 			unsigned long _pt_pad_2;	/* mapping */
-			union {
+            union
+            {
 				struct mm_struct *pt_mm; /* x86 pgds only */
 				atomic_t pt_frag_refcount; /* powerpc */
 			};
@@ -156,7 +169,8 @@
 			spinlock_t ptl;
 #endif
 		};
-		struct {	/* ZONE_DEVICE pages */
+        struct
+        { /* ZONE_DEVICE pages */
 			/** @pgmap: Points to the hosting device page map. */
 			struct dev_pagemap *pgmap;
 			void *zone_device_data;
@@ -176,7 +190,8 @@
 		struct rcu_head rcu_head;
 	};
 
-	union {		/* This union is 4 bytes in size. */
+    union
+    { /* This union is 4 bytes in size. */
 		/*
 		 * If the page can be mapped to userspace, encodes the number
 		 * of times this page is referenced by a page table.
@@ -199,7 +214,8 @@
 	atomic_t _refcount;
 
 #ifdef CONFIG_MEMCG
-	union {
+    union
+    {
 		struct mem_cgroup *mem_cgroup;
 		struct obj_cgroup **obj_cgroups;
 	};
@@ -250,7 +266,8 @@
 	page->private = private;
 }
 
-struct page_frag_cache {
+struct page_frag_cache
+{
 	void * va;
 #if (PAGE_SIZE < PAGE_FRAG_CACHE_MAX_SIZE)
 	__u16 offset;
@@ -272,7 +289,8 @@
  * conditions.  These are held in a global tree and are pinned by the VMAs that
  * map parts of them.
  */
-struct vm_region {
+struct vm_region
+{
 	struct rb_node	vm_rb;		/* link in global region tree */
 	vm_flags_t	vm_flags;	/* VMA vm_flags */
 	unsigned long	vm_start;	/* start address of region */
@@ -287,13 +305,18 @@
 };
 
 #ifdef CONFIG_USERFAULTFD
-#define NULL_VM_UFFD_CTX ((struct vm_userfaultfd_ctx) { NULL, })
-struct vm_userfaultfd_ctx {
+#define NULL_VM_UFFD_CTX ((struct vm_userfaultfd_ctx){ \
+    NULL,                                              \
+})
+struct vm_userfaultfd_ctx
+{
 	struct userfaultfd_ctx *ctx;
 };
 #else /* CONFIG_USERFAULTFD */
 #define NULL_VM_UFFD_CTX ((struct vm_userfaultfd_ctx) {})
-struct vm_userfaultfd_ctx {};
+struct vm_userfaultfd_ctx
+{
+};
 #endif /* CONFIG_USERFAULTFD */
 
 /*
@@ -302,7 +325,8 @@
  * space that has a special rule for the page-fault handlers (ie a shared
  * library, the executable area etc).
  */
-struct vm_area_struct {
+struct vm_area_struct
+{
 	/* The first cache line has the info for VMA tree walking. */
 
 	unsigned long vm_start;		/* Our start address within vm_mm. */
@@ -337,7 +361,8 @@
 	 * For areas with an address space and backing store,
 	 * linkage into the address_space->i_mmap interval tree.
 	 */
-	struct {
+    struct
+    {
 		struct rb_node rb;
 		unsigned long rb_subtree_last;
 	} shared;
@@ -373,20 +398,49 @@
 	struct vm_userfaultfd_ctx vm_userfaultfd_ctx;
 } __randomize_layout;
 
-struct core_thread {
+struct core_thread
+{
 	struct task_struct *task;
 	struct core_thread *next;
 };
 
-struct core_state {
+struct core_state
+{
 	atomic_t nr_threads;
 	struct core_thread dumper;
 	struct completion startup;
 };
 
 struct kioctx_table;
-struct mm_struct {
-	struct {
+
+#define MAX_BINS 12
+
+struct ohp_addr
+{
+    struct mm_struct *mm;
+    struct list_head entry;
+    unsigned long address;
+    unsigned int weight;
+    unsigned int nr_scans;
+};
+
+struct ohp
+{
+    struct mutex lock;
+    struct list_head priority[MAX_BINS];
+    unsigned long count[MAX_BINS];
+    unsigned long ohp_remaining;
+    unsigned long invalid; /* Debugging */
+    unsigned long tstamp;
+    unsigned int ohp_weight;
+    unsigned int current_scan_idx;
+    unsigned int nr_scans;
+};
+
+struct mm_struct
+{
+    struct
+    {
 		struct vm_area_struct *mmap;		/* list of VMAs */
 		struct rb_root mm_rb;
 		u64 vmacache_seqnum;                   /* per-thread vmacache */
@@ -562,6 +615,8 @@
 	 * The mm_cpumask needs to be at the end of mm_struct, because it
 	 * is dynamically sized based on nr_cpu_ids.
 	 */
+    struct list_head ohp_list;
+    struct ohp ohp;
 	unsigned long cpu_bitmap[];
 };
 
@@ -706,7 +761,8 @@
  * @VM_FAULT_HINDEX_MASK:	mask HINDEX value
  *
  */
-enum vm_fault_reason {
+enum vm_fault_reason
+{
 	VM_FAULT_OOM            = (__force vm_fault_t)0x000001,
 	VM_FAULT_SIGBUS         = (__force vm_fault_t)0x000002,
 	VM_FAULT_MAJOR          = (__force vm_fault_t)0x000004,
@@ -744,9 +800,12 @@
 	{ VM_FAULT_RETRY,               "RETRY" },	\
 	{ VM_FAULT_FALLBACK,            "FALLBACK" },	\
 	{ VM_FAULT_DONE_COW,            "DONE_COW" },	\
-	{ VM_FAULT_NEEDDSYNC,           "NEEDDSYNC" }
+    {                                                \
+        VM_FAULT_NEEDDSYNC, "NEEDDSYNC"              \
+    }
 
-struct vm_special_mapping {
+struct vm_special_mapping
+{
 	const char *name;	/* The name, e.g. "[vdso]". */
 
 	/*
@@ -769,7 +828,8 @@
 		     struct vm_area_struct *new_vma);
 };
 
-enum tlb_flush_reason {
+enum tlb_flush_reason
+{
 	TLB_FLUSH_ON_TASK_SWITCH,
 	TLB_REMOTE_SHOOTDOWN,
 	TLB_LOCAL_SHOOTDOWN,
@@ -782,7 +842,8 @@
   * A swap entry has to fit into a "unsigned long", as the entry is hidden
   * in the "index" field of the swapper address space.
   */
-typedef struct {
+typedef struct
+{
 	unsigned long val;
 } swp_entry_t;
 
diff --color -ruN -w -B '--exclude-from=.diff-exclude' linux-5.10/include/linux/ohp.h HawkEye-5.10-cow/include/linux/ohp.h
--- linux-5.10/include/linux/ohp.h	1970-01-01 00:00:00.000000000 +0000
+++ HawkEye-5.10-cow/include/linux/ohp.h	2025-03-23 07:53:49.638569222 +0000
@@ -0,0 +1,48 @@
+#include <linux/khugepaged.h>
+#include <linux/time.h>
+#include <linux/time64.h>
+#include <linux/timekeeping.h>
+
+extern struct mm_struct *ohp_get_target_mm(unsigned int);
+extern void ohp_clear_pte_accessed_mm(struct mm_struct *mm);
+extern void ohp_adjust_mm_bins(struct mm_struct *mm);
+extern void ohp_exit_mm(struct mm_struct *mm);
+extern bool ohp_has_work(void);
+extern void init_mm_ohp_bins(struct mm_struct *mm);
+extern void remove_ohp_bins(struct vm_area_struct *vma);
+extern int add_ohp_bin(struct mm_struct *mm, unsigned long addr);
+extern unsigned long get_next_ohp_addr(struct mm_struct **mm_struct);
+extern struct ohp_addr *get_ohp_mm_addr(struct mm_struct *mm_struct);
+extern void ohp_putback_kaddr(struct mm_struct *mm, struct ohp_addr *kaddr);
+extern unsigned long ohp_mm_pending_promotions(struct mm_struct *mm);
+extern unsigned long ohp_mm_priority_promotions(struct mm_struct *mm);
+extern unsigned long get_time_difference(struct timespec64 *t0, struct timespec64 *t1);
+extern struct ohp_addr *get_ohp_global_kaddr(struct mm_struct **src);
+int start_kbinmanager(void);
+void stop_kbinmanager(void);
+
+#ifdef CONFIG_TRANSPARENT_HUGEPAGE
+static inline int ohp_enter(struct vm_area_struct *vma,
+				unsigned long address, unsigned long vm_flags)
+{
+	//if (!test_bit(MMF_VM_HUGEPAGE, &vma->vm_mm->flags)) {
+	/*
+	 * khugepaged_enter sets the above flag. Hence, we need to skip this
+	 * to add the current address to ohp_bins.
+	 */
+	if ((khugepaged_always() ||
+	     (khugepaged_req_madv() && (vm_flags & VM_HUGEPAGE))) &&
+	    !(vm_flags & VM_NOHUGEPAGE)) {
+		if (add_ohp_bin(vma->vm_mm, address))
+			return -ENOMEM;
+	}
+	//}
+	return 0;
+}
+#else
+static inline int ohp_enter(struct vm_area_struct *vma,
+			unsigned long address, unsigned long vm_flags)
+{
+	return 0;
+}
+#endif
diff --color -ruN -w -B '--exclude-from=.diff-exclude' linux-5.10/include/linux/page-flags.h HawkEye-5.10-cow/include/linux/page-flags.h
--- linux-5.10/include/linux/page-flags.h	2020-12-13 22:41:30.000000000 +0000
+++ HawkEye-5.10-cow/include/linux/page-flags.h	2025-03-23 07:53:49.574661092 +0000
@@ -101,7 +101,8 @@
  * SPARSEMEM section (for variants of SPARSEMEM that require section ids like
  * SPARSEMEM_EXTREME with !SPARSEMEM_VMEMMAP).
  */
-enum pageflags {
+enum pageflags
+{
 	PG_locked,		/* Page is locked. Don't touch. */
 	PG_referenced,
 	PG_uptodate,
@@ -123,6 +124,7 @@
 	PG_reclaim,		/* To be reclaimed asap */
 	PG_swapbacked,		/* Page is backed by RAM/swap */
 	PG_unevictable,		/* Page is "unevictable"  */
+    PG_zeroed,
 #ifdef CONFIG_MMU
 	PG_mlocked,		/* Page is vma mlocked */
 #endif
@@ -262,31 +264,45 @@
  */
 #define TESTPAGEFLAG(uname, lname, policy)				\
 static __always_inline int Page##uname(struct page *page)		\
-	{ return test_bit(PG_##lname, &policy(page, 0)->flags); }
+    {                                                         \
+        return test_bit(PG_##lname, &policy(page, 0)->flags); \
+    }
 
 #define SETPAGEFLAG(uname, lname, policy)				\
 static __always_inline void SetPage##uname(struct page *page)		\
-	{ set_bit(PG_##lname, &policy(page, 1)->flags); }
+    {                                                             \
+        set_bit(PG_##lname, &policy(page, 1)->flags);             \
+    }
 
 #define CLEARPAGEFLAG(uname, lname, policy)				\
 static __always_inline void ClearPage##uname(struct page *page)		\
-	{ clear_bit(PG_##lname, &policy(page, 1)->flags); }
+    {                                                               \
+        clear_bit(PG_##lname, &policy(page, 1)->flags);             \
+    }
 
 #define __SETPAGEFLAG(uname, lname, policy)				\
 static __always_inline void __SetPage##uname(struct page *page)		\
-	{ __set_bit(PG_##lname, &policy(page, 1)->flags); }
+    {                                                               \
+        __set_bit(PG_##lname, &policy(page, 1)->flags);             \
+    }
 
 #define __CLEARPAGEFLAG(uname, lname, policy)				\
 static __always_inline void __ClearPage##uname(struct page *page)	\
-	{ __clear_bit(PG_##lname, &policy(page, 1)->flags); }
+    {                                                                 \
+        __clear_bit(PG_##lname, &policy(page, 1)->flags);             \
+    }
 
 #define TESTSETFLAG(uname, lname, policy)				\
 static __always_inline int TestSetPage##uname(struct page *page)	\
-	{ return test_and_set_bit(PG_##lname, &policy(page, 1)->flags); }
+    {                                                                 \
+        return test_and_set_bit(PG_##lname, &policy(page, 1)->flags); \
+    }
 
 #define TESTCLEARFLAG(uname, lname, policy)				\
 static __always_inline int TestClearPage##uname(struct page *page)	\
-	{ return test_and_clear_bit(PG_##lname, &policy(page, 1)->flags); }
+    {                                                                   \
+        return test_and_clear_bit(PG_##lname, &policy(page, 1)->flags); \
+    }
 
 #define PAGEFLAG(uname, lname, policy)					\
 	TESTPAGEFLAG(uname, lname, policy)				\
@@ -320,21 +336,28 @@
 #define TESTCLEARFLAG_FALSE(uname)					\
 static inline int TestClearPage##uname(struct page *page) { return 0; }
 
-#define PAGEFLAG_FALSE(uname) TESTPAGEFLAG_FALSE(uname)			\
-	SETPAGEFLAG_NOOP(uname) CLEARPAGEFLAG_NOOP(uname)
+#define PAGEFLAG_FALSE(uname) \
+    TESTPAGEFLAG_FALSE(uname) \
+    SETPAGEFLAG_NOOP(uname)   \
+    CLEARPAGEFLAG_NOOP(uname)
 
 #define TESTSCFLAG_FALSE(uname)						\
-	TESTSETFLAG_FALSE(uname) TESTCLEARFLAG_FALSE(uname)
+    TESTSETFLAG_FALSE(uname)    \
+    TESTCLEARFLAG_FALSE(uname)
 
 __PAGEFLAG(Locked, locked, PF_NO_TAIL)
-PAGEFLAG(Waiters, waiters, PF_ONLY_HEAD) __CLEARPAGEFLAG(Waiters, waiters, PF_ONLY_HEAD)
-PAGEFLAG(Error, error, PF_NO_TAIL) TESTCLEARFLAG(Error, error, PF_NO_TAIL)
+PAGEFLAG(Waiters, waiters, PF_ONLY_HEAD)
+__CLEARPAGEFLAG(Waiters, waiters, PF_ONLY_HEAD)
+PAGEFLAG(Error, error, PF_NO_TAIL)
+TESTCLEARFLAG(Error, error, PF_NO_TAIL)
 PAGEFLAG(Referenced, referenced, PF_HEAD)
 	TESTCLEARFLAG(Referenced, referenced, PF_HEAD)
 	__SETPAGEFLAG(Referenced, referenced, PF_HEAD)
-PAGEFLAG(Dirty, dirty, PF_HEAD) TESTSCFLAG(Dirty, dirty, PF_HEAD)
+PAGEFLAG(Dirty, dirty, PF_HEAD)
+TESTSCFLAG(Dirty, dirty, PF_HEAD)
 	__CLEARPAGEFLAG(Dirty, dirty, PF_HEAD)
-PAGEFLAG(LRU, lru, PF_HEAD) __CLEARPAGEFLAG(LRU, lru, PF_HEAD)
+PAGEFLAG(LRU, lru, PF_HEAD)
+__CLEARPAGEFLAG(LRU, lru, PF_HEAD)
 PAGEFLAG(Active, active, PF_HEAD) __CLEARPAGEFLAG(Active, active, PF_HEAD)
 	TESTCLEARFLAG(Active, active, PF_HEAD)
 PAGEFLAG(Workingset, workingset, PF_HEAD)
@@ -363,9 +386,11 @@
  * for its own purposes.
  * - PG_private and PG_private_2 cause releasepage() and co to be invoked
  */
-PAGEFLAG(Private, private, PF_ANY) __SETPAGEFLAG(Private, private, PF_ANY)
+PAGEFLAG(Private, private, PF_ANY)
+__SETPAGEFLAG(Private, private, PF_ANY)
 	__CLEARPAGEFLAG(Private, private, PF_ANY)
-PAGEFLAG(Private2, private_2, PF_ANY) TESTSCFLAG(Private2, private_2, PF_ANY)
+PAGEFLAG(Private2, private_2, PF_ANY)
+TESTSCFLAG(Private2, private_2, PF_ANY)
 PAGEFLAG(OwnerPriv1, owner_priv_1, PF_ANY)
 	TESTCLEARFLAG(OwnerPriv1, owner_priv_1, PF_ANY)
 
@@ -417,7 +441,8 @@
 	__CLEARPAGEFLAG(Mlocked, mlocked, PF_NO_TAIL)
 	TESTSCFLAG(Mlocked, mlocked, PF_NO_TAIL)
 #else
-PAGEFLAG_FALSE(Mlocked) __CLEARPAGEFLAG_NOOP(Mlocked)
+PAGEFLAG_FALSE(Mlocked)
+__CLEARPAGEFLAG_NOOP(Mlocked)
 	TESTSCFLAG_FALSE(Mlocked)
 #endif
 
@@ -568,7 +593,8 @@
 	test_set_page_writeback_keepwrite(page);
 }
 
-__PAGEFLAG(Head, head, PF_ANY) CLEARPAGEFLAG(Head, head, PF_ANY)
+__PAGEFLAG(Head, head, PF_ANY)
+CLEARPAGEFLAG(Head, head, PF_ANY)
 
 static __always_inline void set_compound_head(struct page *page, struct page *head)
 {
@@ -842,7 +867,8 @@
  * alloc-free cycle to prevent from reusing the page.
  */
 #define PAGE_FLAGS_CHECK_AT_PREP	\
-	(((1UL << NR_PAGEFLAGS) - 1) & ~__PG_HWPOISON)
+    (((1UL << NR_PAGEFLAGS) - 1) & ~__PG_HWPOISON & ~(1UL << PG_zeroed))
+// (((1UL << NR_PAGEFLAGS) - 1) & ~__PG_HWPOISON)
 
 #define PAGE_FLAGS_PRIVATE				\
 	(1UL << PG_private | 1UL << PG_private_2)
@@ -858,6 +884,21 @@
 	return !!(page->flags & PAGE_FLAGS_PRIVATE);
 }
 
+static inline int PageZeroed(struct page *page)
+{
+    return test_bit(PG_zeroed, &page->flags);
+}
+
+static inline void SetPageZeroed(struct page *page)
+{
+    set_bit(PG_zeroed, &page->flags);
+}
+
+static inline void ClearPageZeroed(struct page *page)
+{
+    clear_bit(PG_zeroed, &page->flags);
+}
+
 #undef PF_ANY
 #undef PF_HEAD
 #undef PF_ONLY_HEAD
diff --color -ruN -w -B '--exclude-from=.diff-exclude' linux-5.10/include/linux/syscalls.h HawkEye-5.10-cow/include/linux/syscalls.h
--- linux-5.10/include/linux/syscalls.h	2020-12-13 22:41:30.000000000 +0000
+++ HawkEye-5.10-cow/include/linux/syscalls.h	2025-03-23 07:53:48.663288580 +0000
@@ -165,11 +165,9 @@
 
 #define SYSCALL_METADATA(sname, nb, ...)			\
 	static const char *types_##sname[] = {			\
-		__MAP(nb,__SC_STR_TDECL,__VA_ARGS__)		\
-	};							\
+        __MAP(nb, __SC_STR_TDECL, __VA_ARGS__)};                                 \
 	static const char *args_##sname[] = {			\
-		__MAP(nb,__SC_STR_ADECL,__VA_ARGS__)		\
-	};							\
+        __MAP(nb, __SC_STR_ADECL, __VA_ARGS__)};                                 \
 	SYSCALL_TRACE_ENTER_EVENT(sname);			\
 	SYSCALL_TRACE_EXIT_EVENT(sname);			\
 	static struct syscall_metadata __used			\
@@ -1113,6 +1110,7 @@
 				int maxevents, int timeout);
 asmlinkage long sys_ustat(unsigned dev, struct ustat __user *ubuf);
 asmlinkage long sys_vfork(void);
+asmlinkage long update_mm_ohp_stats(unsigned int pid, unsigned int value);
 asmlinkage long sys_recv(int, void __user *, size_t, unsigned);
 asmlinkage long sys_send(int, void __user *, size_t, unsigned);
 asmlinkage long sys_bdflush(int func, long data);
diff --color -ruN -w -B '--exclude-from=.diff-exclude' linux-5.10/include/linux/vm_event_item.h HawkEye-5.10-cow/include/linux/vm_event_item.h
--- linux-5.10/include/linux/vm_event_item.h	2020-12-13 22:41:30.000000000 +0000
+++ HawkEye-5.10-cow/include/linux/vm_event_item.h	2025-03-23 07:53:48.677896272 +0000
@@ -20,14 +20,26 @@
 #define HIGHMEM_ZONE(xx)
 #endif
 
-#define FOR_ALL_ZONES(xx) DMA_ZONE(xx) DMA32_ZONE(xx) xx##_NORMAL, HIGHMEM_ZONE(xx) xx##_MOVABLE
+#define FOR_ALL_ZONES(xx) \
+    DMA_ZONE(xx)          \
+    DMA32_ZONE(xx)        \
+    xx##_NORMAL, HIGHMEM_ZONE(xx) xx##_MOVABLE
 
-enum vm_event_item { PGPGIN, PGPGOUT, PSWPIN, PSWPOUT,
+enum vm_event_item
+{
+    PGPGIN,
+    PGPGOUT,
+    PSWPIN,
+    PSWPOUT,
 		FOR_ALL_ZONES(PGALLOC),
 		FOR_ALL_ZONES(ALLOCSTALL),
 		FOR_ALL_ZONES(PGSCAN_SKIP),
-		PGFREE, PGACTIVATE, PGDEACTIVATE, PGLAZYFREE,
-		PGFAULT, PGMAJFAULT,
+    PGFREE,
+    PGACTIVATE,
+    PGDEACTIVATE,
+    PGLAZYFREE,
+    PGFAULT,
+    PGMAJFAULT,
 		PGLAZYFREED,
 		PGREFILL,
 		PGREUSE,
@@ -43,10 +55,15 @@
 #ifdef CONFIG_NUMA
 		PGSCAN_ZONE_RECLAIM_FAILED,
 #endif
-		PGINODESTEAL, SLABS_SCANNED, KSWAPD_INODESTEAL,
-		KSWAPD_LOW_WMARK_HIT_QUICKLY, KSWAPD_HIGH_WMARK_HIT_QUICKLY,
-		PAGEOUTRUN, PGROTATED,
-		DROP_PAGECACHE, DROP_SLAB,
+    PGINODESTEAL,
+    SLABS_SCANNED,
+    KSWAPD_INODESTEAL,
+    KSWAPD_LOW_WMARK_HIT_QUICKLY,
+    KSWAPD_HIGH_WMARK_HIT_QUICKLY,
+    PAGEOUTRUN,
+    PGROTATED,
+    DROP_PAGECACHE,
+    DROP_SLAB,
 		OOM_KILL,
 #ifdef CONFIG_NUMA_BALANCING
 		NUMA_PTE_UPDATES,
@@ -56,20 +73,26 @@
 		NUMA_PAGE_MIGRATE,
 #endif
 #ifdef CONFIG_MIGRATION
-		PGMIGRATE_SUCCESS, PGMIGRATE_FAIL,
+    PGMIGRATE_SUCCESS,
+    PGMIGRATE_FAIL,
 		THP_MIGRATION_SUCCESS,
 		THP_MIGRATION_FAIL,
 		THP_MIGRATION_SPLIT,
 #endif
 #ifdef CONFIG_COMPACTION
-		COMPACTMIGRATE_SCANNED, COMPACTFREE_SCANNED,
+    COMPACTMIGRATE_SCANNED,
+    COMPACTFREE_SCANNED,
 		COMPACTISOLATED,
-		COMPACTSTALL, COMPACTFAIL, COMPACTSUCCESS,
+    COMPACTSTALL,
+    COMPACTFAIL,
+    COMPACTSUCCESS,
 		KCOMPACTD_WAKE,
-		KCOMPACTD_MIGRATE_SCANNED, KCOMPACTD_FREE_SCANNED,
+    KCOMPACTD_MIGRATE_SCANNED,
+    KCOMPACTD_FREE_SCANNED,
 #endif
 #ifdef CONFIG_HUGETLB_PAGE
-		HTLB_BUDDY_PGALLOC, HTLB_BUDDY_PGALLOC_FAIL,
+    HTLB_BUDDY_PGALLOC,
+    HTLB_BUDDY_PGALLOC_FAIL,
 #endif
 		UNEVICTABLE_PGCULLED,	/* culled to noreclaim list */
 		UNEVICTABLE_PGSCANNED,	/* scanned for reclaimability */
@@ -99,6 +122,7 @@
 		THP_ZERO_PAGE_ALLOC_FAILED,
 		THP_SWPOUT,
 		THP_SWPOUT_FALLBACK,
+    OHP_PROMOTE_FAILED,
 #endif
 #ifdef CONFIG_MEMORY_BALLOON
 		BALLOON_INFLATE,
diff --color -ruN -w -B '--exclude-from=.diff-exclude' linux-5.10/include/linux/vmstat.h HawkEye-5.10-cow/include/linux/vmstat.h
--- linux-5.10/include/linux/vmstat.h	2020-12-13 22:41:30.000000000 +0000
+++ HawkEye-5.10-cow/include/linux/vmstat.h	2025-03-23 07:53:48.821354485 +0000
@@ -21,7 +21,8 @@
 		void *buffer, size_t *length, loff_t *ppos);
 #endif
 
-struct reclaim_stat {
+struct reclaim_stat
+{
 	unsigned nr_dirty;
 	unsigned nr_unqueued_dirty;
 	unsigned nr_congested;
@@ -34,7 +35,8 @@
 	unsigned nr_lazyfree_fail;
 };
 
-enum writeback_stat_item {
+enum writeback_stat_item
+{
 	NR_DIRTY_THRESHOLD,
 	NR_DIRTY_BG_THRESHOLD,
 	NR_VM_WRITEBACK_STAT_ITEMS,
@@ -51,7 +53,8 @@
  * generated will simply be the increment of a global address.
  */
 
-struct vm_event_state {
+struct vm_event_state
+{
 	unsigned long event[NR_VM_EVENT_ITEMS];
 };
 
@@ -71,6 +74,11 @@
 	this_cpu_inc(vm_event_states.event[item]);
 }
 
+static inline unsigned long read_vm_event(enum vm_event_item item)
+{
+    return this_cpu_read(vm_event_states.event[item]);
+}
+
 static inline void __count_vm_events(enum vm_event_item item, long delta)
 {
 	raw_cpu_add(vm_event_states.event[item], delta);
@@ -113,22 +121,39 @@
 #define count_vm_numa_event(x)     count_vm_event(x)
 #define count_vm_numa_events(x, y) count_vm_events(x, y)
 #else
-#define count_vm_numa_event(x) do {} while (0)
-#define count_vm_numa_events(x, y) do { (void)(y); } while (0)
+#define count_vm_numa_event(x) \
+    do                         \
+    {                          \
+    } while (0)
+#define count_vm_numa_events(x, y) \
+    do                             \
+    {                              \
+        (void)(y);                 \
+    } while (0)
 #endif /* CONFIG_NUMA_BALANCING */
 
 #ifdef CONFIG_DEBUG_TLBFLUSH
 #define count_vm_tlb_event(x)	   count_vm_event(x)
 #define count_vm_tlb_events(x, y)  count_vm_events(x, y)
 #else
-#define count_vm_tlb_event(x)     do {} while (0)
-#define count_vm_tlb_events(x, y) do { (void)(y); } while (0)
+#define count_vm_tlb_event(x) \
+    do                        \
+    {                         \
+    } while (0)
+#define count_vm_tlb_events(x, y) \
+    do                            \
+    {                             \
+        (void)(y);                \
+    } while (0)
 #endif
 
 #ifdef CONFIG_DEBUG_VM_VMACACHE
 #define count_vm_vmacache_event(x) count_vm_event(x)
 #else
-#define count_vm_vmacache_event(x) do {} while (0)
+#define count_vm_vmacache_event(x) \
+    do                             \
+    {                              \
+    } while (0)
 #endif
 
 #define __count_zid_vm_events(item, zid, delta) \
@@ -193,8 +218,7 @@
 	return x;
 }
 
-static inline
-unsigned long global_node_page_state_pages(enum node_stat_item item)
+static inline unsigned long global_node_page_state_pages(enum node_stat_item item)
 {
 	long x = atomic_long_read(&vm_node_stat[item]);
 #ifdef CONFIG_SMP
@@ -312,7 +336,8 @@
 static inline void __mod_node_page_state(struct pglist_data *pgdat,
 			enum node_stat_item item, int delta)
 {
-	if (vmstat_item_in_bytes(item)) {
+    if (vmstat_item_in_bytes(item))
+    {
 		VM_WARN_ON_ONCE(delta & (PAGE_SIZE - 1));
 		delta >>= PAGE_SHIFT;
 	}
@@ -386,9 +409,13 @@
 #define inc_node_state __inc_node_state
 #define dec_zone_state __dec_zone_state
 
-#define set_pgdat_percpu_threshold(pgdat, callback) { }
+#define set_pgdat_percpu_threshold(pgdat, callback) \
+    {                                               \
+    }
 
-static inline void refresh_zone_stat_thresholds(void) { }
+static inline void refresh_zone_stat_thresholds(void)
+{
+}
 static inline void cpu_vm_stats_fold(int cpu) { }
 static inline void quiet_vmstat(void) { }
 
diff --color -ruN -w -B '--exclude-from=.diff-exclude' linux-5.10/kernel/fork.c HawkEye-5.10-cow/kernel/fork.c
--- linux-5.10/kernel/fork.c	2020-12-13 22:41:30.000000000 +0000
+++ HawkEye-5.10-cow/kernel/fork.c	2025-03-23 07:54:15.652126615 +0000
@@ -84,6 +84,7 @@
 #include <linux/user-return-notifier.h>
 #include <linux/oom.h>
 #include <linux/khugepaged.h>
+#include <linux/ohp.h>
 #include <linux/signalfd.h>
 #include <linux/uprobes.h>
 #include <linux/aio.h>
@@ -1009,6 +1010,7 @@
 	atomic_set(&mm->mm_count, 1);
 	mmap_init_lock(mm);
 	INIT_LIST_HEAD(&mm->mmlist);
+    init_mm_ohp_bins(mm);
 	mm->core_state = NULL;
 	mm_pgtables_bytes_init(mm);
 	mm->map_count = 0;
@@ -1075,7 +1077,10 @@
 	uprobe_clear_state(mm);
 	exit_aio(mm);
 	ksm_exit(mm);
+#if 0
 	khugepaged_exit(mm); /* must run before exit_mmap */
+#endif
+	ohp_exit_mm(mm);
 	exit_mmap(mm);
 	mm_put_huge_zero_page(mm);
 	set_mm_exe_file(mm, NULL);
diff --color -ruN -w -B '--exclude-from=.diff-exclude' linux-5.10/Makefile HawkEye-5.10-cow/Makefile
--- linux-5.10/Makefile	2020-12-13 22:41:30.000000000 +0000
+++ HawkEye-5.10-cow/Makefile	2025-03-23 07:53:49.785414562 +0000
@@ -2,7 +2,7 @@
 VERSION = 5
 PATCHLEVEL = 10
 SUBLEVEL = 0
-EXTRAVERSION =
+EXTRAVERSION = -HawkEye-cow
 NAME = Kleptomaniac Octopus
 
 # *DOCUMENTATION*
@@ -495,7 +495,7 @@
 KBUILD_CFLAGS   := -Wall -Wundef -Werror=strict-prototypes -Wno-trigraphs \
 		   -fno-strict-aliasing -fno-common -fshort-wchar -fno-PIE \
 		   -Werror=implicit-function-declaration -Werror=implicit-int \
-		   -Werror=return-type -Wno-format-security \
+		   -Werror=return-type -Wno-format-security -fno-stack-protector\
 		   -std=gnu89
 KBUILD_CPPFLAGS := -D__KERNEL__
 KBUILD_AFLAGS_KERNEL :=
@@ -886,6 +886,9 @@
 KBUILD_CFLAGS += $(call cc-option, -fno-inline-functions-called-once)
 endif
 
+KBUILD_CFLAGS	+= $(call cc-option,-fno-PIE)
+KBUILD_AFLAGS	+= $(call cc-option,-fno-PIE)
+
 ifdef CONFIG_LD_DEAD_CODE_DATA_ELIMINATION
 KBUILD_CFLAGS_KERNEL += -ffunction-sections -fdata-sections
 LDFLAGS_vmlinux += --gc-sections
diff --color -ruN -w -B '--exclude-from=.diff-exclude' linux-5.10/mm/debug.c HawkEye-5.10-cow/mm/debug.c
--- linux-5.10/mm/debug.c	2020-12-13 22:41:30.000000000 +0000
+++ HawkEye-5.10-cow/mm/debug.c	2025-03-23 07:53:49.837041627 +0000
@@ -164,7 +164,7 @@
 		}
 	}
 out_mapping:
-	BUILD_BUG_ON(ARRAY_SIZE(pageflag_names) != __NR_PAGEFLAGS + 1);
+	BUILD_BUG_ON(ARRAY_SIZE(pageflag_names) != __NR_PAGEFLAGS);
 
 	pr_warn("%sflags: %#lx(%pGp)%s\n", type, head->flags, &head->flags,
 		page_cma ? " CMA" : "");
diff --color -ruN -w -B '--exclude-from=.diff-exclude' linux-5.10/mm/huge_memory.c HawkEye-5.10-cow/mm/huge_memory.c
--- linux-5.10/mm/huge_memory.c	2020-12-13 22:41:30.000000000 +0000
+++ HawkEye-5.10-cow/mm/huge_memory.c	2025-03-23 07:53:49.885959003 +0000
@@ -19,6 +19,7 @@
 #include <linux/swapops.h>
 #include <linux/dax.h>
 #include <linux/khugepaged.h>
+#include <linux/ohp.h>
 #include <linux/freezer.h>
 #include <linux/pfn_t.h>
 #include <linux/mman.h>
@@ -86,13 +87,15 @@
 
 	zero_page = alloc_pages((GFP_TRANSHUGE | __GFP_ZERO) & ~__GFP_MOVABLE,
 			HPAGE_PMD_ORDER);
-	if (!zero_page) {
+    if (!zero_page)
+    {
 		count_vm_event(THP_ZERO_PAGE_ALLOC_FAILED);
 		return NULL;
 	}
 	count_vm_event(THP_ZERO_PAGE_ALLOC);
 	preempt_disable();
-	if (cmpxchg(&huge_zero_page, NULL, zero_page)) {
+    if (cmpxchg(&huge_zero_page, NULL, zero_page))
+    {
 		preempt_enable();
 		__free_pages(zero_page, compound_order(zero_page));
 		goto retry;
@@ -143,7 +146,8 @@
 static unsigned long shrink_huge_zero_page_scan(struct shrinker *shrink,
 				       struct shrink_control *sc)
 {
-	if (atomic_cmpxchg(&huge_zero_refcount, 1, 0) == 1) {
+    if (atomic_cmpxchg(&huge_zero_refcount, 1, 0) == 1)
+    {
 		struct page *zero_page = xchg(&huge_zero_page, NULL);
 		BUG_ON(zero_page == NULL);
 		__free_pages(zero_page, compound_order(zero_page));
@@ -177,19 +181,26 @@
 {
 	ssize_t ret = count;
 
-	if (sysfs_streq(buf, "always")) {
+    if (sysfs_streq(buf, "always"))
+    {
 		clear_bit(TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG, &transparent_hugepage_flags);
 		set_bit(TRANSPARENT_HUGEPAGE_FLAG, &transparent_hugepage_flags);
-	} else if (sysfs_streq(buf, "madvise")) {
+    }
+    else if (sysfs_streq(buf, "madvise"))
+    {
 		clear_bit(TRANSPARENT_HUGEPAGE_FLAG, &transparent_hugepage_flags);
 		set_bit(TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG, &transparent_hugepage_flags);
-	} else if (sysfs_streq(buf, "never")) {
+    }
+    else if (sysfs_streq(buf, "never"))
+    {
 		clear_bit(TRANSPARENT_HUGEPAGE_FLAG, &transparent_hugepage_flags);
 		clear_bit(TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG, &transparent_hugepage_flags);
-	} else
+    }
+    else
 		ret = -EINVAL;
 
-	if (ret > 0) {
+    if (ret > 0)
+    {
 		int err = start_stop_khugepaged();
 		if (err)
 			ret = err;
@@ -247,32 +258,42 @@
 			    struct kobj_attribute *attr,
 			    const char *buf, size_t count)
 {
-	if (sysfs_streq(buf, "always")) {
+    if (sysfs_streq(buf, "always"))
+    {
 		clear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG, &transparent_hugepage_flags);
 		clear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG, &transparent_hugepage_flags);
 		clear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG, &transparent_hugepage_flags);
 		set_bit(TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG, &transparent_hugepage_flags);
-	} else if (sysfs_streq(buf, "defer+madvise")) {
+    }
+    else if (sysfs_streq(buf, "defer+madvise"))
+    {
 		clear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG, &transparent_hugepage_flags);
 		clear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG, &transparent_hugepage_flags);
 		clear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG, &transparent_hugepage_flags);
 		set_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG, &transparent_hugepage_flags);
-	} else if (sysfs_streq(buf, "defer")) {
+    }
+    else if (sysfs_streq(buf, "defer"))
+    {
 		clear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG, &transparent_hugepage_flags);
 		clear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG, &transparent_hugepage_flags);
 		clear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG, &transparent_hugepage_flags);
 		set_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG, &transparent_hugepage_flags);
-	} else if (sysfs_streq(buf, "madvise")) {
+    }
+    else if (sysfs_streq(buf, "madvise"))
+    {
 		clear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG, &transparent_hugepage_flags);
 		clear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG, &transparent_hugepage_flags);
 		clear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG, &transparent_hugepage_flags);
 		set_bit(TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG, &transparent_hugepage_flags);
-	} else if (sysfs_streq(buf, "never")) {
+    }
+    else if (sysfs_streq(buf, "never"))
+    {
 		clear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG, &transparent_hugepage_flags);
 		clear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG, &transparent_hugepage_flags);
 		clear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG, &transparent_hugepage_flags);
 		clear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG, &transparent_hugepage_flags);
-	} else
+    }
+    else
 		return -EINVAL;
 
 	return count;
@@ -323,19 +344,22 @@
 	int err;
 
 	*hugepage_kobj = kobject_create_and_add("transparent_hugepage", mm_kobj);
-	if (unlikely(!*hugepage_kobj)) {
+    if (unlikely(!*hugepage_kobj))
+    {
 		pr_err("failed to create transparent hugepage kobject\n");
 		return -ENOMEM;
 	}
 
 	err = sysfs_create_group(*hugepage_kobj, &hugepage_attr_group);
-	if (err) {
+    if (err)
+    {
 		pr_err("failed to register transparent hugepage group\n");
 		goto delete_obj;
 	}
 
 	err = sysfs_create_group(*hugepage_kobj, &khugepaged_attr_group);
-	if (err) {
+    if (err)
+    {
 		pr_err("failed to register transparent hugepage group\n");
 		goto remove_hp_group;
 	}
@@ -371,7 +395,8 @@
 	int err;
 	struct kobject *hugepage_kobj;
 
-	if (!has_transparent_hugepage()) {
+    if (!has_transparent_hugepage())
+    {
 		transparent_hugepage_flags = 0;
 		return -EINVAL;
 	}
@@ -406,7 +431,8 @@
 	 * where the extra memory used could hurt more than TLB overhead
 	 * is likely to save.  The admin can still enable it through /sys.
 	 */
-	if (totalram_pages() < (512 << (20 - PAGE_SHIFT))) {
+    if (totalram_pages() < (512 << (20 - PAGE_SHIFT)))
+    {
 		transparent_hugepage_flags = 0;
 		return 0;
 	}
@@ -434,19 +460,24 @@
 	int ret = 0;
 	if (!str)
 		goto out;
-	if (!strcmp(str, "always")) {
+    if (!strcmp(str, "always"))
+    {
 		set_bit(TRANSPARENT_HUGEPAGE_FLAG,
 			&transparent_hugepage_flags);
 		clear_bit(TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG,
 			  &transparent_hugepage_flags);
 		ret = 1;
-	} else if (!strcmp(str, "madvise")) {
+    }
+    else if (!strcmp(str, "madvise"))
+    {
 		clear_bit(TRANSPARENT_HUGEPAGE_FLAG,
 			  &transparent_hugepage_flags);
 		set_bit(TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG,
 			&transparent_hugepage_flags);
 		ret = 1;
-	} else if (!strcmp(str, "never")) {
+    }
+    else if (!strcmp(str, "never"))
+    {
 		clear_bit(TRANSPARENT_HUGEPAGE_FLAG,
 			  &transparent_hugepage_flags);
 		clear_bit(TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG,
@@ -572,7 +603,8 @@
 
 	VM_BUG_ON_PAGE(!PageCompound(page), page);
 
-	if (mem_cgroup_charge(page, vma->vm_mm, gfp)) {
+    if (mem_cgroup_charge(page, vma->vm_mm, gfp))
+    {
 		put_page(page);
 		count_vm_event(THP_FAULT_FALLBACK);
 		count_vm_event(THP_FAULT_FALLBACK_CHARGE);
@@ -581,11 +613,12 @@
 	cgroup_throttle_swaprate(page, gfp);
 
 	pgtable = pte_alloc_one(vma->vm_mm);
-	if (unlikely(!pgtable)) {
+    if (unlikely(!pgtable))
+    {
 		ret = VM_FAULT_OOM;
 		goto release;
 	}
-
+    if (!PageZeroed(page))
 	clear_huge_page(page, vmf->address, HPAGE_PMD_NR);
 	/*
 	 * The memory barrier inside __SetPageUptodate makes sure that
@@ -595,9 +628,12 @@
 	__SetPageUptodate(page);
 
 	vmf->ptl = pmd_lock(vma->vm_mm, vmf->pmd);
-	if (unlikely(!pmd_none(*vmf->pmd))) {
+    if (unlikely(!pmd_none(*vmf->pmd)))
+    {
 		goto unlock_release;
-	} else {
+    }
+    else
+    {
 		pmd_t entry;
 
 		ret = check_stable_address_space(vma->vm_mm);
@@ -605,7 +641,8 @@
 			goto unlock_release;
 
 		/* Deliver the page fault to userland */
-		if (userfaultfd_missing(vma)) {
+        if (userfaultfd_missing(vma))
+        {
 			vm_fault_t ret2;
 
 			spin_unlock(vmf->ptl);
@@ -664,8 +700,7 @@
 	/* Synchronous compaction if madvised, otherwise kick kcompactd */
 	if (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG, &transparent_hugepage_flags))
 		return GFP_TRANSHUGE_LIGHT |
-			(vma_madvised ? __GFP_DIRECT_RECLAIM :
-					__GFP_KSWAPD_RECLAIM);
+               (vma_madvised ? __GFP_DIRECT_RECLAIM : __GFP_KSWAPD_RECLAIM);
 
 	/* Only do synchronous compaction if madvised */
 	if (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG, &transparent_hugepage_flags))
@@ -703,11 +738,16 @@
 		return VM_FAULT_FALLBACK;
 	if (unlikely(anon_vma_prepare(vma)))
 		return VM_FAULT_OOM;
+#if 0
 	if (unlikely(khugepaged_enter(vma, vma->vm_flags)))
 		return VM_FAULT_OOM;
+#endif
+    if (unlikely(ohp_enter(vma, vmf->address, vma->vm_flags)))
+        return VM_FAULT_OOM;
 	if (!(vmf->flags & FAULT_FLAG_WRITE) &&
 			!mm_forbids_zeropage(vma->vm_mm) &&
-			transparent_hugepage_use_zero_page()) {
+        transparent_hugepage_use_zero_page())
+    {
 		pgtable_t pgtable;
 		struct page *zero_page;
 		vm_fault_t ret;
@@ -715,29 +755,38 @@
 		if (unlikely(!pgtable))
 			return VM_FAULT_OOM;
 		zero_page = mm_get_huge_zero_page(vma->vm_mm);
-		if (unlikely(!zero_page)) {
+        if (unlikely(!zero_page))
+        {
 			pte_free(vma->vm_mm, pgtable);
 			count_vm_event(THP_FAULT_FALLBACK);
 			return VM_FAULT_FALLBACK;
 		}
 		vmf->ptl = pmd_lock(vma->vm_mm, vmf->pmd);
 		ret = 0;
-		if (pmd_none(*vmf->pmd)) {
+        if (pmd_none(*vmf->pmd))
+        {
 			ret = check_stable_address_space(vma->vm_mm);
-			if (ret) {
+            if (ret)
+            {
 				spin_unlock(vmf->ptl);
 				pte_free(vma->vm_mm, pgtable);
-			} else if (userfaultfd_missing(vma)) {
+            }
+            else if (userfaultfd_missing(vma))
+            {
 				spin_unlock(vmf->ptl);
 				pte_free(vma->vm_mm, pgtable);
 				ret = handle_userfault(vmf, VM_UFFD_MISSING);
 				VM_BUG_ON(ret & VM_FAULT_FALLBACK);
-			} else {
+            }
+            else
+            {
 				set_huge_zero_page(pgtable, vma->vm_mm, vma,
 						   haddr, vmf->pmd, zero_page);
 				spin_unlock(vmf->ptl);
 			}
-		} else {
+        }
+        else
+        {
 			spin_unlock(vmf->ptl);
 			pte_free(vma->vm_mm, pgtable);
 		}
@@ -745,7 +794,8 @@
 	}
 	gfp = alloc_hugepage_direct_gfpmask(vma);
 	page = alloc_hugepage_vma(gfp, vma, haddr, HPAGE_PMD_ORDER);
-	if (unlikely(!page)) {
+    if (unlikely(!page))
+    {
 		count_vm_event(THP_FAULT_FALLBACK);
 		return VM_FAULT_FALLBACK;
 	}
@@ -762,9 +812,12 @@
 	spinlock_t *ptl;
 
 	ptl = pmd_lock(mm, pmd);
-	if (!pmd_none(*pmd)) {
-		if (write) {
-			if (pmd_pfn(*pmd) != pfn_t_to_pfn(pfn)) {
+    if (!pmd_none(*pmd))
+    {
+        if (write)
+        {
+            if (pmd_pfn(*pmd) != pfn_t_to_pfn(pfn))
+            {
 				WARN_ON_ONCE(!is_huge_zero_pmd(*pmd));
 				goto out_unlock;
 			}
@@ -780,12 +833,14 @@
 	entry = pmd_mkhuge(pfn_t_pmd(pfn, prot));
 	if (pfn_t_devmap(pfn))
 		entry = pmd_mkdevmap(entry);
-	if (write) {
+    if (write)
+    {
 		entry = pmd_mkyoung(pmd_mkdirty(entry));
 		entry = maybe_pmd_mkwrite(entry, vma);
 	}
 
-	if (pgtable) {
+    if (pgtable)
+    {
 		pgtable_trans_huge_deposit(mm, pmd, pgtable);
 		mm_inc_nr_ptes(mm);
 		pgtable = NULL;
@@ -834,7 +889,8 @@
 	if (addr < vma->vm_start || addr >= vma->vm_end)
 		return VM_FAULT_SIGBUS;
 
-	if (arch_needs_pgtable_deposit()) {
+    if (arch_needs_pgtable_deposit())
+    {
 		pgtable = pte_alloc_one(vma->vm_mm);
 		if (!pgtable)
 			return VM_FAULT_OOM;
@@ -863,9 +919,12 @@
 	spinlock_t *ptl;
 
 	ptl = pud_lock(mm, pud);
-	if (!pud_none(*pud)) {
-		if (write) {
-			if (pud_pfn(*pud) != pfn_t_to_pfn(pfn)) {
+    if (!pud_none(*pud))
+    {
+        if (write)
+        {
+            if (pud_pfn(*pud) != pfn_t_to_pfn(pfn))
+            {
 				WARN_ON_ONCE(!is_huge_zero_pud(*pud));
 				goto out_unlock;
 			}
@@ -880,7 +939,8 @@
 	entry = pud_mkhuge(pfn_t_pud(pfn, prot));
 	if (pfn_t_devmap(pfn))
 		entry = pud_mkdevmap(entry);
-	if (write) {
+    if (write)
+    {
 		entry = pud_mkyoung(pud_mkdirty(entry));
 		entry = maybe_pud_mkwrite(entry, vma);
 	}
@@ -1028,11 +1088,13 @@
 		pmd = pmd_clear_uffd_wp(pmd);
 
 #ifdef CONFIG_ARCH_ENABLE_THP_MIGRATION
-	if (unlikely(is_swap_pmd(pmd))) {
+    if (unlikely(is_swap_pmd(pmd)))
+    {
 		swp_entry_t entry = pmd_to_swp_entry(pmd);
 
 		VM_BUG_ON(!is_pmd_migration_entry(pmd));
-		if (is_write_migration_entry(entry)) {
+        if (is_write_migration_entry(entry))
+        {
 			make_migration_entry_read(&entry);
 			pmd = swp_entry_to_pmd(entry);
 			if (pmd_swp_soft_dirty(*src_pmd))
@@ -1048,7 +1110,8 @@
 	}
 #endif
 
-	if (unlikely(!pmd_trans_huge(pmd))) {
+    if (unlikely(!pmd_trans_huge(pmd)))
+    {
 		pte_free(dst_mm, pgtable);
 		goto out_unlock;
 	}
@@ -1057,7 +1120,8 @@
 	 * under splitting since we don't split the page itself, only pmd to
 	 * a page table.
 	 */
-	if (is_huge_zero_pmd(pmd)) {
+    if (is_huge_zero_pmd(pmd))
+    {
 		struct page *zero_page;
 		/*
 		 * get_huge_zero_page() will never allocate a new page here,
@@ -1083,7 +1147,8 @@
 	 */
 	if (unlikely(is_cow_mapping(vma->vm_flags) &&
 		     atomic_read(&src_mm->has_pinned) &&
-		     page_maybe_dma_pinned(src_page))) {
+                 page_maybe_dma_pinned(src_page)))
+    {
 		pte_free(dst_mm, pgtable);
 		spin_unlock(src_ptl);
 		spin_unlock(dst_ptl);
@@ -1190,14 +1255,16 @@
 	 * under splitting since we don't split the page itself, only pud to
 	 * a page table.
 	 */
-	if (is_huge_zero_pud(pud)) {
+    if (is_huge_zero_pud(pud))
+    {
 		/* No huge zero pud yet */
 	}
 
 	/* Please refer to comments in copy_huge_pmd() */
 	if (unlikely(is_cow_mapping(vma->vm_flags) &&
 		     atomic_read(&src_mm->has_pinned) &&
-		     page_maybe_dma_pinned(pud_page(pud)))) {
+                 page_maybe_dma_pinned(pud_page(pud))))
+    {
 		spin_unlock(src_ptl);
 		spin_unlock(dst_ptl);
 		__split_huge_pud(vma, src_pud, addr);
@@ -1272,7 +1339,8 @@
 
 	spin_lock(vmf->ptl);
 
-	if (unlikely(!pmd_same(*vmf->pmd, orig_pmd))) {
+    if (unlikely(!pmd_same(*vmf->pmd, orig_pmd)))
+    {
 		spin_unlock(vmf->ptl);
 		return 0;
 	}
@@ -1281,12 +1349,14 @@
 	VM_BUG_ON_PAGE(!PageCompound(page) || !PageHead(page), page);
 
 	/* Lock page for reuse_swap_page() */
-	if (!trylock_page(page)) {
+    if (!trylock_page(page))
+    {
 		get_page(page);
 		spin_unlock(vmf->ptl);
 		lock_page(page);
 		spin_lock(vmf->ptl);
-		if (unlikely(!pmd_same(*vmf->pmd, orig_pmd))) {
+        if (unlikely(!pmd_same(*vmf->pmd, orig_pmd)))
+        {
 			spin_unlock(vmf->ptl);
 			unlock_page(page);
 			put_page(page);
@@ -1299,7 +1369,8 @@
 	 * We can only reuse the page if nobody else maps the huge page or it's
 	 * part.
 	 */
-	if (reuse_swap_page(page, NULL)) {
+    if (reuse_swap_page(page, NULL))
+    {
 		pmd_t entry;
 		entry = pmd_mkyoung(orig_pmd);
 		entry = maybe_pmd_mkwrite(pmd_mkdirty(entry), vma);
@@ -1357,7 +1428,8 @@
 	if (flags & FOLL_TOUCH)
 		touch_pmd(vma, addr, pmd, flags);
 
-	if ((flags & FOLL_MLOCK) && (vma->vm_flags & VM_LOCKED)) {
+    if ((flags & FOLL_MLOCK) && (vma->vm_flags & VM_LOCKED))
+    {
 		/*
 		 * We don't mlock() pte-mapped THPs. This way we can avoid
 		 * leaking mlocked pages into non-VM_LOCKED VMAs.
@@ -1420,7 +1492,8 @@
 	 * without disrupting NUMA hinting information. Do not relock and
 	 * check_same as the page may no longer be mapped.
 	 */
-	if (unlikely(pmd_trans_migrating(*vmf->pmd))) {
+    if (unlikely(pmd_trans_migrating(*vmf->pmd)))
+    {
 		page = pmd_page(*vmf->pmd);
 		if (!get_page_unless_zero(page))
 			goto out_unlock;
@@ -1434,7 +1507,8 @@
 	page_nid = page_to_nid(page);
 	last_cpupid = page_cpupid_last(page);
 	count_vm_numa_event(NUMA_HINT_FAULTS);
-	if (page_nid == this_nid) {
+    if (page_nid == this_nid)
+    {
 		count_vm_numa_event(NUMA_HINT_FAULTS_LOCAL);
 		flags |= TNF_FAULT_LOCAL;
 	}
@@ -1449,14 +1523,16 @@
 	 */
 	page_locked = trylock_page(page);
 	target_nid = mpol_misplaced(page, vma, haddr);
-	if (target_nid == NUMA_NO_NODE) {
+    if (target_nid == NUMA_NO_NODE)
+    {
 		/* If the page was locked, there are no parallel migrations */
 		if (page_locked)
 			goto clear_pmdnuma;
 	}
 
 	/* Migration could have started since the pmd_trans_migrating check */
-	if (!page_locked) {
+    if (!page_locked)
+    {
 		page_nid = NUMA_NO_NODE;
 		if (!get_page_unless_zero(page))
 			goto out_unlock;
@@ -1475,7 +1551,8 @@
 
 	/* Confirm the PMD did not change while page_table_lock was released */
 	spin_lock(vmf->ptl);
-	if (unlikely(!pmd_same(pmd, *vmf->pmd))) {
+    if (unlikely(!pmd_same(pmd, *vmf->pmd)))
+    {
 		unlock_page(page);
 		put_page(page);
 		page_nid = NUMA_NO_NODE;
@@ -1483,7 +1560,8 @@
 	}
 
 	/* Bail if we fail to protect against THP splits for any reason */
-	if (unlikely(!anon_vma)) {
+    if (unlikely(!anon_vma))
+    {
 		put_page(page);
 		page_nid = NUMA_NO_NODE;
 		goto clear_pmdnuma;
@@ -1500,7 +1578,8 @@
 	 * We are not sure a pending tlb flush here is for a huge page
 	 * mapping or not. Hence use the tlb range variant
 	 */
-	if (mm_tlb_flush_pending(vma->vm_mm)) {
+    if (mm_tlb_flush_pending(vma->vm_mm))
+    {
 		flush_tlb_range(vma, haddr, haddr + HPAGE_PMD_SIZE);
 		/*
 		 * change_huge_pmd() released the pmd lock before
@@ -1523,10 +1602,12 @@
 
 	migrated = migrate_misplaced_transhuge_page(vma->vm_mm, vma,
 				vmf->pmd, pmd, vmf->address, page, target_nid);
-	if (migrated) {
+    if (migrated)
+    {
 		flags |= TNF_MIGRATED;
 		page_nid = target_nid;
-	} else
+    }
+    else
 		flags |= TNF_MIGRATE_FAIL;
 
 	goto out;
@@ -1577,7 +1658,8 @@
 	if (is_huge_zero_pmd(orig_pmd))
 		goto out;
 
-	if (unlikely(!pmd_present(orig_pmd))) {
+    if (unlikely(!pmd_present(orig_pmd)))
+    {
 		VM_BUG_ON(thp_migration_supported() &&
 				  !is_pmd_migration_entry(orig_pmd));
 		goto out;
@@ -1598,7 +1680,8 @@
 	 * If user want to discard part-pages of THP, split it so MADV_FREE
 	 * will deactivate only them.
 	 */
-	if (next - addr != HPAGE_PMD_SIZE) {
+    if (next - addr != HPAGE_PMD_SIZE)
+    {
 		get_page(page);
 		spin_unlock(ptl);
 		split_huge_page(page);
@@ -1611,7 +1694,8 @@
 		ClearPageDirty(page);
 	unlock_page(page);
 
-	if (pmd_young(orig_pmd) || pmd_dirty(orig_pmd)) {
+    if (pmd_young(orig_pmd) || pmd_dirty(orig_pmd))
+    {
 		pmdp_invalidate(vma, addr, pmd);
 		orig_pmd = pmd_mkold(orig_pmd);
 		orig_pmd = pmd_mkclean(orig_pmd);
@@ -1657,39 +1741,51 @@
 	orig_pmd = pmdp_huge_get_and_clear_full(vma, addr, pmd,
 						tlb->fullmm);
 	tlb_remove_pmd_tlb_entry(tlb, pmd, addr);
-	if (vma_is_special_huge(vma)) {
+    if (vma_is_special_huge(vma))
+    {
 		if (arch_needs_pgtable_deposit())
 			zap_deposited_table(tlb->mm, pmd);
 		spin_unlock(ptl);
 		if (is_huge_zero_pmd(orig_pmd))
 			tlb_remove_page_size(tlb, pmd_page(orig_pmd), HPAGE_PMD_SIZE);
-	} else if (is_huge_zero_pmd(orig_pmd)) {
+    }
+    else if (is_huge_zero_pmd(orig_pmd))
+    {
 		zap_deposited_table(tlb->mm, pmd);
 		spin_unlock(ptl);
 		tlb_remove_page_size(tlb, pmd_page(orig_pmd), HPAGE_PMD_SIZE);
-	} else {
+    }
+    else
+    {
 		struct page *page = NULL;
 		int flush_needed = 1;
 
-		if (pmd_present(orig_pmd)) {
+        if (pmd_present(orig_pmd))
+        {
 			page = pmd_page(orig_pmd);
 			page_remove_rmap(page, true);
 			VM_BUG_ON_PAGE(page_mapcount(page) < 0, page);
 			VM_BUG_ON_PAGE(!PageHead(page), page);
-		} else if (thp_migration_supported()) {
+        }
+        else if (thp_migration_supported())
+        {
 			swp_entry_t entry;
 
 			VM_BUG_ON(!is_pmd_migration_entry(orig_pmd));
 			entry = pmd_to_swp_entry(orig_pmd);
 			page = pfn_to_page(swp_offset(entry));
 			flush_needed = 0;
-		} else
+        }
+        else
 			WARN_ONCE(1, "Non present huge pmd without pmd migration enabled!");
 
-		if (PageAnon(page)) {
+        if (PageAnon(page))
+        {
 			zap_deposited_table(tlb->mm, pmd);
 			add_mm_counter(tlb->mm, MM_ANONPAGES, -HPAGE_PMD_NR);
-		} else {
+        }
+        else
+        {
 			if (arch_needs_pgtable_deposit())
 				zap_deposited_table(tlb->mm, pmd);
 			add_mm_counter(tlb->mm, mm_counter_file(page), -HPAGE_PMD_NR);
@@ -1740,7 +1836,8 @@
 	 * The destination pmd shouldn't be established, free_pgtables()
 	 * should have release it.
 	 */
-	if (WARN_ON(!pmd_none(*new_pmd))) {
+    if (WARN_ON(!pmd_none(*new_pmd)))
+    {
 		VM_BUG_ON(pmd_trans_huge(*new_pmd));
 		return false;
 	}
@@ -1750,7 +1847,8 @@
 	 * ptlocks because exclusive mmap_lock prevents deadlock.
 	 */
 	old_ptl = __pmd_trans_huge_lock(old_pmd, vma);
-	if (old_ptl) {
+    if (old_ptl)
+    {
 		new_ptl = pmd_lockptr(mm, new_pmd);
 		if (new_ptl != old_ptl)
 			spin_lock_nested(new_ptl, SINGLE_DEPTH_NESTING);
@@ -1759,7 +1857,8 @@
 			force_flush = true;
 		VM_BUG_ON(!pmd_none(*new_pmd));
 
-		if (pmd_move_must_withdraw(new_ptl, old_ptl, vma)) {
+        if (pmd_move_must_withdraw(new_ptl, old_ptl, vma))
+        {
 			pgtable_t pgtable;
 			pgtable = pgtable_trans_huge_withdraw(mm, old_pmd);
 			pgtable_trans_huge_deposit(mm, new_pmd, pgtable);
@@ -1802,11 +1901,13 @@
 	ret = 1;
 
 #ifdef CONFIG_ARCH_ENABLE_THP_MIGRATION
-	if (is_swap_pmd(*pmd)) {
+    if (is_swap_pmd(*pmd))
+    {
 		swp_entry_t entry = pmd_to_swp_entry(*pmd);
 
 		VM_BUG_ON(!is_pmd_migration_entry(*pmd));
-		if (is_write_migration_entry(entry)) {
+        if (is_write_migration_entry(entry))
+        {
 			pmd_t newpmd;
 			/*
 			 * A protection check is difficult so
@@ -1859,10 +1960,13 @@
 	entry = pmd_modify(entry, newprot);
 	if (preserve_write)
 		entry = pmd_mk_savedwrite(entry);
-	if (uffd_wp) {
+    if (uffd_wp)
+    {
 		entry = pmd_wrprotect(entry);
 		entry = pmd_mkuffd_wp(entry);
-	} else if (uffd_wp_resolve) {
+    }
+    else if (uffd_wp_resolve)
+    {
 		/*
 		 * Leave the write bit to be handled by PF interrupt
 		 * handler, then things like COW could be properly
@@ -1929,10 +2033,13 @@
 	 */
 	pudp_huge_get_and_clear_full(tlb->mm, addr, pud, tlb->fullmm);
 	tlb_remove_pud_tlb_entry(tlb, pud, addr);
-	if (vma_is_special_huge(vma)) {
+    if (vma_is_special_huge(vma))
+    {
 		spin_unlock(ptl);
 		/* No zero page support yet */
-	} else {
+    }
+    else
+    {
 		/* No support for anonymous PUD pages yet */
 		BUG();
 	}
@@ -1998,7 +2105,8 @@
 	pgtable = pgtable_trans_huge_withdraw(mm, pmd);
 	pmd_populate(mm, &_pmd, pgtable);
 
-	for (i = 0; i < HPAGE_PMD_NR; i++, haddr += PAGE_SIZE) {
+    for (i = 0; i < HPAGE_PMD_NR; i++, haddr += PAGE_SIZE)
+    {
 		pte_t *pte, entry;
 		entry = pfn_pte(my_zero_pfn(haddr), vma->vm_page_prot);
 		entry = pte_mkspecial(entry);
@@ -2025,12 +2133,12 @@
 	VM_BUG_ON(haddr & ~HPAGE_PMD_MASK);
 	VM_BUG_ON_VMA(vma->vm_start > haddr, vma);
 	VM_BUG_ON_VMA(vma->vm_end < haddr + HPAGE_PMD_SIZE, vma);
-	VM_BUG_ON(!is_pmd_migration_entry(*pmd) && !pmd_trans_huge(*pmd)
-				&& !pmd_devmap(*pmd));
+    VM_BUG_ON(!is_pmd_migration_entry(*pmd) && !pmd_trans_huge(*pmd) && !pmd_devmap(*pmd));
 
 	count_vm_event(THP_SPLIT_PMD);
 
-	if (!vma_is_anonymous(vma)) {
+    if (!vma_is_anonymous(vma))
+    {
 		_pmd = pmdp_huge_clear_flush_notify(vma, haddr, pmd);
 		/*
 		 * We are going to unmap this huge page. So
@@ -2049,7 +2157,9 @@
 		put_page(page);
 		add_mm_counter(mm, mm_counter_file(page), -HPAGE_PMD_NR);
 		return;
-	} else if (pmd_trans_huge(*pmd) && is_huge_zero_pmd(*pmd)) {
+    }
+    else if (pmd_trans_huge(*pmd) && is_huge_zero_pmd(*pmd))
+    {
 		/*
 		 * FIXME: Do we want to invalidate secondary mmu by calling
 		 * mmu_notifier_invalidate_range() see comments below inside
@@ -2085,7 +2195,8 @@
 	old_pmd = pmdp_invalidate(vma, haddr, pmd);
 
 	pmd_migration = is_pmd_migration_entry(old_pmd);
-	if (unlikely(pmd_migration)) {
+    if (unlikely(pmd_migration))
+    {
 		swp_entry_t entry;
 
 		entry = pmd_to_swp_entry(old_pmd);
@@ -2094,7 +2205,9 @@
 		young = false;
 		soft_dirty = pmd_swp_soft_dirty(old_pmd);
 		uffd_wp = pmd_swp_uffd_wp(old_pmd);
-	} else {
+    }
+    else
+    {
 		page = pmd_page(old_pmd);
 		if (pmd_dirty(old_pmd))
 			SetPageDirty(page);
@@ -2113,14 +2226,16 @@
 	pgtable = pgtable_trans_huge_withdraw(mm, pmd);
 	pmd_populate(mm, &_pmd, pgtable);
 
-	for (i = 0, addr = haddr; i < HPAGE_PMD_NR; i++, addr += PAGE_SIZE) {
+    for (i = 0, addr = haddr; i < HPAGE_PMD_NR; i++, addr += PAGE_SIZE)
+    {
 		pte_t entry, *pte;
 		/*
 		 * Note that NUMA hinting access restrictions are not
 		 * transferred to avoid any possibility of altering
 		 * permissions across VMAs.
 		 */
-		if (freeze || pmd_migration) {
+        if (freeze || pmd_migration)
+        {
 			swp_entry_t swp_entry;
 			swp_entry = make_migration_entry(page + i, write);
 			entry = swp_entry_to_pte(swp_entry);
@@ -2128,7 +2243,9 @@
 				entry = pte_swp_mksoft_dirty(entry);
 			if (uffd_wp)
 				entry = pte_swp_mkuffd_wp(entry);
-		} else {
+        }
+        else
+        {
 			entry = mk_pte(page + i, READ_ONCE(vma->vm_page_prot));
 			entry = maybe_mkwrite(entry, vma);
 			if (!write)
@@ -2148,22 +2265,26 @@
 		pte_unmap(pte);
 	}
 
-	if (!pmd_migration) {
+    if (!pmd_migration)
+    {
 		/*
 		 * Set PG_double_map before dropping compound_mapcount to avoid
 		 * false-negative page_mapped().
 		 */
 		if (compound_mapcount(page) > 1 &&
-		    !TestSetPageDoubleMap(page)) {
+            !TestSetPageDoubleMap(page))
+        {
 			for (i = 0; i < HPAGE_PMD_NR; i++)
 				atomic_inc(&page[i]._mapcount);
 		}
 
 		lock_page_memcg(page);
-		if (atomic_add_negative(-1, compound_mapcount_ptr(page))) {
+        if (atomic_add_negative(-1, compound_mapcount_ptr(page)))
+        {
 			/* Last compound_mapcount is gone. */
 			__dec_lruvec_page_state(page, NR_ANON_THPS);
-			if (TestClearPageDoubleMap(page)) {
+            if (TestClearPageDoubleMap(page))
+            {
 				/* No need in mapcount reference anymore */
 				for (i = 0; i < HPAGE_PMD_NR; i++)
 					atomic_dec(&page[i]._mapcount);
@@ -2175,8 +2296,10 @@
 	smp_wmb(); /* make pte visible before pmd */
 	pmd_populate(mm, pmd, pgtable);
 
-	if (freeze) {
-		for (i = 0; i < HPAGE_PMD_NR; i++) {
+    if (freeze)
+    {
+        for (i = 0; i < HPAGE_PMD_NR; i++)
+        {
 			page_remove_rmap(page + i, false);
 			put_page(page + i);
 		}
@@ -2202,7 +2325,8 @@
 	 * pmd against. Otherwise we can end up replacing wrong page.
 	 */
 	VM_BUG_ON(freeze && !page);
-	if (page) {
+    if (page)
+    {
 		VM_WARN_ON_ONCE(!PageLocked(page));
 		was_locked = true;
 		if (page != pmd_page(*pmd))
@@ -2210,16 +2334,20 @@
 	}
 
 repeat:
-	if (pmd_trans_huge(*pmd)) {
-		if (!page) {
+    if (pmd_trans_huge(*pmd))
+    {
+        if (!page)
+        {
 			page = pmd_page(*pmd);
-			if (unlikely(!trylock_page(page))) {
+            if (unlikely(!trylock_page(page)))
+            {
 				get_page(page);
 				_pmd = *pmd;
 				spin_unlock(ptl);
 				lock_page(page);
 				spin_lock(ptl);
-				if (unlikely(!pmd_same(*pmd, _pmd))) {
+                if (unlikely(!pmd_same(*pmd, _pmd)))
+                {
 					unlock_page(page);
 					put_page(page);
 					page = NULL;
@@ -2230,7 +2358,8 @@
 		}
 		if (PageMlocked(page))
 			clear_page_mlock(page);
-	} else if (!(pmd_devmap(*pmd) || is_pmd_migration_entry(*pmd)))
+    }
+    else if (!(pmd_devmap(*pmd) || is_pmd_migration_entry(*pmd)))
 		goto out;
 	__split_huge_pmd_locked(vma, pmd, range.start, freeze);
 out:
@@ -2308,7 +2437,8 @@
 	 * vm_next->vm_start isn't hpage aligned and it could previously
 	 * contain an hugepage: check if we need to split an huge pmd.
 	 */
-	if (adjust_next > 0) {
+    if (adjust_next > 0)
+    {
 		struct vm_area_struct *next = vma->vm_next;
 		unsigned long nstart = next->vm_start;
 		nstart += adjust_next;
@@ -2337,9 +2467,12 @@
 static void remap_page(struct page *page, unsigned int nr)
 {
 	int i;
-	if (PageTransHuge(page)) {
+    if (PageTransHuge(page))
+    {
 		remove_migration_ptes(page, page, true);
-	} else {
+    }
+    else
+    {
 		for (i = 0; i < nr; i++)
 			remove_migration_ptes(page + i, page + i, true);
 	}
@@ -2426,7 +2559,8 @@
 	/* complete memcg works before add pages to LRU */
 	mem_cgroup_split_huge_fixup(head);
 
-	if (PageAnon(head) && PageSwapCache(head)) {
+    if (PageAnon(head) && PageSwapCache(head))
+    {
 		swp_entry_t entry = { .val = page_private(head) };
 
 		offset = swp_offset(entry);
@@ -2434,19 +2568,25 @@
 		xa_lock(&swap_cache->i_pages);
 	}
 
-	for (i = nr - 1; i >= 1; i--) {
+    for (i = nr - 1; i >= 1; i--)
+    {
 		__split_huge_page_tail(head, i, lruvec, list);
 		/* Some pages can be beyond i_size: drop them from page cache */
-		if (head[i].index >= end) {
+        if (head[i].index >= end)
+        {
 			ClearPageDirty(head + i);
 			__delete_from_page_cache(head + i, NULL);
 			if (IS_ENABLED(CONFIG_SHMEM) && PageSwapBacked(head))
 				shmem_uncharge(head->mapping->host, 1);
 			put_page(head + i);
-		} else if (!PageAnon(page)) {
+        }
+        else if (!PageAnon(page))
+        {
 			__xa_store(&head->mapping->i_pages, head[i].index,
 					head + i, 0);
-		} else if (swap_cache) {
+        }
+        else if (swap_cache)
+        {
 			__xa_store(&swap_cache->i_pages, offset + i,
 					head + i, 0);
 		}
@@ -2457,15 +2597,21 @@
 	split_page_owner(head, nr);
 
 	/* See comment in __split_huge_page_tail() */
-	if (PageAnon(head)) {
+    if (PageAnon(head))
+    {
 		/* Additional pin to swap cache */
-		if (PageSwapCache(head)) {
+        if (PageSwapCache(head))
+        {
 			page_ref_add(head, 2);
 			xa_unlock(&swap_cache->i_pages);
-		} else {
+        }
+        else
+        {
 			page_ref_inc(head);
 		}
-	} else {
+    }
+    else
+    {
 		/* Additional pin to page cache */
 		page_ref_add(head, 2);
 		xa_unlock(&head->mapping->i_pages);
@@ -2475,13 +2621,15 @@
 
 	remap_page(head, nr);
 
-	if (PageSwapCache(head)) {
+    if (PageSwapCache(head))
+    {
 		swp_entry_t entry = { .val = page_private(head) };
 
 		split_swap_cluster(entry);
 	}
 
-	for (i = 0; i < nr; i++) {
+    for (i = 0; i < nr; i++)
+    {
 		struct page *subpage = head + i;
 		if (subpage == page)
 			continue;
@@ -2553,7 +2701,8 @@
 	/* hugetlbfs shouldn't call it */
 	VM_BUG_ON_PAGE(PageHuge(page), page);
 
-	if (likely(!PageTransCompound(page))) {
+    if (likely(!PageTransCompound(page)))
+    {
 		mapcount = atomic_read(&page->_mapcount) + 1;
 		if (total_mapcount)
 			*total_mapcount = mapcount;
@@ -2563,12 +2712,14 @@
 	page = compound_head(page);
 
 	_total_mapcount = ret = 0;
-	for (i = 0; i < thp_nr_pages(page); i++) {
+    for (i = 0; i < thp_nr_pages(page); i++)
+    {
 		mapcount = atomic_read(&page[i]._mapcount) + 1;
 		ret = max(ret, mapcount);
 		_total_mapcount += mapcount;
 	}
-	if (PageDoubleMap(page)) {
+    if (PageDoubleMap(page))
+    {
 		ret -= 1;
 		_total_mapcount -= thp_nr_pages(page);
 	}
@@ -2632,7 +2783,8 @@
 	if (PageWriteback(head))
 		return -EBUSY;
 
-	if (PageAnon(head)) {
+    if (PageAnon(head))
+    {
 		/*
 		 * The caller does not necessarily hold an mmap_lock that would
 		 * prevent the anon_vma disappearing so we first we take a
@@ -2642,18 +2794,22 @@
 		 * operations.
 		 */
 		anon_vma = page_get_anon_vma(head);
-		if (!anon_vma) {
+        if (!anon_vma)
+        {
 			ret = -EBUSY;
 			goto out;
 		}
 		end = -1;
 		mapping = NULL;
 		anon_vma_lock_write(anon_vma);
-	} else {
+    }
+    else
+    {
 		mapping = head->mapping;
 
 		/* Truncated ? */
-		if (!mapping) {
+        if (!mapping)
+        {
 			ret = -EBUSY;
 			goto out;
 		}
@@ -2675,7 +2831,8 @@
 	 * Racy check if we can split the page, before unmap_page() will
 	 * split PMDs
 	 */
-	if (!can_split_huge_page(head, &extra_pins)) {
+    if (!can_split_huge_page(head, &extra_pins))
+    {
 		ret = -EBUSY;
 		goto out_unlock;
 	}
@@ -2686,7 +2843,8 @@
 	/* prevent PageLRU to go away from under us, and freeze lru stats */
 	spin_lock_irqsave(&pgdata->lru_lock, flags);
 
-	if (mapping) {
+    if (mapping)
+    {
 		XA_STATE(xas, &mapping->i_pages, page_index(head));
 
 		/*
@@ -2702,13 +2860,16 @@
 	spin_lock(&ds_queue->split_queue_lock);
 	count = page_count(head);
 	mapcount = total_mapcount(head);
-	if (!mapcount && page_ref_freeze(head, 1 + extra_pins)) {
-		if (!list_empty(page_deferred_list(head))) {
+    if (!mapcount && page_ref_freeze(head, 1 + extra_pins))
+    {
+        if (!list_empty(page_deferred_list(head)))
+        {
 			ds_queue->split_queue_len--;
 			list_del(page_deferred_list(head));
 		}
 		spin_unlock(&ds_queue->split_queue_lock);
-		if (mapping) {
+        if (mapping)
+        {
 			if (PageSwapBacked(head))
 				__dec_node_page_state(head, NR_SHMEM_THPS);
 			else
@@ -2717,8 +2878,11 @@
 
 		__split_huge_page(page, list, end, flags);
 		ret = 0;
-	} else {
-		if (IS_ENABLED(CONFIG_DEBUG_VM) && mapcount) {
+    }
+    else
+    {
+        if (IS_ENABLED(CONFIG_DEBUG_VM) && mapcount)
+        {
 			pr_alert("total_mapcount: %u, page_count(): %u\n",
 					mapcount, count);
 			if (PageTail(page))
@@ -2727,7 +2891,8 @@
 			BUG();
 		}
 		spin_unlock(&ds_queue->split_queue_lock);
-fail:		if (mapping)
+    fail:
+        if (mapping)
 			xa_unlock(&mapping->i_pages);
 		spin_unlock_irqrestore(&pgdata->lru_lock, flags);
 		remap_page(head, thp_nr_pages(head));
@@ -2735,7 +2900,8 @@
 	}
 
 out_unlock:
-	if (anon_vma) {
+    if (anon_vma)
+    {
 		anon_vma_unlock_write(anon_vma);
 		put_anon_vma(anon_vma);
 	}
@@ -2752,7 +2918,8 @@
 	unsigned long flags;
 
 	spin_lock_irqsave(&ds_queue->split_queue_lock, flags);
-	if (!list_empty(page_deferred_list(page))) {
+    if (!list_empty(page_deferred_list(page)))
+    {
 		ds_queue->split_queue_len--;
 		list_del(page_deferred_list(page));
 	}
@@ -2784,7 +2951,8 @@
 		return;
 
 	spin_lock_irqsave(&ds_queue->split_queue_lock, flags);
-	if (list_empty(page_deferred_list(page))) {
+    if (list_empty(page_deferred_list(page)))
+    {
 		count_vm_event(THP_DEFERRED_SPLIT_PAGE);
 		list_add_tail(page_deferred_list(page), &ds_queue->split_queue);
 		ds_queue->split_queue_len++;
@@ -2827,12 +2995,16 @@
 
 	spin_lock_irqsave(&ds_queue->split_queue_lock, flags);
 	/* Take pin on all head pages to avoid freeing them under us */
-	list_for_each_safe(pos, next, &ds_queue->split_queue) {
+    list_for_each_safe(pos, next, &ds_queue->split_queue)
+    {
 		page = list_entry((void *)pos, struct page, mapping);
 		page = compound_head(page);
-		if (get_page_unless_zero(page)) {
+        if (get_page_unless_zero(page))
+        {
 			list_move(page_deferred_list(page), &list);
-		} else {
+        }
+        else
+        {
 			/* We lost race with put_compound_page() */
 			list_del_init(page_deferred_list(page));
 			ds_queue->split_queue_len--;
@@ -2842,7 +3014,8 @@
 	}
 	spin_unlock_irqrestore(&ds_queue->split_queue_lock, flags);
 
-	list_for_each_safe(pos, next, &list) {
+    list_for_each_safe(pos, next, &list)
+    {
 		page = list_entry((void *)pos, struct page, mapping);
 		if (!trylock_page(page))
 			goto next;
@@ -2886,9 +3059,11 @@
 	if (val != 1)
 		return -EINVAL;
 
-	for_each_populated_zone(zone) {
+    for_each_populated_zone(zone)
+    {
 		max_zone_pfn = zone_end_pfn(zone);
-		for (pfn = zone->zone_start_pfn; pfn < max_zone_pfn; pfn++) {
+        for (pfn = zone->zone_start_pfn; pfn < max_zone_pfn; pfn++)
+        {
 			if (!pfn_valid(pfn))
 				continue;
 
diff --color -ruN -w -B '--exclude-from=.diff-exclude' linux-5.10/mm/khugepaged.c HawkEye-5.10-cow/mm/khugepaged.c
--- linux-5.10/mm/khugepaged.c	2020-12-13 22:41:30.000000000 +0000
+++ HawkEye-5.10-cow/mm/khugepaged.c	2025-03-23 07:53:49.835159951 +0000
@@ -11,6 +11,7 @@
 #include <linux/mm_inline.h>
 #include <linux/kthread.h>
 #include <linux/khugepaged.h>
+#include <linux/ohp.h>
 #include <linux/freezer.h>
 #include <linux/mman.h>
 #include <linux/hashtable.h>
@@ -23,7 +24,13 @@
 #include <asm/pgalloc.h>
 #include "internal.h"
 
-enum scan_result {
+#include <uapi/linux/time.h>
+#include <linux/time64.h>
+#include <linux/timekeeping.h>
+
+
+enum scan_result
+{
 	SCAN_FAIL,
 	SCAN_SUCCEED,
 	SCAN_PMD_NULL,
@@ -61,11 +68,16 @@
 
 /* default scan 8*512 pte (or vmas) every 30 second */
 static unsigned int khugepaged_pages_to_scan __read_mostly;
+static unsigned int max_thp_collapse_alloc __read_mostly = 1250000000;
+static atomic_t thp_collapse_alloc;
 static unsigned int khugepaged_pages_collapsed;
 static unsigned int khugepaged_full_scans;
 static unsigned int khugepaged_scan_sleep_millisecs __read_mostly = 10000;
+static unsigned int khugepaged_max_cpu __read_mostly = 0;
+static unsigned int khugepaged_min_sleep __read_mostly = 0;
+static unsigned int khugepaged_promotion_metric __read_mostly = 0;
 /* during fragmentation poll the hugepage allocator once every minute */
-static unsigned int khugepaged_alloc_sleep_millisecs __read_mostly = 60000;
+static unsigned int khugepaged_alloc_sleep_millisecs __read_mostly = 0;
 static unsigned long khugepaged_sleep_expire;
 static DEFINE_SPINLOCK(khugepaged_mm_lock);
 static DECLARE_WAIT_QUEUE_HEAD(khugepaged_wait);
@@ -91,7 +103,8 @@
  * @mm_node: khugepaged scan list headed in khugepaged_scan.mm_head
  * @mm: the mm that this information is valid for
  */
-struct mm_slot {
+struct mm_slot
+{
 	struct hlist_node hash;
 	struct list_head mm_node;
 	struct mm_struct *mm;
@@ -109,7 +122,8 @@
  *
  * There is only the one khugepaged_scan instance of this cursor structure.
  */
-struct khugepaged_scan {
+struct khugepaged_scan
+{
 	struct list_head mm_head;
 	struct mm_slot *mm_slot;
 	unsigned long address;
@@ -148,6 +162,75 @@
 	__ATTR(scan_sleep_millisecs, 0644, scan_sleep_millisecs_show,
 	       scan_sleep_millisecs_store);
 
+static ssize_t max_cpu_show(struct kobject *kobj, struct kobj_attribute *attr,
+                            char *buf)
+{
+    return sprintf(buf, "%u\n", khugepaged_max_cpu);
+}
+
+static ssize_t max_cpu_store(struct kobject *kobj, struct kobj_attribute *attr,
+                             const char *buf, size_t count)
+{
+    unsigned long cpu;
+    int err;
+
+    err = kstrtoul(buf, 10, &cpu);
+    if (err || cpu < 0 || cpu > 100)
+        return -EINVAL;
+
+    khugepaged_max_cpu = cpu;
+    return count;
+}
+
+static struct kobj_attribute max_cpu_attr =
+    __ATTR(max_cpu, 0644, max_cpu_show, max_cpu_store);
+
+static ssize_t min_sleep_show(struct kobject *kobj, struct kobj_attribute *attr,
+                              char *buf)
+{
+    return sprintf(buf, "%u\n", khugepaged_min_sleep);
+}
+
+static ssize_t min_sleep_store(struct kobject *kobj, struct kobj_attribute *attr,
+                               const char *buf, size_t count)
+{
+    unsigned long cpu;
+    int err;
+
+    err = kstrtoul(buf, 10, &cpu);
+    if (err || cpu < 0 || cpu > 100)
+        return -EINVAL;
+
+    khugepaged_min_sleep = cpu;
+    return count;
+}
+
+static struct kobj_attribute min_sleep_attr =
+    __ATTR(min_sleep, 0644, min_sleep_show, min_sleep_store);
+
+static ssize_t promotion_metric_show(struct kobject *kobj,
+                                     struct kobj_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%u\n", khugepaged_promotion_metric);
+}
+
+static ssize_t promotion_metric_store(struct kobject *kobj,
+                                      struct kobj_attribute *attr, const char *buf, size_t count)
+{
+    unsigned long metric;
+    int err;
+
+    err = kstrtoul(buf, 10, &metric);
+    if (err || metric < 0 || metric > 2)
+        return -EINVAL;
+
+    khugepaged_promotion_metric = metric;
+    return count;
+}
+
+static struct kobj_attribute promotion_metric_attr =
+    __ATTR(promotion_metric, 0644, promotion_metric_show, promotion_metric_store);
+
 static ssize_t alloc_sleep_millisecs_show(struct kobject *kobj,
 					  struct kobj_attribute *attr,
 					  char *buf)
@@ -182,6 +265,34 @@
 {
 	return sprintf(buf, "%u\n", khugepaged_pages_to_scan);
 }
+
+static ssize_t max_thp_collapse_alloc_show(struct kobject *kobj,
+                                           struct kobj_attribute *attr,
+                                           char *buf)
+{
+    return sprintf(buf, "%u\n", max_thp_collapse_alloc);
+}
+
+static ssize_t max_thp_collapse_alloc_store(struct kobject *kobj,
+                                            struct kobj_attribute *attr,
+                                            const char *buf, size_t count)
+{
+    int err;
+    unsigned long pages;
+
+    err = kstrtoul(buf, 10, &pages);
+    if (err || !pages || pages > UINT_MAX)
+        return -EINVAL;
+
+    max_thp_collapse_alloc = pages + read_vm_event(THP_COLLAPSE_ALLOC);
+
+    return count;
+}
+
+static struct kobj_attribute max_thp_collapse_alloc_attr =
+    __ATTR(max_thp_collapse_alloc, 0644, max_thp_collapse_alloc_show,
+           max_thp_collapse_alloc_store);
+
 static ssize_t pages_to_scan_store(struct kobject *kobj,
 				   struct kobj_attribute *attr,
 				   const char *buf, size_t count)
@@ -333,6 +444,10 @@
 	&full_scans_attr.attr,
 	&scan_sleep_millisecs_attr.attr,
 	&alloc_sleep_millisecs_attr.attr,
+    &max_thp_collapse_alloc_attr.attr,
+    &max_cpu_attr.attr,
+    &min_sleep_attr.attr,
+    &promotion_metric_attr.attr,
 	NULL,
 };
 
@@ -345,7 +460,8 @@
 int hugepage_madvise(struct vm_area_struct *vma,
 		     unsigned long *vm_flags, int advice)
 {
-	switch (advice) {
+    switch (advice)
+    {
 	case MADV_HUGEPAGE:
 #ifdef CONFIG_S390
 		/*
@@ -418,9 +534,7 @@
 {
 	struct mm_slot *mm_slot;
 
-	hash_for_each_possible(mm_slots_hash, mm_slot, hash, (unsigned long)mm)
-		if (mm == mm_slot->mm)
-			return mm_slot;
+    hash_for_each_possible(mm_slots_hash, mm_slot, hash, (unsigned long)mm) if (mm == mm_slot->mm) return mm_slot;
 
 	return NULL;
 }
@@ -448,7 +562,8 @@
 	if (shmem_file(vma->vm_file) ||
 	    (IS_ENABLED(CONFIG_READ_ONLY_THP_FOR_FS) &&
 	     vma->vm_file &&
-	     (vm_flags & VM_DENYWRITE))) {
+         (vm_flags & VM_DENYWRITE)))
+    {
 		return IS_ALIGNED((vma->vm_start >> PAGE_SHIFT) - vma->vm_pgoff,
 				HPAGE_PMD_NR);
 	}
@@ -470,7 +585,8 @@
 
 	/* __khugepaged_exit() must not run from under us */
 	VM_BUG_ON_MM(atomic_read(&mm->mm_users) == 0, mm);
-	if (unlikely(test_and_set_bit(MMF_VM_HUGEPAGE, &mm->flags))) {
+    if (unlikely(test_and_set_bit(MMF_VM_HUGEPAGE, &mm->flags)))
+    {
 		free_mm_slot(mm_slot);
 		return 0;
 	}
@@ -519,18 +635,22 @@
 
 	spin_lock(&khugepaged_mm_lock);
 	mm_slot = get_mm_slot(mm);
-	if (mm_slot && khugepaged_scan.mm_slot != mm_slot) {
+    if (mm_slot && khugepaged_scan.mm_slot != mm_slot)
+    {
 		hash_del(&mm_slot->hash);
 		list_del(&mm_slot->mm_node);
 		free = 1;
 	}
 	spin_unlock(&khugepaged_mm_lock);
 
-	if (free) {
+    if (free)
+    {
 		clear_bit(MMF_VM_HUGEPAGE, &mm->flags);
 		free_mm_slot(mm_slot);
 		mmdrop(mm);
-	} else if (mm_slot) {
+    }
+    else if (mm_slot)
+    {
 		/*
 		 * This is required to serialize against
 		 * khugepaged_test_exit() (which is guaranteed to run
@@ -558,7 +678,8 @@
 {
 	struct page *page, *tmp;
 
-	while (--_pte >= pte) {
+    while (--_pte >= pte)
+    {
 		pte_t pteval = *_pte;
 
 		page = pte_page(pteval);
@@ -567,7 +688,8 @@
 			release_pte_page(page);
 	}
 
-	list_for_each_entry_safe(page, tmp, compound_pagelist, lru) {
+    list_for_each_entry_safe(page, tmp, compound_pagelist, lru)
+    {
 		list_del(&page->lru);
 		release_pte_page(page);
 	}
@@ -595,24 +717,31 @@
 	bool writable = false;
 
 	for (_pte = pte; _pte < pte+HPAGE_PMD_NR;
-	     _pte++, address += PAGE_SIZE) {
+         _pte++, address += PAGE_SIZE)
+    {
 		pte_t pteval = *_pte;
 		if (pte_none(pteval) || (pte_present(pteval) &&
-				is_zero_pfn(pte_pfn(pteval)))) {
+                                 is_zero_pfn(pte_pfn(pteval))))
+        {
 			if (!userfaultfd_armed(vma) &&
-			    ++none_or_zero <= khugepaged_max_ptes_none) {
+                ++none_or_zero <= khugepaged_max_ptes_none)
+            {
 				continue;
-			} else {
+            }
+            else
+            {
 				result = SCAN_EXCEED_NONE_PTE;
 				goto out;
 			}
 		}
-		if (!pte_present(pteval)) {
+        if (!pte_present(pteval))
+        {
 			result = SCAN_PTE_NON_PRESENT;
 			goto out;
 		}
 		page = vm_normal_page(vma, address, pteval);
-		if (unlikely(!page)) {
+        if (unlikely(!page))
+        {
 			result = SCAN_PAGE_NULL;
 			goto out;
 		}
@@ -620,12 +749,14 @@
 		VM_BUG_ON_PAGE(!PageAnon(page), page);
 
 		if (page_mapcount(page) > 1 &&
-				++shared > khugepaged_max_ptes_shared) {
+            ++shared > khugepaged_max_ptes_shared)
+        {
 			result = SCAN_EXCEED_SHARED_PTE;
 			goto out;
 		}
 
-		if (PageCompound(page)) {
+        if (PageCompound(page))
+        {
 			struct page *p;
 			page = compound_head(page);
 
@@ -633,7 +764,8 @@
 			 * Check if we have dealt with the compound page
 			 * already
 			 */
-			list_for_each_entry(p, compound_pagelist, lru) {
+            list_for_each_entry(p, compound_pagelist, lru)
+            {
 				if (page == p)
 					goto next;
 			}
@@ -645,7 +777,8 @@
 		 * is needed to serialize against split_huge_page
 		 * when invoked from the VM.
 		 */
-		if (!trylock_page(page)) {
+        if (!trylock_page(page))
+        {
 			result = SCAN_PAGE_LOCK;
 			goto out;
 		}
@@ -661,13 +794,15 @@
 		 * but not from this process. The other process cannot write to
 		 * the page, only trigger CoW.
 		 */
-		if (!is_refcount_suitable(page)) {
+        if (!is_refcount_suitable(page))
+        {
 			unlock_page(page);
 			result = SCAN_PAGE_COUNT;
 			goto out;
 		}
 		if (!pte_write(pteval) && PageSwapCache(page) &&
-				!reuse_swap_page(page, NULL)) {
+            !reuse_swap_page(page, NULL))
+        {
 			/*
 			 * Page is in the swap cache and cannot be re-used.
 			 * It cannot be collapsed into a THP.
@@ -681,7 +816,8 @@
 		 * Isolate the page to avoid collapsing an hugepage
 		 * currently in use by the VM.
 		 */
-		if (isolate_lru_page(page)) {
+        if (isolate_lru_page(page))
+        {
 			unlock_page(page);
 			result = SCAN_DEL_PAGE_LRU;
 			goto out;
@@ -704,14 +840,18 @@
 		if (pte_write(pteval))
 			writable = true;
 	}
-	if (likely(writable)) {
-		if (likely(referenced)) {
+    if (likely(writable))
+    {
+        if (likely(referenced))
+        {
 			result = SCAN_SUCCEED;
 			trace_mm_collapse_huge_page_isolate(page, none_or_zero,
 							    referenced, writable, result);
 			return 1;
 		}
-	} else {
+    }
+    else
+    {
 		result = SCAN_PAGE_RO;
 	}
 
@@ -731,13 +871,16 @@
 	struct page *src_page, *tmp;
 	pte_t *_pte;
 	for (_pte = pte; _pte < pte + HPAGE_PMD_NR;
-				_pte++, page++, address += PAGE_SIZE) {
+         _pte++, page++, address += PAGE_SIZE)
+    {
 		pte_t pteval = *_pte;
 
-		if (pte_none(pteval) || is_zero_pfn(pte_pfn(pteval))) {
+        if (pte_none(pteval) || is_zero_pfn(pte_pfn(pteval)))
+        {
 			clear_user_highpage(page, address);
 			add_mm_counter(vma->vm_mm, MM_ANONPAGES, 1);
-			if (is_zero_pfn(pte_pfn(pteval))) {
+            if (is_zero_pfn(pte_pfn(pteval)))
+            {
 				/*
 				 * ptl mostly unnecessary.
 				 */
@@ -749,7 +892,9 @@
 				pte_clear(vma->vm_mm, address, _pte);
 				spin_unlock(ptl);
 			}
-		} else {
+        }
+        else
+        {
 			src_page = pte_page(pteval);
 			copy_user_highpage(page, src_page, address, vma);
 			if (!PageCompound(src_page))
@@ -771,7 +916,8 @@
 		}
 	}
 
-	list_for_each_entry_safe(src_page, tmp, compound_pagelist, lru) {
+    list_for_each_entry_safe(src_page, tmp, compound_pagelist, lru)
+    {
 		list_del(&src_page->lru);
 		release_pte_page(src_page);
 	}
@@ -804,7 +950,8 @@
 	if (khugepaged_node_load[nid])
 		return false;
 
-	for (i = 0; i < MAX_NUMNODES; i++) {
+    for (i = 0; i < MAX_NUMNODES; i++)
+    {
 		if (!khugepaged_node_load[i])
 			continue;
 		if (node_distance(nid, i) > node_reclaim_distance)
@@ -827,7 +974,8 @@
 
 	/* find first node with max normal pages hit */
 	for (nid = 0; nid < MAX_NUMNODES; nid++)
-		if (khugepaged_node_load[nid] > max_value) {
+        if (khugepaged_node_load[nid] > max_value)
+        {
 			max_value = khugepaged_node_load[nid];
 			target_node = nid;
 		}
@@ -836,7 +984,8 @@
 	if (target_node <= last_khugepaged_target_node)
 		for (nid = last_khugepaged_target_node + 1; nid < MAX_NUMNODES;
 				nid++)
-			if (max_value == khugepaged_node_load[nid]) {
+            if (max_value == khugepaged_node_load[nid])
+            {
 				target_node = nid;
 				break;
 			}
@@ -847,14 +996,17 @@
 
 static bool khugepaged_prealloc_page(struct page **hpage, bool *wait)
 {
-	if (IS_ERR(*hpage)) {
+    if (IS_ERR(*hpage))
+    {
 		if (!*wait)
 			return false;
 
 		*wait = false;
 		*hpage = NULL;
 		khugepaged_alloc_sleep();
-	} else if (*hpage) {
+    }
+    else if (*hpage)
+    {
 		put_page(*hpage);
 		*hpage = NULL;
 	}
@@ -867,8 +1019,13 @@
 {
 	VM_BUG_ON_PAGE(*hpage, *hpage);
 
+    // *hpage = __alloc_pages_node(node, gfp, HPAGE_PMD_ORDER);
+    if (atomic_read(&thp_collapse_alloc) < max_thp_collapse_alloc)
 	*hpage = __alloc_pages_node(node, gfp, HPAGE_PMD_ORDER);
-	if (unlikely(!*hpage)) {
+    else
+        *hpage = NULL;
+    if (unlikely(!*hpage))
+    {
 		count_vm_event(THP_COLLAPSE_ALLOC_FAILED);
 		*hpage = ERR_PTR(-ENOMEM);
 		return NULL;
@@ -876,6 +1033,7 @@
 
 	prep_transhuge_page(*hpage);
 	count_vm_event(THP_COLLAPSE_ALLOC);
+    atomic_inc(&thp_collapse_alloc);
 	return *hpage;
 }
 #else
@@ -899,16 +1057,19 @@
 {
 	struct page *hpage;
 
-	do {
+    do
+    {
 		hpage = alloc_khugepaged_hugepage();
-		if (!hpage) {
+        if (!hpage)
+        {
 			count_vm_event(THP_COLLAPSE_ALLOC_FAILED);
 			if (!*wait)
 				return NULL;
 
 			*wait = false;
 			khugepaged_alloc_sleep();
-		} else
+        }
+        else
 			count_vm_event(THP_COLLAPSE_ALLOC);
 	} while (unlikely(!hpage) && likely(khugepaged_enabled()));
 
@@ -924,7 +1085,8 @@
 	 * finding the hpage reused for the same mapping at a different offset.
 	 * Just release the previous allocation if there is any danger of that.
 	 */
-	if (*hpage && page_count(*hpage) > 1) {
+    if (*hpage && page_count(*hpage) > 1)
+    {
 		put_page(*hpage);
 		*hpage = NULL;
 	}
@@ -1004,7 +1166,8 @@
 
 	vmf.pte = pte_offset_map(pmd, address);
 	for (; vmf.address < address + HPAGE_PMD_NR*PAGE_SIZE;
-			vmf.pte++, vmf.address += PAGE_SIZE) {
+         vmf.pte++, vmf.address += PAGE_SIZE)
+    {
 		vmf.orig_pte = *vmf.pte;
 		if (!is_swap_pte(vmf.orig_pte))
 			continue;
@@ -1012,20 +1175,24 @@
 		ret = do_swap_page(&vmf);
 
 		/* do_swap_page returns VM_FAULT_RETRY with released mmap_lock */
-		if (ret & VM_FAULT_RETRY) {
+        if (ret & VM_FAULT_RETRY)
+        {
 			mmap_read_lock(mm);
-			if (hugepage_vma_revalidate(mm, address, &vmf.vma)) {
+            if (hugepage_vma_revalidate(mm, address, &vmf.vma))
+            {
 				/* vma is no longer available, don't continue to swapin */
 				trace_mm_collapse_huge_page_swapin(mm, swapped_in, referenced, 0);
 				return false;
 			}
 			/* check if the pmd is still valid */
-			if (mm_find_pmd(mm, address) != pmd) {
+            if (mm_find_pmd(mm, address) != pmd)
+            {
 				trace_mm_collapse_huge_page_swapin(mm, swapped_in, referenced, 0);
 				return false;
 			}
 		}
-		if (ret & VM_FAULT_ERROR) {
+        if (ret & VM_FAULT_ERROR)
+        {
 			trace_mm_collapse_huge_page_swapin(mm, swapped_in, referenced, 0);
 			return false;
 		}
@@ -1043,7 +1210,7 @@
 	return true;
 }
 
-static void collapse_huge_page(struct mm_struct *mm,
+static int collapse_huge_page(struct mm_struct *mm,
 				   unsigned long address,
 				   struct page **hpage,
 				   int node, int referenced, int unmapped)
@@ -1072,26 +1239,38 @@
 	 */
 	mmap_read_unlock(mm);
 	new_page = khugepaged_alloc_page(hpage, gfp, node);
-	if (!new_page) {
+    if (!new_page)
+    {
 		result = SCAN_ALLOC_HUGE_PAGE_FAIL;
-		goto out_nolock;
+        if (!IS_ERR_OR_NULL(*hpage))
+            mem_cgroup_uncharge(*hpage);
+        trace_mm_collapse_huge_page(mm, isolated, result);
+        return 0;
+        // goto out_nolock; // return 0;
 	}
 
-	if (unlikely(mem_cgroup_charge(new_page, mm, gfp))) {
+    if (unlikely(mem_cgroup_charge(new_page, mm, gfp)))
+    {
 		result = SCAN_CGROUP_CHARGE_FAIL;
-		goto out_nolock;
+        // goto out_nolock; // return 0;
+        if (!IS_ERR_OR_NULL(*hpage))
+            mem_cgroup_uncharge(*hpage);
+        trace_mm_collapse_huge_page(mm, isolated, result);
+        return 0;
 	}
 	count_memcg_page_event(new_page, THP_COLLAPSE_ALLOC);
 
 	mmap_read_lock(mm);
 	result = hugepage_vma_revalidate(mm, address, &vma);
-	if (result) {
+    if (result)
+    {
 		mmap_read_unlock(mm);
 		goto out_nolock;
 	}
 
 	pmd = mm_find_pmd(mm, address);
-	if (!pmd) {
+    if (!pmd)
+    {
 		result = SCAN_PMD_NULL;
 		mmap_read_unlock(mm);
 		goto out_nolock;
@@ -1103,7 +1282,8 @@
 	 * Continuing to collapse causes inconsistency.
 	 */
 	if (unmapped && !__collapse_huge_page_swapin(mm, vma, address,
-						     pmd, referenced)) {
+                                                 pmd, referenced))
+    {
 		mmap_read_unlock(mm);
 		goto out_nolock;
 	}
@@ -1147,7 +1327,8 @@
 			&compound_pagelist);
 	spin_unlock(pte_ptl);
 
-	if (unlikely(!isolated)) {
+    if (unlikely(!isolated))
+    {
 		pte_unmap(pte);
 		spin_lock(pmd_ptl);
 		BUG_ON(!pmd_none(*pmd));
@@ -1204,7 +1385,7 @@
 	if (!IS_ERR_OR_NULL(*hpage))
 		mem_cgroup_uncharge(*hpage);
 	trace_mm_collapse_huge_page(mm, isolated, result);
-	return;
+    return 1;
 out:
 	goto out_up_write;
 }
@@ -1227,7 +1408,8 @@
 	VM_BUG_ON(address & ~HPAGE_PMD_MASK);
 
 	pmd = mm_find_pmd(mm, address);
-	if (!pmd) {
+    if (!pmd)
+    {
 		result = SCAN_PMD_NULL;
 		goto out;
 	}
@@ -1235,39 +1417,51 @@
 	memset(khugepaged_node_load, 0, sizeof(khugepaged_node_load));
 	pte = pte_offset_map_lock(mm, pmd, address, &ptl);
 	for (_address = address, _pte = pte; _pte < pte+HPAGE_PMD_NR;
-	     _pte++, _address += PAGE_SIZE) {
+         _pte++, _address += PAGE_SIZE)
+    {
 		pte_t pteval = *_pte;
-		if (is_swap_pte(pteval)) {
-			if (++unmapped <= khugepaged_max_ptes_swap) {
+        if (is_swap_pte(pteval))
+        {
+            if (++unmapped <= khugepaged_max_ptes_swap)
+            {
 				/*
 				 * Always be strict with uffd-wp
 				 * enabled swap entries.  Please see
 				 * comment below for pte_uffd_wp().
 				 */
-				if (pte_swp_uffd_wp(pteval)) {
+                if (pte_swp_uffd_wp(pteval))
+                {
 					result = SCAN_PTE_UFFD_WP;
 					goto out_unmap;
 				}
 				continue;
-			} else {
+            }
+            else
+            {
 				result = SCAN_EXCEED_SWAP_PTE;
 				goto out_unmap;
 			}
 		}
-		if (pte_none(pteval) || is_zero_pfn(pte_pfn(pteval))) {
+        if (pte_none(pteval) || is_zero_pfn(pte_pfn(pteval)))
+        {
 			if (!userfaultfd_armed(vma) &&
-			    ++none_or_zero <= khugepaged_max_ptes_none) {
+                ++none_or_zero <= khugepaged_max_ptes_none)
+            {
 				continue;
-			} else {
+            }
+            else
+            {
 				result = SCAN_EXCEED_NONE_PTE;
 				goto out_unmap;
 			}
 		}
-		if (!pte_present(pteval)) {
+        if (!pte_present(pteval))
+        {
 			result = SCAN_PTE_NON_PRESENT;
 			goto out_unmap;
 		}
-		if (pte_uffd_wp(pteval)) {
+        if (pte_uffd_wp(pteval))
+        {
 			/*
 			 * Don't collapse the page if any of the small
 			 * PTEs are armed with uffd write protection.
@@ -1284,13 +1478,15 @@
 			writable = true;
 
 		page = vm_normal_page(vma, _address, pteval);
-		if (unlikely(!page)) {
+        if (unlikely(!page))
+        {
 			result = SCAN_PAGE_NULL;
 			goto out_unmap;
 		}
 
 		if (page_mapcount(page) > 1 &&
-				++shared > khugepaged_max_ptes_shared) {
+            ++shared > khugepaged_max_ptes_shared)
+        {
 			result = SCAN_EXCEED_SHARED_PTE;
 			goto out_unmap;
 		}
@@ -1304,20 +1500,24 @@
 		 * hit record.
 		 */
 		node = page_to_nid(page);
-		if (khugepaged_scan_abort(node)) {
+        if (khugepaged_scan_abort(node))
+        {
 			result = SCAN_SCAN_ABORT;
 			goto out_unmap;
 		}
 		khugepaged_node_load[node]++;
-		if (!PageLRU(page)) {
+        if (!PageLRU(page))
+        {
 			result = SCAN_PAGE_LRU;
 			goto out_unmap;
 		}
-		if (PageLocked(page)) {
+        if (PageLocked(page))
+        {
 			result = SCAN_PAGE_LOCK;
 			goto out_unmap;
 		}
-		if (!PageAnon(page)) {
+        if (!PageAnon(page))
+        {
 			result = SCAN_PAGE_ANON;
 			goto out_unmap;
 		}
@@ -1339,7 +1539,8 @@
 		 * has excessive GUP pins (i.e. 512).  Anyway the same check
 		 * will be done again later the risk seems low.
 		 */
-		if (!is_refcount_suitable(page)) {
+        if (!is_refcount_suitable(page))
+        {
 			result = SCAN_PAGE_COUNT;
 			goto out_unmap;
 		}
@@ -1348,26 +1549,35 @@
 		    mmu_notifier_test_young(vma->vm_mm, address))
 			referenced++;
 	}
-	if (!writable) {
+    if (!writable)
+    {
 		result = SCAN_PAGE_RO;
-	} else if (!referenced || (unmapped && referenced < HPAGE_PMD_NR/2)) {
+    }
+    else if (!referenced || (unmapped && referenced < HPAGE_PMD_NR / 2))
+    {
 		result = SCAN_LACK_REFERENCED_PAGE;
-	} else {
+    }
+    else
+    {
 		result = SCAN_SUCCEED;
 		ret = 1;
 	}
 out_unmap:
 	pte_unmap_unlock(pte, ptl);
-	if (ret) {
+    if (ret)
+    {
 		node = khugepaged_find_target_node();
 		/* collapse_huge_page will return with the mmap_lock released */
-		collapse_huge_page(mm, address, hpage, node,
+        ret = 1 + collapse_huge_page(mm, address, hpage, node,
 				referenced, unmapped);
+        trace_mm_khugepaged_scan_pmd(mm, page, writable, referenced,
+                                     none_or_zero, result, unmapped);
+        return ret;
 	}
 out:
 	trace_mm_khugepaged_scan_pmd(mm, page, writable, referenced,
 				     none_or_zero, result, unmapped);
-	return ret;
+    return 0;
 }
 
 static void collect_mm_slot(struct mm_slot *mm_slot)
@@ -1376,7 +1586,8 @@
 
 	lockdep_assert_held(&khugepaged_mm_lock);
 
-	if (khugepaged_test_exit(mm)) {
+    if (khugepaged_test_exit(mm))
+    {
 		/* free mm_slot */
 		hash_del(&mm_slot->hash);
 		list_del(&mm_slot->mm_node);
@@ -1393,6 +1604,116 @@
 	}
 }
 
+/*
+ * This is parallel to khugepage_scan_mm_slot but selects
+ * pages to be promoted from opportunistice huge page framework.
+ * Make sure it does not affect the correctness and we release
+ * all khugepaged resources when a process exits.
+ * Ideally, khugepaged should be completely replaced by ohp.
+ */
+#define OHP_NO_WORK 99999
+static unsigned int ohp_scan_mm(struct mm_struct *mm,
+                                unsigned int pages, struct page **hpage)
+{
+    struct vm_area_struct *vma;
+    struct ohp_addr *kaddr;
+    unsigned long address;
+    int progress = 0, failed = 0, ret;
+
+    VM_BUG_ON(!pages);
+
+    /*
+     * Each iteration will acquire and release the mmap semaphore
+     * independently. This may look messy but keeps the code simple.
+     */
+    while (progress < pages && failed < 100)
+    {
+        /*
+         * 0 - overhead only.
+         * 1 - overhead per GB memory.
+         * 2 - global, round-robin policy.
+         */
+        if (khugepaged_promotion_metric < 2)
+            kaddr = get_ohp_mm_addr(mm);
+        else
+            kaddr = get_ohp_global_kaddr(&mm);
+
+        if (!kaddr)
+            return OHP_NO_WORK;
+
+        address = kaddr->address;
+
+//        down_read(&mm->mmap_sem);
+        mmap_read_lock(mm);
+        if (unlikely(khugepaged_test_exit(mm)))
+            vma = NULL;
+        else
+            vma = find_vma(mm, address);
+
+        if (!vma)
+        {
+            failed += 1;
+            //up_read(&mm->mmap_sem);
+	    mmap_read_unlock(mm);
+            ohp_putback_kaddr(mm, kaddr);
+            continue;
+        }
+
+        if (!(address >= vma->vm_start && address < vma->vm_end))
+        {
+            failed += 1;
+            //up_read(&mm->mmap_sem);
+	    mmap_read_unlock(mm);
+            ohp_putback_kaddr(mm, kaddr);
+            continue;
+        }
+
+        if (!hugepage_vma_check(vma, vma->vm_flags))
+        {
+            failed += 1;
+            // up_read(&mm->mmap_sem);
+	    mmap_read_unlock(mm);
+            ohp_putback_kaddr(mm, kaddr);
+            continue;
+        }
+
+        /* Check for alignment. */
+        VM_BUG_ON(address & ~HPAGE_PMD_MASK);
+
+        /* promote into a huge page.
+         * Total two return values are possible.
+         * 0 - semaphore must be released.
+         * 1 - semaphore has been released but promotion failed
+         *     due to huge page allocation failure.
+         * 2 - semaphore has been released and promotion succeded.
+         */
+        ret = khugepaged_scan_pmd(mm, vma, address, hpage);
+        /* mmap sem already released. */
+        if (ret == 2)
+        {
+            progress += HPAGE_PMD_NR;
+            kfree(kaddr);
+        }
+        else if (ret == 1)
+        {
+            failed += 100;
+            ohp_putback_kaddr(mm, kaddr);
+            count_vm_event(OHP_PROMOTE_FAILED);
+        }
+        else
+        {
+            failed += 1;
+            /* Give it another chance. */
+            ohp_putback_kaddr(mm, kaddr);
+            /* release and require */
+            // up_read(&mm->mmap_sem);
+	    mmap_read_unlock(mm);
+        }
+    }
+
+    return progress;
+}
+
 #ifdef CONFIG_SHMEM
 /*
  * Notify khugepaged that given addr of the mm is pte-mapped THP. Then
@@ -1460,7 +1781,8 @@
 
 	/* step 1: check all mapped PTEs are to the right huge page */
 	for (i = 0, addr = haddr, pte = start_pte;
-	     i < HPAGE_PMD_NR; i++, addr += PAGE_SIZE, pte++) {
+         i < HPAGE_PMD_NR; i++, addr += PAGE_SIZE, pte++)
+    {
 		struct page *page;
 
 		/* empty pte, skip */
@@ -1484,7 +1806,8 @@
 
 	/* step 2: adjust rmap */
 	for (i = 0, addr = haddr, pte = start_pte;
-	     i < HPAGE_PMD_NR; i++, addr += PAGE_SIZE, pte++) {
+         i < HPAGE_PMD_NR; i++, addr += PAGE_SIZE, pte++)
+    {
 		struct page *page;
 
 		if (pte_none(*pte))
@@ -1496,7 +1819,8 @@
 	pte_unmap_unlock(start_pte, ptl);
 
 	/* step 3: set proper refcount and mm_counters. */
-	if (count) {
+    if (count)
+    {
 		page_ref_sub(hpage, count);
 		add_mm_counter(vma->vm_mm, mm_counter_file(hpage), -count);
 	}
@@ -1549,7 +1873,8 @@
 	pmd_t *pmd, _pmd;
 
 	i_mmap_lock_write(mapping);
-	vma_interval_tree_foreach(vma, &mapping->i_mmap, pgoff, pgoff) {
+    vma_interval_tree_foreach(vma, &mapping->i_mmap, pgoff, pgoff)
+    {
 		/*
 		 * Check vma->anon_vma to exclude MAP_PRIVATE mappings that
 		 * got written to. These VMAs are likely not worth investing
@@ -1584,8 +1909,10 @@
 		 * mmap_lock while holding page lock. Fault path does it in
 		 * reverse order. Trylock is a way to avoid deadlock.
 		 */
-		if (mmap_write_trylock(mm)) {
-			if (!khugepaged_test_exit(mm)) {
+        if (mmap_write_trylock(mm))
+        {
+            if (!khugepaged_test_exit(mm))
+            {
 				spinlock_t *ptl = pmd_lock(mm, pmd);
 				/* assume page table is clear */
 				_pmd = pmdp_collapse_flush(vma, addr, pmd);
@@ -1594,7 +1921,9 @@
 				pte_free(mm, pmd_pgtable(_pmd));
 			}
 			mmap_write_unlock(mm);
-		} else {
+        }
+        else
+        {
 			/* Try again later */
 			khugepaged_add_pte_mapped_thp(mm, addr);
 		}
@@ -1640,25 +1969,29 @@
 	gfp = alloc_hugepage_khugepaged_gfpmask() | __GFP_THISNODE;
 
 	new_page = khugepaged_alloc_page(hpage, gfp, node);
-	if (!new_page) {
+    if (!new_page)
+    {
 		result = SCAN_ALLOC_HUGE_PAGE_FAIL;
 		goto out;
 	}
 
-	if (unlikely(mem_cgroup_charge(new_page, mm, gfp))) {
+    if (unlikely(mem_cgroup_charge(new_page, mm, gfp)))
+    {
 		result = SCAN_CGROUP_CHARGE_FAIL;
 		goto out;
 	}
 	count_memcg_page_event(new_page, THP_COLLAPSE_ALLOC);
 
 	/* This will be less messy when we use multi-index entries */
-	do {
+    do
+    {
 		xas_lock_irq(&xas);
 		xas_create_range(&xas);
 		if (!xas_error(&xas))
 			break;
 		xas_unlock_irq(&xas);
-		if (!xas_nomem(&xas, GFP_KERNEL)) {
+        if (!xas_nomem(&xas, GFP_KERNEL))
+        {
 			result = SCAN_FAIL;
 			goto out;
 		}
@@ -1677,25 +2010,31 @@
 	 */
 
 	xas_set(&xas, start);
-	for (index = start; index < end; index++) {
+    for (index = start; index < end; index++)
+    {
 		struct page *page = xas_next(&xas);
 
 		VM_BUG_ON(index != xas.xa_index);
-		if (is_shmem) {
-			if (!page) {
+        if (is_shmem)
+        {
+            if (!page)
+            {
 				/*
 				 * Stop if extent has been truncated or
 				 * hole-punched, and is now completely
 				 * empty.
 				 */
-				if (index == start) {
-					if (!xas_next_entry(&xas, end - 1)) {
+                if (index == start)
+                {
+                    if (!xas_next_entry(&xas, end - 1))
+                    {
 						result = SCAN_TRUNCATED;
 						goto xa_locked;
 					}
 					xas_set(&xas, index);
 				}
-				if (!shmem_charge(mapping->host, 1)) {
+                if (!shmem_charge(mapping->host, 1))
+                {
 					result = SCAN_FAIL;
 					goto xa_locked;
 				}
@@ -1704,23 +2043,32 @@
 				continue;
 			}
 
-			if (xa_is_value(page) || !PageUptodate(page)) {
+            if (xa_is_value(page) || !PageUptodate(page))
+            {
 				xas_unlock_irq(&xas);
 				/* swap in or instantiate fallocated page */
 				if (shmem_getpage(mapping->host, index, &page,
-						  SGP_NOHUGE)) {
+                                  SGP_NOHUGE))
+                {
 					result = SCAN_FAIL;
 					goto xa_unlocked;
 				}
-			} else if (trylock_page(page)) {
+            }
+            else if (trylock_page(page))
+            {
 				get_page(page);
 				xas_unlock_irq(&xas);
-			} else {
+            }
+            else
+            {
 				result = SCAN_PAGE_LOCK;
 				goto xa_locked;
 			}
-		} else {	/* !is_shmem */
-			if (!page || xa_is_value(page)) {
+        }
+        else
+        { /* !is_shmem */
+            if (!page || xa_is_value(page))
+            {
 				xas_unlock_irq(&xas);
 				page_cache_sync_readahead(mapping, &file->f_ra,
 							  file, index,
@@ -1728,11 +2076,14 @@
 				/* drain pagevecs to help isolate_lru_page() */
 				lru_add_drain();
 				page = find_lock_page(mapping, index);
-				if (unlikely(page == NULL)) {
+                if (unlikely(page == NULL))
+                {
 					result = SCAN_FAIL;
 					goto xa_unlocked;
 				}
-			} else if (PageDirty(page)) {
+            }
+            else if (PageDirty(page))
+            {
 				/*
 				 * khugepaged only works on read-only fd,
 				 * so this page is dirty because it hasn't
@@ -1750,10 +2101,14 @@
 				filemap_flush(mapping);
 				result = SCAN_FAIL;
 				goto xa_unlocked;
-			} else if (trylock_page(page)) {
+            }
+            else if (trylock_page(page))
+            {
 				get_page(page);
 				xas_unlock_irq(&xas);
-			} else {
+            }
+            else
+            {
 				result = SCAN_PAGE_LOCK;
 				goto xa_locked;
 			}
@@ -1766,7 +2121,8 @@
 		VM_BUG_ON_PAGE(!PageLocked(page), page);
 
 		/* make sure the page is up to date */
-		if (unlikely(!PageUptodate(page))) {
+        if (unlikely(!PageUptodate(page)))
+        {
 			result = SCAN_FAIL;
 			goto out_unlock;
 		}
@@ -1775,17 +2131,20 @@
 		 * If file was truncated then extended, or hole-punched, before
 		 * we locked the first page, then a THP might be there already.
 		 */
-		if (PageTransCompound(page)) {
+        if (PageTransCompound(page))
+        {
 			result = SCAN_PAGE_COMPOUND;
 			goto out_unlock;
 		}
 
-		if (page_mapping(page) != mapping) {
+        if (page_mapping(page) != mapping)
+        {
 			result = SCAN_TRUNCATED;
 			goto out_unlock;
 		}
 
-		if (!is_shmem && PageDirty(page)) {
+        if (!is_shmem && PageDirty(page))
+        {
 			/*
 			 * khugepaged only works on read-only fd, so this
 			 * page is dirty because it hasn't been flushed
@@ -1795,13 +2154,15 @@
 			goto out_unlock;
 		}
 
-		if (isolate_lru_page(page)) {
+        if (isolate_lru_page(page))
+        {
 			result = SCAN_DEL_PAGE_LRU;
 			goto out_unlock;
 		}
 
 		if (page_has_private(page) &&
-		    !try_to_release_page(page, GFP_KERNEL)) {
+            !try_to_release_page(page, GFP_KERNEL))
+        {
 			result = SCAN_PAGE_HAS_PRIVATE;
 			putback_lru_page(page);
 			goto out_unlock;
@@ -1822,7 +2183,8 @@
 		 *  - one reference from page cache;
 		 *  - one from isolate_lru_page;
 		 */
-		if (!page_ref_freeze(page, 3)) {
+        if (!page_ref_freeze(page, 3))
+        {
 			result = SCAN_PAGE_COUNT;
 			xas_unlock_irq(&xas);
 			putback_lru_page(page);
@@ -1846,12 +2208,14 @@
 
 	if (is_shmem)
 		__inc_node_page_state(new_page, NR_SHMEM_THPS);
-	else {
+    else
+    {
 		__inc_node_page_state(new_page, NR_FILE_THPS);
 		filemap_nr_thps_inc(mapping);
 	}
 
-	if (nr_none) {
+    if (nr_none)
+    {
 		__mod_lruvec_page_state(new_page, NR_FILE_PAGES, nr_none);
 		if (is_shmem)
 			__mod_lruvec_page_state(new_page, NR_SHMEM, nr_none);
@@ -1861,7 +2225,8 @@
 	xas_unlock_irq(&xas);
 xa_unlocked:
 
-	if (result == SCAN_SUCCEED) {
+    if (result == SCAN_SUCCEED)
+    {
 		struct page *page, *tmp;
 
 		/*
@@ -1869,8 +2234,10 @@
 		 * need to copy the content and free the old pages.
 		 */
 		index = start;
-		list_for_each_entry_safe(page, tmp, &pagelist, lru) {
-			while (index < page->index) {
+        list_for_each_entry_safe(page, tmp, &pagelist, lru)
+        {
+            while (index < page->index)
+            {
 				clear_highpage(new_page + (index % HPAGE_PMD_NR));
 				index++;
 			}
@@ -1885,7 +2252,8 @@
 			put_page(page);
 			index++;
 		}
-		while (index < end) {
+        while (index < end)
+        {
 			clear_highpage(new_page + (index % HPAGE_PMD_NR));
 			index++;
 		}
@@ -1903,7 +2271,9 @@
 		*hpage = NULL;
 
 		khugepaged_pages_collapsed++;
-	} else {
+    }
+    else
+    {
 		struct page *page;
 
 		/* Something went wrong: roll back page cache changes */
@@ -1914,10 +2284,12 @@
 			shmem_uncharge(mapping->host, nr_none);
 
 		xas_set(&xas, start);
-		xas_for_each(&xas, page, end - 1) {
+        xas_for_each(&xas, page, end - 1)
+        {
 			page = list_first_entry_or_null(&pagelist,
 					struct page, lru);
-			if (!page || xas.xa_index < page->index) {
+            if (!page || xas.xa_index < page->index)
+            {
 				if (!nr_none)
 					break;
 				nr_none--;
@@ -1966,37 +2338,44 @@
 	swap = 0;
 	memset(khugepaged_node_load, 0, sizeof(khugepaged_node_load));
 	rcu_read_lock();
-	xas_for_each(&xas, page, start + HPAGE_PMD_NR - 1) {
+    xas_for_each(&xas, page, start + HPAGE_PMD_NR - 1)
+    {
 		if (xas_retry(&xas, page))
 			continue;
 
-		if (xa_is_value(page)) {
-			if (++swap > khugepaged_max_ptes_swap) {
+        if (xa_is_value(page))
+        {
+            if (++swap > khugepaged_max_ptes_swap)
+            {
 				result = SCAN_EXCEED_SWAP_PTE;
 				break;
 			}
 			continue;
 		}
 
-		if (PageTransCompound(page)) {
+        if (PageTransCompound(page))
+        {
 			result = SCAN_PAGE_COMPOUND;
 			break;
 		}
 
 		node = page_to_nid(page);
-		if (khugepaged_scan_abort(node)) {
+        if (khugepaged_scan_abort(node))
+        {
 			result = SCAN_SCAN_ABORT;
 			break;
 		}
 		khugepaged_node_load[node]++;
 
-		if (!PageLRU(page)) {
+        if (!PageLRU(page))
+        {
 			result = SCAN_PAGE_LRU;
 			break;
 		}
 
 		if (page_count(page) !=
-		    1 + page_mapcount(page) + page_has_private(page)) {
+            1 + page_mapcount(page) + page_has_private(page))
+        {
 			result = SCAN_PAGE_COUNT;
 			break;
 		}
@@ -2009,17 +2388,22 @@
 
 		present++;
 
-		if (need_resched()) {
+        if (need_resched())
+        {
 			xas_pause(&xas);
 			cond_resched_rcu();
 		}
 	}
 	rcu_read_unlock();
 
-	if (result == SCAN_SUCCEED) {
-		if (present < HPAGE_PMD_NR - khugepaged_max_ptes_none) {
+    if (result == SCAN_SUCCEED)
+    {
+        if (present < HPAGE_PMD_NR - khugepaged_max_ptes_none)
+        {
 			result = SCAN_EXCEED_NONE_PTE;
-		} else {
+        }
+        else
+        {
 			node = khugepaged_find_target_node();
 			collapse_file(mm, file, start, hpage, node);
 		}
@@ -2040,6 +2424,7 @@
 }
 #endif
 
+#if 0
 static unsigned int khugepaged_scan_mm_slot(unsigned int pages,
 					    struct page **hpage)
 	__releases(&khugepaged_mm_lock)
@@ -2055,7 +2440,8 @@
 
 	if (khugepaged_scan.mm_slot)
 		mm_slot = khugepaged_scan.mm_slot;
-	else {
+    else
+    {
 		mm_slot = list_entry(khugepaged_scan.mm_head.next,
 				     struct mm_slot, mm_node);
 		khugepaged_scan.address = 0;
@@ -2076,15 +2462,18 @@
 		vma = find_vma(mm, khugepaged_scan.address);
 
 	progress++;
-	for (; vma; vma = vma->vm_next) {
+    for (; vma; vma = vma->vm_next)
+    {
 		unsigned long hstart, hend;
 
 		cond_resched();
-		if (unlikely(khugepaged_test_exit(mm))) {
+        if (unlikely(khugepaged_test_exit(mm)))
+        {
 			progress++;
 			break;
 		}
-		if (!hugepage_vma_check(vma, vma->vm_flags)) {
+        if (!hugepage_vma_check(vma, vma->vm_flags))
+        {
 skip:
 			progress++;
 			continue;
@@ -2101,7 +2490,8 @@
 		if (shmem_file(vma->vm_file) && !shmem_huge_enabled(vma))
 			goto skip;
 
-		while (khugepaged_scan.address < hend) {
+        while (khugepaged_scan.address < hend)
+        {
 			int ret;
 			cond_resched();
 			if (unlikely(khugepaged_test_exit(mm)))
@@ -2110,7 +2500,8 @@
 			VM_BUG_ON(khugepaged_scan.address < hstart ||
 				  khugepaged_scan.address + HPAGE_PMD_SIZE >
 				  hend);
-			if (IS_ENABLED(CONFIG_SHMEM) && vma->vm_file) {
+            if (IS_ENABLED(CONFIG_SHMEM) && vma->vm_file)
+            {
 				struct file *file = get_file(vma->vm_file);
 				pgoff_t pgoff = linear_page_index(vma,
 						khugepaged_scan.address);
@@ -2119,7 +2510,9 @@
 				ret = 1;
 				khugepaged_scan_file(mm, file, pgoff, hpage);
 				fput(file);
-			} else {
+            }
+            else
+            {
 				ret = khugepaged_scan_pmd(mm, vma,
 						khugepaged_scan.address,
 						hpage);
@@ -2144,18 +2537,22 @@
 	 * Release the current mm_slot if this mm is about to die, or
 	 * if we scanned all vmas of this mm.
 	 */
-	if (khugepaged_test_exit(mm) || !vma) {
+    if (khugepaged_test_exit(mm) || !vma)
+    {
 		/*
 		 * Make sure that if mm_users is reaching zero while
 		 * khugepaged runs here, khugepaged_exit will find
 		 * mm_slot not pointing to the exiting mm.
 		 */
-		if (mm_slot->mm_node.next != &khugepaged_scan.mm_head) {
+        if (mm_slot->mm_node.next != &khugepaged_scan.mm_head)
+        {
 			khugepaged_scan.mm_slot = list_entry(
 				mm_slot->mm_node.next,
 				struct mm_slot, mm_node);
 			khugepaged_scan.address = 0;
-		} else {
+        }
+        else
+        {
 			khugepaged_scan.mm_slot = NULL;
 			khugepaged_full_scans++;
 		}
@@ -2165,31 +2562,76 @@
 
 	return progress;
 }
-
+#endif
+#if 0
 static int khugepaged_has_work(void)
 {
 	return !list_empty(&khugepaged_scan.mm_head) &&
 		khugepaged_enabled();
 }
+#endif
+// static int khugepaged_wait_event(void)
+// {
+//     return !list_empty(&khugepaged_scan.mm_head) ||
+//            kthread_should_stop();
+// }
 
-static int khugepaged_wait_event(void)
+static int khugepaged_has_work(void)
 {
-	return !list_empty(&khugepaged_scan.mm_head) ||
-		kthread_should_stop();
+    return ohp_has_work();
 }
 
-static void khugepaged_do_scan(void)
+// static void khugepaged_do_scan(void)
+// {
+//     struct page *hpage = NULL;
+//     unsigned int progress = 0, pass_through_head = 0;
+//     unsigned int pages = khugepaged_pages_to_scan;
+//     bool wait = true;
+
+//     barrier(); /* write khugepaged_pages_to_scan to local stack */
+
+//     lru_add_drain_all();
+
+//     while (progress < pages)
+//     {
+//         if (!khugepaged_prealloc_page(&hpage, &wait))
+//             break;
+
+//         cond_resched();
+
+//         if (unlikely(kthread_should_stop() || try_to_freeze()))
+//             break;
+
+//         spin_lock(&khugepaged_mm_lock);
+//         if (!khugepaged_scan.mm_slot)
+//             pass_through_head++;
+//         if (khugepaged_has_work() &&
+//             pass_through_head < 2)
+//             progress += khugepaged_scan_mm_slot(pages - progress,
+//                                                 &hpage);
+//         else
+//             progress = pages;
+//         spin_unlock(&khugepaged_mm_lock);
+//     }
+
+//     if (!IS_ERR_OR_NULL(hpage))
+//         put_page(hpage);
+// }
+
+static void khugepaged_promote_mm(struct mm_struct *mm)
 {
 	struct page *hpage = NULL;
 	unsigned int progress = 0, pass_through_head = 0;
 	unsigned int pages = khugepaged_pages_to_scan;
+    unsigned int ret;
 	bool wait = true;
 
 	barrier(); /* write khugepaged_pages_to_scan to local stack */
 
 	lru_add_drain_all();
 
-	while (progress < pages) {
+    while (progress < pages)
+    {
 		if (!khugepaged_prealloc_page(&hpage, &wait))
 			break;
 
@@ -2201,10 +2643,26 @@
 		spin_lock(&khugepaged_mm_lock);
 		if (!khugepaged_scan.mm_slot)
 			pass_through_head++;
-		if (khugepaged_has_work() &&
-		    pass_through_head < 2)
-			progress += khugepaged_scan_mm_slot(pages - progress,
-							    &hpage);
+        if (khugepaged_has_work() && pass_through_head < 2)
+        {
+            ret = ohp_scan_mm(mm, pages - progress, &hpage);
+            if (ret != OHP_NO_WORK)
+            {
+                progress += ret;
+            }
+            else
+            {
+                /*
+                 * If there is no work to be done, we can
+                 * safely put khugepaged to sleep.
+                 */
+                progress = pages;
+                spin_unlock(&khugepaged_mm_lock);
+                break;
+            }
+            // progress += khugepaged_scan_mm_slot(pages - progress,
+            //                                     &hpage);
+        }
 		else
 			progress = pages;
 		spin_unlock(&khugepaged_mm_lock);
@@ -2220,36 +2678,92 @@
 	       time_after_eq(jiffies, khugepaged_sleep_expire);
 }
 
-static void khugepaged_wait_work(void)
-{
-	if (khugepaged_has_work()) {
+// static void khugepaged_wait_work(void)
+// {
+//     if (khugepaged_has_work())
+//     {
+//         const unsigned long scan_sleep_jiffies =
+//             msecs_to_jiffies(khugepaged_scan_sleep_millisecs);
+
+//         if (!scan_sleep_jiffies)
+//             return;
+
+//         khugepaged_sleep_expire = jiffies + scan_sleep_jiffies;
+//         wait_event_freezable_timeout(khugepaged_wait,
+//                                      khugepaged_should_wakeup(),
+//                                      scan_sleep_jiffies);
+//         return;
+//     }
+
+//     if (khugepaged_enabled())
+//         wait_event_freezable(khugepaged_wait, khugepaged_wait_event());
+// }
+
+static void ohp_sleep_iteration(unsigned long busy_msecs,
+                                unsigned long sleep_msecs)
+{
+    long idle_msecs;
+    // if (khugepaged_has_work())
+    // {
 		const unsigned long scan_sleep_jiffies =
 			msecs_to_jiffies(khugepaged_scan_sleep_millisecs);
 
-		if (!scan_sleep_jiffies)
-			return;
+    //     if (!scan_sleep_jiffies)
+    //         return;
 
 		khugepaged_sleep_expire = jiffies + scan_sleep_jiffies;
+
+    if (khugepaged_max_cpu == 0)
+    {
+
 		wait_event_freezable_timeout(khugepaged_wait,
 					     khugepaged_should_wakeup(),
 					     scan_sleep_jiffies);
 		return;
 	}
-
-	if (khugepaged_enabled())
-		wait_event_freezable(khugepaged_wait, khugepaged_wait_event());
+    idle_msecs = (busy_msecs * 100) / khugepaged_max_cpu;
+    if (idle_msecs < khugepaged_min_sleep)
+        idle_msecs = khugepaged_min_sleep;
+    // if (khugepaged_enabled())
+    //     wait_event_freezable(khugepaged_wait, khugepaged_wait_event());
+    wait_event_freezable_timeout(khugepaged_wait, kthread_should_stop(),
+                                 msecs_to_jiffies((unsigned long)idle_msecs));
 }
 
 static int khugepaged(void *none)
 {
 	struct mm_slot *mm_slot;
+    struct mm_struct *mm = NULL;
+    //struct timeval t0, t1;
+    struct timespec64 t0, t1;
+    unsigned long promotion_msecs = 0, wait_msecs = 0;
 
 	set_freezable();
 	set_user_nice(current, MAX_NICE);
 
-	while (!kthread_should_stop()) {
-		khugepaged_do_scan();
-		khugepaged_wait_work();
+    while (!kthread_should_stop())
+    {
+        // khugepaged_do_scan();
+        // khugepaged_wait_work();
+        if (khugepaged_promotion_metric < 2)
+        {
+            /* select target mm */
+            mm = ohp_get_target_mm(khugepaged_promotion_metric);
+            if (!mm)
+                goto do_wait;
+        }
+
+        //do_gettimeofday(&t0);
+        ktime_get_ts64(&t0);
+        khugepaged_promote_mm(mm);
+        //do_gettimeofday(&t1);
+        ktime_get_ts64(&t1);
+        promotion_msecs = get_time_difference(&t0, &t1);
+        // trace_printk("khugepaged: Promotion Time: %ld msecs\n",
+        //		promotion_msecs);
+    do_wait:
+        /* Give khugepaged a break. */
+        ohp_sleep_iteration(promotion_msecs, wait_msecs);
 	}
 
 	spin_lock(&khugepaged_mm_lock);
@@ -2267,7 +2781,8 @@
 	int nr_zones = 0;
 	unsigned long recommended_min;
 
-	for_each_populated_zone(zone) {
+    for_each_populated_zone(zone)
+    {
 		/*
 		 * We don't need to worry about fragmentation of
 		 * ZONE_MOVABLE since it only has movable pages.
@@ -2295,7 +2810,8 @@
 			      (unsigned long) nr_free_buffer_pages() / 20);
 	recommended_min <<= (PAGE_SHIFT-10);
 
-	if (recommended_min > min_free_kbytes) {
+    if (recommended_min > min_free_kbytes)
+    {
 		if (user_min_free_kbytes >= 0)
 			pr_info("raising min_free_kbytes from %d to %lu to help transparent hugepage allocations\n",
 				min_free_kbytes, recommended_min);
@@ -2310,11 +2826,13 @@
 	int err = 0;
 
 	mutex_lock(&khugepaged_mutex);
-	if (khugepaged_enabled()) {
+    if (khugepaged_enabled())
+    {
 		if (!khugepaged_thread)
 			khugepaged_thread = kthread_run(khugepaged, NULL,
 							"khugepaged");
-		if (IS_ERR(khugepaged_thread)) {
+        if (IS_ERR(khugepaged_thread))
+        {
 			pr_err("khugepaged: kthread_run(khugepaged) failed\n");
 			err = PTR_ERR(khugepaged_thread);
 			khugepaged_thread = NULL;
@@ -2325,7 +2843,9 @@
 			wake_up_interruptible(&khugepaged_wait);
 
 		set_recommended_min_free_kbytes();
-	} else if (khugepaged_thread) {
+    }
+    else if (khugepaged_thread)
+    {
 		kthread_stop(khugepaged_thread);
 		khugepaged_thread = NULL;
 	}
@@ -2341,3 +2861,10 @@
 		set_recommended_min_free_kbytes();
 	mutex_unlock(&khugepaged_mutex);
 }
+
+struct page *follow_page_custom(struct vm_area_struct *vma,
+                                unsigned long addr, unsigned int foll_flags)
+{
+    return follow_page(vma, addr, foll_flags);
+}
+EXPORT_SYMBOL(follow_page_custom);
diff --color -ruN -w -B '--exclude-from=.diff-exclude' linux-5.10/mm/ksm.c HawkEye-5.10-cow/mm/ksm.c
--- linux-5.10/mm/ksm.c	2020-12-13 22:41:30.000000000 +0000
+++ HawkEye-5.10-cow/mm/ksm.c	2025-03-23 07:53:49.822887415 +0000
@@ -242,6 +242,11 @@
 static struct kmem_cache *stable_node_cache;
 static struct kmem_cache *mm_slot_cache;
 
+//zhehua
+unsigned long nr_ksm_cows = 0;
+unsigned long nr_ksm_shares = 0;
+unsigned int runksm = 0;
+
 /* The number of nodes in the stable tree */
 static unsigned long ksm_pages_shared;
 
@@ -1010,6 +1015,9 @@
 	/* Clean up stable nodes, but don't worry if some are still busy */
 	remove_all_stable_nodes();
 	ksm_scan.seqnr = 0;
+	//zhehua
+	nr_ksm_cows = 0;
+	nr_ksm_shares = 0;
 	return 0;
 
 error:
@@ -2018,6 +2026,8 @@
 	rmap_item->address |= STABLE_FLAG;
 	hlist_add_head(&rmap_item->hlist, &stable_node->hlist);
 
+	//zhehua
+	nr_ksm_shares++;
 	if (rmap_item->hlist.next)
 		ksm_pages_sharing++;
 	else
@@ -3046,6 +3056,21 @@
 }
 KSM_ATTR(max_page_sharing);
 
+//zhehua
+static ssize_t nr_ksm_cows_show(struct kobject *kobj,
+				 struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%lu\n", nr_ksm_cows);
+}
+KSM_ATTR_RO(nr_ksm_cows);
+
+static ssize_t nr_ksm_shares_show(struct kobject *kobj,
+				 struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%lu\n", nr_ksm_shares);
+}
+KSM_ATTR_RO(nr_ksm_shares);
+
 static ssize_t pages_shared_show(struct kobject *kobj,
 				 struct kobj_attribute *attr, char *buf)
 {
@@ -3148,6 +3173,9 @@
 	&stable_node_dups_attr.attr,
 	&stable_node_chains_prune_millisecs_attr.attr,
 	&use_zero_pages_attr.attr,
+	//zhehua
+	&nr_ksm_cows_attr.attr,
+	&nr_ksm_shares_attr.attr,
 	NULL,
 };
 
diff --color -ruN -w -B '--exclude-from=.diff-exclude' linux-5.10/mm/Makefile HawkEye-5.10-cow/mm/Makefile
--- linux-5.10/mm/Makefile	2020-12-13 22:41:30.000000000 +0000
+++ HawkEye-5.10-cow/mm/Makefile	2025-03-23 07:53:49.848944637 +0000
@@ -86,6 +86,7 @@
 obj-$(CONFIG_MEMTEST)		+= memtest.o
 obj-$(CONFIG_MIGRATION) += migrate.o
 obj-$(CONFIG_TRANSPARENT_HUGEPAGE) += huge_memory.o khugepaged.o
+obj-$(CONFIG_TRANSPARENT_HUGEPAGE) += ohp.o
 obj-$(CONFIG_PAGE_COUNTER) += page_counter.o
 obj-$(CONFIG_MEMCG) += memcontrol.o vmpressure.o
 obj-$(CONFIG_MEMCG_SWAP) += swap_cgroup.o
diff --color -ruN -w -B '--exclude-from=.diff-exclude' linux-5.10/mm/memory.c HawkEye-5.10-cow/mm/memory.c
--- linux-5.10/mm/memory.c	2020-12-13 22:41:30.000000000 +0000
+++ HawkEye-5.10-cow/mm/memory.c	2025-03-23 07:53:49.856761241 +0000
@@ -73,6 +73,7 @@
 #include <linux/perf_event.h>
 #include <linux/ptrace.h>
 #include <linux/vmalloc.h>
+#include <linux/kernel.h>
 
 #include <trace/events/kmem.h>
 
@@ -167,8 +168,10 @@
 {
 	int i;
 
-	for (i = 0; i < NR_MM_COUNTERS; i++) {
-		if (current->rss_stat.count[i]) {
+    for (i = 0; i < NR_MM_COUNTERS; i++)
+    {
+        if (current->rss_stat.count[i])
+        {
 			add_mm_counter(mm, i, current->rss_stat.count[i]);
 			current->rss_stat.count[i] = 0;
 		}
@@ -231,7 +234,8 @@
 
 	start = addr;
 	pmd = pmd_offset(pud, addr);
-	do {
+    do
+    {
 		next = pmd_addr_end(addr, end);
 		if (pmd_none_or_clear_bad(pmd))
 			continue;
@@ -241,7 +245,8 @@
 	start &= PUD_MASK;
 	if (start < floor)
 		return;
-	if (ceiling) {
+    if (ceiling)
+    {
 		ceiling &= PUD_MASK;
 		if (!ceiling)
 			return;
@@ -265,7 +270,8 @@
 
 	start = addr;
 	pud = pud_offset(p4d, addr);
-	do {
+    do
+    {
 		next = pud_addr_end(addr, end);
 		if (pud_none_or_clear_bad(pud))
 			continue;
@@ -275,7 +281,8 @@
 	start &= P4D_MASK;
 	if (start < floor)
 		return;
-	if (ceiling) {
+    if (ceiling)
+    {
 		ceiling &= P4D_MASK;
 		if (!ceiling)
 			return;
@@ -299,7 +306,8 @@
 
 	start = addr;
 	p4d = p4d_offset(pgd, addr);
-	do {
+    do
+    {
 		next = p4d_addr_end(addr, end);
 		if (p4d_none_or_clear_bad(p4d))
 			continue;
@@ -309,7 +317,8 @@
 	start &= PGDIR_MASK;
 	if (start < floor)
 		return;
-	if (ceiling) {
+    if (ceiling)
+    {
 		ceiling &= PGDIR_MASK;
 		if (!ceiling)
 			return;
@@ -359,12 +368,14 @@
 	 */
 
 	addr &= PMD_MASK;
-	if (addr < floor) {
+    if (addr < floor)
+    {
 		addr += PMD_SIZE;
 		if (!addr)
 			return;
 	}
-	if (ceiling) {
+    if (ceiling)
+    {
 		ceiling &= PMD_MASK;
 		if (!ceiling)
 			return;
@@ -379,7 +390,8 @@
 	 */
 	tlb_change_page_size(tlb, PAGE_SIZE);
 	pgd = pgd_offset(tlb->mm, addr);
-	do {
+    do
+    {
 		next = pgd_addr_end(addr, end);
 		if (pgd_none_or_clear_bad(pgd))
 			continue;
@@ -390,7 +402,8 @@
 void free_pgtables(struct mmu_gather *tlb, struct vm_area_struct *vma,
 		unsigned long floor, unsigned long ceiling)
 {
-	while (vma) {
+    while (vma)
+    {
 		struct vm_area_struct *next = vma->vm_next;
 		unsigned long addr = vma->vm_start;
 
@@ -401,15 +414,18 @@
 		unlink_anon_vmas(vma);
 		unlink_file_vma(vma);
 
-		if (is_vm_hugetlb_page(vma)) {
+        if (is_vm_hugetlb_page(vma))
+        {
 			hugetlb_free_pgd_range(tlb, addr, vma->vm_end,
 				floor, next ? next->vm_start : ceiling);
-		} else {
+        }
+        else
+        {
 			/*
 			 * Optimization: gather nearby vmas into one call down
 			 */
-			while (next && next->vm_start <= vma->vm_end + PMD_SIZE
-			       && !is_vm_hugetlb_page(next)) {
+            while (next && next->vm_start <= vma->vm_end + PMD_SIZE && !is_vm_hugetlb_page(next))
+            {
 				vma = next;
 				next = vma->vm_next;
 				unlink_anon_vmas(vma);
@@ -445,7 +461,8 @@
 	smp_wmb(); /* Could be smp_wmb__xxx(before|after)_spin_lock */
 
 	ptl = pmd_lock(mm, pmd);
-	if (likely(pmd_none(*pmd))) {	/* Has another populated it ? */
+    if (likely(pmd_none(*pmd)))
+    { /* Has another populated it ? */
 		mm_inc_nr_ptes(mm);
 		pmd_populate(mm, pmd, new);
 		new = NULL;
@@ -465,7 +482,8 @@
 	smp_wmb(); /* See comment in __pte_alloc */
 
 	spin_lock(&init_mm.page_table_lock);
-	if (likely(pmd_none(*pmd))) {	/* Has another populated it ? */
+    if (likely(pmd_none(*pmd)))
+    { /* Has another populated it ? */
 		pmd_populate_kernel(&init_mm, pmd, new);
 		new = NULL;
 	}
@@ -515,12 +533,15 @@
 	 * Allow a burst of 60 reports, then keep quiet for that minute;
 	 * or allow a steady drip of one report per second.
 	 */
-	if (nr_shown == 60) {
-		if (time_before(jiffies, resume)) {
+    if (nr_shown == 60)
+    {
+        if (time_before(jiffies, resume))
+        {
 			nr_unshown++;
 			return;
 		}
-		if (nr_unshown) {
+        if (nr_unshown)
+        {
 			pr_alert("BUG: Bad page map: %lu messages suppressed\n",
 				 nr_unshown);
 			nr_unshown = 0;
@@ -596,7 +617,8 @@
 {
 	unsigned long pfn = pte_pfn(pte);
 
-	if (IS_ENABLED(CONFIG_ARCH_HAS_PTE_SPECIAL)) {
+    if (IS_ENABLED(CONFIG_ARCH_HAS_PTE_SPECIAL))
+    {
 		if (likely(!pte_special(pte)))
 			goto check_pfn;
 		if (vma->vm_ops && vma->vm_ops->find_special_page)
@@ -614,12 +636,16 @@
 
 	/* !CONFIG_ARCH_HAS_PTE_SPECIAL case follows: */
 
-	if (unlikely(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))) {
-		if (vma->vm_flags & VM_MIXEDMAP) {
+    if (unlikely(vma->vm_flags & (VM_PFNMAP | VM_MIXEDMAP)))
+    {
+        if (vma->vm_flags & VM_MIXEDMAP)
+        {
 			if (!pfn_valid(pfn))
 				return NULL;
 			goto out;
-		} else {
+        }
+        else
+        {
 			unsigned long off;
 			off = (addr - vma->vm_start) >> PAGE_SHIFT;
 			if (pfn == vma->vm_pgoff + off)
@@ -633,7 +659,8 @@
 		return NULL;
 
 check_pfn:
-	if (unlikely(pfn > highest_memmap_pfn)) {
+    if (unlikely(pfn > highest_memmap_pfn))
+    {
 		print_bad_pte(vma, addr, pte, NULL);
 		return NULL;
 	}
@@ -657,12 +684,16 @@
 	 * in a direct-access (dax) mapping, so let's just replicate the
 	 * !CONFIG_ARCH_HAS_PTE_SPECIAL case from vm_normal_page() here.
 	 */
-	if (unlikely(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))) {
-		if (vma->vm_flags & VM_MIXEDMAP) {
+    if (unlikely(vma->vm_flags & (VM_PFNMAP | VM_MIXEDMAP)))
+    {
+        if (vma->vm_flags & VM_MIXEDMAP)
+        {
 			if (!pfn_valid(pfn))
 				return NULL;
 			goto out;
-		} else {
+        }
+        else
+        {
 			unsigned long off;
 			off = (addr - vma->vm_start) >> PAGE_SHIFT;
 			if (pfn == vma->vm_pgoff + off)
@@ -704,12 +735,14 @@
 	struct page *page;
 	swp_entry_t entry = pte_to_swp_entry(pte);
 
-	if (likely(!non_swap_entry(entry))) {
+    if (likely(!non_swap_entry(entry)))
+    {
 		if (swap_duplicate(entry) < 0)
 			return entry.val;
 
 		/* make sure dst_mm is on swapoff's mmlist. */
-		if (unlikely(list_empty(&dst_mm->mmlist))) {
+        if (unlikely(list_empty(&dst_mm->mmlist)))
+        {
 			spin_lock(&mmlist_lock);
 			if (list_empty(&dst_mm->mmlist))
 				list_add(&dst_mm->mmlist,
@@ -717,13 +750,16 @@
 			spin_unlock(&mmlist_lock);
 		}
 		rss[MM_SWAPENTS]++;
-	} else if (is_migration_entry(entry)) {
+    }
+    else if (is_migration_entry(entry))
+    {
 		page = migration_entry_to_page(entry);
 
 		rss[mm_counter(page)]++;
 
 		if (is_write_migration_entry(entry) &&
-				is_cow_mapping(vm_flags)) {
+            is_cow_mapping(vm_flags))
+        {
 			/*
 			 * COW mappings require pages in both
 			 * parent and child to be set to read.
@@ -736,7 +772,9 @@
 				pte = pte_swp_mkuffd_wp(pte);
 			set_pte_at(src_mm, addr, src_pte, pte);
 		}
-	} else if (is_device_private_entry(entry)) {
+    }
+    else if (is_device_private_entry(entry))
+    {
 		page = device_private_entry_to_page(entry);
 
 		/*
@@ -760,7 +798,8 @@
 		 * save and restore device driver state).
 		 */
 		if (is_write_device_private_entry(entry) &&
-		    is_cow_mapping(vm_flags)) {
+            is_cow_mapping(vm_flags))
+        {
 			make_device_private_entry_read(&entry);
 			pte = swp_entry_to_pte(entry);
 			if (pte_swp_uffd_wp(*src_pte))
@@ -858,7 +897,8 @@
 	struct page *page;
 
 	page = vm_normal_page(src_vma, addr, pte);
-	if (page) {
+    if (page)
+    {
 		int retval;
 
 		retval = copy_present_page(dst_vma, src_vma, dst_pte, src_pte,
@@ -875,7 +915,8 @@
 	 * If it's a COW mapping, write protect it both
 	 * in the parent and the child
 	 */
-	if (is_cow_mapping(vm_flags) && pte_write(pte)) {
+    if (is_cow_mapping(vm_flags) && pte_write(pte))
+    {
 		ptep_set_wrprotect(src_mm, addr, src_pte);
 		pte = pte_wrprotect(pte);
 	}
@@ -910,7 +951,8 @@
 	if (!new_page)
 		return NULL;
 
-	if (mem_cgroup_charge(new_page, src_mm, GFP_KERNEL)) {
+    if (mem_cgroup_charge(new_page, src_mm, GFP_KERNEL))
+    {
 		put_page(new_page);
 		return NULL;
 	}
@@ -939,7 +981,8 @@
 	init_rss_vec(rss);
 
 	dst_pte = pte_alloc_map_lock(dst_mm, dst_pmd, addr, &dst_ptl);
-	if (!dst_pte) {
+    if (!dst_pte)
+    {
 		ret = -ENOMEM;
 		goto out;
 	}
@@ -950,22 +993,26 @@
 	orig_dst_pte = dst_pte;
 	arch_enter_lazy_mmu_mode();
 
-	do {
+    do
+    {
 		/*
 		 * We are holding two locks at this point - either of them
 		 * could generate latencies in another task on another CPU.
 		 */
-		if (progress >= 32) {
+        if (progress >= 32)
+        {
 			progress = 0;
 			if (need_resched() ||
 			    spin_needbreak(src_ptl) || spin_needbreak(dst_ptl))
 				break;
 		}
-		if (pte_none(*src_pte)) {
+        if (pte_none(*src_pte))
+        {
 			progress++;
 			continue;
 		}
-		if (unlikely(!pte_present(*src_pte))) {
+        if (unlikely(!pte_present(*src_pte)))
+        {
 			entry.val = copy_nonpresent_pte(dst_mm, src_mm,
 							dst_pte, src_pte,
 							src_vma, addr, rss);
@@ -983,7 +1030,8 @@
 		 */
 		if (unlikely(ret == -EAGAIN))
 			break;
-		if (unlikely(prealloc)) {
+        if (unlikely(prealloc))
+        {
 			/*
 			 * pre-alloc page cannot be reused by next time so as
 			 * to strictly follow mempolicy (e.g., alloc_page_vma()
@@ -1003,13 +1051,17 @@
 	pte_unmap_unlock(orig_dst_pte, dst_ptl);
 	cond_resched();
 
-	if (entry.val) {
-		if (add_swap_count_continuation(entry, GFP_KERNEL) < 0) {
+    if (entry.val)
+    {
+        if (add_swap_count_continuation(entry, GFP_KERNEL) < 0)
+        {
 			ret = -ENOMEM;
 			goto out;
 		}
 		entry.val = 0;
-	} else if (ret) {
+    }
+    else if (ret)
+    {
 		WARN_ON_ONCE(ret != -EAGAIN);
 		prealloc = page_copy_prealloc(src_mm, src_vma, addr);
 		if (!prealloc)
@@ -1039,10 +1091,11 @@
 	if (!dst_pmd)
 		return -ENOMEM;
 	src_pmd = pmd_offset(src_pud, addr);
-	do {
+    do
+    {
 		next = pmd_addr_end(addr, end);
-		if (is_swap_pmd(*src_pmd) || pmd_trans_huge(*src_pmd)
-			|| pmd_devmap(*src_pmd)) {
+        if (is_swap_pmd(*src_pmd) || pmd_trans_huge(*src_pmd) || pmd_devmap(*src_pmd))
+        {
 			int err;
 			VM_BUG_ON_VMA(next-addr != HPAGE_PMD_SIZE, src_vma);
 			err = copy_huge_pmd(dst_mm, src_mm,
@@ -1076,9 +1129,11 @@
 	if (!dst_pud)
 		return -ENOMEM;
 	src_pud = pud_offset(src_p4d, addr);
-	do {
+    do
+    {
 		next = pud_addr_end(addr, end);
-		if (pud_trans_huge(*src_pud) || pud_devmap(*src_pud)) {
+        if (pud_trans_huge(*src_pud) || pud_devmap(*src_pud))
+        {
 			int err;
 
 			VM_BUG_ON_VMA(next-addr != HPAGE_PUD_SIZE, src_vma);
@@ -1112,7 +1167,8 @@
 	if (!dst_p4d)
 		return -ENOMEM;
 	src_p4d = p4d_offset(src_pgd, addr);
-	do {
+    do
+    {
 		next = p4d_addr_end(addr, end);
 		if (p4d_none_or_clear_bad(src_p4d))
 			continue;
@@ -1123,8 +1179,7 @@
 	return 0;
 }
 
-int
-copy_page_range(struct vm_area_struct *dst_vma, struct vm_area_struct *src_vma)
+int copy_page_range(struct vm_area_struct *dst_vma, struct vm_area_struct *src_vma)
 {
 	pgd_t *src_pgd, *dst_pgd;
 	unsigned long next;
@@ -1149,7 +1204,8 @@
 	if (is_vm_hugetlb_page(src_vma))
 		return copy_hugetlb_page_range(dst_mm, src_mm, src_vma);
 
-	if (unlikely(src_vma->vm_flags & VM_PFNMAP)) {
+    if (unlikely(src_vma->vm_flags & VM_PFNMAP))
+    {
 		/*
 		 * We do not free on error cases below as remove_vma
 		 * gets called on error from higher level routine
@@ -1167,7 +1223,8 @@
 	 */
 	is_cow = is_cow_mapping(src_vma->vm_flags);
 
-	if (is_cow) {
+    if (is_cow)
+    {
 		mmu_notifier_range_init(&range, MMU_NOTIFY_PROTECTION_PAGE,
 					0, src_vma, src_mm, addr, end);
 		mmu_notifier_invalidate_range_start(&range);
@@ -1176,12 +1233,14 @@
 	ret = 0;
 	dst_pgd = pgd_offset(dst_mm, addr);
 	src_pgd = pgd_offset(src_mm, addr);
-	do {
+    do
+    {
 		next = pgd_addr_end(addr, end);
 		if (pgd_none_or_clear_bad(src_pgd))
 			continue;
 		if (unlikely(copy_p4d_range(dst_vma, src_vma, dst_pgd, src_pgd,
-					    addr, next))) {
+                                    addr, next)))
+        {
 			ret = -ENOMEM;
 			break;
 		}
@@ -1212,7 +1271,8 @@
 	pte = start_pte;
 	flush_tlb_batched_pending(mm);
 	arch_enter_lazy_mmu_mode();
-	do {
+    do
+    {
 		pte_t ptent = *pte;
 		if (pte_none(ptent))
 			continue;
@@ -1220,11 +1280,13 @@
 		if (need_resched())
 			break;
 
-		if (pte_present(ptent)) {
+        if (pte_present(ptent))
+        {
 			struct page *page;
 
 			page = vm_normal_page(vma, addr, ptent);
-			if (unlikely(details) && page) {
+            if (unlikely(details) && page)
+            {
 				/*
 				 * unmap_shared_mapping_pages() wants to
 				 * invalidate cache without truncating:
@@ -1240,8 +1302,10 @@
 			if (unlikely(!page))
 				continue;
 
-			if (!PageAnon(page)) {
-				if (pte_dirty(ptent)) {
+            if (!PageAnon(page))
+            {
+                if (pte_dirty(ptent))
+                {
 					force_flush = 1;
 					set_page_dirty(page);
 				}
@@ -1253,7 +1317,8 @@
 			page_remove_rmap(page, false);
 			if (unlikely(page_mapcount(page) < 0))
 				print_bad_pte(vma, addr, ptent, page);
-			if (unlikely(__tlb_remove_page(tlb, page))) {
+            if (unlikely(__tlb_remove_page(tlb, page)))
+            {
 				force_flush = 1;
 				addr += PAGE_SIZE;
 				break;
@@ -1262,10 +1327,12 @@
 		}
 
 		entry = pte_to_swp_entry(ptent);
-		if (is_device_private_entry(entry)) {
+        if (is_device_private_entry(entry))
+        {
 			struct page *page = device_private_entry_to_page(entry);
 
-			if (unlikely(details && details->check_mapping)) {
+            if (unlikely(details && details->check_mapping))
+            {
 				/*
 				 * unmap_shared_mapping_pages() wants to
 				 * invalidate cache without truncating:
@@ -1289,7 +1356,8 @@
 
 		if (!non_swap_entry(entry))
 			rss[MM_SWAPENTS]--;
-		else if (is_migration_entry(entry)) {
+        else if (is_migration_entry(entry))
+        {
 			struct page *page;
 
 			page = migration_entry_to_page(entry);
@@ -1314,12 +1382,14 @@
 	 * entries before releasing the ptl), free the batched
 	 * memory too. Restart if we didn't do everything.
 	 */
-	if (force_flush) {
+    if (force_flush)
+    {
 		force_flush = 0;
 		tlb_flush_mmu(tlb);
 	}
 
-	if (addr != end) {
+    if (addr != end)
+    {
 		cond_resched();
 		goto again;
 	}
@@ -1336,9 +1406,11 @@
 	unsigned long next;
 
 	pmd = pmd_offset(pud, addr);
-	do {
+    do
+    {
 		next = pmd_addr_end(addr, end);
-		if (is_swap_pmd(*pmd) || pmd_trans_huge(*pmd) || pmd_devmap(*pmd)) {
+        if (is_swap_pmd(*pmd) || pmd_trans_huge(*pmd) || pmd_devmap(*pmd))
+        {
 			if (next - addr != HPAGE_PMD_SIZE)
 				__split_huge_pmd(vma, pmd, addr, false, NULL);
 			else if (zap_huge_pmd(tlb, vma, pmd, addr))
@@ -1371,13 +1443,17 @@
 	unsigned long next;
 
 	pud = pud_offset(p4d, addr);
-	do {
+    do
+    {
 		next = pud_addr_end(addr, end);
-		if (pud_trans_huge(*pud) || pud_devmap(*pud)) {
-			if (next - addr != HPAGE_PUD_SIZE) {
+        if (pud_trans_huge(*pud) || pud_devmap(*pud))
+        {
+            if (next - addr != HPAGE_PUD_SIZE)
+            {
 				mmap_assert_locked(tlb->mm);
 				split_huge_pud(vma, pud, addr);
-			} else if (zap_huge_pud(tlb, vma, pud, addr))
+            }
+            else if (zap_huge_pud(tlb, vma, pud, addr))
 				goto next;
 			/* fall through */
 		}
@@ -1400,7 +1476,8 @@
 	unsigned long next;
 
 	p4d = p4d_offset(pgd, addr);
-	do {
+    do
+    {
 		next = p4d_addr_end(addr, end);
 		if (p4d_none_or_clear_bad(p4d))
 			continue;
@@ -1421,7 +1498,8 @@
 	BUG_ON(addr >= end);
 	tlb_start_vma(tlb, vma);
 	pgd = pgd_offset(vma->vm_mm, addr);
-	do {
+    do
+    {
 		next = pgd_addr_end(addr, end);
 		if (pgd_none_or_clear_bad(pgd))
 			continue;
@@ -1451,8 +1528,10 @@
 	if (unlikely(vma->vm_flags & VM_PFNMAP))
 		untrack_pfn(vma, 0, 0);
 
-	if (start != end) {
-		if (unlikely(is_vm_hugetlb_page(vma))) {
+    if (start != end)
+    {
+        if (unlikely(is_vm_hugetlb_page(vma)))
+        {
 			/*
 			 * It is undesirable to test vma->vm_file as it
 			 * should be non-null for valid hugetlb area.
@@ -1464,12 +1543,14 @@
 			 * Since no pte has actually been setup, it is
 			 * safe to do nothing in this case.
 			 */
-			if (vma->vm_file) {
+            if (vma->vm_file)
+            {
 				i_mmap_lock_write(vma->vm_file->f_mapping);
 				__unmap_hugepage_range_final(tlb, vma, start, end, NULL);
 				i_mmap_unlock_write(vma->vm_file->f_mapping);
 			}
-		} else
+        }
+        else
 			unmap_page_range(tlb, vma, start, end, details);
 	}
 }
@@ -1531,7 +1612,7 @@
 	mmu_notifier_invalidate_range_end(&range);
 	tlb_finish_mmu(&tlb, start, range.end);
 }
-
+EXPORT_SYMBOL(zap_page_range);
 /**
  * zap_page_range_single - remove user pages in a given range
  * @vma: vm_area_struct holding the applicable pages
@@ -1703,15 +1784,18 @@
 	if (pte_alloc(mm, pmd))
 		goto out;
 
-	while (pages_to_write_in_pmd) {
+    while (pages_to_write_in_pmd)
+    {
 		int pte_idx = 0;
 		const int batch_size = min_t(int, pages_to_write_in_pmd, 8);
 
 		start_pte = pte_offset_map_lock(mm, pmd, addr, &pte_lock);
-		for (pte = start_pte; pte_idx < batch_size; ++pte, ++pte_idx) {
+        for (pte = start_pte; pte_idx < batch_size; ++pte, ++pte_idx)
+        {
 			int err = insert_page_in_batch_locked(mm, pte,
 				addr, pages[curr_page_idx], prot);
-			if (unlikely(err)) {
+            if (unlikely(err))
+            {
 				pte_unmap_unlock(start_pte, pte_lock);
 				ret = err;
 				remaining_pages_total -= pte_idx;
@@ -1756,7 +1840,8 @@
 
 	if (addr < vma->vm_start || end_addr >= vma->vm_end)
 		return -EFAULT;
-	if (!(vma->vm_flags & VM_MIXEDMAP)) {
+    if (!(vma->vm_flags & VM_MIXEDMAP))
+    {
 		BUG_ON(mmap_read_trylock(vma->vm_mm));
 		BUG_ON(vma->vm_flags & VM_PFNMAP);
 		vma->vm_flags |= VM_MIXEDMAP;
@@ -1767,7 +1852,8 @@
 	unsigned long idx = 0, pgcount = *num;
 	int err = -EINVAL;
 
-	for (; idx < pgcount; ++idx) {
+    for (; idx < pgcount; ++idx)
+    {
 		err = vm_insert_page(vma, addr + (PAGE_SIZE * idx), pages[idx]);
 		if (err)
 			break;
@@ -1814,7 +1900,8 @@
 		return -EFAULT;
 	if (!page_count(page))
 		return -EINVAL;
-	if (!(vma->vm_flags & VM_MIXEDMAP)) {
+    if (!(vma->vm_flags & VM_MIXEDMAP))
+    {
 		BUG_ON(mmap_read_trylock(vma->vm_mm));
 		BUG_ON(vma->vm_flags & VM_PFNMAP);
 		vma->vm_flags |= VM_MIXEDMAP;
@@ -1849,7 +1936,8 @@
 	if (count > num - offset)
 		return -ENXIO;
 
-	for (i = 0; i < count; i++) {
+    for (i = 0; i < count; i++)
+    {
 		ret = vm_insert_page(vma, uaddr, pages[offset + i]);
 		if (ret < 0)
 			return ret;
@@ -1914,8 +2002,10 @@
 	pte = get_locked_pte(mm, addr, &ptl);
 	if (!pte)
 		return VM_FAULT_OOM;
-	if (!pte_none(*pte)) {
-		if (mkwrite) {
+    if (!pte_none(*pte))
+    {
+        if (mkwrite)
+        {
 			/*
 			 * For read faults on private mappings the PFN passed
 			 * in may not match the PFN we have mapped if the
@@ -1926,7 +2016,8 @@
 			 * allocation and mapping invalidation so just skip the
 			 * update.
 			 */
-			if (pte_pfn(*pte) != pfn_t_to_pfn(pfn)) {
+            if (pte_pfn(*pte) != pfn_t_to_pfn(pfn))
+            {
 				WARN_ON_ONCE(!is_zero_pfn(pte_pfn(*pte)));
 				goto out_unlock;
 			}
@@ -1944,7 +2035,8 @@
 	else
 		entry = pte_mkspecial(pfn_t_pte(pfn, prot));
 
-	if (mkwrite) {
+    if (mkwrite)
+    {
 		entry = pte_mkyoung(entry);
 		entry = maybe_mkwrite(pte_mkdirty(entry), vma);
 	}
@@ -2071,7 +2163,8 @@
 	 * without pte special, it would there be refcounted as a normal page.
 	 */
 	if (!IS_ENABLED(CONFIG_ARCH_HAS_PTE_SPECIAL) &&
-	    !pfn_t_devmap(pfn) && pfn_t_valid(pfn)) {
+        !pfn_t_devmap(pfn) && pfn_t_valid(pfn))
+    {
 		struct page *page;
 
 		/*
@@ -2081,7 +2174,9 @@
 		 */
 		page = pfn_to_page(pfn_t_to_pfn(pfn));
 		err = insert_page(vma, addr, page, pgprot);
-	} else {
+    }
+    else
+    {
 		return insert_pfn(vma, addr, pfn, pgprot, mkwrite);
 	}
 
@@ -2162,9 +2257,11 @@
 	if (!pte)
 		return -ENOMEM;
 	arch_enter_lazy_mmu_mode();
-	do {
+    do
+    {
 		BUG_ON(!pte_none(*pte));
-		if (!pfn_modify_allowed(pfn, prot)) {
+        if (!pfn_modify_allowed(pfn, prot))
+        {
 			err = -EACCES;
 			break;
 		}
@@ -2189,7 +2286,8 @@
 	if (!pmd)
 		return -ENOMEM;
 	VM_BUG_ON(pmd_trans_huge(*pmd));
-	do {
+    do
+    {
 		next = pmd_addr_end(addr, end);
 		err = remap_pte_range(mm, pmd, addr, next,
 				pfn + (addr >> PAGE_SHIFT), prot);
@@ -2211,7 +2309,8 @@
 	pud = pud_alloc(mm, p4d, addr);
 	if (!pud)
 		return -ENOMEM;
-	do {
+    do
+    {
 		next = pud_addr_end(addr, end);
 		err = remap_pmd_range(mm, pud, addr, next,
 				pfn + (addr >> PAGE_SHIFT), prot);
@@ -2233,7 +2332,8 @@
 	p4d = p4d_alloc(mm, pgd, addr);
 	if (!p4d)
 		return -ENOMEM;
-	do {
+    do
+    {
 		next = p4d_addr_end(addr, end);
 		err = remap_pud_range(mm, p4d, addr, next,
 				pfn + (addr >> PAGE_SHIFT), prot);
@@ -2286,7 +2386,8 @@
 	 * un-COW'ed pages by matching them up with "vma->vm_pgoff".
 	 * See vm_normal_page() for details.
 	 */
-	if (is_cow_mapping(vma->vm_flags)) {
+    if (is_cow_mapping(vma->vm_flags))
+    {
 		if (addr != vma->vm_start || end != vma->vm_end)
 			return -EINVAL;
 		vma->vm_pgoff = pfn;
@@ -2302,7 +2403,8 @@
 	pfn -= addr >> PAGE_SHIFT;
 	pgd = pgd_offset(mm, addr);
 	flush_cache_range(vma, addr, end);
-	do {
+    do
+    {
 		next = pgd_addr_end(addr, end);
 		err = remap_p4d_range(mm, pgd, addr, next,
 				pfn + (addr >> PAGE_SHIFT), prot);
@@ -2375,25 +2477,27 @@
 	int err = 0;
 	spinlock_t *ptl;
 
-	if (create) {
-		pte = (mm == &init_mm) ?
-			pte_alloc_kernel_track(pmd, addr, mask) :
-			pte_alloc_map_lock(mm, pmd, addr, &ptl);
+    if (create)
+    {
+        pte = (mm == &init_mm) ? pte_alloc_kernel_track(pmd, addr, mask) : pte_alloc_map_lock(mm, pmd, addr, &ptl);
 		if (!pte)
 			return -ENOMEM;
-	} else {
-		pte = (mm == &init_mm) ?
-			pte_offset_kernel(pmd, addr) :
-			pte_offset_map_lock(mm, pmd, addr, &ptl);
+    }
+    else
+    {
+        pte = (mm == &init_mm) ? pte_offset_kernel(pmd, addr) : pte_offset_map_lock(mm, pmd, addr, &ptl);
 	}
 
 	BUG_ON(pmd_huge(*pmd));
 
 	arch_enter_lazy_mmu_mode();
 
-	if (fn) {
-		do {
-			if (create || !pte_none(*pte)) {
+    if (fn)
+    {
+        do
+        {
+            if (create || !pte_none(*pte))
+            {
 				err = fn(pte++, addr, data);
 				if (err)
 					break;
@@ -2420,16 +2524,21 @@
 
 	BUG_ON(pud_huge(*pud));
 
-	if (create) {
+    if (create)
+    {
 		pmd = pmd_alloc_track(mm, pud, addr, mask);
 		if (!pmd)
 			return -ENOMEM;
-	} else {
+    }
+    else
+    {
 		pmd = pmd_offset(pud, addr);
 	}
-	do {
+    do
+    {
 		next = pmd_addr_end(addr, end);
-		if (create || !pmd_none_or_clear_bad(pmd)) {
+        if (create || !pmd_none_or_clear_bad(pmd))
+        {
 			err = apply_to_pte_range(mm, pmd, addr, next, fn, data,
 						 create, mask);
 			if (err)
@@ -2448,16 +2557,21 @@
 	unsigned long next;
 	int err = 0;
 
-	if (create) {
+    if (create)
+    {
 		pud = pud_alloc_track(mm, p4d, addr, mask);
 		if (!pud)
 			return -ENOMEM;
-	} else {
+    }
+    else
+    {
 		pud = pud_offset(p4d, addr);
 	}
-	do {
+    do
+    {
 		next = pud_addr_end(addr, end);
-		if (create || !pud_none_or_clear_bad(pud)) {
+        if (create || !pud_none_or_clear_bad(pud))
+        {
 			err = apply_to_pmd_range(mm, pud, addr, next, fn, data,
 						 create, mask);
 			if (err)
@@ -2476,16 +2590,21 @@
 	unsigned long next;
 	int err = 0;
 
-	if (create) {
+    if (create)
+    {
 		p4d = p4d_alloc_track(mm, pgd, addr, mask);
 		if (!p4d)
 			return -ENOMEM;
-	} else {
+    }
+    else
+    {
 		p4d = p4d_offset(pgd, addr);
 	}
-	do {
+    do
+    {
 		next = p4d_addr_end(addr, end);
-		if (create || !p4d_none_or_clear_bad(p4d)) {
+        if (create || !p4d_none_or_clear_bad(p4d))
+        {
 			err = apply_to_pud_range(mm, p4d, addr, next, fn, data,
 						 create, mask);
 			if (err)
@@ -2509,7 +2628,8 @@
 		return -EINVAL;
 
 	pgd = pgd_offset(mm, addr);
-	do {
+    do
+    {
 		next = pgd_addr_end(addr, end);
 		if (!create && pgd_none_or_clear_bad(pgd))
 			continue;
@@ -2562,7 +2682,8 @@
 {
 	int same = 1;
 #if defined(CONFIG_SMP) || defined(CONFIG_PREEMPTION)
-	if (sizeof(pte_t) > sizeof(unsigned long)) {
+    if (sizeof(pte_t) > sizeof(unsigned long))
+    {
 		spinlock_t *ptl = pte_lockptr(mm, pmd);
 		spin_lock(ptl);
 		same = pte_same(*page_table, orig_pte);
@@ -2584,7 +2705,8 @@
 	struct mm_struct *mm = vma->vm_mm;
 	unsigned long addr = vmf->address;
 
-	if (likely(src)) {
+    if (likely(src))
+    {
 		copy_user_highpage(dst, src, addr, vma);
 		return true;
 	}
@@ -2602,12 +2724,14 @@
 	 * On architectures with software "accessed" bits, we would
 	 * take a double page fault, so mark it accessed here.
 	 */
-	if (arch_faults_on_old_pte() && !pte_young(vmf->orig_pte)) {
+    if (arch_faults_on_old_pte() && !pte_young(vmf->orig_pte))
+    {
 		pte_t entry;
 
 		vmf->pte = pte_offset_map_lock(mm, vmf->pmd, addr, &vmf->ptl);
 		locked = true;
-		if (!likely(pte_same(*vmf->pte, vmf->orig_pte))) {
+        if (!likely(pte_same(*vmf->pte, vmf->orig_pte)))
+        {
 			/*
 			 * Other thread has already handled the fault
 			 * and update local tlb only
@@ -2628,14 +2752,16 @@
 	 * in which case we just give up and fill the result with
 	 * zeroes.
 	 */
-	if (__copy_from_user_inatomic(kaddr, uaddr, PAGE_SIZE)) {
+    if (__copy_from_user_inatomic(kaddr, uaddr, PAGE_SIZE))
+    {
 		if (locked)
 			goto warn;
 
 		/* Re-validate under PTL if the page is still mapped */
 		vmf->pte = pte_offset_map_lock(mm, vmf->pmd, addr, &vmf->ptl);
 		locked = true;
-		if (!likely(pte_same(*vmf->pte, vmf->orig_pte))) {
+        if (!likely(pte_same(*vmf->pte, vmf->orig_pte)))
+        {
 			/* The PTE changed under us, update local tlb */
 			update_mmu_tlb(vma, addr, vmf->pte);
 			ret = false;
@@ -2646,7 +2772,8 @@
 		 * The same page can be mapped back since last copy attempt.
 		 * Try to copy again under PTL.
 		 */
-		if (__copy_from_user_inatomic(kaddr, uaddr, PAGE_SIZE)) {
+        if (__copy_from_user_inatomic(kaddr, uaddr, PAGE_SIZE))
+        {
 			/*
 			 * Give a warn in case there can be some obscure
 			 * use-case
@@ -2705,14 +2832,17 @@
 	vmf->flags = old_flags;
 	if (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE)))
 		return ret;
-	if (unlikely(!(ret & VM_FAULT_LOCKED))) {
+    if (unlikely(!(ret & VM_FAULT_LOCKED)))
+    {
 		lock_page(page);
-		if (!page->mapping) {
+        if (!page->mapping)
+        {
 			unlock_page(page);
 			return 0; /* retry */
 		}
 		ret |= VM_FAULT_LOCKED;
-	} else
+    }
+    else
 		VM_BUG_ON_PAGE(!PageLocked(page), page);
 	return ret;
 }
@@ -2753,12 +2883,14 @@
 	 * Drop the mmap_lock before waiting on IO, if we can. The file
 	 * is pinning the mapping, as per above.
 	 */
-	if ((dirtied || page_mkwrite) && mapping) {
+    if ((dirtied || page_mkwrite) && mapping)
+    {
 		struct file *fpin;
 
 		fpin = maybe_unlock_mmap_for_io(vmf, NULL);
 		balance_dirty_pages_ratelimited(mapping);
-		if (fpin) {
+        if (fpin)
+        {
 			fput(fpin);
 			return VM_FAULT_RETRY;
 		}
@@ -2827,18 +2959,22 @@
 	if (unlikely(anon_vma_prepare(vma)))
 		goto oom;
 
-	if (is_zero_pfn(pte_pfn(vmf->orig_pte))) {
+    if (is_zero_pfn(pte_pfn(vmf->orig_pte)))
+    {
 		new_page = alloc_zeroed_user_highpage_movable(vma,
 							      vmf->address);
 		if (!new_page)
 			goto oom;
-	} else {
+    }
+    else
+    {
 		new_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma,
 				vmf->address);
 		if (!new_page)
 			goto oom;
 
-		if (!cow_user_page(new_page, old_page, vmf)) {
+        if (!cow_user_page(new_page, old_page, vmf))
+        {
 			/*
 			 * COW failed, if the fault was solved by other,
 			 * it's fine. If not, userspace would re-fault on
@@ -2867,14 +3003,19 @@
 	 * Re-check the pte - we dropped the lock
 	 */
 	vmf->pte = pte_offset_map_lock(mm, vmf->pmd, vmf->address, &vmf->ptl);
-	if (likely(pte_same(*vmf->pte, vmf->orig_pte))) {
-		if (old_page) {
-			if (!PageAnon(old_page)) {
+    if (likely(pte_same(*vmf->pte, vmf->orig_pte)))
+    {
+        if (old_page)
+        {
+            if (!PageAnon(old_page))
+            {
 				dec_mm_counter_fast(mm,
 						mm_counter_file(old_page));
 				inc_mm_counter_fast(mm, MM_ANONPAGES);
 			}
-		} else {
+        }
+        else
+        {
 			inc_mm_counter_fast(mm, MM_ANONPAGES);
 		}
 		flush_cache_page(vma, vmf->address, pte_pfn(vmf->orig_pte));
@@ -2897,7 +3038,8 @@
 		 */
 		set_pte_at_notify(mm, vmf->address, vmf->pte, entry);
 		update_mmu_cache(vma, vmf->address, vmf->pte);
-		if (old_page) {
+        if (old_page)
+        {
 			/*
 			 * Only after switching the pte to the new page may
 			 * we remove the mapcount here. Otherwise another
@@ -2926,7 +3068,9 @@
 		/* Free the old page.. */
 		new_page = old_page;
 		page_copied = 1;
-	} else {
+    }
+    else
+    {
 		update_mmu_tlb(vma, vmf->address, vmf->pte);
 	}
 
@@ -2939,12 +3083,14 @@
 	 * the above ptep_clear_flush_notify() did already call it.
 	 */
 	mmu_notifier_invalidate_range_only_end(&range);
-	if (old_page) {
+    if (old_page)
+    {
 		/*
 		 * Don't let another task, with possibly unlocked vma,
 		 * keep the mlocked page.
 		 */
-		if (page_copied && (vma->vm_flags & VM_LOCKED)) {
+        if (page_copied && (vma->vm_flags & VM_LOCKED))
+        {
 			lock_page(old_page);	/* LRU manipulation */
 			if (PageMlocked(old_page))
 				munlock_vma_page(old_page);
@@ -2986,7 +3132,8 @@
 	 * We might have raced with another page fault while we released the
 	 * pte_offset_map_lock.
 	 */
-	if (!pte_same(*vmf->pte, vmf->orig_pte)) {
+    if (!pte_same(*vmf->pte, vmf->orig_pte))
+    {
 		update_mmu_tlb(vmf->vma, vmf->address, vmf->pte);
 		pte_unmap_unlock(vmf->pte, vmf->ptl);
 		return VM_FAULT_NOPAGE;
@@ -3003,7 +3150,8 @@
 {
 	struct vm_area_struct *vma = vmf->vma;
 
-	if (vma->vm_ops && vma->vm_ops->pfn_mkwrite) {
+    if (vma->vm_ops && vma->vm_ops->pfn_mkwrite)
+    {
 		vm_fault_t ret;
 
 		pte_unmap_unlock(vmf->pte, vmf->ptl);
@@ -3025,23 +3173,28 @@
 
 	get_page(vmf->page);
 
-	if (vma->vm_ops && vma->vm_ops->page_mkwrite) {
+    if (vma->vm_ops && vma->vm_ops->page_mkwrite)
+    {
 		vm_fault_t tmp;
 
 		pte_unmap_unlock(vmf->pte, vmf->ptl);
 		tmp = do_page_mkwrite(vmf);
 		if (unlikely(!tmp || (tmp &
-				      (VM_FAULT_ERROR | VM_FAULT_NOPAGE)))) {
+                              (VM_FAULT_ERROR | VM_FAULT_NOPAGE))))
+        {
 			put_page(vmf->page);
 			return tmp;
 		}
 		tmp = finish_mkwrite_fault(vmf);
-		if (unlikely(tmp & (VM_FAULT_ERROR | VM_FAULT_NOPAGE))) {
+        if (unlikely(tmp & (VM_FAULT_ERROR | VM_FAULT_NOPAGE)))
+        {
 			unlock_page(vmf->page);
 			put_page(vmf->page);
 			return tmp;
 		}
-	} else {
+    }
+    else
+    {
 		wp_page_reuse(vmf);
 		lock_page(vmf->page);
 	}
@@ -3074,13 +3227,15 @@
 {
 	struct vm_area_struct *vma = vmf->vma;
 
-	if (userfaultfd_pte_wp(vma, *vmf->pte)) {
+    if (userfaultfd_pte_wp(vma, *vmf->pte))
+    {
 		pte_unmap_unlock(vmf->pte, vmf->ptl);
 		return handle_userfault(vmf, VM_UFFD_WP);
 	}
 
 	vmf->page = vm_normal_page(vma, vmf->address, vmf->orig_pte);
-	if (!vmf->page) {
+    if (!vmf->page)
+    {
 		/*
 		 * VM_MIXEDMAP !pfn_valid() case, or VM_SOFTDIRTY clear on a
 		 * VM_PFNMAP VMA.
@@ -3100,15 +3255,21 @@
 	 * Take out anonymous pages first, anonymous shared vmas are
 	 * not dirty accountable.
 	 */
-	if (PageAnon(vmf->page)) {
+    if (PageAnon(vmf->page))
+    {
 		struct page *page = vmf->page;
 
 		/* PageKsm() doesn't necessarily raise the page refcount */
-		if (PageKsm(page) || page_count(page) != 1)
+        if (PageKsm(page) || page_count(page) != 1){
+            //zhehua
+			if (PageKsm(page))
+                nr_ksm_cows++;
 			goto copy;
+        }
 		if (!trylock_page(page))
 			goto copy;
-		if (PageKsm(page) || page_mapcount(page) != 1 || page_count(page) != 1) {
+        if (PageKsm(page) || page_mapcount(page) != 1 || page_count(page) != 1)
+        {
 			unlock_page(page);
 			goto copy;
 		}
@@ -3120,8 +3281,10 @@
 		unlock_page(page);
 		wp_page_reuse(vmf);
 		return VM_FAULT_WRITE;
-	} else if (unlikely((vma->vm_flags & (VM_WRITE|VM_SHARED)) ==
-					(VM_WRITE|VM_SHARED))) {
+    }
+    else if (unlikely((vma->vm_flags & (VM_WRITE | VM_SHARED)) ==
+                      (VM_WRITE | VM_SHARED)))
+    {
 		return wp_page_shared(vmf);
 	}
 copy:
@@ -3148,7 +3311,8 @@
 	pgoff_t vba, vea, zba, zea;
 
 	vma_interval_tree_foreach(vma, root,
-			details->first_index, details->last_index) {
+                              details->first_index, details->last_index)
+    {
 
 		vba = vma->vm_pgoff;
 		vea = vba + vma_pages(vma) - 1;
@@ -3219,7 +3383,8 @@
 	pgoff_t hlen = (holelen + PAGE_SIZE - 1) >> PAGE_SHIFT;
 
 	/* Check for overflow. */
-	if (sizeof(holelen) > sizeof(hlen)) {
+    if (sizeof(holelen) > sizeof(hlen))
+    {
 		long long holeend =
 			(holebegin + holelen + PAGE_SIZE - 1) >> PAGE_SHIFT;
 		if (holeend & ~(long long)ULONG_MAX)
@@ -3253,16 +3418,24 @@
 		goto out;
 
 	entry = pte_to_swp_entry(vmf->orig_pte);
-	if (unlikely(non_swap_entry(entry))) {
-		if (is_migration_entry(entry)) {
+    if (unlikely(non_swap_entry(entry)))
+    {
+        if (is_migration_entry(entry))
+        {
 			migration_entry_wait(vma->vm_mm, vmf->pmd,
 					     vmf->address);
-		} else if (is_device_private_entry(entry)) {
+        }
+        else if (is_device_private_entry(entry))
+        {
 			vmf->page = device_private_entry_to_page(entry);
 			ret = vmf->page->pgmap->ops->migrate_to_ram(vmf);
-		} else if (is_hwpoison_entry(entry)) {
+        }
+        else if (is_hwpoison_entry(entry))
+        {
 			ret = VM_FAULT_HWPOISON;
-		} else {
+        }
+        else
+        {
 			print_bad_pte(vma, vmf->address, vmf->orig_pte, NULL);
 			ret = VM_FAULT_SIGBUS;
 		}
@@ -3269,20 +3442,22 @@
 		goto out;
 	}
 
-
 	delayacct_set_flag(DELAYACCT_PF_SWAPIN);
 	page = lookup_swap_cache(entry, vma, vmf->address);
 	swapcache = page;
 
-	if (!page) {
+    if (!page)
+    {
 		struct swap_info_struct *si = swp_swap_info(entry);
 
 		if (data_race(si->flags & SWP_SYNCHRONOUS_IO) &&
-		    __swap_count(entry) == 1) {
+            __swap_count(entry) == 1)
+        {
 			/* skip swapcache */
 			page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma,
 							vmf->address);
-			if (page) {
+            if (page)
+            {
 				int err;
 
 				__SetPageLocked(page);
@@ -3294,7 +3469,8 @@
 				err = mem_cgroup_charge(page, vma->vm_mm,
 							GFP_KERNEL);
 				ClearPageSwapCache(page);
-				if (err) {
+                if (err)
+                {
 					ret = VM_FAULT_OOM;
 					goto out_page;
 				}
@@ -3306,13 +3482,16 @@
 				lru_cache_add(page);
 				swap_readpage(page, true);
 			}
-		} else {
+        }
+        else
+        {
 			page = swapin_readahead(entry, GFP_HIGHUSER_MOVABLE,
 						vmf);
 			swapcache = page;
 		}
 
-		if (!page) {
+        if (!page)
+        {
 			/*
 			 * Back out if somebody else faulted in this pte
 			 * while we released the pte lock.
@@ -3329,7 +3508,9 @@
 		ret = VM_FAULT_MAJOR;
 		count_vm_event(PGMAJFAULT);
 		count_memcg_event_mm(vma->vm_mm, PGMAJFAULT);
-	} else if (PageHWPoison(page)) {
+    }
+    else if (PageHWPoison(page))
+    {
 		/*
 		 * hwpoisoned dirty swapcache pages are kept for killing
 		 * owner processes (which may be unknown at hwpoison time)
@@ -3342,7 +3523,8 @@
 	locked = lock_page_or_retry(page, vma->vm_mm, vmf->flags);
 
 	delayacct_clear_flag(DELAYACCT_PF_SWAPIN);
-	if (!locked) {
+    if (!locked)
+    {
 		ret |= VM_FAULT_RETRY;
 		goto out_release;
 	}
@@ -3354,11 +3536,13 @@
 	 * swapcache, we need to check that the page's swap has not changed.
 	 */
 	if (unlikely((!PageSwapCache(page) ||
-			page_private(page) != entry.val)) && swapcache)
+                  page_private(page) != entry.val)) &&
+        swapcache)
 		goto out_page;
 
 	page = ksm_might_need_to_copy(page, vma, vmf->address);
-	if (unlikely(!page)) {
+    if (unlikely(!page))
+    {
 		ret = VM_FAULT_OOM;
 		page = swapcache;
 		goto out_page;
@@ -3374,7 +3558,8 @@
 	if (unlikely(!pte_same(*vmf->pte, vmf->orig_pte)))
 		goto out_nomap;
 
-	if (unlikely(!PageUptodate(page))) {
+    if (unlikely(!PageUptodate(page)))
+    {
 		ret = VM_FAULT_SIGBUS;
 		goto out_nomap;
 	}
@@ -3392,7 +3577,8 @@
 	inc_mm_counter_fast(vma->vm_mm, MM_ANONPAGES);
 	dec_mm_counter_fast(vma->vm_mm, MM_SWAPENTS);
 	pte = mk_pte(page, vma->vm_page_prot);
-	if ((vmf->flags & FAULT_FLAG_WRITE) && reuse_swap_page(page, NULL)) {
+    if ((vmf->flags & FAULT_FLAG_WRITE) && reuse_swap_page(page, NULL))
+    {
 		pte = maybe_mkwrite(pte_mkdirty(pte), vma);
 		vmf->flags &= ~FAULT_FLAG_WRITE;
 		ret |= VM_FAULT_WRITE;
@@ -3401,7 +3587,8 @@
 	flush_icache_page(vma, page);
 	if (pte_swp_soft_dirty(vmf->orig_pte))
 		pte = pte_mksoft_dirty(pte);
-	if (pte_swp_uffd_wp(vmf->orig_pte)) {
+    if (pte_swp_uffd_wp(vmf->orig_pte))
+    {
 		pte = pte_mkuffd_wp(pte);
 		pte = pte_wrprotect(pte);
 	}
@@ -3410,10 +3597,13 @@
 	vmf->orig_pte = pte;
 
 	/* ksm created a completely new copy */
-	if (unlikely(page != swapcache && swapcache)) {
+    if (unlikely(page != swapcache && swapcache))
+    {
 		page_add_new_anon_rmap(page, vma, vmf->address, false);
 		lru_cache_add_inactive_or_unevictable(page, vma);
-	} else {
+    }
+    else
+    {
 		do_page_add_anon_rmap(page, vma, vmf->address, exclusive);
 	}
 
@@ -3422,7 +3612,8 @@
 	    (vma->vm_flags & VM_LOCKED) || PageMlocked(page))
 		try_to_free_swap(page);
 	unlock_page(page);
-	if (page != swapcache && swapcache) {
+    if (page != swapcache && swapcache)
+    {
 		/*
 		 * Hold the lock to avoid the swap entry to be reused
 		 * until we take the PT lock for the pte_same() check
@@ -3435,7 +3626,8 @@
 		put_page(swapcache);
 	}
 
-	if (vmf->flags & FAULT_FLAG_WRITE) {
+    if (vmf->flags & FAULT_FLAG_WRITE)
+    {
 		ret |= do_wp_page(vmf);
 		if (ret & VM_FAULT_ERROR)
 			ret &= VM_FAULT_ERROR;
@@ -3454,7 +3646,8 @@
 	unlock_page(page);
 out_release:
 	put_page(page);
-	if (page != swapcache && swapcache) {
+    if (page != swapcache && swapcache)
+    {
 		unlock_page(swapcache);
 		put_page(swapcache);
 	}
@@ -3496,12 +3689,14 @@
 
 	/* Use the zero-page for reads */
 	if (!(vmf->flags & FAULT_FLAG_WRITE) &&
-			!mm_forbids_zeropage(vma->vm_mm)) {
+        !mm_forbids_zeropage(vma->vm_mm))
+    {
 		entry = pte_mkspecial(pfn_pte(my_zero_pfn(vmf->address),
 						vma->vm_page_prot));
 		vmf->pte = pte_offset_map_lock(vma->vm_mm, vmf->pmd,
 				vmf->address, &vmf->ptl);
-		if (!pte_none(*vmf->pte)) {
+        if (!pte_none(*vmf->pte))
+        {
 			update_mmu_tlb(vma, vmf->address, vmf->pte);
 			goto unlock;
 		}
@@ -3509,7 +3704,8 @@
 		if (ret)
 			goto unlock;
 		/* Deliver the page fault to userland, check inside PT lock */
-		if (userfaultfd_missing(vma)) {
+        if (userfaultfd_missing(vma))
+        {
 			pte_unmap_unlock(vmf->pte, vmf->ptl);
 			return handle_userfault(vmf, VM_UFFD_MISSING);
 		}
@@ -3541,7 +3737,8 @@
 
 	vmf->pte = pte_offset_map_lock(vma->vm_mm, vmf->pmd, vmf->address,
 			&vmf->ptl);
-	if (!pte_none(*vmf->pte)) {
+    if (!pte_none(*vmf->pte))
+    {
 		update_mmu_cache(vma, vmf->address, vmf->pte);
 		goto release;
 	}
@@ -3551,7 +3748,8 @@
 		goto release;
 
 	/* Deliver the page fault to userland, check inside PT lock */
-	if (userfaultfd_missing(vma)) {
+    if (userfaultfd_missing(vma))
+    {
 		pte_unmap_unlock(vmf->pte, vmf->ptl);
 		put_page(page);
 		return handle_userfault(vmf, VM_UFFD_MISSING);
@@ -3602,7 +3800,8 @@
 	 *				unlock_page(B)
 	 *				# flush A, B to clear the writeback
 	 */
-	if (pmd_none(*vmf->pmd) && !vmf->prealloc_pte) {
+    if (pmd_none(*vmf->pmd) && !vmf->prealloc_pte)
+    {
 		vmf->prealloc_pte = pte_alloc_one(vma->vm_mm);
 		if (!vmf->prealloc_pte)
 			return VM_FAULT_OOM;
@@ -3614,7 +3813,8 @@
 			    VM_FAULT_DONE_COW)))
 		return ret;
 
-	if (unlikely(PageHWPoison(vmf->page))) {
+    if (unlikely(PageHWPoison(vmf->page)))
+    {
 		if (ret & VM_FAULT_LOCKED)
 			unlock_page(vmf->page);
 		put_page(vmf->page);
@@ -3647,9 +3847,11 @@
 
 	if (!pmd_none(*vmf->pmd))
 		goto map_pte;
-	if (vmf->prealloc_pte) {
+    if (vmf->prealloc_pte)
+    {
 		vmf->ptl = pmd_lock(vma->vm_mm, vmf->pmd);
-		if (unlikely(!pmd_none(*vmf->pmd))) {
+        if (unlikely(!pmd_none(*vmf->pmd)))
+        {
 			spin_unlock(vmf->ptl);
 			goto map_pte;
 		}
@@ -3658,7 +3860,9 @@
 		pmd_populate(vma->vm_mm, vmf->pmd, vmf->prealloc_pte);
 		spin_unlock(vmf->ptl);
 		vmf->prealloc_pte = NULL;
-	} else if (unlikely(pte_alloc(vma->vm_mm, vmf->pmd))) {
+    }
+    else if (unlikely(pte_alloc(vma->vm_mm, vmf->pmd)))
+    {
 		return VM_FAULT_OOM;
 	}
 map_pte:
@@ -3724,7 +3928,8 @@
 	 * Archs like ppc64 need additonal space to store information
 	 * related to pte entry. Use the preallocated table for that.
 	 */
-	if (arch_needs_pgtable_deposit() && !vmf->prealloc_pte) {
+    if (arch_needs_pgtable_deposit() && !vmf->prealloc_pte)
+    {
 		vmf->prealloc_pte = pte_alloc_one(vma->vm_mm);
 		if (!vmf->prealloc_pte)
 			return VM_FAULT_OOM;
@@ -3791,20 +3996,23 @@
 	pte_t entry;
 	vm_fault_t ret;
 
-	if (pmd_none(*vmf->pmd) && PageTransCompound(page)) {
+    if (pmd_none(*vmf->pmd) && PageTransCompound(page))
+    {
 		ret = do_set_pmd(vmf, page);
 		if (ret != VM_FAULT_FALLBACK)
 			return ret;
 	}
 
-	if (!vmf->pte) {
+    if (!vmf->pte)
+    {
 		ret = pte_alloc_one_map(vmf);
 		if (ret)
 			return ret;
 	}
 
 	/* Re-check under ptl */
-	if (unlikely(!pte_none(*vmf->pte))) {
+    if (unlikely(!pte_none(*vmf->pte)))
+    {
 		update_mmu_tlb(vma, vmf->address, vmf->pte);
 		return VM_FAULT_NOPAGE;
 	}
@@ -3815,11 +4023,14 @@
 	if (write)
 		entry = maybe_mkwrite(pte_mkdirty(entry), vma);
 	/* copy-on-write page */
-	if (write && !(vma->vm_flags & VM_SHARED)) {
+    if (write && !(vma->vm_flags & VM_SHARED))
+    {
 		inc_mm_counter_fast(vma->vm_mm, MM_ANONPAGES);
 		page_add_new_anon_rmap(page, vma, vmf->address, false);
 		lru_cache_add_inactive_or_unevictable(page, vma);
-	} else {
+    }
+    else
+    {
 		inc_mm_counter_fast(vma->vm_mm, mm_counter_file(page));
 		page_add_file_rmap(page, false);
 	}
@@ -3957,7 +4167,8 @@
 	end_pgoff = min3(end_pgoff, vma_pages(vmf->vma) + vmf->vma->vm_pgoff - 1,
 			start_pgoff + nr_pages - 1);
 
-	if (pmd_none(*vmf->pmd)) {
+    if (pmd_none(*vmf->pmd))
+    {
 		vmf->prealloc_pte = pte_alloc_one(vmf->vma->vm_mm);
 		if (!vmf->prealloc_pte)
 			goto out;
@@ -3967,7 +4178,8 @@
 	vmf->vma->vm_ops->map_pages(vmf, start_pgoff, end_pgoff);
 
 	/* Huge page is mapped? Page fault is solved */
-	if (pmd_trans_huge(*vmf->pmd)) {
+    if (pmd_trans_huge(*vmf->pmd))
+    {
 		ret = VM_FAULT_NOPAGE;
 		goto out;
 	}
@@ -3997,7 +4209,8 @@
 	 * if page by the offset is not ready to be mapped (cold cache or
 	 * something).
 	 */
-	if (vma->vm_ops->map_pages && fault_around_bytes >> PAGE_SHIFT > 1) {
+    if (vma->vm_ops->map_pages && fault_around_bytes >> PAGE_SHIFT > 1)
+    {
 		ret = do_fault_around(vmf);
 		if (ret)
 			return ret;
@@ -4026,7 +4239,8 @@
 	if (!vmf->cow_page)
 		return VM_FAULT_OOM;
 
-	if (mem_cgroup_charge(vmf->cow_page, vma->vm_mm, GFP_KERNEL)) {
+    if (mem_cgroup_charge(vmf->cow_page, vma->vm_mm, GFP_KERNEL))
+    {
 		put_page(vmf->cow_page);
 		return VM_FAULT_OOM;
 	}
@@ -4065,11 +4279,13 @@
 	 * Check if the backing address space wants to know that the page is
 	 * about to become writable
 	 */
-	if (vma->vm_ops->page_mkwrite) {
+    if (vma->vm_ops->page_mkwrite)
+    {
 		unlock_page(vmf->page);
 		tmp = do_page_mkwrite(vmf);
 		if (unlikely(!tmp ||
-				(tmp & (VM_FAULT_ERROR | VM_FAULT_NOPAGE)))) {
+                     (tmp & (VM_FAULT_ERROR | VM_FAULT_NOPAGE))))
+        {
 			put_page(vmf->page);
 			return tmp;
 		}
@@ -4077,7 +4293,8 @@
 
 	ret |= finish_fault(vmf);
 	if (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE |
-					VM_FAULT_RETRY))) {
+                        VM_FAULT_RETRY)))
+    {
 		unlock_page(vmf->page);
 		put_page(vmf->page);
 		return ret;
@@ -4104,14 +4321,16 @@
 	/*
 	 * The VMA was not fully populated on mmap() or missing VM_DONTEXPAND
 	 */
-	if (!vma->vm_ops->fault) {
+    if (!vma->vm_ops->fault)
+    {
 		/*
 		 * If we find a migration pmd entry or a none pmd entry, which
 		 * should never happen, return SIGBUS
 		 */
 		if (unlikely(!pmd_present(*vmf->pmd)))
 			ret = VM_FAULT_SIGBUS;
-		else {
+        else
+        {
 			vmf->pte = pte_offset_map_lock(vmf->vma->vm_mm,
 						       vmf->pmd,
 						       vmf->address,
@@ -4130,7 +4349,8 @@
 
 			pte_unmap_unlock(vmf->pte, vmf->ptl);
 		}
-	} else if (!(vmf->flags & FAULT_FLAG_WRITE))
+    }
+    else if (!(vmf->flags & FAULT_FLAG_WRITE))
 		ret = do_read_fault(vmf);
 	else if (!(vma->vm_flags & VM_SHARED))
 		ret = do_cow_fault(vmf);
@@ -4138,7 +4358,8 @@
 		ret = do_shared_fault(vmf);
 
 	/* preallocated pagetable is unused: free it */
-	if (vmf->prealloc_pte) {
+    if (vmf->prealloc_pte)
+    {
 		pte_free(vm_mm, vmf->prealloc_pte);
 		vmf->prealloc_pte = NULL;
 	}
@@ -4152,7 +4373,8 @@
 	get_page(page);
 
 	count_vm_numa_event(NUMA_HINT_FAULTS);
-	if (page_nid == numa_node_id()) {
+    if (page_nid == numa_node_id())
+    {
 		count_vm_numa_event(NUMA_HINT_FAULTS_LOCAL);
 		*flags |= TNF_FAULT_LOCAL;
 	}
@@ -4179,7 +4401,8 @@
 	 */
 	vmf->ptl = pte_lockptr(vma->vm_mm, vmf->pmd);
 	spin_lock(vmf->ptl);
-	if (unlikely(!pte_same(*vmf->pte, vmf->orig_pte))) {
+    if (unlikely(!pte_same(*vmf->pte, vmf->orig_pte)))
+    {
 		pte_unmap_unlock(vmf->pte, vmf->ptl);
 		goto out;
 	}
@@ -4197,13 +4420,15 @@
 	update_mmu_cache(vma, vmf->address, vmf->pte);
 
 	page = vm_normal_page(vma, vmf->address, pte);
-	if (!page) {
+    if (!page)
+    {
 		pte_unmap_unlock(vmf->pte, vmf->ptl);
 		return 0;
 	}
 
 	/* TODO: handle PTE-mapped THP */
-	if (PageCompound(page)) {
+    if (PageCompound(page))
+    {
 		pte_unmap_unlock(vmf->pte, vmf->ptl);
 		return 0;
 	}
@@ -4231,17 +4456,20 @@
 	target_nid = numa_migrate_prep(page, vma, vmf->address, page_nid,
 			&flags);
 	pte_unmap_unlock(vmf->pte, vmf->ptl);
-	if (target_nid == NUMA_NO_NODE) {
+    if (target_nid == NUMA_NO_NODE)
+    {
 		put_page(page);
 		goto out;
 	}
 
 	/* Migrate to the requested node */
 	migrated = migrate_misplaced_page(page, vma, target_nid);
-	if (migrated) {
+    if (migrated)
+    {
 		page_nid = target_nid;
 		flags |= TNF_MIGRATED;
-	} else
+    }
+    else
 		flags |= TNF_MIGRATE_FAIL;
 
 out:
@@ -4262,12 +4490,14 @@
 /* `inline' is required to avoid gcc 4.1.2 build error */
 static inline vm_fault_t wp_huge_pmd(struct vm_fault *vmf, pmd_t orig_pmd)
 {
-	if (vma_is_anonymous(vmf->vma)) {
+    if (vma_is_anonymous(vmf->vma))
+    {
 		if (userfaultfd_huge_pmd_wp(vmf->vma, orig_pmd))
 			return handle_userfault(vmf, VM_UFFD_WP);
 		return do_huge_pmd_wp_page(vmf, orig_pmd);
 	}
-	if (vmf->vma->vm_ops->huge_fault) {
+    if (vmf->vma->vm_ops->huge_fault)
+    {
 		vm_fault_t ret = vmf->vma->vm_ops->huge_fault(vmf, PE_SIZE_PMD);
 
 		if (!(ret & VM_FAULT_FALLBACK))
@@ -4287,7 +4517,8 @@
 	/* No support for anonymous transparent PUD pages yet */
 	if (vma_is_anonymous(vmf->vma))
 		goto split;
-	if (vmf->vma->vm_ops->huge_fault) {
+    if (vmf->vma->vm_ops->huge_fault)
+    {
 		vm_fault_t ret = vmf->vma->vm_ops->huge_fault(vmf, PE_SIZE_PUD);
 
 		if (!(ret & VM_FAULT_FALLBACK))
@@ -4331,7 +4562,9 @@
 {
 	pte_t entry;
 
-	if (unlikely(pmd_none(*vmf->pmd))) {
+
+    if (unlikely(pmd_none(*vmf->pmd)))
+    {
 		/*
 		 * Leave __pte_alloc() until later: because vm_ops->fault may
 		 * want to allocate huge page, and if we expose page table
@@ -4339,7 +4572,9 @@
 		 * concurrent faults and from rmap lookups.
 		 */
 		vmf->pte = NULL;
-	} else {
+    }
+    else
+    {
 		/* See comment in pte_alloc_one_map() */
 		if (pmd_devmap_trans_unstable(vmf->pmd))
 			return 0;
@@ -4361,13 +4596,15 @@
 		 * ptl lock held. So here a barrier will do.
 		 */
 		barrier();
-		if (pte_none(vmf->orig_pte)) {
+        if (pte_none(vmf->orig_pte))
+        {
 			pte_unmap(vmf->pte);
 			vmf->pte = NULL;
 		}
 	}
 
-	if (!vmf->pte) {
+    if (!vmf->pte)
+    {
 		if (vma_is_anonymous(vmf->vma))
 			return do_anonymous_page(vmf);
 		else
@@ -4383,20 +4620,25 @@
 	vmf->ptl = pte_lockptr(vmf->vma->vm_mm, vmf->pmd);
 	spin_lock(vmf->ptl);
 	entry = vmf->orig_pte;
-	if (unlikely(!pte_same(*vmf->pte, entry))) {
+    if (unlikely(!pte_same(*vmf->pte, entry)))
+    {
 		update_mmu_tlb(vmf->vma, vmf->address, vmf->pte);
 		goto unlock;
 	}
-	if (vmf->flags & FAULT_FLAG_WRITE) {
+    if (vmf->flags & FAULT_FLAG_WRITE)
+    {
 		if (!pte_write(entry))
 			return do_wp_page(vmf);
 		entry = pte_mkdirty(entry);
 	}
 	entry = pte_mkyoung(entry);
 	if (ptep_set_access_flags(vmf->vma, vmf->address, vmf->pte, entry,
-				vmf->flags & FAULT_FLAG_WRITE)) {
+                              vmf->flags & FAULT_FLAG_WRITE))
+    {
 		update_mmu_cache(vmf->vma, vmf->address, vmf->pte);
-	} else {
+    }
+    else
+    {
 		/* Skip spurious TLB flush for retried page fault */
 		if (vmf->flags & FAULT_FLAG_TRIED)
 			goto unlock;
@@ -4445,23 +4687,30 @@
 	if (!vmf.pud)
 		return VM_FAULT_OOM;
 retry_pud:
-	if (pud_none(*vmf.pud) && __transparent_hugepage_enabled(vma)) {
+    if (pud_none(*vmf.pud) && __transparent_hugepage_enabled(vma))
+    {
 		ret = create_huge_pud(&vmf);
 		if (!(ret & VM_FAULT_FALLBACK))
 			return ret;
-	} else {
+    }
+    else
+    {
 		pud_t orig_pud = *vmf.pud;
 
 		barrier();
-		if (pud_trans_huge(orig_pud) || pud_devmap(orig_pud)) {
+        if (pud_trans_huge(orig_pud) || pud_devmap(orig_pud))
+        {
 
 			/* NUMA case for anonymous PUDs would go here */
 
-			if (dirty && !pud_write(orig_pud)) {
+            if (dirty && !pud_write(orig_pud))
+            {
 				ret = wp_huge_pud(&vmf, orig_pud);
 				if (!(ret & VM_FAULT_FALLBACK))
 					return ret;
-			} else {
+            }
+            else
+            {
 				huge_pud_set_accessed(&vmf, orig_pud);
 				return 0;
 			}
@@ -4476,30 +4725,38 @@
 	if (pud_trans_unstable(vmf.pud))
 		goto retry_pud;
 
-	if (pmd_none(*vmf.pmd) && __transparent_hugepage_enabled(vma)) {
+    if (pmd_none(*vmf.pmd) && __transparent_hugepage_enabled(vma))
+    {
 		ret = create_huge_pmd(&vmf);
 		if (!(ret & VM_FAULT_FALLBACK))
 			return ret;
-	} else {
+    }
+    else
+    {
 		pmd_t orig_pmd = *vmf.pmd;
 
 		barrier();
-		if (unlikely(is_swap_pmd(orig_pmd))) {
+        if (unlikely(is_swap_pmd(orig_pmd)))
+        {
 			VM_BUG_ON(thp_migration_supported() &&
 					  !is_pmd_migration_entry(orig_pmd));
 			if (is_pmd_migration_entry(orig_pmd))
 				pmd_migration_entry_wait(mm, vmf.pmd);
 			return 0;
 		}
-		if (pmd_trans_huge(orig_pmd) || pmd_devmap(orig_pmd)) {
+        if (pmd_trans_huge(orig_pmd) || pmd_devmap(orig_pmd))
+        {
 			if (pmd_protnone(orig_pmd) && vma_is_accessible(vma))
 				return do_huge_pmd_numa_page(&vmf, orig_pmd);
 
-			if (dirty && !pmd_write(orig_pmd)) {
+            if (dirty && !pmd_write(orig_pmd))
+            {
 				ret = wp_huge_pmd(&vmf, orig_pmd);
 				if (!(ret & VM_FAULT_FALLBACK))
 					return ret;
-			} else {
+            }
+            else
+            {
 				huge_pmd_set_accessed(&vmf, orig_pmd);
 				return 0;
 			}
@@ -4603,10 +4860,16 @@
 
 	if (unlikely(is_vm_hugetlb_page(vma)))
 		ret = hugetlb_fault(vma->vm_mm, vma, address, flags);
-	else
+    else{
+        ktime_t start, diff;
+	    start = ktime_get();
 		ret = __handle_mm_fault(vma, address, flags);
+        diff = ktime_sub(ktime_get(), start);
+        trace_printk("fault = %lldus\n", ktime_to_us(diff));
+    }
 
-	if (flags & FAULT_FLAG_USER) {
+    if (flags & FAULT_FLAG_USER)
+    {
 		mem_cgroup_exit_user_fault();
 		/*
 		 * The task may have entered a memcg OOM situation but
@@ -4661,10 +4924,12 @@
 	smp_wmb(); /* See comment in __pte_alloc */
 
 	spin_lock(&mm->page_table_lock);
-	if (!p4d_present(*p4d)) {
+    if (!p4d_present(*p4d))
+    {
 		mm_inc_nr_puds(mm);
 		p4d_populate(mm, p4d, new);
-	} else	/* Another has populated it */
+    }
+    else /* Another has populated it */
 		pud_free(mm, new);
 	spin_unlock(&mm->page_table_lock);
 	return 0;
@@ -4686,10 +4951,12 @@
 	smp_wmb(); /* See comment in __pte_alloc */
 
 	ptl = pud_lock(mm, pud);
-	if (!pud_present(*pud)) {
+    if (!pud_present(*pud))
+    {
 		mm_inc_nr_pmds(mm);
 		pud_populate(mm, pud, new);
-	} else	/* Another has populated it */
+    }
+    else /* Another has populated it */
 		pmd_free(mm, new);
 	spin_unlock(ptl);
 	return 0;
@@ -4721,18 +4988,21 @@
 	pmd = pmd_offset(pud, address);
 	VM_BUG_ON(pmd_trans_huge(*pmd));
 
-	if (pmd_huge(*pmd)) {
+    if (pmd_huge(*pmd))
+    {
 		if (!pmdpp)
 			goto out;
 
-		if (range) {
+        if (range)
+        {
 			mmu_notifier_range_init(range, MMU_NOTIFY_CLEAR, 0,
 						NULL, mm, address & PMD_MASK,
 						(address & PMD_MASK) + PMD_SIZE);
 			mmu_notifier_invalidate_range_start(range);
 		}
 		*ptlp = pmd_lock(mm, pmd);
-		if (pmd_huge(*pmd)) {
+        if (pmd_huge(*pmd))
+        {
 			*pmdpp = pmd;
 			return 0;
 		}
@@ -4744,7 +5014,8 @@
 	if (pmd_none(*pmd) || unlikely(pmd_bad(*pmd)))
 		goto out;
 
-	if (range) {
+    if (range)
+    {
 		mmu_notifier_range_init(range, MMU_NOTIFY_CLEAR, 0, NULL, mm,
 					address & PAGE_MASK,
 					(address & PAGE_MASK) + PAGE_SIZE);
@@ -4888,14 +5159,16 @@
 		return 0;
 
 	/* ignore errors, just check how much was successfully transferred */
-	while (len) {
+    while (len)
+    {
 		int bytes, ret, offset;
 		void *maddr;
 		struct page *page = NULL;
 
 		ret = get_user_pages_remote(mm, addr, 1,
 				gup_flags, &page, &vma, NULL);
-		if (ret <= 0) {
+        if (ret <= 0)
+        {
 #ifndef CONFIG_HAVE_IOREMAP_PROT
 			break;
 #else
@@ -4913,18 +5186,23 @@
 				break;
 			bytes = ret;
 #endif
-		} else {
+        }
+        else
+        {
 			bytes = len;
 			offset = addr & (PAGE_SIZE-1);
 			if (bytes > PAGE_SIZE-offset)
 				bytes = PAGE_SIZE-offset;
 
 			maddr = kmap(page);
-			if (write) {
+            if (write)
+            {
 				copy_to_user_page(vma, page, addr,
 						  maddr + offset, buf, bytes);
 				set_page_dirty_lock(page);
-			} else {
+            }
+            else
+            {
 				copy_from_user_page(vma, page, addr,
 						    buf, maddr + offset, bytes);
 			}
@@ -4996,10 +5274,12 @@
 		return;
 
 	vma = find_vma(mm, ip);
-	if (vma && vma->vm_file) {
+    if (vma && vma->vm_file)
+    {
 		struct file *f = vma->vm_file;
 		char *buf = (char *)__get_free_page(GFP_NOWAIT);
-		if (buf) {
+        if (buf)
+        {
 			char *p;
 
 			p = file_path(f, buf, PAGE_SIZE);
@@ -5054,21 +5334,26 @@
 	/* Process target subpage last to keep its cache lines hot */
 	might_sleep();
 	n = (addr_hint - addr) / PAGE_SIZE;
-	if (2 * n <= pages_per_huge_page) {
+    if (2 * n <= pages_per_huge_page)
+    {
 		/* If target subpage in first half of huge page */
 		base = 0;
 		l = n;
 		/* Process subpages at the end of huge page */
-		for (i = pages_per_huge_page - 1; i >= 2 * n; i--) {
+        for (i = pages_per_huge_page - 1; i >= 2 * n; i--)
+        {
 			cond_resched();
 			process_subpage(addr + i * PAGE_SIZE, i, arg);
 		}
-	} else {
+    }
+    else
+    {
 		/* If target subpage in second half of huge page */
 		base = pages_per_huge_page - 2 * (pages_per_huge_page - n);
 		l = pages_per_huge_page - n;
 		/* Process subpages at the begin of huge page */
-		for (i = 0; i < base; i++) {
+        for (i = 0; i < base; i++)
+        {
 			cond_resched();
 			process_subpage(addr + i * PAGE_SIZE, i, arg);
 		}
@@ -5077,7 +5362,8 @@
 	 * Process remaining subpages in left-right-left-right pattern
 	 * towards the target subpage
 	 */
-	for (i = 0; i < l; i++) {
+    for (i = 0; i < l; i++)
+    {
 		int left_idx = base + i;
 		int right_idx = base + 2 * l - 1 - i;
 
@@ -5097,7 +5383,8 @@
 
 	might_sleep();
 	for (i = 0; i < pages_per_huge_page;
-	     i++, p = mem_map_next(p, page, i)) {
+         i++, p = mem_map_next(p, page, i))
+    {
 		cond_resched();
 		clear_user_highpage(p, addr + i * PAGE_SIZE);
 	}
@@ -5106,7 +5393,7 @@
 static void clear_subpage(unsigned long addr, int idx, void *arg)
 {
 	struct page *page = arg;
-
+    if (!PageZeroed(page))
 	clear_user_highpage(page + idx, addr);
 }
 
@@ -5116,7 +5403,8 @@
 	unsigned long addr = addr_hint &
 		~(((unsigned long)pages_per_huge_page << PAGE_SHIFT) - 1);
 
-	if (unlikely(pages_per_huge_page > MAX_ORDER_NR_PAGES)) {
+    if (unlikely(pages_per_huge_page > MAX_ORDER_NR_PAGES))
+    {
 		clear_gigantic_page(page, addr, pages_per_huge_page);
 		return;
 	}
@@ -5133,7 +5421,8 @@
 	struct page *dst_base = dst;
 	struct page *src_base = src;
 
-	for (i = 0; i < pages_per_huge_page; ) {
+    for (i = 0; i < pages_per_huge_page;)
+    {
 		cond_resched();
 		copy_user_highpage(dst, src, addr + i*PAGE_SIZE, vma);
 
@@ -5143,7 +5432,8 @@
 	}
 }
 
-struct copy_subpage_arg {
+struct copy_subpage_arg
+{
 	struct page *dst;
 	struct page *src;
 	struct vm_area_struct *vma;
@@ -5169,7 +5459,8 @@
 		.vma = vma,
 	};
 
-	if (unlikely(pages_per_huge_page > MAX_ORDER_NR_PAGES)) {
+    if (unlikely(pages_per_huge_page > MAX_ORDER_NR_PAGES))
+    {
 		copy_user_gigantic_page(dst, src, addr, vma,
 					pages_per_huge_page);
 		return;
@@ -5188,7 +5479,8 @@
 	unsigned long i, rc = 0;
 	unsigned long ret_val = pages_per_huge_page * PAGE_SIZE;
 
-	for (i = 0; i < pages_per_huge_page; i++) {
+    for (i = 0; i < pages_per_huge_page; i++)
+    {
 		if (allow_pagefault)
 			page_kaddr = kmap(dst_page + i);
 		else
diff --color -ruN -w -B '--exclude-from=.diff-exclude' linux-5.10/mm/mmap.c HawkEye-5.10-cow/mm/mmap.c
--- linux-5.10/mm/mmap.c	2020-12-13 22:41:30.000000000 +0000
+++ HawkEye-5.10-cow/mm/mmap.c	2025-03-23 07:53:49.831609627 +0000
@@ -37,6 +37,7 @@
 #include <linux/perf_event.h>
 #include <linux/audit.h>
 #include <linux/khugepaged.h>
+#include <linux/ohp.h>
 #include <linux/uprobes.h>
 #include <linux/rbtree_augmented.h>
 #include <linux/notifier.h>
@@ -96,8 +97,7 @@
  */
 pgprot_t protection_map[16] __ro_after_init = {
 	__P000, __P001, __P010, __P011, __P100, __P101, __P110, __P111,
-	__S000, __S001, __S010, __S011, __S100, __S101, __S110, __S111
-};
+    __S000, __S001, __S010, __S011, __S100, __S101, __S110, __S111};
 
 #ifndef CONFIG_ARCH_HAS_FILTER_PGPROT
 static inline pgprot_t arch_filter_pgprot(pgprot_t prot)
@@ -128,7 +128,8 @@
 	pgprot_t vm_page_prot;
 
 	vm_page_prot = vm_pgprot_modify(vma->vm_page_prot, vm_flags);
-	if (vma_wants_writenotify(vma, vm_page_prot)) {
+    if (vma_wants_writenotify(vma, vm_page_prot))
+    {
 		vm_flags &= ~VM_SHARED;
 		vm_page_prot = vm_pgprot_modify(vm_page_prot, vm_flags);
 	}
@@ -160,7 +161,8 @@
 {
 	struct file *file = vma->vm_file;
 
-	if (file) {
+    if (file)
+    {
 		struct address_space *mapping = file->f_mapping;
 		i_mmap_lock_write(mapping);
 		__remove_shared_vm_struct(vma, file, mapping);
@@ -181,6 +183,7 @@
 	if (vma->vm_file)
 		fput(vma->vm_file);
 	mpol_put(vma_policy(vma));
+    remove_ohp_bins(vma);
 	vm_area_free(vma);
 	return next;
 }
@@ -231,7 +234,8 @@
 
 	newbrk = PAGE_ALIGN(brk);
 	oldbrk = PAGE_ALIGN(mm->brk);
-	if (oldbrk == newbrk) {
+    if (oldbrk == newbrk)
+    {
 		mm->brk = brk;
 		goto success;
 	}
@@ -240,7 +244,8 @@
 	 * Always allow shrinking brk.
 	 * __do_munmap() may downgrade mmap_lock to read.
 	 */
-	if (brk <= mm->brk) {
+    if (brk <= mm->brk)
+    {
 		int ret;
 
 		/*
@@ -250,10 +255,13 @@
 		 */
 		mm->brk = brk;
 		ret = __do_munmap(mm, newbrk, oldbrk-newbrk, &uf, true);
-		if (ret < 0) {
+        if (ret < 0)
+        {
 			mm->brk = origbrk;
 			goto out;
-		} else if (ret == 1) {
+        }
+        else if (ret == 1)
+        {
 			downgraded = true;
 		}
 		goto success;
@@ -297,7 +305,8 @@
 	 * That's a little inconsistent, but keeps the code here simpler.
 	 */
 	gap = vm_start_gap(vma);
-	if (vma->vm_prev) {
+    if (vma->vm_prev)
+    {
 		prev_end = vm_end_gap(vma->vm_prev);
 		if (gap > prev_end)
 			gap -= prev_end;
@@ -311,15 +320,19 @@
 static unsigned long vma_compute_subtree_gap(struct vm_area_struct *vma)
 {
 	unsigned long max = vma_compute_gap(vma), subtree_gap;
-	if (vma->vm_rb.rb_left) {
+    if (vma->vm_rb.rb_left)
+    {
 		subtree_gap = rb_entry(vma->vm_rb.rb_left,
-				struct vm_area_struct, vm_rb)->rb_subtree_gap;
+                               struct vm_area_struct, vm_rb)
+                          ->rb_subtree_gap;
 		if (subtree_gap > max)
 			max = subtree_gap;
 	}
-	if (vma->vm_rb.rb_right) {
+    if (vma->vm_rb.rb_right)
+    {
 		subtree_gap = rb_entry(vma->vm_rb.rb_right,
-				struct vm_area_struct, vm_rb)->rb_subtree_gap;
+                               struct vm_area_struct, vm_rb)
+                          ->rb_subtree_gap;
 		if (subtree_gap > max)
 			max = subtree_gap;
 	}
@@ -333,26 +346,31 @@
 	struct rb_node *nd, *pn = NULL;
 	unsigned long prev = 0, pend = 0;
 
-	for (nd = rb_first(root); nd; nd = rb_next(nd)) {
+    for (nd = rb_first(root); nd; nd = rb_next(nd))
+    {
 		struct vm_area_struct *vma;
 		vma = rb_entry(nd, struct vm_area_struct, vm_rb);
-		if (vma->vm_start < prev) {
+        if (vma->vm_start < prev)
+        {
 			pr_emerg("vm_start %lx < prev %lx\n",
 				  vma->vm_start, prev);
 			bug = 1;
 		}
-		if (vma->vm_start < pend) {
+        if (vma->vm_start < pend)
+        {
 			pr_emerg("vm_start %lx < pend %lx\n",
 				  vma->vm_start, pend);
 			bug = 1;
 		}
-		if (vma->vm_start > vma->vm_end) {
+        if (vma->vm_start > vma->vm_end)
+        {
 			pr_emerg("vm_start %lx > vm_end %lx\n",
 				  vma->vm_start, vma->vm_end);
 			bug = 1;
 		}
 		spin_lock(&mm->page_table_lock);
-		if (vma->rb_subtree_gap != vma_compute_subtree_gap(vma)) {
+        if (vma->rb_subtree_gap != vma_compute_subtree_gap(vma))
+        {
 			pr_emerg("free gap %lx, correct %lx\n",
 			       vma->rb_subtree_gap,
 			       vma_compute_subtree_gap(vma));
@@ -367,7 +385,8 @@
 	j = 0;
 	for (nd = pn; nd; nd = rb_prev(nd))
 		j++;
-	if (i != j) {
+    if (i != j)
+    {
 		pr_emerg("backwards %d, forwards %d\n", j, i);
 		bug = 1;
 	}
@@ -378,7 +397,8 @@
 {
 	struct rb_node *nd;
 
-	for (nd = rb_first(root); nd; nd = rb_next(nd)) {
+    for (nd = rb_first(root); nd; nd = rb_next(nd))
+    {
 		struct vm_area_struct *vma;
 		vma = rb_entry(nd, struct vm_area_struct, vm_rb);
 		VM_BUG_ON_VMA(vma != ignore &&
@@ -394,11 +414,13 @@
 	unsigned long highest_address = 0;
 	struct vm_area_struct *vma = mm->mmap;
 
-	while (vma) {
+    while (vma)
+    {
 		struct anon_vma *anon_vma = vma->anon_vma;
 		struct anon_vma_chain *avc;
 
-		if (anon_vma) {
+        if (anon_vma)
+        {
 			anon_vma_lock_read(anon_vma);
 			list_for_each_entry(avc, &vma->anon_vma_chain, same_vma)
 				anon_vma_interval_tree_verify(avc);
@@ -409,17 +431,20 @@
 		vma = vma->vm_next;
 		i++;
 	}
-	if (i != mm->map_count) {
+    if (i != mm->map_count)
+    {
 		pr_emerg("map_count %d vm_next %d\n", mm->map_count, i);
 		bug = 1;
 	}
-	if (highest_address != mm->highest_vm_end) {
+    if (highest_address != mm->highest_vm_end)
+    {
 		pr_emerg("mm->highest_vm_end %lx, found %lx\n",
 			  mm->highest_vm_end, highest_address);
 		bug = 1;
 	}
 	i = browse_rb(mm);
-	if (i != mm->map_count) {
+    if (i != mm->map_count)
+    {
 		if (i != -1)
 			pr_emerg("map_count %d rb %d\n", mm->map_count, i);
 		bug = 1;
@@ -427,8 +452,14 @@
 	VM_BUG_ON_MM(bug, mm);
 }
 #else
-#define validate_mm_rb(root, ignore) do { } while (0)
-#define validate_mm(mm) do { } while (0)
+#define validate_mm_rb(root, ignore) \
+    do                               \
+    {                                \
+    } while (0)
+#define validate_mm(mm) \
+    do                  \
+    {                   \
+    } while (0)
 #endif
 
 RB_DECLARE_CALLBACKS_MAX(static, vma_gap_callbacks,
@@ -533,18 +564,22 @@
 	__rb_link = &mm->mm_rb.rb_node;
 	rb_prev = __rb_parent = NULL;
 
-	while (*__rb_link) {
+    while (*__rb_link)
+    {
 		struct vm_area_struct *vma_tmp;
 
 		__rb_parent = *__rb_link;
 		vma_tmp = rb_entry(__rb_parent, struct vm_area_struct, vm_rb);
 
-		if (vma_tmp->vm_end > addr) {
+        if (vma_tmp->vm_end > addr)
+        {
 			/* Fail if an existing vma overlaps the area */
 			if (vma_tmp->vm_start < end)
 				return -ENOMEM;
 			__rb_link = &__rb_parent->rb_left;
-		} else {
+        }
+        else
+        {
 			rb_prev = __rb_parent;
 			__rb_link = &__rb_parent->rb_right;
 		}
@@ -614,10 +649,12 @@
 		return 0;
 
 	nr_pages = (min(end, vma->vm_end) -
-		max(addr, vma->vm_start)) >> PAGE_SHIFT;
+                max(addr, vma->vm_start)) >>
+               PAGE_SHIFT;
 
 	/* Iterate over the rest of the overlaps */
-	for (vma = vma->vm_next; vma; vma = vma->vm_next) {
+    for (vma = vma->vm_next; vma; vma = vma->vm_next)
+    {
 		unsigned long overlap_len;
 
 		if (vma->vm_start > end)
@@ -659,7 +696,8 @@
 	struct file *file;
 
 	file = vma->vm_file;
-	if (file) {
+    if (file)
+    {
 		struct address_space *mapping = file->f_mapping;
 
 		if (vma->vm_flags & VM_DENYWRITE)
@@ -688,7 +726,8 @@
 {
 	struct address_space *mapping = NULL;
 
-	if (vma->vm_file) {
+    if (vma->vm_file)
+    {
 		mapping = vma->vm_file->f_mapping;
 		i_mmap_lock_write(mapping);
 	}
@@ -750,17 +789,20 @@
 	long adjust_next = 0;
 	int remove_next = 0;
 
-	if (next && !insert) {
+    if (next && !insert)
+    {
 		struct vm_area_struct *exporter = NULL, *importer = NULL;
 
-		if (end >= next->vm_end) {
+        if (end >= next->vm_end)
+        {
 			/*
 			 * vma expands, overlapping all the next, and
 			 * perhaps the one after too (mprotect case 6).
 			 * The only other cases that gets here are
 			 * case 1, case 7 and case 8.
 			 */
-			if (next == expand) {
+            if (next == expand)
+            {
 				/*
 				 * The only case where we don't expand "vma"
 				 * and we expand "next" instead is case 8.
@@ -774,7 +816,9 @@
 				remove_next = 3;
 				VM_WARN_ON(file != next->vm_file);
 				swap(vma, next);
-			} else {
+            }
+            else
+            {
 				VM_WARN_ON(expand != vma);
 				/*
 				 * case 1, 6, 7, remove_next == 2 is case 6,
@@ -796,8 +840,9 @@
 			 */
 			if (remove_next == 2 && !next->anon_vma)
 				exporter = next->vm_next;
-
-		} else if (end > next->vm_start) {
+        }
+        else if (end > next->vm_start)
+        {
 			/*
 			 * vma expands, overlapping part of the next:
 			 * mprotect case 5 shifting the boundary up.
@@ -806,7 +851,9 @@
 			exporter = next;
 			importer = vma;
 			VM_WARN_ON(expand != importer);
-		} else if (end < vma->vm_end) {
+        }
+        else if (end < vma->vm_end)
+        {
 			/*
 			 * vma shrinks, and !insert tells it's not
 			 * split_vma inserting another: so it must be
@@ -823,7 +870,8 @@
 		 * make sure the expanding vma has anon_vma set if the
 		 * shrinking vma had, to cover any anon pages imported.
 		 */
-		if (exporter && exporter->anon_vma && !importer->anon_vma) {
+        if (exporter && exporter->anon_vma && !importer->anon_vma)
+        {
 			int error;
 
 			importer->anon_vma = exporter->anon_vma;
@@ -835,7 +883,8 @@
 again:
 	vma_adjust_trans_huge(orig_vma, start, end, adjust_next);
 
-	if (file) {
+    if (file)
+    {
 		mapping = file->f_mapping;
 		root = &mapping->i_mmap;
 		uprobe_munmap(vma, vma->vm_start, vma->vm_end);
@@ -844,7 +893,8 @@
 			uprobe_munmap(next, next->vm_start, next->vm_end);
 
 		i_mmap_lock_write(mapping);
-		if (insert) {
+        if (insert)
+        {
 			/*
 			 * Put into interval tree now, so instantiated pages
 			 * are visible to arm/parisc __flush_dcache_page
@@ -858,7 +908,8 @@
 	anon_vma = vma->anon_vma;
 	if (!anon_vma && adjust_next)
 		anon_vma = next->anon_vma;
-	if (anon_vma) {
+    if (anon_vma)
+    {
 		VM_WARN_ON(adjust_next && next->anon_vma &&
 			   anon_vma != next->anon_vma);
 		anon_vma_lock_write(anon_vma);
@@ -867,35 +918,41 @@
 			anon_vma_interval_tree_pre_update_vma(next);
 	}
 
-	if (file) {
+    if (file)
+    {
 		flush_dcache_mmap_lock(mapping);
 		vma_interval_tree_remove(vma, root);
 		if (adjust_next)
 			vma_interval_tree_remove(next, root);
 	}
 
-	if (start != vma->vm_start) {
+    if (start != vma->vm_start)
+    {
 		vma->vm_start = start;
 		start_changed = true;
 	}
-	if (end != vma->vm_end) {
+    if (end != vma->vm_end)
+    {
 		vma->vm_end = end;
 		end_changed = true;
 	}
 	vma->vm_pgoff = pgoff;
-	if (adjust_next) {
+    if (adjust_next)
+    {
 		next->vm_start += adjust_next;
 		next->vm_pgoff += adjust_next >> PAGE_SHIFT;
 	}
 
-	if (file) {
+    if (file)
+    {
 		if (adjust_next)
 			vma_interval_tree_insert(next, root);
 		vma_interval_tree_insert(vma, root);
 		flush_dcache_mmap_unlock(mapping);
 	}
 
-	if (remove_next) {
+    if (remove_next)
+    {
 		/*
 		 * vma_merge has merged next into vma, and needs
 		 * us to remove next before dropping the locks.
@@ -915,17 +972,22 @@
 			__vma_unlink(mm, next, vma);
 		if (file)
 			__remove_shared_vm_struct(next, file, mapping);
-	} else if (insert) {
+    }
+    else if (insert)
+    {
 		/*
 		 * split_vma has split insert from vma, and needs
 		 * us to insert it before dropping the locks
 		 * (it may either follow vma or precede it).
 		 */
 		__insert_vm_struct(mm, insert);
-	} else {
+    }
+    else
+    {
 		if (start_changed)
 			vma_gap_update(vma);
-		if (end_changed) {
+        if (end_changed)
+        {
 			if (!next)
 				mm->highest_vm_end = vm_end_gap(vma);
 			else if (!adjust_next)
@@ -933,14 +995,16 @@
 		}
 	}
 
-	if (anon_vma) {
+    if (anon_vma)
+    {
 		anon_vma_interval_tree_post_update_vma(vma);
 		if (adjust_next)
 			anon_vma_interval_tree_post_update_vma(next);
 		anon_vma_unlock_write(anon_vma);
 	}
 
-	if (file) {
+    if (file)
+    {
 		i_mmap_unlock_write(mapping);
 		uprobe_mmap(vma);
 
@@ -948,8 +1012,10 @@
 			uprobe_mmap(next);
 	}
 
-	if (remove_next) {
-		if (file) {
+    if (remove_next)
+    {
+        if (file)
+        {
 			uprobe_munmap(next, next->vm_start, next->vm_end);
 			fput(file);
 		}
@@ -963,7 +1029,8 @@
 		 * we must remove another next too. It would clutter
 		 * up the code too much to do both in one go.
 		 */
-		if (remove_next != 3) {
+        if (remove_next != 3)
+        {
 			/*
 			 * If "next" was removed and vma->vm_end was
 			 * expanded (up) over it, in turn
@@ -971,7 +1038,9 @@
 			 * "vma->vm_next" gap must be updated.
 			 */
 			next = vma->vm_next;
-		} else {
+        }
+        else
+        {
 			/*
 			 * For the scope of the comment "next" and
 			 * "vma" considered pre-swap(): if "vma" was
@@ -984,14 +1053,16 @@
 			 */
 			next = vma;
 		}
-		if (remove_next == 2) {
+        if (remove_next == 2)
+        {
 			remove_next = 1;
 			end = next->vm_end;
 			goto again;
 		}
 		else if (next)
 			vma_gap_update(next);
-		else {
+        else
+        {
 			/*
 			 * If remove_next == 2 we obviously can't
 			 * reach this path.
@@ -1081,7 +1152,8 @@
 		     struct vm_userfaultfd_ctx vm_userfaultfd_ctx)
 {
 	if (is_mergeable_vma(vma, file, vm_flags, vm_userfaultfd_ctx) &&
-	    is_mergeable_anon_vma(anon_vma, vma->anon_vma, vma)) {
+        is_mergeable_anon_vma(anon_vma, vma->anon_vma, vma))
+    {
 		if (vma->vm_pgoff == vm_pgoff)
 			return 1;
 	}
@@ -1102,7 +1174,8 @@
 		    struct vm_userfaultfd_ctx vm_userfaultfd_ctx)
 {
 	if (is_mergeable_vma(vma, file, vm_flags, vm_userfaultfd_ctx) &&
-	    is_mergeable_anon_vma(anon_vma, vma->anon_vma, vma)) {
+        is_mergeable_anon_vma(anon_vma, vma->anon_vma, vma))
+    {
 		pgoff_t vm_pglen;
 		vm_pglen = vma_pages(vma);
 		if (vma->vm_pgoff + vm_pglen == vm_pgoff)
@@ -1189,7 +1262,8 @@
 			mpol_equal(vma_policy(prev), policy) &&
 			can_vma_merge_after(prev, vm_flags,
 					    anon_vma, file, pgoff,
-					    vm_userfaultfd_ctx)) {
+                            vm_userfaultfd_ctx))
+    {
 		/*
 		 * OK, it can.  Can we now merge in the successor as well?
 		 */
@@ -1200,12 +1274,14 @@
 						     pgoff+pglen,
 						     vm_userfaultfd_ctx) &&
 				is_mergeable_anon_vma(prev->anon_vma,
-						      next->anon_vma, NULL)) {
+                                  next->anon_vma, NULL))
+        {
 							/* cases 1, 6 */
 			err = __vma_adjust(prev, prev->vm_start,
 					 next->vm_end, prev->vm_pgoff, NULL,
 					 prev);
-		} else					/* cases 2, 5, 7 */
+        }
+        else /* cases 2, 5, 7 */
 			err = __vma_adjust(prev, prev->vm_start,
 					 end, prev->vm_pgoff, NULL, prev);
 		if (err)
@@ -1221,11 +1297,13 @@
 			mpol_equal(policy, vma_policy(next)) &&
 			can_vma_merge_before(next, vm_flags,
 					     anon_vma, file, pgoff+pglen,
-					     vm_userfaultfd_ctx)) {
+                             vm_userfaultfd_ctx))
+    {
 		if (prev && addr < prev->vm_end)	/* case 4 */
 			err = __vma_adjust(prev, prev->vm_start,
 					 addr, prev->vm_pgoff, NULL, next);
-		else {					/* cases 3, 8 */
+        else
+        { /* cases 3, 8 */
 			err = __vma_adjust(area, addr, next->vm_end,
 					 next->vm_pgoff - pglen, NULL, next);
 			/*
@@ -1290,7 +1368,8 @@
  */
 static struct anon_vma *reusable_anon_vma(struct vm_area_struct *old, struct vm_area_struct *a, struct vm_area_struct *b)
 {
-	if (anon_vma_compatible(a, b)) {
+    if (anon_vma_compatible(a, b))
+    {
 		struct anon_vma *anon_vma = READ_ONCE(old->anon_vma);
 
 		if (anon_vma && list_is_singular(&old->anon_vma_chain))
@@ -1312,7 +1391,8 @@
 	struct anon_vma *anon_vma = NULL;
 
 	/* Try next first. */
-	if (vma->vm_next) {
+    if (vma->vm_next)
+    {
 		anon_vma = reusable_anon_vma(vma->vm_next, vma, vma->vm_next);
 		if (anon_vma)
 			return anon_vma;
@@ -1355,7 +1435,8 @@
 	unsigned long locked, lock_limit;
 
 	/*  mlock MCL_FUTURE? */
-	if (flags & VM_LOCKED) {
+    if (flags & VM_LOCKED)
+    {
 		locked = len >> PAGE_SHIFT;
 		locked += mm->locked_vm;
 		lock_limit = rlimit(RLIMIT_MEMLOCK);
@@ -1452,14 +1533,16 @@
 	if (IS_ERR_VALUE(addr))
 		return addr;
 
-	if (flags & MAP_FIXED_NOREPLACE) {
+    if (flags & MAP_FIXED_NOREPLACE)
+    {
 		struct vm_area_struct *vma = find_vma(mm, addr);
 
 		if (vma && vma->vm_start < addr + len)
 			return -EEXIST;
 	}
 
-	if (prot == PROT_EXEC) {
+    if (prot == PROT_EXEC)
+    {
 		pkey = execute_only_pkey(mm);
 		if (pkey < 0)
 			pkey = 0;
@@ -1479,7 +1562,8 @@
 	if (mlock_future_check(mm, vm_flags, len))
 		return -EAGAIN;
 
-	if (file) {
+    if (file)
+    {
 		struct inode *inode = file_inode(file);
 		unsigned long flags_mask;
 
@@ -1488,7 +1572,8 @@
 
 		flags_mask = LEGACY_MAP_MASK | file->f_op->mmap_supported_flags;
 
-		switch (flags & MAP_TYPE) {
+        switch (flags & MAP_TYPE)
+        {
 		case MAP_SHARED:
 			/*
 			 * Force use of MAP_SHARED_VALIDATE with non-legacy
@@ -1502,7 +1587,8 @@
 		case MAP_SHARED_VALIDATE:
 			if (flags & ~flags_mask)
 				return -EOPNOTSUPP;
-			if (prot & PROT_WRITE) {
+            if (prot & PROT_WRITE)
+            {
 				if (!(file->f_mode & FMODE_WRITE))
 					return -EACCES;
 				if (IS_SWAPFILE(file->f_mapping->host))
@@ -1529,7 +1615,8 @@
 		case MAP_PRIVATE:
 			if (!(file->f_mode & FMODE_READ))
 				return -EACCES;
-			if (path_noexec(&file->f_path)) {
+            if (path_noexec(&file->f_path))
+            {
 				if (vm_flags & VM_EXEC)
 					return -EPERM;
 				vm_flags &= ~VM_MAYEXEC;
@@ -1544,8 +1631,11 @@
 		default:
 			return -EINVAL;
 		}
-	} else {
-		switch (flags & MAP_TYPE) {
+    }
+    else
+    {
+        switch (flags & MAP_TYPE)
+        {
 		case MAP_SHARED:
 			if (vm_flags & (VM_GROWSDOWN|VM_GROWSUP))
 				return -EINVAL;
@@ -1570,7 +1660,8 @@
 	 * Set 'VM_NORESERVE' if we should not account for the
 	 * memory use of this mapping.
 	 */
-	if (flags & MAP_NORESERVE) {
+    if (flags & MAP_NORESERVE)
+    {
 		/* We honor MAP_NORESERVE if allowed to overcommit */
 		if (sysctl_overcommit_memory != OVERCOMMIT_NEVER)
 			vm_flags |= VM_NORESERVE;
@@ -1595,18 +1686,24 @@
 	struct file *file = NULL;
 	unsigned long retval;
 
-	if (!(flags & MAP_ANONYMOUS)) {
+    if (!(flags & MAP_ANONYMOUS))
+    {
 		audit_mmap_fd(fd, flags);
 		file = fget(fd);
 		if (!file)
 			return -EBADF;
-		if (is_file_hugepages(file)) {
+        if (is_file_hugepages(file))
+        {
 			len = ALIGN(len, huge_page_size(hstate_file(file)));
-		} else if (unlikely(flags & MAP_HUGETLB)) {
+        }
+        else if (unlikely(flags & MAP_HUGETLB))
+        {
 			retval = -EINVAL;
 			goto out_fput;
 		}
-	} else if (flags & MAP_HUGETLB) {
+    }
+    else if (flags & MAP_HUGETLB)
+    {
 		struct user_struct *user = NULL;
 		struct hstate *hs;
 
@@ -1646,7 +1743,8 @@
 }
 
 #ifdef __ARCH_WANT_SYS_OLD_MMAP
-struct mmap_arg_struct {
+struct mmap_arg_struct
+{
 	unsigned long addr;
 	unsigned long len;
 	unsigned long prot;
@@ -1734,7 +1832,8 @@
 	unsigned long charged = 0;
 
 	/* Check against address space limit. */
-	if (!may_expand_vm(mm, vm_flags, len >> PAGE_SHIFT)) {
+    if (!may_expand_vm(mm, vm_flags, len >> PAGE_SHIFT))
+    {
 		unsigned long nr_pages;
 
 		/*
@@ -1754,7 +1853,8 @@
 	/*
 	 * Private writable mapping: check memory availability
 	 */
-	if (accountable_mapping(file, vm_flags)) {
+    if (accountable_mapping(file, vm_flags))
+    {
 		charged = len >> PAGE_SHIFT;
 		if (security_vm_enough_memory_mm(mm, charged))
 			return -ENOMEM;
@@ -1775,7 +1875,8 @@
 	 * not unmapped, but the maps are removed from the list.
 	 */
 	vma = vm_area_alloc(mm);
-	if (!vma) {
+    if (!vma)
+    {
 		error = -ENOMEM;
 		goto unacct_error;
 	}
@@ -1786,13 +1887,16 @@
 	vma->vm_page_prot = vm_get_page_prot(vm_flags);
 	vma->vm_pgoff = pgoff;
 
-	if (file) {
-		if (vm_flags & VM_DENYWRITE) {
+    if (file)
+    {
+        if (vm_flags & VM_DENYWRITE)
+        {
 			error = deny_write_access(file);
 			if (error)
 				goto free_vma;
 		}
-		if (vm_flags & VM_SHARED) {
+        if (vm_flags & VM_SHARED)
+        {
 			error = mapping_map_writable(file->f_mapping);
 			if (error)
 				goto allow_write_and_free_vma;
@@ -1822,10 +1926,12 @@
 		/* If vm_flags changed after call_mmap(), we should try merge vma again
 		 * as we may succeed this time.
 		 */
-		if (unlikely(vm_flags != vma->vm_flags && prev)) {
+        if (unlikely(vm_flags != vma->vm_flags && prev))
+        {
 			merge = vma_merge(mm, prev, vma->vm_start, vma->vm_end, vma->vm_flags,
 				NULL, vma->vm_file, vma->vm_pgoff, NULL, NULL_VM_UFFD_CTX);
-			if (merge) {
+            if (merge)
+            {
 				/* ->mmap() can change vma->vm_file and fput the original file. So
 				 * fput the vma->vm_file here or we would add an extra fput for file
 				 * and cause general protection fault ultimately.
@@ -1840,16 +1946,21 @@
 		}
 
 		vm_flags = vma->vm_flags;
-	} else if (vm_flags & VM_SHARED) {
+    }
+    else if (vm_flags & VM_SHARED)
+    {
 		error = shmem_zero_setup(vma);
 		if (error)
 			goto free_vma;
-	} else {
+    }
+    else
+    {
 		vma_set_anonymous(vma);
 	}
 
 	/* Allow architectures to sanity-check the vm_flags */
-	if (!arch_validate_flags(vma->vm_flags)) {
+    if (!arch_validate_flags(vma->vm_flags))
+    {
 		error = -EINVAL;
 		if (file)
 			goto unmap_and_free_vma;
@@ -1859,7 +1970,8 @@
 
 	vma_link(mm, vma, prev, rb_link, rb_parent);
 	/* Once vma denies write, undo our temporary denial count */
-	if (file) {
+    if (file)
+    {
 unmap_writable:
 		if (vm_flags & VM_SHARED)
 			mapping_unmap_writable(file->f_mapping);
@@ -1871,7 +1983,8 @@
 	perf_event_mmap(vma);
 
 	vm_stat_account(mm, vm_flags, len >> PAGE_SHIFT);
-	if (vm_flags & VM_LOCKED) {
+    if (vm_flags & VM_LOCKED)
+    {
 		if ((vm_flags & VM_SPECIAL) || vma_is_dax(vma) ||
 					is_vm_hugetlb_page(vma) ||
 					vma == get_gate_vma(current->mm))
@@ -1951,14 +2064,17 @@
 	if (vma->rb_subtree_gap < length)
 		goto check_highest;
 
-	while (true) {
+    while (true)
+    {
 		/* Visit left subtree if it looks promising */
 		gap_end = vm_start_gap(vma);
-		if (gap_end >= low_limit && vma->vm_rb.rb_left) {
+        if (gap_end >= low_limit && vma->vm_rb.rb_left)
+        {
 			struct vm_area_struct *left =
 				rb_entry(vma->vm_rb.rb_left,
 					 struct vm_area_struct, vm_rb);
-			if (left->rb_subtree_gap >= length) {
+            if (left->rb_subtree_gap >= length)
+            {
 				vma = left;
 				continue;
 			}
@@ -1974,24 +2090,28 @@
 			goto found;
 
 		/* Visit right subtree if it looks promising */
-		if (vma->vm_rb.rb_right) {
+        if (vma->vm_rb.rb_right)
+        {
 			struct vm_area_struct *right =
 				rb_entry(vma->vm_rb.rb_right,
 					 struct vm_area_struct, vm_rb);
-			if (right->rb_subtree_gap >= length) {
+            if (right->rb_subtree_gap >= length)
+            {
 				vma = right;
 				continue;
 			}
 		}
 
 		/* Go back up the rbtree to find next candidate node */
-		while (true) {
+        while (true)
+        {
 			struct rb_node *prev = &vma->vm_rb;
 			if (!rb_parent(prev))
 				goto check_highest;
 			vma = rb_entry(rb_parent(prev),
 				       struct vm_area_struct, vm_rb);
-			if (prev == vma->vm_rb.rb_left) {
+            if (prev == vma->vm_rb.rb_left)
+            {
 				gap_start = vm_end_gap(vma->vm_prev);
 				gap_end = vm_start_gap(vma);
 				goto check_current;
@@ -2055,14 +2175,17 @@
 	if (vma->rb_subtree_gap < length)
 		return -ENOMEM;
 
-	while (true) {
+    while (true)
+    {
 		/* Visit right subtree if it looks promising */
 		gap_start = vma->vm_prev ? vm_end_gap(vma->vm_prev) : 0;
-		if (gap_start <= high_limit && vma->vm_rb.rb_right) {
+        if (gap_start <= high_limit && vma->vm_rb.rb_right)
+        {
 			struct vm_area_struct *right =
 				rb_entry(vma->vm_rb.rb_right,
 					 struct vm_area_struct, vm_rb);
-			if (right->rb_subtree_gap >= length) {
+            if (right->rb_subtree_gap >= length)
+            {
 				vma = right;
 				continue;
 			}
@@ -2078,26 +2201,29 @@
 			goto found;
 
 		/* Visit left subtree if it looks promising */
-		if (vma->vm_rb.rb_left) {
+        if (vma->vm_rb.rb_left)
+        {
 			struct vm_area_struct *left =
 				rb_entry(vma->vm_rb.rb_left,
 					 struct vm_area_struct, vm_rb);
-			if (left->rb_subtree_gap >= length) {
+            if (left->rb_subtree_gap >= length)
+            {
 				vma = left;
 				continue;
 			}
 		}
 
 		/* Go back up the rbtree to find next candidate node */
-		while (true) {
+        while (true)
+        {
 			struct rb_node *prev = &vma->vm_rb;
 			if (!rb_parent(prev))
 				return -ENOMEM;
 			vma = rb_entry(rb_parent(prev),
 				       struct vm_area_struct, vm_rb);
-			if (prev == vma->vm_rb.rb_right) {
-				gap_start = vma->vm_prev ?
-					vm_end_gap(vma->vm_prev) : 0;
+            if (prev == vma->vm_rb.rb_right)
+            {
+                gap_start = vma->vm_prev ? vm_end_gap(vma->vm_prev) : 0;
 				goto check_current;
 			}
 		}
@@ -2175,7 +2301,8 @@
 	if (flags & MAP_FIXED)
 		return addr;
 
-	if (addr) {
+    if (addr)
+    {
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma_prev(mm, addr, &prev);
 		if (mmap_end - len >= addr && addr >= mmap_min_addr &&
@@ -2217,7 +2344,8 @@
 		return addr;
 
 	/* requesting a specific address */
-	if (addr) {
+    if (addr)
+    {
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma_prev(mm, addr, &prev);
 		if (mmap_end - len >= addr && addr >= mmap_min_addr &&
@@ -2240,7 +2368,8 @@
 	 * can happen with large stack limits and large mmap()
 	 * allocations.
 	 */
-	if (offset_in_page(addr)) {
+    if (offset_in_page(addr))
+    {
 		VM_BUG_ON(addr != -ENOMEM);
 		info.flags = 0;
 		info.low_limit = TASK_UNMAPPED_BASE;
@@ -2268,10 +2397,13 @@
 		return -ENOMEM;
 
 	get_area = current->mm->get_unmapped_area;
-	if (file) {
+    if (file)
+    {
 		if (file->f_op->get_unmapped_area)
 			get_area = file->f_op->get_unmapped_area;
-	} else if (flags & MAP_SHARED) {
+    }
+    else if (flags & MAP_SHARED)
+    {
 		/*
 		 * mmap_region() will call shmem_zero_setup() to create a file,
 		 * so use shmem's get_unmapped_area in case it can be huge.
@@ -2309,17 +2441,20 @@
 
 	rb_node = mm->mm_rb.rb_node;
 
-	while (rb_node) {
+    while (rb_node)
+    {
 		struct vm_area_struct *tmp;
 
 		tmp = rb_entry(rb_node, struct vm_area_struct, vm_rb);
 
-		if (tmp->vm_end > addr) {
+        if (tmp->vm_end > addr)
+        {
 			vma = tmp;
 			if (tmp->vm_start <= addr)
 				break;
 			rb_node = rb_node->rb_left;
-		} else
+        }
+        else
 			rb_node = rb_node->rb_right;
 	}
 
@@ -2340,9 +2475,12 @@
 	struct vm_area_struct *vma;
 
 	vma = find_vma(mm, addr);
-	if (vma) {
+    if (vma)
+    {
 		*pprev = vma->vm_prev;
-	} else {
+    }
+    else
+    {
 		struct rb_node *rb_node = rb_last(&mm->mm_rb);
 
 		*pprev = rb_node ? rb_entry(rb_node, struct vm_area_struct, vm_rb) : NULL;
@@ -2370,7 +2508,8 @@
 		return -ENOMEM;
 
 	/* mlock limit tests */
-	if (vma->vm_flags & VM_LOCKED) {
+    if (vma->vm_flags & VM_LOCKED)
+    {
 		unsigned long locked;
 		unsigned long limit;
 		locked = mm->locked_vm + grow;
@@ -2381,8 +2520,7 @@
 	}
 
 	/* Check to ensure the stack will not grow into a hugetlb-only region */
-	new_start = (vma->vm_flags & VM_GROWSUP) ? vma->vm_start :
-			vma->vm_end - size;
+    new_start = (vma->vm_flags & VM_GROWSUP) ? vma->vm_start : vma->vm_end - size;
 	if (is_hugepage_only_range(vma->vm_mm, new_start, size))
 		return -EFAULT;
 
@@ -2425,7 +2563,8 @@
 		gap_addr = TASK_SIZE;
 
 	next = vma->vm_next;
-	if (next && next->vm_start < gap_addr && vma_is_accessible(next)) {
+    if (next && next->vm_start < gap_addr && vma_is_accessible(next))
+    {
 		if (!(next->vm_flags & VM_GROWSUP))
 			return -ENOMEM;
 		/* Check that both stack segments have the same anon_vma? */
@@ -2443,16 +2582,19 @@
 	anon_vma_lock_write(vma->anon_vma);
 
 	/* Somebody else might have raced and expanded it already */
-	if (address > vma->vm_end) {
+    if (address > vma->vm_end)
+    {
 		unsigned long size, grow;
 
 		size = address - vma->vm_start;
 		grow = (address - vma->vm_end) >> PAGE_SHIFT;
 
 		error = -ENOMEM;
-		if (vma->vm_pgoff + (size >> PAGE_SHIFT) >= vma->vm_pgoff) {
+        if (vma->vm_pgoff + (size >> PAGE_SHIFT) >= vma->vm_pgoff)
+        {
 			error = acct_stack_growth(vma, size, grow);
-			if (!error) {
+            if (!error)
+            {
 				/*
 				 * vma_gap_update() doesn't support concurrent
 				 * updates, but we only hold a shared mmap_lock
@@ -2506,7 +2648,8 @@
 	prev = vma->vm_prev;
 	/* Check that both stack segments have the same anon_vma? */
 	if (prev && !(prev->vm_flags & VM_GROWSDOWN) &&
-			vma_is_accessible(prev)) {
+        vma_is_accessible(prev))
+    {
 		if (address - prev->vm_end < stack_guard_gap)
 			return -ENOMEM;
 	}
@@ -2523,16 +2666,19 @@
 	anon_vma_lock_write(vma->anon_vma);
 
 	/* Somebody else might have raced and expanded it already */
-	if (address < vma->vm_start) {
+    if (address < vma->vm_start)
+    {
 		unsigned long size, grow;
 
 		size = vma->vm_end - address;
 		grow = (vma->vm_start - address) >> PAGE_SHIFT;
 
 		error = -ENOMEM;
-		if (grow <= vma->vm_pgoff) {
+        if (grow <= vma->vm_pgoff)
+        {
 			error = acct_stack_growth(vma, size, grow);
-			if (!error) {
+            if (!error)
+            {
 				/*
 				 * vma_gap_update() doesn't support concurrent
 				 * updates, but we only hold a shared mmap_lock
@@ -2646,7 +2792,8 @@
 
 	/* Update high watermark before we lower total_vm */
 	update_hiwater_vm(mm);
-	do {
+    do
+    {
 		long nrpages = vma_pages(vma);
 
 		if (vma->vm_flags & VM_ACCOUNT)
@@ -2692,17 +2839,20 @@
 
 	insertion_point = (prev ? &prev->vm_next : &mm->mmap);
 	vma->vm_prev = NULL;
-	do {
+    do
+    {
 		vma_rb_erase(vma, &mm->mm_rb);
 		mm->map_count--;
 		tail_vma = vma;
 		vma = vma->vm_next;
 	} while (vma && vma->vm_start < end);
 	*insertion_point = vma;
-	if (vma) {
+    if (vma)
+    {
 		vma->vm_prev = prev;
 		vma_gap_update(vma);
-	} else
+    }
+    else
 		mm->highest_vm_end = prev ? vm_end_gap(prev) : 0;
 	tail_vma->vm_next = NULL;
 
@@ -2731,7 +2881,8 @@
 	struct vm_area_struct *new;
 	int err;
 
-	if (vma->vm_ops && vma->vm_ops->split) {
+    if (vma->vm_ops && vma->vm_ops->split)
+    {
 		err = vma->vm_ops->split(vma, addr);
 		if (err)
 			return err;
@@ -2743,7 +2894,8 @@
 
 	if (new_below)
 		new->vm_end = addr;
-	else {
+    else
+    {
 		new->vm_start = addr;
 		new->vm_pgoff += ((addr - vma->vm_start) >> PAGE_SHIFT);
 	}
@@ -2763,8 +2915,7 @@
 		new->vm_ops->open(new);
 
 	if (new_below)
-		err = vma_adjust(vma, addr, vma->vm_end, vma->vm_pgoff +
-			((addr - new->vm_start) >> PAGE_SHIFT), new);
+        err = vma_adjust(vma, addr, vma->vm_end, vma->vm_pgoff + ((addr - new->vm_start) >> PAGE_SHIFT), new);
 	else
 		err = vma_adjust(vma, vma->vm_start, addr, vma->vm_pgoff, new);
 
@@ -2842,7 +2993,8 @@
 	 * unmapped vm_area_struct will remain in use: so lower split_vma
 	 * places tmp vma above, and higher split_vma places tmp vma below.
 	 */
-	if (start > vma->vm_start) {
+    if (start > vma->vm_start)
+    {
 		int error;
 
 		/*
@@ -2861,14 +3013,16 @@
 
 	/* Does it split the last one? */
 	last = find_vma(mm, end);
-	if (last && end > last->vm_start) {
+    if (last && end > last->vm_start)
+    {
 		int error = __split_vma(mm, last, end, 1);
 		if (error)
 			return error;
 	}
 	vma = vma_next(mm, prev);
 
-	if (unlikely(uf)) {
+    if (unlikely(uf))
+    {
 		/*
 		 * If userfaultfd_unmap_prep returns an error the vmas
 		 * will remain splitted, but userland will get a
@@ -2886,10 +3040,13 @@
 	/*
 	 * unlock any mlock()ed ranges before detaching vmas
 	 */
-	if (mm->locked_vm) {
+    if (mm->locked_vm)
+    {
 		struct vm_area_struct *tmp = vma;
-		while (tmp && tmp->vm_start < end) {
-			if (tmp->vm_flags & VM_LOCKED) {
+        while (tmp && tmp->vm_start < end)
+        {
+            if (tmp->vm_flags & VM_LOCKED)
+            {
 				mm->locked_vm -= vma_pages(tmp);
 				munlock_vma_pages_all(tmp);
 			}
@@ -2934,10 +3091,12 @@
 	 * But 1 is not legal return value of vm_munmap() and munmap(), reset
 	 * it to 0 before return.
 	 */
-	if (ret == 1) {
+    if (ret == 1)
+    {
 		mmap_read_unlock(mm);
 		ret = 0;
-	} else
+    }
+    else
 		mmap_write_unlock(mm);
 
 	userfaultfd_unmap_complete(mm, &uf);
@@ -2997,10 +3155,12 @@
 	if (start < vma->vm_start)
 		goto out;
 
-	if (start + size > vma->vm_end) {
+    if (start + size > vma->vm_end)
+    {
 		struct vm_area_struct *next;
 
-		for (next = vma->vm_next; next; next = next->vm_next) {
+        for (next = vma->vm_next; next; next = next->vm_next)
+        {
 			/* hole between vmas ? */
 			if (next->vm_start != next->vm_prev->vm_end)
 				goto out;
@@ -3025,13 +3185,15 @@
 
 	flags &= MAP_NONBLOCK;
 	flags |= MAP_SHARED | MAP_FIXED | MAP_POPULATE;
-	if (vma->vm_flags & VM_LOCKED) {
+    if (vma->vm_flags & VM_LOCKED)
+    {
 		struct vm_area_struct *tmp;
 		flags |= MAP_LOCKED;
 
 		/* drop PG_Mlocked flag for over-mapped range */
 		for (tmp = vma; tmp->vm_start >= start + size;
-				tmp = tmp->vm_next) {
+             tmp = tmp->vm_next)
+        {
 			/*
 			 * Split pmd and munlock page on the border
 			 * of the range.
@@ -3108,7 +3270,8 @@
 	 * create a vma struct for an anonymous mapping
 	 */
 	vma = vm_area_alloc(mm);
-	if (!vma) {
+    if (!vma)
+    {
 		vm_unacct_memory(len >> PAGE_SHIFT);
 		return -ENOMEM;
 	}
@@ -3173,7 +3336,8 @@
 	/* mm's last user has gone, and its about to be pulled down */
 	mmu_notifier_release(mm);
 
-	if (unlikely(mm_is_oom_victim(mm))) {
+    if (unlikely(mm_is_oom_victim(mm)))
+    {
 		/*
 		 * Manually reap the mm to free as much memory as possible.
 		 * Then, as the oom reaper does, set MMF_OOM_SKIP to disregard
@@ -3197,9 +3361,11 @@
 		mmap_write_unlock(mm);
 	}
 
-	if (mm->locked_vm) {
+    if (mm->locked_vm)
+    {
 		vma = mm->mmap;
-		while (vma) {
+        while (vma)
+        {
 			if (vma->vm_flags & VM_LOCKED)
 				munlock_vma_pages_all(vma);
 			vma = vma->vm_next;
@@ -3225,7 +3391,8 @@
 	 * Walk the list again, actually closing and freeing it,
 	 * with preemption enabled, without holding any MM locks.
 	 */
-	while (vma) {
+    while (vma)
+    {
 		if (vma->vm_flags & VM_ACCOUNT)
 			nr_accounted += vma_pages(vma);
 		vma = remove_vma(vma);
@@ -3262,7 +3429,8 @@
 	 * using the existing file pgoff checks and manipulations.
 	 * Similarly in do_mmap and in do_brk_flags.
 	 */
-	if (vma_is_anonymous(vma)) {
+    if (vma_is_anonymous(vma))
+    {
 		BUG_ON(vma->anon_vma);
 		vma->vm_pgoff = vma->vm_start >> PAGE_SHIFT;
 	}
@@ -3290,7 +3458,8 @@
 	 * If anonymous vma has not yet been faulted, update new pgoff
 	 * to match new location, to increase its chance of merging.
 	 */
-	if (unlikely(vma_is_anonymous(vma) && !vma->anon_vma)) {
+    if (unlikely(vma_is_anonymous(vma) && !vma->anon_vma))
+    {
 		pgoff = addr >> PAGE_SHIFT;
 		faulted_in_anon_vma = false;
 	}
@@ -3300,12 +3469,14 @@
 	new_vma = vma_merge(mm, prev, addr, addr + len, vma->vm_flags,
 			    vma->anon_vma, vma->vm_file, pgoff, vma_policy(vma),
 			    vma->vm_userfaultfd_ctx);
-	if (new_vma) {
+    if (new_vma)
+    {
 		/*
 		 * Source vma may have been merged into new_vma
 		 */
 		if (unlikely(vma_start >= new_vma->vm_start &&
-			     vma_start < new_vma->vm_end)) {
+                     vma_start < new_vma->vm_end))
+        {
 			/*
 			 * The only way we can get a vma_merge with
 			 * self during an mremap is if the vma hasn't
@@ -3322,7 +3493,9 @@
 			*vmap = vma = new_vma;
 		}
 		*need_rmap_locks = (new_vma->vm_pgoff <= vma->vm_pgoff);
-	} else {
+    }
+    else
+    {
 		new_vma = vm_area_dup(vma);
 		if (!new_vma)
 			goto out;
@@ -3360,7 +3533,8 @@
 		return false;
 
 	if (is_data_mapping(flags) &&
-	    mm->data_vm + npages > rlimit(RLIMIT_DATA) >> PAGE_SHIFT) {
+        mm->data_vm + npages > rlimit(RLIMIT_DATA) >> PAGE_SHIFT)
+    {
 		/* Workaround for Valgrind */
 		if (rlimit(RLIMIT_DATA) == 0 &&
 		    mm->data_vm + npages <= rlimit_max(RLIMIT_DATA) >> PAGE_SHIFT)
@@ -3438,9 +3612,12 @@
 	pgoff_t pgoff;
 	struct page **pages;
 
-	if (vma->vm_ops == &legacy_special_mapping_vmops) {
+    if (vma->vm_ops == &legacy_special_mapping_vmops)
+    {
 		pages = vma->vm_private_data;
-	} else {
+    }
+    else
+    {
 		struct vm_special_mapping *sm = vma->vm_private_data;
 
 		if (sm->fault)
@@ -3452,7 +3629,8 @@
 	for (pgoff = vmf->pgoff; pgoff && *pages; ++pages)
 		pgoff--;
 
-	if (*pages) {
+    if (*pages)
+    {
 		struct page *page = *pages;
 		get_page(page);
 		vmf->page = page;
@@ -3540,7 +3718,8 @@
 
 static void vm_lock_anon_vma(struct mm_struct *mm, struct anon_vma *anon_vma)
 {
-	if (!test_bit(0, (unsigned long *) &anon_vma->root->rb_root.rb_root.rb_node)) {
+    if (!test_bit(0, (unsigned long *)&anon_vma->root->rb_root.rb_root.rb_node))
+    {
 		/*
 		 * The LSB of head.next can't change from under us
 		 * because we hold the mm_all_locks_mutex.
@@ -3555,15 +3734,15 @@
 		 * can't change from under us thanks to the
 		 * anon_vma->root->rwsem.
 		 */
-		if (__test_and_set_bit(0, (unsigned long *)
-				       &anon_vma->root->rb_root.rb_root.rb_node))
+        if (__test_and_set_bit(0, (unsigned long *)&anon_vma->root->rb_root.rb_root.rb_node))
 			BUG();
 	}
 }
 
 static void vm_lock_mapping(struct mm_struct *mm, struct address_space *mapping)
 {
-	if (!test_bit(AS_MM_ALL_LOCKS, &mapping->flags)) {
+    if (!test_bit(AS_MM_ALL_LOCKS, &mapping->flags))
+    {
 		/*
 		 * AS_MM_ALL_LOCKS can't change from under us because
 		 * we hold the mm_all_locks_mutex.
@@ -3625,7 +3804,8 @@
 
 	mutex_lock(&mm_all_locks_mutex);
 
-	for (vma = mm->mmap; vma; vma = vma->vm_next) {
+    for (vma = mm->mmap; vma; vma = vma->vm_next)
+    {
 		if (signal_pending(current))
 			goto out_unlock;
 		if (vma->vm_file && vma->vm_file->f_mapping &&
@@ -3633,7 +3813,8 @@
 			vm_lock_mapping(mm, vma->vm_file->f_mapping);
 	}
 
-	for (vma = mm->mmap; vma; vma = vma->vm_next) {
+    for (vma = mm->mmap; vma; vma = vma->vm_next)
+    {
 		if (signal_pending(current))
 			goto out_unlock;
 		if (vma->vm_file && vma->vm_file->f_mapping &&
@@ -3641,7 +3822,8 @@
 			vm_lock_mapping(mm, vma->vm_file->f_mapping);
 	}
 
-	for (vma = mm->mmap; vma; vma = vma->vm_next) {
+    for (vma = mm->mmap; vma; vma = vma->vm_next)
+    {
 		if (signal_pending(current))
 			goto out_unlock;
 		if (vma->anon_vma)
@@ -3658,7 +3840,8 @@
 
 static void vm_unlock_anon_vma(struct anon_vma *anon_vma)
 {
-	if (test_bit(0, (unsigned long *) &anon_vma->root->rb_root.rb_root.rb_node)) {
+    if (test_bit(0, (unsigned long *)&anon_vma->root->rb_root.rb_root.rb_node))
+    {
 		/*
 		 * The LSB of head.next can't change to 0 from under
 		 * us because we hold the mm_all_locks_mutex.
@@ -3671,8 +3854,7 @@
 		 * can't change from under us until we release the
 		 * anon_vma->root->rwsem.
 		 */
-		if (!__test_and_clear_bit(0, (unsigned long *)
-					  &anon_vma->root->rb_root.rb_root.rb_node))
+        if (!__test_and_clear_bit(0, (unsigned long *)&anon_vma->root->rb_root.rb_root.rb_node))
 			BUG();
 		anon_vma_unlock_write(anon_vma);
 	}
@@ -3680,7 +3862,8 @@
 
 static void vm_unlock_mapping(struct address_space *mapping)
 {
-	if (test_bit(AS_MM_ALL_LOCKS, &mapping->flags)) {
+    if (test_bit(AS_MM_ALL_LOCKS, &mapping->flags))
+    {
 		/*
 		 * AS_MM_ALL_LOCKS can't change to 0 from under us
 		 * because we hold the mm_all_locks_mutex.
@@ -3704,7 +3887,8 @@
 	BUG_ON(mmap_read_trylock(mm));
 	BUG_ON(!mutex_is_locked(&mm_all_locks_mutex));
 
-	for (vma = mm->mmap; vma; vma = vma->vm_next) {
+    for (vma = mm->mmap; vma; vma = vma->vm_next)
+    {
 		if (vma->anon_vma)
 			list_for_each_entry(avc, &vma->anon_vma_chain, same_vma)
 				vm_unlock_anon_vma(avc->anon_vma);
@@ -3791,7 +3975,8 @@
 {
 	unsigned long tmp, free_kbytes;
 
-	switch (action) {
+    switch (action)
+    {
 	case MEM_ONLINE:
 		/* Default max is 128MB. Leave alone if modified by operator. */
 		tmp = sysctl_user_reserve_kbytes;
@@ -3807,13 +3992,15 @@
 	case MEM_OFFLINE:
 		free_kbytes = global_zone_page_state(NR_FREE_PAGES) << (PAGE_SHIFT - 10);
 
-		if (sysctl_user_reserve_kbytes > free_kbytes) {
+        if (sysctl_user_reserve_kbytes > free_kbytes)
+        {
 			init_user_reserve();
 			pr_info("vm.user_reserve_kbytes reset to %lu\n",
 				sysctl_user_reserve_kbytes);
 		}
 
-		if (sysctl_admin_reserve_kbytes > free_kbytes) {
+        if (sysctl_admin_reserve_kbytes > free_kbytes)
+        {
 			init_admin_reserve();
 			pr_info("vm.admin_reserve_kbytes reset to %lu\n",
 				sysctl_admin_reserve_kbytes);
diff --color -ruN -w -B '--exclude-from=.diff-exclude' linux-5.10/mm/mmzone.c HawkEye-5.10-cow/mm/mmzone.c
--- linux-5.10/mm/mmzone.c	2020-12-13 22:41:30.000000000 +0000
+++ HawkEye-5.10-cow/mm/mmzone.c	2025-03-23 07:53:49.820390166 +0000
@@ -14,6 +13,7 @@
 {
 	return NODE_DATA(first_online_node);
 }
+EXPORT_SYMBOL(first_online_pgdat);
 
 struct pglist_data *next_online_pgdat(struct pglist_data *pgdat)
 {
@@ -23,7 +23,7 @@
 		return NULL;
 	return NODE_DATA(nid);
 }
-
+EXPORT_SYMBOL(next_online_pgdat);
 /*
  * next_zone - helper magic for for_each_zone()
  */
@@ -33,7 +33,8 @@
 
 	if (zone < pgdat->node_zones + MAX_NR_ZONES - 1)
 		zone++;
-	else {
+    else
+    {
 		pgdat = next_online_pgdat(pgdat);
 		if (pgdat)
 			zone = pgdat->node_zones;
@@ -42,6 +43,7 @@
 	}
 	return zone;
 }
+EXPORT_SYMBOL(next_zone);
 
 static inline int zref_in_nodemask(struct zoneref *zref, nodemask_t *nodes)
 {
@@ -102,7 +104,8 @@
 	unsigned long old_flags, flags;
 	int last_cpupid;
 
-	do {
+    do
+    {
 		old_flags = flags = page->flags;
 		last_cpupid = page_cpupid_last(page);
 
diff --color -ruN -w -B '--exclude-from=.diff-exclude' linux-5.10/mm/ohp.c HawkEye-5.10-cow/mm/ohp.c
--- linux-5.10/mm/ohp.c	1970-01-01 00:00:00.000000000 +0000
+++ HawkEye-5.10-cow/mm/ohp.c	2025-03-23 07:53:49.854298439 +0000
@@ -0,0 +1,949 @@
+/*
+ * Core Infrastrucure to support Opportunistic Huge Pages.
+ * Abbreaviated to ohp.
+ */
+
+#include <linux/mm_types.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/cred.h>
+#include <linux/sched.h>
+#include <linux/syscalls.h>
+#include <linux/spinlock.h>
+#include <linux/list.h>
+#include <linux/log2.h>
+#include <linux/freezer.h>
+#include <linux/kthread.h>
+#include <linux/khugepaged.h>
+#include <linux/ohp.h>
+#include <linux/sched/mm.h>
+#include <uapi/linux/time.h>
+#include <linux/time64.h>
+#include <linux/time.h>
+#include <linux/timekeeping.h>
+/* To protect ohp maintenance list */
+DEFINE_SPINLOCK(ohp_mm_lock);
+
+static struct task_struct *kbinmanager_thread __read_mostly;
+static DECLARE_WAIT_QUEUE_HEAD(kbinmanager_wait);
+
+/*
+ * This exists for testing purpose as of now.
+ * It tells how many huge pages are still to be promoted.
+ * We always update it with ohp_mm_lock held.
+ * Hence, no need for separate synchronization for this.
+ */
+unsigned long nr_ohp_bins = 0;
+
+/*
+ * List of mm structs to be processed for huge page promotion.
+ */
+struct ohp_scan {
+	struct list_head mm_head;
+};
+
+struct ohp_scan ohp_scan = {
+	.mm_head = LIST_HEAD_INIT(ohp_scan.mm_head),
+};
+
+//unsigned long get_time_difference(struct timeval *t0, struct timeval *t1)
+unsigned long get_time_difference(struct timespec64 *t0, struct timespec64 *t1)
+{
+	long msecs;
+
+	msecs = (t1->tv_sec - t0->tv_sec) * 1000 +
+			(t1->tv_nsec - t0->tv_nsec) / 1000000;
+	if (msecs < 0)
+		msecs = 0;
+
+	return (unsigned long) msecs;
+}
+
+bool ohp_has_work(void)
+{
+	/*
+	return !list_empty(&ohp_scan.mm_head);
+	*/
+	return !(!nr_ohp_bins);
+}
+
+#define OHP_TASK_ENTER	1000
+#define OHP_TASK_EXIT	1001
+
+static inline void ohp_add_mm(struct mm_struct *mm)
+{
+	struct mm_struct *mm_struct = NULL;
+
+	spin_lock(&ohp_mm_lock);
+
+	/* Check if mm is already present in the list. */
+	list_for_each_entry(mm_struct, &ohp_scan.mm_head, ohp_list)
+		if (mm_struct == mm)
+			goto out;
+
+	list_add_tail(&mm->ohp_list, &ohp_scan.mm_head);
+	atomic_inc(&mm->mm_count);
+out:
+	spin_unlock(&ohp_mm_lock);
+	return;
+}
+
+void ohp_exit_mm(struct mm_struct *mm_src)
+{
+	struct mm_struct *mm, *tmp;
+
+	spin_lock(&ohp_mm_lock);
+	list_for_each_entry_safe(mm, tmp, &ohp_scan.mm_head,
+					ohp_list) {
+		if (mm == mm_src) {
+			list_del(&mm->ohp_list);
+			mmdrop(mm);
+			break;
+		}
+	}
+	spin_unlock(&ohp_mm_lock);
+	return;
+}
+
+/*
+ * TODO: Verify if how we get reference to task mm in below functions
+ * is correct. Handle cases if mm runs away from under us.
+ */
+static inline int ohp_add_task(struct task_struct *task)
+{
+	struct mm_struct *mm;
+
+	mm = get_task_mm(task);
+	if (!mm)
+		return -EINVAL;
+
+	ohp_add_mm(mm);
+	/*
+	 * kbinmanager may not have been started yet.
+	 */
+	start_kbinmanager();
+	mmput(mm);
+	return 0;
+}
+
+static inline int ohp_exit_task(struct task_struct *task)
+{
+	struct mm_struct *mm;
+
+	mm = get_task_mm(task);
+
+	if (!mm)
+		return -EINVAL;
+
+	ohp_exit_mm(mm);
+	mmput(mm);
+	return 0;
+}
+
+/*
+ * Initialize ohp buckets for the specified process.
+ * This would hold all the huge page aligned addresses
+ * in different buckets based on the heatmap of accesses.
+ */
+void init_mm_ohp_bins(struct mm_struct *mm)
+{
+	int i;
+
+	/* We perhaps do not need locking here as the process
+	 * is just getting initialized.
+	 */
+    // printk("func: %s, MAX_BINS=%d\n",__func__, MAX_BINS);
+	for (i=0; i<MAX_BINS; i++) {
+		mutex_init(&mm->ohp.lock);
+		INIT_LIST_HEAD(&(mm->ohp.priority[i]));
+		mm->ohp.count[i] = 0;
+		mm->ohp.ohp_remaining = 0;
+		mm->ohp.nr_scans = 0;
+	}
+}
+
+/*
+ * We use this to decide if we should continue scanning the
+ * mm. The mm belong to the list as long as the process exists.
+ * This handles processes with dynamic memory requirements.
+ */
+unsigned long ohp_mm_pending_promotions(struct mm_struct *mm)
+{
+	int i;
+	unsigned long remaining = 0;
+
+	for (i = MAX_BINS - 1; i > 1; i--)
+		remaining += mm->ohp.count[i];
+
+	/*
+	 * mm should have enough promotions pending for the
+	 * atleat 1 khugepaged iteration.
+	 */
+	return remaining >= 8 ? remaining : 0;
+}
+EXPORT_SYMBOL(ohp_mm_pending_promotions);
+
+#define TLB_OVERHEAD_ONLY	0
+static inline
+unsigned long mm_ohp_weight(struct mm_struct *mm, unsigned int metric)
+{
+	unsigned long pending = 0;
+	unsigned long weight = 0;
+
+	mutex_lock(&mm->ohp.lock);
+	pending = ohp_mm_pending_promotions(mm);
+	if (pending) {
+		if (metric == TLB_OVERHEAD_ONLY)
+			weight = mm->ohp.ohp_weight;
+		else
+			weight = ((mm->ohp.ohp_weight * 10000)/pending);
+	}
+	mutex_unlock(&mm->ohp.lock);
+
+	//return weight > 2 ? weight : 0;
+	return weight;
+}
+
+/*
+ * Traverse through the list of all processes currently
+ * participating in ohp framework and select the process
+ * with the highest weight.
+ */
+struct mm_struct *ohp_get_target_mm(unsigned int metric)
+{
+	struct mm_struct *mm = NULL, *best_mm = NULL;
+	unsigned long weight, best_weight = 0;
+
+	spin_lock(&ohp_mm_lock);
+	list_for_each_entry(mm, &ohp_scan.mm_head, ohp_list) {
+		weight = mm_ohp_weight(mm, metric);
+		if (weight > best_weight) {
+			best_mm = mm;
+			best_weight = weight;
+		}
+	}
+	/*
+	 * Shift best mm to the tail of this list. This is to ensure
+	 * that promotions happen in round-robin fashion when two
+	 * or more processes have similar weight.
+	 */
+	if (best_mm)
+		list_move_tail(&best_mm->ohp_list, &ohp_scan.mm_head);
+	spin_unlock(&ohp_mm_lock);
+	return best_mm;
+}
+EXPORT_SYMBOL(ohp_get_target_mm);
+
+/* This is no longer being used. */
+#if 0
+/*
+ * Get the next huge page candidate.
+ */
+unsigned long get_next_ohp_addr(struct mm_struct **mm_src)
+{
+	struct mm_struct *mm;
+	struct ohp_addr *kaddr;
+	unsigned long address = 0;
+	int i;
+
+	*mm_src = NULL;
+	/* select the best process first.*/
+	mm = ohp_get_target_mm();
+	if (!mm)
+		return address;
+
+	mutex_lock(&mm->ohp.lock);
+#if 0
+	for (i = MAX_BINS-1; i >= 0; i--) {
+		if (list_empty(&mm->ohp.priority[i]))
+			continue;
+		/* If we are here, we have found the next ohp candidate. */
+		goto found;
+	}
+#endif
+	i = MAX_BINS - 1;
+	if (list_empty(&mm->ohp.priority[i]))
+		goto out;
+
+	kaddr = list_first_entry(&mm->ohp.priority[i],
+			struct ohp_addr, entry);
+
+	address = kaddr->address;
+	*mm_src = kaddr->mm;
+	/*
+	 * We perhaps do not want to see the same address again.
+	 * Delete it.
+	 */
+	list_del(&kaddr->entry);
+	kfree(kaddr);
+	mm->ohp.count[i] -= 1;
+	mm->ohp.ohp_remaining -= 1;
+	nr_ohp_bins -= 1;
+out:
+	mutex_unlock(&mm->ohp.lock);
+	return address;
+}
+#endif
+
+/*
+ * Get the next huge page candidate for a specific mm.
+ */
+struct ohp_addr *get_ohp_mm_addr(struct mm_struct *mm)
+{
+	struct ohp_addr *kaddr = NULL;
+	int i;
+
+	if (!mm)
+		return 0;
+
+	mutex_lock(&mm->ohp.lock);
+
+	/* search backwards from high to low priority bins. */
+	for (i = MAX_BINS - 1; i >= 0; i--) {
+		if (list_empty(&mm->ohp.priority[i]))
+			continue;
+		/* If we are here, we have found the next ohp candidate. */
+		goto found;
+	}
+
+	//if (i <= 0 || list_empty(&mm->ohp.priority[i]))
+	/* If we are here, we didn't find anything. */
+	goto out;
+
+found:
+	kaddr = list_first_entry(&mm->ohp.priority[i],
+			struct ohp_addr, entry);
+
+	/*
+	 * We perhaps do not want to see the same address again.
+	 * Delete it.
+	 */
+	list_del(&kaddr->entry);
+	mm->ohp.count[i] -= 1;
+	mm->ohp.ohp_remaining -= 1;
+	nr_ohp_bins -= 1;
+out:
+	mutex_unlock(&mm->ohp.lock);
+	return kaddr;
+}
+
+struct ohp_addr *get_ohp_global_kaddr(struct mm_struct **src)
+{
+	struct mm_struct *mm = NULL;
+	struct ohp_addr *kaddr = NULL;
+	int index, ret = 0;
+
+	spin_lock(&ohp_mm_lock);
+	/* start from the topmost bin. */
+	for(index = MAX_BINS - 1; index > 0; index--) {
+		list_for_each_entry(mm, &ohp_scan.mm_head, ohp_list) {
+			/* Don't block or sleep on the lock. */
+			ret = mutex_trylock(&mm->ohp.lock);
+			if (!ret)
+				continue;
+			/* Select the next process if the list is empty. */
+			if (list_empty(&mm->ohp.priority[index])) {
+				mutex_unlock(&mm->ohp.lock);
+				continue;
+			}
+
+			kaddr = list_first_entry(&mm->ohp.priority[index],
+						struct ohp_addr, entry);
+			list_del(&kaddr->entry);
+			mm->ohp.count[index] -= 1;
+			mm->ohp.ohp_remaining -= 1;
+			nr_ohp_bins -= 1;
+			mutex_unlock(&mm->ohp.lock);
+			*src = mm;
+			/*
+			 * Put the current mm at the tail. This logic implements
+			 * the round-robin promotion policy.
+			 */
+			list_del(&mm->ohp_list);
+			list_add_tail(&mm->ohp_list, &ohp_scan.mm_head);
+			goto found;
+		}
+	}
+found:
+	spin_unlock(&ohp_mm_lock);
+	return kaddr;
+}
+
+void ohp_putback_kaddr(struct mm_struct *mm, struct ohp_addr *kaddr)
+{
+	int pos = 0;
+
+	mutex_lock(&mm->ohp.lock);
+	list_add_tail(&kaddr->entry, &mm->ohp.priority[pos]);
+	mm->ohp.count[pos] += 1;
+	mm->ohp.ohp_remaining += 1;
+	nr_ohp_bins += 1;
+	mutex_unlock(&mm->ohp.lock);
+}
+
+/*
+ * Remove a range of addresses from the ohps.
+ * This should also take care of cases when mm is being destroyed.
+ */
+void remove_ohp_bins(struct vm_area_struct *vma)
+{
+	struct mm_struct *mm;
+	struct ohp_addr *tmp, *kaddr;
+	int i;
+
+	mm = vma->vm_mm;
+	if (!mm)
+		return;
+
+	/* TODO: See if this can be optimized. */
+	mutex_lock(&mm->ohp.lock);
+	for (i=0; i<MAX_BINS; i++) {
+		list_for_each_entry_safe(kaddr, tmp,
+				&mm->ohp.priority[i], entry) {
+			if (kaddr->address >= vma->vm_start &&
+				kaddr->address <= vma->vm_end) {
+				list_del(&kaddr->entry);
+				mm->ohp.count[i] -= 1;
+				mm->ohp.ohp_remaining -= 1;
+				nr_ohp_bins -= 1;
+				kfree(kaddr);
+			}
+		}
+	}
+	mutex_unlock(&mm->ohp.lock);
+}
+
+/*
+ * Check for potential race conditions. We should already
+ * be holding mm semaphore at this point.
+ */
+int add_ohp_bin(struct mm_struct *mm, unsigned long addr)
+{
+	struct ohp_addr *kaddr;
+	unsigned int index = 0;
+
+	if (!mm)
+		return 0;
+
+	/* Align with huge page boundary.
+	 * TODO: Verify if the address is still valid after alignment.
+	 * It can also be done at the time of promotion.
+	 */
+	addr = (addr + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;
+
+	/*
+	 * TODO: Optimize this for performance with a dedicated slab.
+	 */
+	kaddr = kzalloc(sizeof(struct ohp_addr), GFP_KERNEL);
+	if (!kaddr)
+		return -ENOMEM;
+
+	/*
+	 * This may be enabled if a generic huge page support extension
+	 * is needed. For now, we rely on the userspace to provide us with
+	 * every process that needs to be considered for huge pages.
+	 */
+	/* ohp_add_mm(mm); */
+	kaddr->address = addr;
+	kaddr->mm = mm;
+
+	mutex_lock(&mm->ohp.lock);
+	list_add_tail(&(kaddr->entry), &(mm->ohp.priority[index]));
+	mm->ohp.count[index] += 1;
+	mm->ohp.ohp_remaining += 1;
+	nr_ohp_bins += 1;
+	mutex_unlock(&mm->ohp.lock);
+	return 0;
+}
+
+/*
+ * Helper function which can be used by a loadable kernel module
+ * for debugging or analysis purpose.
+ */
+long count_ohp_bins(struct mm_struct *mm)
+{
+	int i;
+	long count = 0;
+
+	if (!mm)
+		return -EINVAL;
+
+	/*
+	 * This is potentially racy. But does it matter ?
+	 */
+	for (i=0; i<MAX_BINS; i++) {
+		count += mm->ohp.count[i];
+	}
+
+	return count;
+}
+EXPORT_SYMBOL(count_ohp_bins);
+
+/*
+ * We decide the action to be taken using value, as per the
+ * following rules -
+ * 1000 -   The process has just started and needs to be added to
+ *          the queue for monitoring its huge pages.
+ * 1001 -   The process has finished and hence it is safe to remove
+ *          from the list. Make sure to drop reference to any of task
+ *          members. Ideally, this should not be required as we take care
+ *          of this case at the time of mmexit.
+ * Others - All other values denote a legitimate sensitivity for
+ *          the process. It must be between 0 and 100.
+ */
+SYSCALL_DEFINE2(update_mm_ohp_stats, unsigned int, pid, unsigned int, value)
+{
+	struct task_struct *task;
+	struct pid *pid_struct;
+	struct mm_struct *mm;
+	long ret = 0;
+
+	pid_struct = find_get_pid(pid);
+	if (!pid_struct) {
+		printk(KERN_INFO"Invalid pid: %d\n", pid);
+		return -EINVAL;
+	}
+
+	task = pid_task(pid_struct, PIDTYPE_PID);
+	if (!task) {
+		printk(KERN_INFO"Unable to retrieve task for pid: %d\n", pid);
+		return -EINVAL;
+	}
+
+	if (value == OHP_TASK_ENTER) {
+		ohp_add_task(task);
+		printk(KERN_INFO"Added pid: %d %s to scan list\n",
+						pid, task->comm);
+		goto exit_success;
+	}
+
+	if (value == OHP_TASK_EXIT) {
+		ohp_exit_task(task);
+		printk(KERN_INFO"Removed pid: %d %s from scan list\n",
+						pid, task->comm);
+		goto exit_success;
+	}
+	/*
+	 * Verify the validity of the sensitivity value.
+	 * Valid range is only from 0 - 100.
+	 * We can't simply return from here as the task is locked.
+	 */
+	if (value > 100)
+		return -EINVAL;
+
+	mm = get_task_mm(task);
+	if (!mm)
+		return -EINVAL;
+
+	/*
+	 * We expect the user-space deamon to suppply weight
+	 * as the moving average. Floating point caclulation is
+	 * easier in the user-space so it also avoids the need
+	 * for tuning the calculation.
+	 */
+	mm->ohp.ohp_weight = value;
+	mmput(mm);
+
+exit_success:
+	return ret;
+}
+
+static void kbinmanager_wait_cpu_bound(unsigned long busy_msecs,
+				unsigned long idle_msecs)
+{
+	unsigned long sleep_msecs;
+
+	/*
+	 * We have seen idle to be more than busy at times.
+	 * Below is a workaround to handle indefinite sleeping.
+	 */
+	if (idle_msecs > busy_msecs)
+		busy_msecs = 0;
+	else
+		busy_msecs = busy_msecs - idle_msecs;
+	/*
+	 * Bound by 5% cpu utilization.
+	 * Also, enforce minimum bound of 5 seconds.
+	 */
+	sleep_msecs = busy_msecs * 19;
+	if (sleep_msecs < 5000)
+		sleep_msecs = 5000;
+
+	trace_printk("busy: %ld ms sleep: %ld ms\n", busy_msecs, sleep_msecs);
+
+	/* put to sleep for a certain period */
+	wait_event_freezable_timeout(kbinmanager_wait, kthread_should_stop(),
+			msecs_to_jiffies(sleep_msecs));
+}
+
+static void kbinmanager_wait_scan_period(unsigned long msecs)
+{
+	/* put to sleep for a certain period */
+	wait_event_freezable_timeout(kbinmanager_wait, kthread_should_stop(),
+			msecs_to_jiffies(msecs));
+}
+
+static struct mm_struct *ohp_next_scan_candidate(unsigned long curr_tstamp)
+{
+	struct mm_struct *mm, *mm_candidate = NULL;
+
+	spin_lock(&ohp_mm_lock);
+	/* Select the mm with least scan timestamp. */
+	list_for_each_entry(mm, &ohp_scan.mm_head, ohp_list) {
+		if (mm->ohp.tstamp < curr_tstamp) {
+			mm_candidate = mm;
+			break;
+		}
+	}
+	spin_unlock(&ohp_mm_lock);
+
+	return mm_candidate;
+}
+
+static void kbinmanager_do_scan(unsigned long *idle_msecs)
+{
+	static unsigned long curr_tstamp = 0;
+	struct mm_struct *mm = NULL;
+
+	/* First, update the current timestamp. */
+	curr_tstamp += 1;
+
+	/*
+	 * Now, scan and adjust every mm whose timestamp is
+	 * less than the current iteration.
+	 */
+	while (true) {
+		mm = ohp_next_scan_candidate(curr_tstamp);
+		if (!mm)
+			break;
+
+		ohp_clear_pte_accessed_mm(mm);
+		kbinmanager_wait_scan_period(1000);
+		*idle_msecs += 1000;
+		ohp_adjust_mm_bins(mm);
+		mm->ohp.tstamp = curr_tstamp;
+	}
+}
+
+/*
+ * Kernel thread that opportunistically scans process
+ * address space to get a measure of its working set.
+ */
+static int kbinmanager(void *none)
+{
+	// struct timeval start, end;
+	struct timespec64 start, end;
+	unsigned long idle_msecs, busy_msecs;
+
+	set_freezable();
+	set_user_nice(current, MAX_NICE);
+
+	while (!kthread_should_stop()) {
+		idle_msecs = 0;
+		//do_gettimeofday(&start);
+                ktime_get_ts64(&start);
+		kbinmanager_do_scan(&idle_msecs);
+		//do_gettimeofday(&end);
+                ktime_get_ts64(&end);
+		kbinmanager_wait_cpu_bound(busy_msecs, idle_msecs);
+	}
+
+	return 0;
+}
+
+int start_kbinmanager(void)
+{
+	int err=  0;
+
+	/*
+	 * Check if the thread is not active already. Start if it is not.
+	 */
+	if (khugepaged_enabled()) {
+		if (!kbinmanager_thread) {
+			kbinmanager_thread = kthread_run(kbinmanager, NULL,
+								"kbinmanager");
+			if (unlikely(IS_ERR(kbinmanager_thread))) {
+				pr_err("kbinmanager thread failed to start\n");
+				err = PTR_ERR(kbinmanager_thread);
+				kbinmanager_thread = NULL;
+				goto fail;
+			}
+		}
+	}
+fail:
+	return err;
+}
+
+void stop_kbinmanager(void)
+{
+	if (kbinmanager_thread) {
+		kthread_stop(kbinmanager_thread);
+		kbinmanager_thread = NULL;
+	}
+}
+
+#define CLEAR_PTE	0
+#define PTE_ACCESSED	1
+int ohp_follow_pte(struct mm_struct *mm, struct vm_area_struct *vma,
+			unsigned long addr, unsigned int op)
+{
+	pgd_t *pgd;
+	pud_t *pud;
+	pmd_t *pmd;
+	pte_t *ptep, pte, cleared;
+	spinlock_t *ptl;
+	int ret = 0;
+
+	pgd = pgd_offset(mm, addr);
+	if (pgd_none(*pgd) || unlikely (pgd_bad(*pgd)))
+		return ret;
+
+	pud = pud_offset((p4d_t *)pgd, addr);
+	if (pud_none(*pud))
+		return ret;
+
+	pmd = pmd_offset(pud, addr);
+	if (pmd_none(*pmd))
+		return ret;
+
+	if (pmd_protnone(*pmd))
+		return ret;
+
+	/* This should be a bug. */
+	if (pmd_trans_huge(*pmd))
+		return ret;
+
+	ptep = pte_offset_map_lock(mm, pmd, addr, &ptl);
+	/* Sanity check to make sure the page table exists. */
+	if (pte_none(*ptep))
+		goto unlock;
+
+	pte = *ptep;
+	if (!pte_present(pte))
+		goto unlock;
+
+	if (op == PTE_ACCESSED) {
+		ret = pte_young(pte);
+	} else {
+		cleared = pte_mkold(pte);
+		set_pte_at(mm, addr, ptep, cleared);
+	}
+unlock:
+	pte_unmap_unlock(ptep, ptl);
+	return ret;
+}
+
+static void ohp_clear_hpage_range(struct mm_struct *mm,
+		struct vm_area_struct *vma, unsigned long address)
+{
+	pgd_t *pgd;
+	pud_t *pud;
+	pmd_t *pmd;
+	pte_t *ptep, pte, cleared;
+	spinlock_t *ptl;
+	unsigned long addr;
+
+	pgd = pgd_offset(mm, address);
+	if (pgd_none(*pgd) || unlikely (pgd_bad(*pgd)))
+		return;
+
+	pud = pud_offset((p4d_t *)pgd, address);
+	if (pud_none(*pud))
+		return;
+
+	pmd = pmd_offset(pud, address);
+	if (pmd_none(*pmd))
+		return;
+
+	if (pmd_trans_huge(*pmd))
+		return;
+
+	for (addr = address; addr < address + HPAGE_PMD_SIZE;
+			addr += PAGE_SIZE) {
+		ptep = pte_offset_map_lock(mm, pmd, addr, &ptl);
+		/* Sanity check to make sure the page table exists. */
+		if (pte_none(*ptep))
+			goto unlock;
+
+		pte = *ptep;
+		if (!pte_present(pte))
+			goto unlock;
+
+		cleared = pte_mkold(pte);
+		set_pte_at(mm, addr, ptep, cleared);
+unlock:
+		pte_unmap_unlock(ptep, ptl);
+	}
+}
+
+/*
+ * find_vma can also return the next vma if the address
+ * does not currently belong to a region. We can not promote
+ * such addresses. Hence, it seems more safe to discard such
+ * regions from further huge page considerations.
+ */
+static inline bool is_vma_valid(struct vm_area_struct *vma, unsigned long addr)
+{
+	return (addr >= vma->vm_start && addr < vma->vm_end);
+}
+
+/* Clears the page table accessed bit for the specified huge page region.
+ * The address must be aligned with the huge page boundary.
+ */
+void ohp_clear_pte_accessed_range(struct mm_struct *mm, unsigned long start)
+{
+	struct vm_area_struct *vma1, *vma2;
+	unsigned long end = start + HPAGE_PMD_SIZE;
+
+	/*
+	 * Check if the whole range falls within a single vma.
+	 * If not, there is no need to scan this page as it can not
+	 * be promoted anyway.
+	 */
+	vma1 = find_vma(mm, start);
+	if (!vma1 || !is_vma_valid(vma1, start))
+		return;
+
+	vma2 = find_vma(mm, end - PAGE_SIZE);
+	if (!vma2 || vma2 != vma1)
+		return;
+
+	/* Clear the accessed bit of each base page */
+	ohp_clear_hpage_range(mm, vma1, start);
+}
+
+void ohp_clear_pte_accessed_mm(struct mm_struct *mm)
+{
+	int index;
+	struct ohp_addr *kaddr;
+
+	mutex_lock(&mm->ohp.lock);
+	for (index = MAX_BINS-1; index >= 0; index--) {
+		list_for_each_entry(kaddr, &mm->ohp.priority[index], entry)
+			ohp_clear_pte_accessed_range(mm, kaddr->address);
+	}
+	mutex_unlock(&mm->ohp.lock);
+}
+EXPORT_SYMBOL(ohp_clear_pte_accessed_mm);
+
+static int ohp_calc_hpage_hotness(struct mm_struct *mm,
+		struct vm_area_struct *vma, unsigned long address)
+{
+	pgd_t *pgd;
+	pud_t *pud;
+	pmd_t *pmd;
+	pte_t *ptep, pte;
+	spinlock_t *ptl;
+	unsigned long addr;
+	int accessed = 0;
+
+	pgd = pgd_offset(mm, address);
+	if (pgd_none(*pgd) || unlikely (pgd_bad(*pgd)))
+		return -1;
+
+	pud = pud_offset((p4d_t *)pgd, address);
+	if (pud_none(*pud))
+		return -1;
+
+	pmd = pmd_offset(pud, address);
+	if (pmd_none(*pmd))
+		return -1;
+
+	if (pmd_trans_huge(*pmd))
+		return -1;
+
+	for (addr = address; addr < address + HPAGE_PMD_SIZE;
+			addr += PAGE_SIZE) {
+		ptep = pte_offset_map_lock(mm, pmd, addr, &ptl);
+		/* Sanity check to make sure the page table exists. */
+		if (pte_none(*ptep))
+			goto unlock;
+
+		pte = *ptep;
+		if (!pte_present(pte))
+			goto unlock;
+
+		if (pte_young(pte))
+			accessed += 1;
+unlock:
+		pte_unmap_unlock(ptep, ptl);
+	}
+	return accessed;
+}
+
+/*
+ * Returns the number of active baseline pages for the given huge page region.
+ * The address must be already aligned with the huge page boundary.
+ */
+static int ohp_nr_accessed(struct mm_struct *mm, unsigned long start)
+{
+	struct vm_area_struct *vma1, *vma2;
+	unsigned long end = start + HPAGE_PMD_SIZE;
+
+	vma1 = find_vma(mm, start);
+	if (!vma1 || !is_vma_valid(vma1, start))
+		return -1;
+
+	vma2 = find_vma(mm, end - PAGE_SIZE);
+	if (!vma2 || vma2 != vma1)
+		return -1;
+
+	return ohp_calc_hpage_hotness(mm, vma1, start);
+}
+
+static inline void update_kaddr_weight(struct ohp_addr *kaddr, int nr_accessed)
+{
+	kaddr->weight = (kaddr->weight * 6 + nr_accessed * 4) / 10;
+	if (kaddr->weight > HPAGE_PMD_NR)
+		kaddr->weight = HPAGE_PMD_NR;
+}
+
+void ohp_adjust_mm_bins(struct mm_struct *mm)
+{
+	int nr_accessed, index, new_index;
+	struct ohp_addr *kaddr, *tmp;
+
+	/* TODO: Optimize locking behavior. */
+	mutex_lock(&mm->ohp.lock);
+	mm->ohp.nr_scans += 1;
+	for (index = MAX_BINS - 1; index >=0; index--) {
+		list_for_each_entry_safe(kaddr, tmp,
+				&mm->ohp.priority[index], entry) {
+			/*
+			 * Don't traverse a single huge page more than once
+			 * in one iteration.
+			 */
+			if (kaddr->nr_scans == mm->ohp.nr_scans)
+				continue;
+
+			nr_accessed = ohp_nr_accessed(mm, kaddr->address);
+			/* Remove invalid addressed first. */
+			if (nr_accessed < 0) {
+				/*
+				 * We treat this to be an error and discard this from
+				 * further considerations.
+				 */
+				list_del(&kaddr->entry);
+				mm->ohp.ohp_remaining -= 1;
+				mm->ohp.count[index] -= 1;
+				mm->ohp.invalid += 1;
+				nr_ohp_bins -= 1;
+				kfree(kaddr);
+				continue;
+			}
+
+			kaddr->nr_scans = mm->ohp.nr_scans;
+			update_kaddr_weight(kaddr, nr_accessed);
+			new_index = order_base_2(kaddr->weight);
+
+			/* Validate the new index of the current huge page region. */
+			VM_BUG_ON(new_index >= MAX_BINS);
+			list_move(&kaddr->entry, &mm->ohp.priority[new_index]);
+			mm->ohp.count[index] -= 1;
+			mm->ohp.count[new_index] += 1;
+		}
+	}
+	mutex_unlock(&mm->ohp.lock);
+}
+EXPORT_SYMBOL(ohp_adjust_mm_bins);
diff --color -ruN -w -B '--exclude-from=.diff-exclude' linux-5.10/mm/page_alloc.c HawkEye-5.10-cow/mm/page_alloc.c
--- linux-5.10/mm/page_alloc.c	2020-12-13 22:41:30.000000000 +0000
+++ HawkEye-5.10-cow/mm/page_alloc.c	2025-03-23 07:53:49.801074506 +0000
@@ -129,7 +129,8 @@
 #endif
 
 /* work_structs for global per-cpu drains */
-struct pcpu_drain {
+struct pcpu_drain
+{
 	struct zone *zone;
 	struct work_struct work;
 };
@@ -249,7 +250,8 @@
 void pm_restore_gfp_mask(void)
 {
 	WARN_ON(!mutex_is_locked(&system_transition_mutex));
-	if (saved_gfp_mask) {
+    if (saved_gfp_mask)
+    {
 		gfp_allowed_mask = saved_gfp_mask;
 		saved_gfp_mask = 0;
 	}
@@ -439,7 +441,8 @@
 	 * prev_end_pfn static that contains the end of previous zone
 	 * No need to protect because called very early in boot before smp_init.
 	 */
-	if (prev_end_pfn != end_pfn) {
+    if (prev_end_pfn != end_pfn)
+    {
 		prev_end_pfn = end_pfn;
 		nr_initialised = 0;
 	}
@@ -454,7 +457,8 @@
 	 */
 	nr_initialised++;
 	if ((nr_initialised > PAGES_PER_SECTION) &&
-	    (pfn & (PAGES_PER_SECTION - 1)) == 0) {
+        (pfn & (PAGES_PER_SECTION - 1)) == 0)
+    {
 		NODE_DATA(nid)->first_deferred_pfn = pfn;
 		return true;
 	}
@@ -503,8 +507,7 @@
  *
  * Return: pageblock_bits flags
  */
-static __always_inline
-unsigned long __get_pfnblock_flags_mask(struct page *page,
+static __always_inline unsigned long __get_pfnblock_flags_mask(struct page *page,
 					unsigned long pfn,
 					unsigned long mask)
 {
@@ -561,7 +564,8 @@
 	flags <<= bitidx;
 
 	word = READ_ONCE(bitmap[word_bitidx]);
-	for (;;) {
+    for (;;)
+    {
 		old_word = cmpxchg(&bitmap[word_bitidx], word, (word & ~mask) | flags);
 		if (word == old_word)
 			break;
@@ -587,7 +591,8 @@
 	unsigned long pfn = page_to_pfn(page);
 	unsigned long sp, start_pfn;
 
-	do {
+    do
+    {
 		seq = zone_span_seqbegin(zone);
 		start_pfn = zone->zone_start_pfn;
 		sp = zone->spanned_pages;
@@ -641,12 +646,15 @@
 	 * Allow a burst of 60 reports, then keep quiet for that minute;
 	 * or allow a steady drip of one report per second.
 	 */
-	if (nr_shown == 60) {
-		if (time_before(jiffies, resume)) {
+    if (nr_shown == 60)
+    {
+        if (time_before(jiffies, resume))
+        {
 			nr_unshown++;
 			goto out;
 		}
-		if (nr_unshown) {
+        if (nr_unshown)
+        {
 			pr_alert(
 			      "BUG: Bad page state: %lu messages suppressed\n",
 				nr_unshown);
@@ -697,7 +705,8 @@
 	int nr_pages = 1 << order;
 
 	__SetPageHead(page);
-	for (i = 1; i < nr_pages; i++) {
+    for (i = 1; i < nr_pages; i++)
+    {
 		struct page *p = page + i;
 		set_page_count(p, 0);
 		p->mapping = TAIL_MAPPING;
@@ -714,8 +723,7 @@
 #ifdef CONFIG_DEBUG_PAGEALLOC
 unsigned int _debug_guardpage_minorder;
 
-bool _debug_pagealloc_enabled_early __read_mostly
-			= IS_ENABLED(CONFIG_DEBUG_PAGEALLOC_ENABLE_DEFAULT);
+bool _debug_pagealloc_enabled_early __read_mostly = IS_ENABLED(CONFIG_DEBUG_PAGEALLOC_ENABLE_DEFAULT);
 EXPORT_SYMBOL(_debug_pagealloc_enabled_early);
 DEFINE_STATIC_KEY_FALSE(_debug_pagealloc_enabled);
 EXPORT_SYMBOL(_debug_pagealloc_enabled);
@@ -745,7 +753,8 @@
 {
 	unsigned long res;
 
-	if (kstrtoul(buf, 10, &res) < 0 ||  res > MAX_ORDER / 2) {
+    if (kstrtoul(buf, 10, &res) < 0 || res > MAX_ORDER / 2)
+    {
 		pr_err("Bad debug_guardpage_minorder value\n");
 		return 0;
 	}
@@ -787,7 +796,10 @@
 }
 #else
 static inline bool set_page_guard(struct zone *zone, struct page *page,
-			unsigned int order, int migratetype) { return false; }
+                                  unsigned int order, int migratetype)
+{
+    return false;
+}
 static inline void clear_page_guard(struct zone *zone, struct page *page,
 				unsigned int order, int migratetype) {}
 #endif
@@ -840,7 +852,9 @@
 	return unlikely(capc) &&
 		!(current->flags & PF_KTHREAD) &&
 		!capc->page &&
-		capc->cc->zone == zone ? capc : NULL;
+                   capc->cc->zone == zone
+               ? capc
+               : NULL;
 }
 
 static inline bool
@@ -990,7 +1004,7 @@
 	struct capture_control *capc = task_capc(zone);
 	unsigned long buddy_pfn;
 	unsigned long combined_pfn;
-	unsigned int max_order;
+    unsigned int i, max_order;
 	struct page *buddy;
 	bool to_tail;
 
@@ -1006,9 +1020,14 @@
 	VM_BUG_ON_PAGE(pfn & ((1 << order) - 1), page);
 	VM_BUG_ON_PAGE(bad_range(zone, page), page);
 
+    for (i = 0; i < (1 << order); i++)
+        ClearPageZeroed(page + i);
+
 continue_merging:
-	while (order < max_order - 1) {
-		if (compaction_capture(capc, page, order, migratetype)) {
+    while (order < max_order - 1)
+    {
+        if (compaction_capture(capc, page, order, migratetype))
+        {
 			__mod_zone_freepage_state(zone, -(1 << order),
 								migratetype);
 			return;
@@ -1033,7 +1052,8 @@
 		pfn = combined_pfn;
 		order++;
 	}
-	if (max_order < MAX_ORDER) {
+    if (max_order < MAX_ORDER)
+    {
 		/* If we are here, it means order is >= pageblock_order.
 		 * We want to prevent merge between freepages on isolate
 		 * pageblock and normal pageblock. Without this, pageblock
@@ -1042,15 +1062,15 @@
 		 * We don't want to hit this code for the more frequent
 		 * low-order merging.
 		 */
-		if (unlikely(has_isolate_pageblock(zone))) {
+        if (unlikely(has_isolate_pageblock(zone)))
+        {
 			int buddy_mt;
 
 			buddy_pfn = __find_buddy_pfn(pfn, order);
 			buddy = page + (buddy_pfn - pfn);
 			buddy_mt = get_pageblock_migratetype(buddy);
 
-			if (migratetype != buddy_mt
-					&& (is_migrate_isolate(migratetype) ||
+            if (migratetype != buddy_mt && (is_migrate_isolate(migratetype) ||
 						is_migrate_isolate(buddy_mt)))
 				goto done_merging;
 		}
@@ -1110,7 +1130,8 @@
 		bad_reason = "non-NULL mapping";
 	if (unlikely(page_ref_count(page) != 0))
 		bad_reason = "nonzero _refcount";
-	if (unlikely(page->flags & flags)) {
+    if (unlikely(page->flags & flags))
+    {
 		if (flags == PAGE_FLAGS_CHECK_AT_PREP)
 			bad_reason = "PAGE_FLAGS_CHECK_AT_PREP flag(s) set";
 		else
@@ -1149,14 +1170,17 @@
 	 */
 	BUILD_BUG_ON((unsigned long)LIST_POISON1 & 1);
 
-	if (!IS_ENABLED(CONFIG_DEBUG_VM)) {
+    if (!IS_ENABLED(CONFIG_DEBUG_VM))
+    {
 		ret = 0;
 		goto out;
 	}
-	switch (page - head_page) {
+    switch (page - head_page)
+    {
 	case 1:
 		/* the first tail page: ->mapping may be compound_mapcount() */
-		if (unlikely(compound_mapcount(page))) {
+        if (unlikely(compound_mapcount(page)))
+        {
 			bad_page(page, "nonzero compound_mapcount");
 			goto out;
 		}
@@ -1168,17 +1192,20 @@
 		 */
 		break;
 	default:
-		if (page->mapping != TAIL_MAPPING) {
+        if (page->mapping != TAIL_MAPPING)
+        {
 			bad_page(page, "corrupted mapping in tail page");
 			goto out;
 		}
 		break;
 	}
-	if (unlikely(!PageTail(page))) {
+    if (unlikely(!PageTail(page)))
+    {
 		bad_page(page, "PageTail not set");
 		goto out;
 	}
-	if (unlikely(compound_head(page) != head_page)) {
+    if (unlikely(compound_head(page) != head_page))
+    {
 		bad_page(page, "compound_head not consistent");
 		goto out;
 	}
@@ -1196,7 +1223,10 @@
 	/* s390's use of memset() could override KASAN redzones. */
 	kasan_disable_current();
 	for (i = 0; i < numpages; i++)
+    {
+        if (!PageZeroed(page + i))
 		clear_highpage(page + i);
+    }
 	kasan_enable_current();
 }
 
@@ -1209,7 +1239,8 @@
 
 	trace_mm_page_free(page, order);
 
-	if (unlikely(PageHWPoison(page)) && !order) {
+    if (unlikely(PageHWPoison(page)) && !order)
+    {
 		/*
 		 * Do not let hwpoison pages hit pcplists/buddy
 		 * Untie memcg state and reset page's owner
@@ -1224,7 +1255,8 @@
 	 * Check tail pages before head page information is cleared to
 	 * avoid checking PageCompound for order-0 pages.
 	 */
-	if (unlikely(order)) {
+    if (unlikely(order))
+    {
 		bool compound = PageCompound(page);
 		int i;
 
@@ -1232,10 +1264,12 @@
 
 		if (compound)
 			ClearPageDoubleMap(page);
-		for (i = 1; i < (1 << order); i++) {
+        for (i = 1; i < (1 << order); i++)
+        {
 			if (compound)
 				bad += free_tail_pages_check(page, page + i);
-			if (unlikely(check_free_page(page + i))) {
+            if (unlikely(check_free_page(page + i)))
+            {
 				bad++;
 				continue;
 			}
@@ -1255,7 +1289,8 @@
 	page->flags &= ~PAGE_FLAGS_CHECK_AT_PREP;
 	reset_page_owner(page, order);
 
-	if (!PageHighMem(page)) {
+    if (!PageHighMem(page))
+    {
 		debug_check_no_locks_freed(page_address(page),
 					   PAGE_SIZE << order);
 		debug_check_no_obj_freed(page_address(page),
@@ -1354,7 +1389,8 @@
 	 * below while (list_empty(list)) loop.
 	 */
 	count = min(pcp->count, count);
-	while (count) {
+    while (count)
+    {
 		struct list_head *list;
 
 		/*
@@ -1364,7 +1400,8 @@
 		 * off fuller lists instead of spinning excessively around empty
 		 * lists
 		 */
-		do {
+        do
+        {
 			batch_free++;
 			if (++migratetype == MIGRATE_PCPTYPES)
 				migratetype = 0;
@@ -1375,7 +1412,8 @@
 		if (batch_free == MIGRATE_PCPTYPES)
 			batch_free = count;
 
-		do {
+        do
+        {
 			page = list_last_entry(list, struct page, lru);
 			/* must delete to avoid corrupting pcp list */
 			list_del(&page->lru);
@@ -1407,7 +1445,8 @@
 	 * Use safe version since after __free_one_page(),
 	 * page->lru.next will not point to original list.
 	 */
-	list_for_each_entry_safe(page, tmp, &head, lru) {
+    list_for_each_entry_safe(page, tmp, &head, lru)
+    {
 		int mt = get_pcppage_migratetype(page);
 		/* MIGRATE_ISOLATE page should not go to pcplists */
 		VM_BUG_ON_PAGE(is_migrate_isolate(mt), page);
@@ -1428,7 +1467,8 @@
 {
 	spin_lock(&zone->lock);
 	if (unlikely(has_isolate_pageblock(zone) ||
-		is_migrate_isolate(migratetype))) {
+                 is_migrate_isolate(migratetype)))
+    {
 		migratetype = get_pfnblock_migratetype(page, pfn);
 	}
 	__free_one_page(page, pfn, zone, order, migratetype, fpi_flags);
@@ -1465,7 +1505,8 @@
 	nid = early_pfn_to_nid(pfn);
 	pgdat = NODE_DATA(nid);
 
-	for (zid = 0; zid < MAX_NR_ZONES; zid++) {
+    for (zid = 0; zid < MAX_NR_ZONES; zid++)
+    {
 		struct zone *zone = &pgdat->node_zones[zid];
 
 		if (pfn >= zone->zone_start_pfn && pfn < zone_end_pfn(zone))
@@ -1490,8 +1531,10 @@
 	unsigned long start_pfn = PFN_DOWN(start);
 	unsigned long end_pfn = PFN_UP(end);
 
-	for (; start_pfn < end_pfn; start_pfn++) {
-		if (pfn_valid(start_pfn)) {
+    for (; start_pfn < end_pfn; start_pfn++)
+    {
+        if (pfn_valid(start_pfn))
+        {
 			struct page *page = pfn_to_page(start_pfn);
 
 			init_reserved_page(start_pfn);
@@ -1539,7 +1582,8 @@
 	 * refcount of all involved pages to 0.
 	 */
 	prefetchw(p);
-	for (loop = 0; loop < (nr_pages - 1); loop++, p++) {
+    for (loop = 0; loop < (nr_pages - 1); loop++, p++)
+    {
 		prefetchw(p + 1);
 		__ClearPageReserved(p);
 		set_page_count(p, 0);
@@ -1575,7 +1619,8 @@
 		return state->last_nid;
 
 	nid = memblock_search_pfn_nid(pfn, &start_pfn, &end_pfn);
-	if (nid != NUMA_NO_NODE) {
+    if (nid != NUMA_NO_NODE)
+    {
 		state->last_start = start_pfn;
 		state->last_end = end_pfn;
 		state->last_nid = nid;
@@ -1661,7 +1706,8 @@
 	block_end_pfn = ALIGN(block_start_pfn + 1, pageblock_nr_pages);
 	for (; block_start_pfn < zone_end_pfn(zone);
 			block_start_pfn = block_end_pfn,
-			 block_end_pfn += pageblock_nr_pages) {
+         block_end_pfn += pageblock_nr_pages)
+    {
 
 		block_end_pfn = min(block_end_pfn, zone_end_pfn(zone));
 
@@ -1694,13 +1740,15 @@
 
 	/* Free a large naturally-aligned chunk if possible */
 	if (nr_pages == pageblock_nr_pages &&
-	    (pfn & (pageblock_nr_pages - 1)) == 0) {
+        (pfn & (pageblock_nr_pages - 1)) == 0)
+    {
 		set_pageblock_migratetype(page, MIGRATE_MOVABLE);
 		__free_pages_core(page, pageblock_order);
 		return;
 	}
 
-	for (i = 0; i < nr_pages; i++, page++, pfn++) {
+    for (i = 0; i < nr_pages; i++, page++, pfn++)
+    {
 		if ((pfn & (pageblock_nr_pages - 1)) == 0)
 			set_pageblock_migratetype(page, MIGRATE_MOVABLE);
 		__free_pages_core(page, 0);
@@ -1746,14 +1794,20 @@
 	unsigned long nr_pgmask = pageblock_nr_pages - 1;
 	unsigned long nr_free = 0;
 
-	for (; pfn < end_pfn; pfn++) {
-		if (!deferred_pfn_valid(pfn)) {
+    for (; pfn < end_pfn; pfn++)
+    {
+        if (!deferred_pfn_valid(pfn))
+        {
 			deferred_free_range(pfn - nr_free, nr_free);
 			nr_free = 0;
-		} else if (!(pfn & nr_pgmask)) {
+        }
+        else if (!(pfn & nr_pgmask))
+        {
 			deferred_free_range(pfn - nr_free, nr_free);
 			nr_free = 1;
-		} else {
+        }
+        else
+        {
 			nr_free++;
 		}
 	}
@@ -1776,13 +1830,19 @@
 	int zid = zone_idx(zone);
 	struct page *page = NULL;
 
-	for (; pfn < end_pfn; pfn++) {
-		if (!deferred_pfn_valid(pfn)) {
+    for (; pfn < end_pfn; pfn++)
+    {
+        if (!deferred_pfn_valid(pfn))
+        {
 			page = NULL;
 			continue;
-		} else if (!page || !(pfn & nr_pgmask)) {
+        }
+        else if (!page || !(pfn & nr_pgmask))
+        {
 			page = pfn_to_page(pfn);
-		} else {
+        }
+        else
+        {
 			page++;
 		}
 		__init_single_page(page, pfn, zid, nid);
@@ -1809,7 +1869,8 @@
 	 * already been initialized. We don't need to do anything with them
 	 * so we just need to flush them out of the system.
 	 */
-	for_each_free_mem_pfn_range_in_zone(j, zone, spfn, epfn) {
+    for_each_free_mem_pfn_range_in_zone(j, zone, spfn, epfn)
+    {
 		if (*epfn <= first_init_pfn)
 			continue;
 		if (*spfn < first_init_pfn)
@@ -1841,7 +1902,8 @@
 	u64 j = *i;
 
 	/* First we loop through and initialize the page values */
-	for_each_free_mem_pfn_range_in_zone_from(j, zone, start_pfn, end_pfn) {
+    for_each_free_mem_pfn_range_in_zone_from(j, zone, start_pfn, end_pfn)
+    {
 		unsigned long t;
 
 		if (mo_pfn <= *start_pfn)
@@ -1850,7 +1912,8 @@
 		t = min(mo_pfn, *end_pfn);
 		nr_pages += deferred_init_pages(zone, *start_pfn, t);
 
-		if (mo_pfn < *end_pfn) {
+        if (mo_pfn < *end_pfn)
+        {
 			*start_pfn = mo_pfn;
 			break;
 		}
@@ -1859,7 +1922,8 @@
 	/* Reset values and now loop through freeing pages as needed */
 	swap(j, *i);
 
-	for_each_free_mem_pfn_range_in_zone_from(j, zone, &spfn, &epfn) {
+    for_each_free_mem_pfn_range_in_zone_from(j, zone, &spfn, &epfn)
+    {
 		unsigned long t;
 
 		if (mo_pfn <= spfn)
@@ -1889,7 +1953,8 @@
 	 * Initialize and free pages in MAX_ORDER sized increments so that we
 	 * can avoid introducing any issues with the buddy allocator.
 	 */
-	while (spfn < end_pfn) {
+    while (spfn < end_pfn)
+    {
 		deferred_init_maxorder(&i, zone, &spfn, &epfn);
 		cond_resched();
 	}
@@ -1920,7 +1985,8 @@
 
 	pgdat_resize_lock(pgdat, &flags);
 	first_init_pfn = pgdat->first_deferred_pfn;
-	if (first_init_pfn == ULONG_MAX) {
+    if (first_init_pfn == ULONG_MAX)
+    {
 		pgdat_resize_unlock(pgdat, &flags);
 		pgdat_init_report_one_done();
 		return 0;
@@ -1939,7 +2005,8 @@
 	pgdat_resize_unlock(pgdat, &flags);
 
 	/* Only the highest zone is deferred so find it */
-	for (zid = 0; zid < MAX_NR_ZONES; zid++) {
+    for (zid = 0; zid < MAX_NR_ZONES; zid++)
+    {
 		zone = pgdat->node_zones + zid;
 		if (first_init_pfn < zone_end_pfn(zone))
 			break;
@@ -1952,7 +2019,8 @@
 
 	max_threads = deferred_page_init_max_threads(cpumask);
 
-	while (spfn < epfn) {
+    while (spfn < epfn)
+    {
 		unsigned long epfn_align = ALIGN(epfn, PAGES_PER_SECTION);
 		struct padata_mt_job job = {
 			.thread_fn   = deferred_init_memmap_chunk,
@@ -2014,14 +2082,16 @@
 	 * If someone grew this zone while we were waiting for spinlock, return
 	 * true, as there might be enough pages already.
 	 */
-	if (first_deferred_pfn != pgdat->first_deferred_pfn) {
+    if (first_deferred_pfn != pgdat->first_deferred_pfn)
+    {
 		pgdat_resize_unlock(pgdat, &flags);
 		return true;
 	}
 
 	/* If the zone is empty somebody else may have cleared out the zone */
 	if (!deferred_init_mem_pfn_range_in_zone(&i, zone, &spfn, &epfn,
-						 first_deferred_pfn)) {
+                                             first_deferred_pfn))
+    {
 		pgdat->first_deferred_pfn = ULONG_MAX;
 		pgdat_resize_unlock(pgdat, &flags);
 		/* Retry only once. */
@@ -2033,7 +2103,8 @@
 	 * that we can avoid introducing any issues with the buddy
 	 * allocator.
 	 */
-	while (spfn < epfn) {
+    while (spfn < epfn)
+    {
 		/* update our first deferred PFN for this section */
 		first_deferred_pfn = spfn;
 
@@ -2078,7 +2149,8 @@
 
 	/* There will be num_node_state(N_MEMORY) threads */
 	atomic_set(&pgdat_init_n_undone, num_node_state(N_MEMORY));
-	for_each_node_state(nid, N_MEMORY) {
+    for_each_node_state(nid, N_MEMORY)
+    {
 		kthread_run(deferred_init_memmap, NODE_DATA(nid), "pgdatinit%d", nid);
 	}
 
@@ -2120,22 +2192,27 @@
 	unsigned i = pageblock_nr_pages;
 	struct page *p = page;
 
-	do {
+    do
+    {
 		__ClearPageReserved(p);
 		set_page_count(p, 0);
 	} while (++p, --i);
 
 	set_pageblock_migratetype(page, MIGRATE_CMA);
 
-	if (pageblock_order >= MAX_ORDER) {
+    if (pageblock_order >= MAX_ORDER)
+    {
 		i = pageblock_nr_pages;
 		p = page;
-		do {
+        do
+        {
 			set_page_refcounted(p);
 			__free_pages(p, MAX_ORDER - 1);
 			p += MAX_ORDER_NR_PAGES;
 		} while (i -= MAX_ORDER_NR_PAGES);
-	} else {
+    }
+    else
+    {
 		set_page_refcounted(page);
 		__free_pages(page, pageblock_order);
 	}
@@ -2163,7 +2240,8 @@
 {
 	unsigned long size = 1 << high;
 
-	while (high > low) {
+    while (high > low)
+    {
 		high--;
 		size >>= 1;
 		VM_BUG_ON_PAGE(bad_range(zone, &page[size]), &page[size]);
@@ -2184,7 +2262,8 @@
 
 static void check_new_page_bad(struct page *page)
 {
-	if (unlikely(page->flags & __PG_HWPOISON)) {
+    if (unlikely(page->flags & __PG_HWPOISON))
+    {
 		/* Don't complain about hwpoisoned pages */
 		page_mapcount_reset(page); /* remove PageBuddy */
 		return;
@@ -2210,7 +2289,8 @@
 static inline bool free_pages_prezeroed(void)
 {
 	return (IS_ENABLED(CONFIG_PAGE_POISONING_ZERO) &&
-		page_poisoning_enabled()) || want_init_on_free();
+            page_poisoning_enabled()) ||
+           want_init_on_free();
 }
 
 #ifdef CONFIG_DEBUG_VM
@@ -2253,7 +2333,8 @@
 static bool check_new_pages(struct page *page, unsigned int order)
 {
 	int i;
-	for (i = 0; i < (1 << order); i++) {
+    for (i = 0; i < (1 << order); i++)
+    {
 		struct page *p = page + i;
 
 		if (unlikely(check_new_page(p)))
@@ -2304,8 +2385,7 @@
  * Go through the free lists for the given migratetype and remove
  * the smallest available page from the freelists
  */
-static __always_inline
-struct page *__rmqueue_smallest(struct zone *zone, unsigned int order,
+static __always_inline struct page *__rmqueue_smallest(struct zone *zone, unsigned int order,
 						int migratetype)
 {
 	unsigned int current_order;
@@ -2313,7 +2393,8 @@
 	struct page *page;
 
 	/* Find a page of the appropriate size in the preferred list */
-	for (current_order = order; current_order < MAX_ORDER; ++current_order) {
+    for (current_order = order; current_order < MAX_ORDER; ++current_order)
+    {
 		area = &(zone->free_area[current_order]);
 		page = get_page_from_free_area(area, migratetype);
 		if (!page)
@@ -2352,7 +2432,10 @@
 }
 #else
 static inline struct page *__rmqueue_cma_fallback(struct zone *zone,
-					unsigned int order) { return NULL; }
+                                                  unsigned int order)
+{
+    return NULL;
+}
 #endif
 
 /*
@@ -2368,13 +2451,16 @@
 	unsigned int order;
 	int pages_moved = 0;
 
-	for (page = start_page; page <= end_page;) {
-		if (!pfn_valid_within(page_to_pfn(page))) {
+    for (page = start_page; page <= end_page;)
+    {
+        if (!pfn_valid_within(page_to_pfn(page)))
+        {
 			page++;
 			continue;
 		}
 
-		if (!PageBuddy(page)) {
+        if (!PageBuddy(page))
+        {
 			/*
 			 * We assume that pages that could be isolated for
 			 * migration are movable. But we don't actually try
@@ -2431,7 +2517,8 @@
 {
 	int nr_pageblocks = 1 << (start_order - pageblock_order);
 
-	while (nr_pageblocks--) {
+    while (nr_pageblocks--)
+    {
 		set_pageblock_migratetype(pageblock_page, migratetype);
 		pageblock_page += pageblock_nr_pages;
 	}
@@ -2530,7 +2617,8 @@
 		goto single_page;
 
 	/* Take ownership for orders >= pageblock_order */
-	if (current_order >= pageblock_order) {
+    if (current_order >= pageblock_order)
+    {
 		change_pageblock_range(page, current_order, start_type);
 		goto single_page;
 	}
@@ -2555,9 +2643,12 @@
 	 * For movable allocation, it's the number of movable pages which
 	 * we just obtained. For other types it's a bit more tricky.
 	 */
-	if (start_type == MIGRATE_MOVABLE) {
+    if (start_type == MIGRATE_MOVABLE)
+    {
 		alike_pages = movable_pages;
-	} else {
+    }
+    else
+    {
 		/*
 		 * If we are falling back a RECLAIMABLE or UNMOVABLE allocation
 		 * to MOVABLE pageblock, consider all non-movable pages as
@@ -2566,8 +2657,7 @@
 		 * exact migratetype of non-movable pages.
 		 */
 		if (old_block_type == MIGRATE_MOVABLE)
-			alike_pages = pageblock_nr_pages
-						- (free_pages + movable_pages);
+            alike_pages = pageblock_nr_pages - (free_pages + movable_pages);
 		else
 			alike_pages = 0;
 	}
@@ -2606,7 +2696,8 @@
 		return -1;
 
 	*can_steal = false;
-	for (i = 0;; i++) {
+    for (i = 0;; i++)
+    {
 		fallback_mt = fallbacks[migratetype][i];
 		if (fallback_mt == MIGRATE_TYPES)
 			break;
@@ -2653,8 +2744,8 @@
 
 	/* Yoink! */
 	mt = get_pageblock_migratetype(page);
-	if (!is_migrate_highatomic(mt) && !is_migrate_isolate(mt)
-	    && !is_migrate_cma(mt)) {
+    if (!is_migrate_highatomic(mt) && !is_migrate_isolate(mt) && !is_migrate_cma(mt))
+    {
 		zone->nr_reserved_highatomic += pageblock_nr_pages;
 		set_pageblock_migratetype(page, MIGRATE_HIGHATOMIC);
 		move_freepages_block(zone, page, MIGRATE_HIGHATOMIC, NULL);
@@ -2685,7 +2776,8 @@
 	bool ret;
 
 	for_each_zone_zonelist_nodemask(zone, z, zonelist, ac->highest_zoneidx,
-								ac->nodemask) {
+                                    ac->nodemask)
+    {
 		/*
 		 * Preserve at least one pageblock unless memory pressure
 		 * is really high.
@@ -2695,7 +2787,8 @@
 			continue;
 
 		spin_lock_irqsave(&zone->lock, flags);
-		for (order = 0; order < MAX_ORDER; order++) {
+        for (order = 0; order < MAX_ORDER; order++)
+        {
 			struct free_area *area = &(zone->free_area[order]);
 
 			page = get_page_from_free_area(area, MIGRATE_HIGHATOMIC);
@@ -2709,7 +2802,8 @@
 			 * from highatomic to ac->migratetype. So we should
 			 * adjust the count once.
 			 */
-			if (is_migrate_highatomic_page(page)) {
+            if (is_migrate_highatomic_page(page))
+            {
 				/*
 				 * It should never happen but changes to
 				 * locking could inadvertently allow a per-cpu
@@ -2734,7 +2828,8 @@
 			set_pageblock_migratetype(page, ac->migratetype);
 			ret = move_freepages_block(zone, page, ac->migratetype,
 									NULL);
-			if (ret) {
+            if (ret)
+            {
 				spin_unlock_irqrestore(&zone->lock, flags);
 				return ret;
 			}
@@ -2780,7 +2875,8 @@
 	 * would be too costly to do exactly.
 	 */
 	for (current_order = MAX_ORDER - 1; current_order >= min_order;
-				--current_order) {
+         --current_order)
+    {
 		area = &(zone->free_area[current_order]);
 		fallback_mt = find_suitable_fallback(area, current_order,
 				start_migratetype, false, &can_steal);
@@ -2795,8 +2891,7 @@
 		 * allocation falls back into a different pageblock than this
 		 * one, it won't cause permanent fragmentation.
 		 */
-		if (!can_steal && start_migratetype == MIGRATE_MOVABLE
-					&& current_order > order)
+        if (!can_steal && start_migratetype == MIGRATE_MOVABLE && current_order > order)
 			goto find_smallest;
 
 		goto do_steal;
@@ -2806,7 +2901,8 @@
 
 find_smallest:
 	for (current_order = order; current_order < MAX_ORDER;
-							current_order++) {
+         current_order++)
+    {
 		area = &(zone->free_area[current_order]);
 		fallback_mt = find_suitable_fallback(area, current_order,
 				start_migratetype, false, &can_steal);
@@ -2851,7 +2946,8 @@
 	 */
 	if (alloc_flags & ALLOC_CMA &&
 	    zone_page_state(zone, NR_FREE_CMA_PAGES) >
-	    zone_page_state(zone, NR_FREE_PAGES) / 2) {
+            zone_page_state(zone, NR_FREE_PAGES) / 2)
+    {
 		page = __rmqueue_cma_fallback(zone, order);
 		if (page)
 			return page;
@@ -2859,7 +2955,8 @@
 #endif
 retry:
 	page = __rmqueue_smallest(zone, order, migratetype);
-	if (unlikely(!page)) {
+    if (unlikely(!page))
+    {
 		if (alloc_flags & ALLOC_CMA)
 			page = __rmqueue_cma_fallback(zone, order);
 
@@ -2884,7 +2981,8 @@
 	int i, alloced = 0;
 
 	spin_lock(&zone->lock);
-	for (i = 0; i < count; ++i) {
+    for (i = 0; i < count; ++i)
+    {
 		struct page *page = __rmqueue(zone, order, migratetype,
 								alloc_flags);
 		if (unlikely(page == NULL))
@@ -2977,7 +3075,8 @@
 {
 	struct zone *zone;
 
-	for_each_populated_zone(zone) {
+    for_each_populated_zone(zone)
+    {
 		drain_pages_zone(cpu, zone);
 	}
 }
@@ -3045,7 +3144,8 @@
 	 * a zone. Such callers are primarily CMA and memory hotplug and need
 	 * the drain to be complete when the call returns.
 	 */
-	if (unlikely(!mutex_trylock(&pcpu_drain_mutex))) {
+    if (unlikely(!mutex_trylock(&pcpu_drain_mutex)))
+    {
 		if (!zone)
 			return;
 		mutex_lock(&pcpu_drain_mutex);
@@ -3057,19 +3157,25 @@
 	 * cpu to drain that CPU pcps and on_each_cpu_mask
 	 * disables preemption as part of its processing
 	 */
-	for_each_online_cpu(cpu) {
+    for_each_online_cpu(cpu)
+    {
 		struct per_cpu_pageset *pcp;
 		struct zone *z;
 		bool has_pcps = false;
 
-		if (zone) {
+        if (zone)
+        {
 			pcp = per_cpu_ptr(zone->pageset, cpu);
 			if (pcp->pcp.count)
 				has_pcps = true;
-		} else {
-			for_each_populated_zone(z) {
+        }
+        else
+        {
+            for_each_populated_zone(z)
+            {
 				pcp = per_cpu_ptr(z->pageset, cpu);
-				if (pcp->pcp.count) {
+                if (pcp->pcp.count)
+                {
 					has_pcps = true;
 					break;
 				}
@@ -3082,7 +3188,8 @@
 			cpumask_clear_cpu(cpu, &cpus_with_pcps);
 	}
 
-	for_each_cpu(cpu, &cpus_with_pcps) {
+    for_each_cpu(cpu, &cpus_with_pcps)
+    {
 		struct pcpu_drain *drain = per_cpu_ptr(&pcpu_drain, cpu);
 
 		drain->zone = zone;
@@ -3116,10 +3223,12 @@
 
 	max_zone_pfn = zone_end_pfn(zone);
 	for (pfn = zone->zone_start_pfn; pfn < max_zone_pfn; pfn++)
-		if (pfn_valid(pfn)) {
+        if (pfn_valid(pfn))
+        {
 			page = pfn_to_page(pfn);
 
-			if (!--page_count) {
+            if (!--page_count)
+            {
 				touch_nmi_watchdog();
 				page_count = WD_PAGE_COUNT;
 			}
@@ -3131,14 +3240,18 @@
 				swsusp_unset_page_free(page);
 		}
 
-	for_each_migratetype_order(order, t) {
+    for_each_migratetype_order(order, t)
+    {
 		list_for_each_entry(page,
-				&zone->free_area[order].free_list[t], lru) {
+                            &zone->free_area[order].free_list[t], lru)
+        {
 			unsigned long i;
 
 			pfn = page_to_pfn(page);
-			for (i = 0; i < (1UL << order); i++) {
-				if (!--page_count) {
+            for (i = 0; i < (1UL << order); i++)
+            {
+                if (!--page_count)
+                {
 					touch_nmi_watchdog();
 					page_count = WD_PAGE_COUNT;
 				}
@@ -3178,8 +3291,10 @@
 	 * areas back if necessary. Otherwise, we may have to free
 	 * excessively into the page allocator
 	 */
-	if (migratetype >= MIGRATE_PCPTYPES) {
-		if (unlikely(is_migrate_isolate(migratetype))) {
+    if (migratetype >= MIGRATE_PCPTYPES)
+    {
+        if (unlikely(is_migrate_isolate(migratetype)))
+        {
 			free_one_page(zone, page, pfn, 0, migratetype,
 				      FPI_NONE);
 			return;
@@ -3187,10 +3302,13 @@
 		migratetype = MIGRATE_MOVABLE;
 	}
 
+    ClearPageZeroed(page);
+
 	pcp = &this_cpu_ptr(zone->pageset)->pcp;
 	list_add(&page->lru, &pcp->lists[migratetype]);
 	pcp->count++;
-	if (pcp->count >= pcp->high) {
+    if (pcp->count >= pcp->high)
+    {
 		unsigned long batch = READ_ONCE(pcp->batch);
 		free_pcppages_bulk(zone, batch, pcp);
 	}
@@ -3222,7 +3340,8 @@
 	int batch_count = 0;
 
 	/* Prepare pages for freeing */
-	list_for_each_entry_safe(page, next, list, lru) {
+    list_for_each_entry_safe(page, next, list, lru)
+    {
 		pfn = page_to_pfn(page);
 		if (!free_unref_page_prepare(page, pfn))
 			list_del(&page->lru);
@@ -3230,7 +3349,8 @@
 	}
 
 	local_irq_save(flags);
-	list_for_each_entry_safe(page, next, list, lru) {
+    list_for_each_entry_safe(page, next, list, lru)
+    {
 		unsigned long pfn = page_private(page);
 
 		set_page_private(page, 0);
@@ -3241,7 +3361,8 @@
 		 * Guard against excessive IRQ disabled times when we get
 		 * a large list of pages to free.
 		 */
-		if (++batch_count == SWAP_CLUSTER_MAX) {
+        if (++batch_count == SWAP_CLUSTER_MAX)
+        {
 			local_irq_restore(flags);
 			batch_count = 0;
 			local_irq_save(flags);
@@ -3282,7 +3403,8 @@
 	zone = page_zone(page);
 	mt = get_pageblock_migratetype(page);
 
-	if (!is_migrate_isolate(mt)) {
+    if (!is_migrate_isolate(mt))
+    {
 		/*
 		 * Obey watermarks as if the page was being allocated. We can
 		 * emulate a high-order watermark check with a raised order-0
@@ -3304,12 +3426,13 @@
 	 * Set the pageblock if the isolated page is at least half of a
 	 * pageblock
 	 */
-	if (order >= pageblock_order - 1) {
+    if (order >= pageblock_order - 1)
+    {
 		struct page *endpage = page + (1 << order) - 1;
-		for (; page < endpage; page += pageblock_nr_pages) {
+        for (; page < endpage; page += pageblock_nr_pages)
+        {
 			int mt = get_pageblock_migratetype(page);
-			if (!is_migrate_isolate(mt) && !is_migrate_cma(mt)
-			    && !is_migrate_highatomic(mt))
+            if (!is_migrate_isolate(mt) && !is_migrate_cma(mt) && !is_migrate_highatomic(mt))
 				set_pageblock_migratetype(page,
 							  MIGRATE_MOVABLE);
 		}
@@ -3359,7 +3481,8 @@
 
 	if (zone_to_nid(z) == zone_to_nid(preferred_zone))
 		__inc_numa_state(z, NUMA_HIT);
-	else {
+    else
+    {
 		__inc_numa_state(z, NUMA_MISS);
 		__inc_numa_state(preferred_zone, NUMA_FOREIGN);
 	}
@@ -3375,8 +3498,10 @@
 {
 	struct page *page;
 
-	do {
-		if (list_empty(list)) {
+    do
+    {
+        if (list_empty(list))
+        {
 			pcp->count += rmqueue_bulk(zone, 0,
 					pcp->batch, list,
 					migratetype, alloc_flags);
@@ -3406,7 +3531,8 @@
 	pcp = &this_cpu_ptr(zone->pageset)->pcp;
 	list = &pcp->lists[migratetype];
 	page = __rmqueue_pcplist(zone,  migratetype, alloc_flags, pcp, list);
-	if (page) {
+    if (page)
+    {
 		__count_zid_vm_events(PGALLOC, page_zonenum(page), 1);
 		zone_statistics(preferred_zone, zone);
 	}
@@ -3417,8 +3543,7 @@
 /*
  * Allocate a page from the given zone. Use pcplists for order-0 allocations.
  */
-static inline
-struct page *rmqueue(struct zone *preferred_zone,
+static inline struct page *rmqueue(struct zone *preferred_zone,
 			struct zone *zone, unsigned int order,
 			gfp_t gfp_flags, unsigned int alloc_flags,
 			int migratetype)
@@ -3426,13 +3551,15 @@
 	unsigned long flags;
 	struct page *page;
 
-	if (likely(order == 0)) {
+    if (likely(order == 0))
+    {
 		/*
 		 * MIGRATE_MOVABLE pcplist could have the pages on CMA area and
 		 * we need to skip it when CMA area isn't allowed.
 		 */
 		if (!IS_ENABLED(CONFIG_CMA) || alloc_flags & ALLOC_CMA ||
-				migratetype != MIGRATE_MOVABLE) {
+            migratetype != MIGRATE_MOVABLE)
+        {
 			page = rmqueue_pcplist(preferred_zone, zone, gfp_flags,
 					migratetype, alloc_flags);
 			goto out;
@@ -3446,7 +3573,8 @@
 	WARN_ON_ONCE((gfp_flags & __GFP_NOFAIL) && (order > 1));
 	spin_lock_irqsave(&zone->lock, flags);
 
-	do {
+    do
+    {
 		page = NULL;
 		/*
 		 * order-0 request can reach here when the pcplist is skipped
@@ -3454,7 +3582,8 @@
 		 * reserved for high-order atomic allocation, so order-0
 		 * request should skip it.
 		 */
-		if (order > 0 && alloc_flags & ALLOC_HARDER) {
+        if (order > 0 && alloc_flags & ALLOC_HARDER)
+        {
 			page = __rmqueue_smallest(zone, order, MIGRATE_HIGHATOMIC);
 			if (page)
 				trace_mm_page_alloc_zone_locked(page, order, migratetype);
@@ -3474,7 +3603,8 @@
 
 out:
 	/* Separate test+clear to avoid unnecessary atomics */
-	if (test_bit(ZONE_BOOSTED_WATERMARK, &zone->flags)) {
+    if (test_bit(ZONE_BOOSTED_WATERMARK, &zone->flags))
+    {
 		clear_bit(ZONE_BOOSTED_WATERMARK, &zone->flags);
 		wakeup_kswapd(zone, 0, 0, zone_idx(zone));
 	}
@@ -3489,7 +3619,8 @@
 
 #ifdef CONFIG_FAIL_PAGE_ALLOC
 
-static struct {
+static struct
+{
 	struct fault_attr attr;
 
 	bool ignore_gfp_highmem;
@@ -3604,7 +3735,8 @@
 	if (alloc_flags & ALLOC_HIGH)
 		min -= min / 2;
 
-	if (unlikely(alloc_harder)) {
+    if (unlikely(alloc_harder))
+    {
 		/*
 		 * OOM victims can try even harder than normal ALLOC_HARDER
 		 * users on the grounds that it's definitely going to be in
@@ -3630,21 +3762,24 @@
 		return true;
 
 	/* For a high-order request, check at least one suitable page is free */
-	for (o = order; o < MAX_ORDER; o++) {
+    for (o = order; o < MAX_ORDER; o++)
+    {
 		struct free_area *area = &z->free_area[o];
 		int mt;
 
 		if (!area->nr_free)
 			continue;
 
-		for (mt = 0; mt < MIGRATE_PCPTYPES; mt++) {
+        for (mt = 0; mt < MIGRATE_PCPTYPES; mt++)
+        {
 			if (!free_area_empty(area, mt))
 				return true;
 		}
 
 #ifdef CONFIG_CMA
 		if ((alloc_flags & ALLOC_CMA) &&
-		    !free_area_empty(area, MIGRATE_CMA)) {
+            !free_area_empty(area, MIGRATE_CMA))
+        {
 			return true;
 		}
 #endif
@@ -3673,7 +3808,8 @@
 	 * Fast check for order-0 only. If this fails then the reserves
 	 * need to be calculated.
 	 */
-	if (!order) {
+    if (!order)
+    {
 		long fast_free;
 
 		fast_free = free_pages;
@@ -3691,8 +3827,8 @@
 	 * point where boosting is ignored so that kswapd is woken up
 	 * when below the low watermark.
 	 */
-	if (unlikely(!order && (gfp_mask & __GFP_ATOMIC) && z->watermark_boost
-		&& ((alloc_flags & ALLOC_WMARK_MASK) == WMARK_MIN))) {
+    if (unlikely(!order && (gfp_mask & __GFP_ATOMIC) && z->watermark_boost && ((alloc_flags & ALLOC_WMARK_MASK) == WMARK_MIN)))
+    {
 		mark = z->_watermark[WMARK_MIN];
 		return __zone_watermark_ok(z, order, mark, highest_zoneidx,
 					alloc_flags, free_pages);
@@ -3801,7 +3937,8 @@
 	no_fallback = alloc_flags & ALLOC_NOFRAGMENT;
 	z = ac->preferred_zoneref;
 	for_next_zone_zonelist_nodemask(zone, z, ac->highest_zoneidx,
-					ac->nodemask) {
+                                    ac->nodemask)
+    {
 		struct page *page;
 		unsigned long mark;
 
@@ -3828,18 +3965,21 @@
 		 * will require awareness of nodes in the
 		 * dirty-throttling and the flusher threads.
 		 */
-		if (ac->spread_dirty_pages) {
+        if (ac->spread_dirty_pages)
+        {
 			if (last_pgdat_dirty_limit == zone->zone_pgdat)
 				continue;
 
-			if (!node_dirty_ok(zone->zone_pgdat)) {
+            if (!node_dirty_ok(zone->zone_pgdat))
+            {
 				last_pgdat_dirty_limit = zone->zone_pgdat;
 				continue;
 			}
 		}
 
 		if (no_fallback && nr_online_nodes > 1 &&
-		    zone != ac->preferred_zoneref->zone) {
+            zone != ac->preferred_zoneref->zone)
+        {
 			int local_nid;
 
 			/*
@@ -3848,7 +3988,8 @@
 			 * than fragmentation avoidance.
 			 */
 			local_nid = zone_to_nid(ac->preferred_zoneref->zone);
-			if (zone_to_nid(zone) != local_nid) {
+            if (zone_to_nid(zone) != local_nid)
+            {
 				alloc_flags &= ~ALLOC_NOFRAGMENT;
 				goto retry;
 			}
@@ -3857,7 +3998,8 @@
 		mark = wmark_pages(zone, alloc_flags & ALLOC_WMARK_MASK);
 		if (!zone_watermark_fast(zone, order, mark,
 				       ac->highest_zoneidx, alloc_flags,
-				       gfp_mask)) {
+                                 gfp_mask))
+        {
 			int ret;
 
 #ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT
@@ -3865,7 +4007,8 @@
 			 * Watermark failed for this zone, but see if we can
 			 * grow this zone if it contains deferred pages.
 			 */
-			if (static_branch_unlikely(&deferred_pages)) {
+            if (static_branch_unlikely(&deferred_pages))
+            {
 				if (_deferred_grow_zone(zone, order))
 					goto try_this_zone;
 			}
@@ -3880,7 +4023,8 @@
 				continue;
 
 			ret = node_reclaim(zone->zone_pgdat, gfp_mask, order);
-			switch (ret) {
+            switch (ret)
+            {
 			case NODE_RECLAIM_NOSCAN:
 				/* did not scan */
 				continue;
@@ -3900,7 +4044,8 @@
 try_this_zone:
 		page = rmqueue(ac->preferred_zoneref->zone, zone, order,
 				gfp_mask, alloc_flags, ac->migratetype);
-		if (page) {
+        if (page)
+        {
 			prep_new_page(page, order, gfp_mask, alloc_flags);
 
 			/*
@@ -3911,10 +4056,13 @@
 				reserve_highatomic_pageblock(page, zone, order);
 
 			return page;
-		} else {
+        }
+        else
+        {
 #ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT
 			/* Try again if zone has deferred pages */
-			if (static_branch_unlikely(&deferred_pages)) {
+            if (static_branch_unlikely(&deferred_pages))
+            {
 				if (_deferred_grow_zone(zone, order))
 					goto try_this_zone;
 			}
@@ -3926,7 +4074,8 @@
 	 * It's possible on a UMA machine to get through all zones that are
 	 * fragmented. If avoiding fragmentation, reset and try again.
 	 */
-	if (no_fallback) {
+    if (no_fallback)
+    {
 		alloc_flags &= ~ALLOC_NOFRAGMENT;
 		goto retry;
 	}
@@ -4015,7 +4164,8 @@
 	 * Acquire the oom lock.  If that fails, somebody else is
 	 * making progress for us.
 	 */
-	if (!mutex_trylock(&oom_lock)) {
+    if (!mutex_trylock(&oom_lock))
+    {
 		*did_some_progress = 1;
 		schedule_timeout_uninterruptible(1);
 		return NULL;
@@ -4029,7 +4179,8 @@
 	 * allocation which will never fail due to oom_lock already held.
 	 */
 	page = get_page_from_freelist((gfp_mask | __GFP_HARDWALL) &
-				      ~__GFP_DIRECT_RECLAIM, order,
+                                      ~__GFP_DIRECT_RECLAIM,
+                                  order,
 				      ALLOC_WMARK_HIGH|ALLOC_CPUSET, ac);
 	if (page)
 		goto out;
@@ -4066,7 +4217,8 @@
 	 */
 
 	/* Exhausted what can be done so it's blame time */
-	if (out_of_memory(&oc) || WARN_ON_ONCE(gfp_mask & __GFP_NOFAIL)) {
+    if (out_of_memory(&oc) || WARN_ON_ONCE(gfp_mask & __GFP_NOFAIL))
+    {
 		*did_some_progress = 1;
 
 		/*
@@ -4125,7 +4277,8 @@
 	if (!page)
 		page = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);
 
-	if (page) {
+    if (page)
+    {
 		struct zone *zone = page_zone(page);
 
 		zone->compact_blockskip_flush = false;
@@ -4175,7 +4328,8 @@
 	 * compaction was skipped because there are not enough order-0 pages
 	 * to work with, so we retry only if it looks like reclaim can help.
 	 */
-	if (compaction_needs_reclaim(compact_result)) {
+    if (compaction_needs_reclaim(compact_result))
+    {
 		ret = compaction_zonelist_suitable(ac, order, alloc_flags);
 		goto out;
 	}
@@ -4186,7 +4340,8 @@
 	 * But the next retry should use a higher priority if allowed, so
 	 * we don't just keep bailing out endlessly.
 	 */
-	if (compaction_withdrawn(compact_result)) {
+    if (compaction_withdrawn(compact_result))
+    {
 		goto check_priority;
 	}
 
@@ -4200,7 +4355,8 @@
 	 */
 	if (order > PAGE_ALLOC_COSTLY_ORDER)
 		max_retries /= 4;
-	if (*compaction_retries <= max_retries) {
+    if (*compaction_retries <= max_retries)
+    {
 		ret = true;
 		goto out;
 	}
@@ -4210,10 +4366,10 @@
 	 * all retries or failed at the lower priorities.
 	 */
 check_priority:
-	min_priority = (order > PAGE_ALLOC_COSTLY_ORDER) ?
-			MIN_COMPACT_COSTLY_PRIORITY : MIN_COMPACT_PRIORITY;
+    min_priority = (order > PAGE_ALLOC_COSTLY_ORDER) ? MIN_COMPACT_COSTLY_PRIORITY : MIN_COMPACT_PRIORITY;
 
-	if (*compact_priority > min_priority) {
+    if (*compact_priority > min_priority)
+    {
 		(*compact_priority)--;
 		*compaction_retries = 0;
 		ret = true;
@@ -4251,7 +4407,8 @@
 	 * watermarks are OK.
 	 */
 	for_each_zone_zonelist_nodemask(zone, z, ac->zonelist,
-				ac->highest_zoneidx, ac->nodemask) {
+                                    ac->highest_zoneidx, ac->nodemask)
+    {
 		if (zone_watermark_ok(zone, 0, min_wmark_pages(zone),
 					ac->highest_zoneidx, alloc_flags))
 			return true;
@@ -4360,7 +4517,8 @@
 	 * pages are pinned on the per-cpu lists or in high alloc reserves.
 	 * Shrink them and try again
 	 */
-	if (!page && !drained) {
+    if (!page && !drained)
+    {
 		unreserve_highatomic_pageblock(ac, false);
 		drain_all_pages(NULL);
 		drained = true;
@@ -4379,7 +4537,8 @@
 	enum zone_type highest_zoneidx = ac->highest_zoneidx;
 
 	for_each_zone_zonelist_nodemask(zone, z, ac->zonelist, highest_zoneidx,
-					ac->nodemask) {
+                                    ac->nodemask)
+    {
 		if (last_pgdat != zone->zone_pgdat)
 			wakeup_kswapd(zone, gfp_mask, order, highest_zoneidx);
 		last_pgdat = zone->zone_pgdat;
@@ -4405,10 +4564,10 @@
 	 * policy or is asking for __GFP_HIGH memory.  GFP_ATOMIC requests will
 	 * set both ALLOC_HARDER (__GFP_ATOMIC) and ALLOC_HIGH (__GFP_HIGH).
 	 */
-	alloc_flags |= (__force int)
-		(gfp_mask & (__GFP_HIGH | __GFP_KSWAPD_RECLAIM));
+    alloc_flags |= (__force int)(gfp_mask & (__GFP_HIGH | __GFP_KSWAPD_RECLAIM));
 
-	if (gfp_mask & __GFP_ATOMIC) {
+    if (gfp_mask & __GFP_ATOMIC)
+    {
 		/*
 		 * Not worth trying to allocate harder for __GFP_NOMEMALLOC even
 		 * if it can't schedule.
@@ -4420,7 +4579,8 @@
 		 * comment for __cpuset_node_allowed().
 		 */
 		alloc_flags &= ~ALLOC_CPUSET;
-	} else if (unlikely(rt_task(current)) && !in_interrupt())
+    }
+    else if (unlikely(rt_task(current)) && !in_interrupt())
 		alloc_flags |= ALLOC_HARDER;
 
 	alloc_flags = current_alloc_flags(gfp_mask, alloc_flags);
@@ -4455,7 +4615,8 @@
 		return ALLOC_NO_WATERMARKS;
 	if (in_serving_softirq() && (current->flags & PF_MEMALLOC))
 		return ALLOC_NO_WATERMARKS;
-	if (!in_interrupt()) {
+    if (!in_interrupt())
+    {
 		if (current->flags & PF_MEMALLOC)
 			return ALLOC_NO_WATERMARKS;
 		else if (oom_reserves_allowed(current))
@@ -4503,7 +4664,8 @@
 	 * Make sure we converge to OOM if we cannot make any progress
 	 * several times in the row.
 	 */
-	if (*no_progress_loops > MAX_RECLAIM_RETRIES) {
+    if (*no_progress_loops > MAX_RECLAIM_RETRIES)
+    {
 		/* Before OOM, exhaust highatomic_reserve */
 		return unreserve_highatomic_pageblock(ac, true);
 	}
@@ -4515,7 +4677,8 @@
 	 * screwed and have to go OOM.
 	 */
 	for_each_zone_zonelist_nodemask(zone, z, ac->zonelist,
-				ac->highest_zoneidx, ac->nodemask) {
+                                    ac->highest_zoneidx, ac->nodemask)
+    {
 		unsigned long available;
 		unsigned long reclaimable;
 		unsigned long min_wmark = min_wmark_pages(zone);
@@ -4532,20 +4695,23 @@
 				ac->highest_zoneidx, alloc_flags, available);
 		trace_reclaim_retry_zone(z, order, reclaimable,
 				available, min_wmark, *no_progress_loops, wmark);
-		if (wmark) {
+        if (wmark)
+        {
 			/*
 			 * If we didn't make any progress and have a lot of
 			 * dirty + writeback pages then we should wait for
 			 * an IO to complete to slow down the reclaim and
 			 * prevent from pre mature OOM
 			 */
-			if (!did_some_progress) {
+            if (!did_some_progress)
+            {
 				unsigned long write_pending;
 
 				write_pending = zone_page_state_snapshot(zone,
 							NR_ZONE_WRITE_PENDING);
 
-				if (2 * write_pending > reclaimable) {
+                if (2 * write_pending > reclaimable)
+                {
 					congestion_wait(BLK_RW_ASYNC, HZ/10);
 					return true;
 				}
@@ -4586,7 +4752,8 @@
 	 * caller can deal with a violated nodemask.
 	 */
 	if (cpusets_enabled() && ac->nodemask &&
-			!cpuset_nodemask_valid_mems_allowed(ac->nodemask)) {
+        !cpuset_nodemask_valid_mems_allowed(ac->nodemask))
+    {
 		ac->nodemask = NULL;
 		return true;
 	}
@@ -4674,8 +4841,9 @@
 	 */
 	if (can_direct_reclaim &&
 			(costly_order ||
-			   (order > 0 && ac->migratetype != MIGRATE_MOVABLE))
-			&& !gfp_pfmemalloc_allowed(gfp_mask)) {
+         (order > 0 && ac->migratetype != MIGRATE_MOVABLE)) &&
+        !gfp_pfmemalloc_allowed(gfp_mask))
+    {
 		page = __alloc_pages_direct_compact(gfp_mask, order,
 						alloc_flags, ac,
 						INIT_COMPACT_PRIORITY,
@@ -4687,7 +4855,8 @@
 		 * Checks for costly allocations with __GFP_NORETRY, which
 		 * includes some THP page fault allocations
 		 */
-		if (costly_order && (gfp_mask & __GFP_NORETRY)) {
+        if (costly_order && (gfp_mask & __GFP_NORETRY))
+        {
 			/*
 			 * If allocating entire pageblock(s) and compaction
 			 * failed because all zones are below low watermarks
@@ -4732,7 +4901,8 @@
 	 * ignored. These allocations are high priority and system rather than
 	 * user oriented.
 	 */
-	if (!(alloc_flags & ALLOC_CPUSET) || reserve_flags) {
+    if (!(alloc_flags & ALLOC_CPUSET) || reserve_flags)
+    {
 		ac->nodemask = NULL;
 		ac->preferred_zoneref = first_zones_zonelist(ac->zonelist,
 					ac->highest_zoneidx, ac->nodemask);
@@ -4807,7 +4976,8 @@
 		goto nopage;
 
 	/* Retry as long as the OOM killer is making progress */
-	if (did_some_progress) {
+    if (did_some_progress)
+    {
 		no_progress_loops = 0;
 		goto retry;
 	}
@@ -4821,7 +4991,8 @@
 	 * Make sure that __GFP_NOFAIL request doesn't leak out and make sure
 	 * we always retry
 	 */
-	if (gfp_mask & __GFP_NOFAIL) {
+    if (gfp_mask & __GFP_NOFAIL)
+    {
 		/*
 		 * All existing users of the __GFP_NOFAIL are blockable, so warn
 		 * of any new users that actually require GFP_NOWAIT
@@ -4874,7 +5045,8 @@
 	ac->nodemask = nodemask;
 	ac->migratetype = gfp_migratetype(gfp_mask);
 
-	if (cpusets_enabled()) {
+    if (cpusets_enabled())
+    {
 		*alloc_mask |= __GFP_HARDWALL;
 		/*
 		 * When we are in the interrupt context, it is irrelevant
@@ -4926,7 +5098,8 @@
 	 * There are several places where we assume that the order value is sane
 	 * so bail out early if the request is out of bound.
 	 */
-	if (unlikely(order >= MAX_ORDER)) {
+    if (unlikely(order >= MAX_ORDER))
+    {
 		WARN_ON_ONCE(!(gfp_mask & __GFP_NOWARN));
 		return NULL;
 	}
@@ -4966,7 +5139,8 @@
 
 out:
 	if (memcg_kmem_enabled() && (gfp_mask & __GFP_ACCOUNT) && page &&
-	    unlikely(__memcg_kmem_charge_page(page, gfp_mask, order) != 0)) {
+        unlikely(__memcg_kmem_charge_page(page, gfp_mask, order) != 0))
+    {
 		__free_pages(page, order);
 		page = NULL;
 	}
@@ -5019,7 +5193,8 @@
 
 void free_pages(unsigned long addr, unsigned int order)
 {
-	if (addr != 0) {
+    if (addr != 0)
+    {
 		VM_BUG_ON(!virt_addr_valid((void *)addr));
 		__free_pages(virt_to_page((void *)addr), order);
 	}
@@ -5075,7 +5250,8 @@
 	struct page *page;
 	int offset;
 
-	if (unlikely(!nc->va)) {
+    if (unlikely(!nc->va))
+    {
 refill:
 		page = __page_frag_cache_refill(nc, gfp_mask);
 		if (!page)
@@ -5097,13 +5273,15 @@
 	}
 
 	offset = nc->offset - fragsz;
-	if (unlikely(offset < 0)) {
+    if (unlikely(offset < 0))
+    {
 		page = virt_to_page(nc->va);
 
 		if (!page_ref_sub_and_test(page, nc->pagecnt_bias))
 			goto refill;
 
-		if (unlikely(nc->pfmemalloc)) {
+        if (unlikely(nc->pfmemalloc))
+        {
 			free_the_page(page, compound_order(page));
 			goto refill;
 		}
@@ -5142,12 +5320,14 @@
 static void *make_alloc_exact(unsigned long addr, unsigned int order,
 		size_t size)
 {
-	if (addr) {
+    if (addr)
+    {
 		unsigned long alloc_end = addr + (PAGE_SIZE << order);
 		unsigned long used = addr + PAGE_ALIGN(size);
 
 		split_page(virt_to_page((void *)addr), order);
-		while (used < alloc_end) {
+        while (used < alloc_end)
+        {
 			free_page(used);
 			used += PAGE_SIZE;
 		}
@@ -5221,7 +5401,8 @@
 	unsigned long addr = (unsigned long)virt;
 	unsigned long end = addr + PAGE_ALIGN(size);
 
-	while (addr < end) {
+    while (addr < end)
+    {
 		free_page(addr);
 		addr += PAGE_SIZE;
 	}
@@ -5250,7 +5431,8 @@
 
 	struct zonelist *zonelist = node_zonelist(numa_node_id(), GFP_KERNEL);
 
-	for_each_zone_zonelist(zone, z, zonelist, offset) {
+    for_each_zone_zonelist(zone, z, zonelist, offset)
+    {
 		unsigned long size = zone_managed_pages(zone);
 		unsigned long high = high_wmark_pages(zone);
 		if (size > high)
@@ -5355,10 +5537,12 @@
 	val->sharedram = node_page_state(pgdat, NR_SHMEM);
 	val->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);
 #ifdef CONFIG_HIGHMEM
-	for (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {
+    for (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)
+    {
 		struct zone *zone = &pgdat->node_zones[zone_type];
 
-		if (is_highmem(zone)) {
+        if (is_highmem(zone))
+        {
 			managed_highpages += zone_managed_pages(zone);
 			free_highpages += zone_page_state(zone, NR_FREE_PAGES);
 		}
@@ -5413,7 +5597,8 @@
 	char *p = tmp;
 	int i;
 
-	for (i = 0; i < MIGRATE_TYPES; i++) {
+    for (i = 0; i < MIGRATE_TYPES; i++)
+    {
 		if (type & (1 << i))
 			*p++ = types[i];
 	}
@@ -5438,7 +5623,8 @@
 	struct zone *zone;
 	pg_data_t *pgdat;
 
-	for_each_populated_zone(zone) {
+    for_each_populated_zone(zone)
+    {
 		if (show_mem_node_skip(filter, zone_to_nid(zone), nodemask))
 			continue;
 
@@ -5471,7 +5657,8 @@
 		free_pcp,
 		global_zone_page_state(NR_FREE_CMA_PAGES));
 
-	for_each_online_pgdat(pgdat) {
+    for_each_online_pgdat(pgdat)
+    {
 		if (show_mem_node_skip(filter, pgdat->node_id, nodemask))
 			continue;
 
@@ -5513,8 +5700,7 @@
 			K(node_page_state(pgdat, NR_SHMEM)),
 #ifdef CONFIG_TRANSPARENT_HUGEPAGE
 			K(node_page_state(pgdat, NR_SHMEM_THPS) * HPAGE_PMD_NR),
-			K(node_page_state(pgdat, NR_SHMEM_PMDMAPPED)
-					* HPAGE_PMD_NR),
+               K(node_page_state(pgdat, NR_SHMEM_PMDMAPPED) * HPAGE_PMD_NR),
 			K(node_page_state(pgdat, NR_ANON_THPS) * HPAGE_PMD_NR),
 #endif
 			K(node_page_state(pgdat, NR_WRITEBACK_TEMP)),
@@ -5522,11 +5708,11 @@
 #ifdef CONFIG_SHADOW_CALL_STACK
 			node_page_state(pgdat, NR_KERNEL_SCS_KB),
 #endif
-			pgdat->kswapd_failures >= MAX_RECLAIM_RETRIES ?
-				"yes" : "no");
+               pgdat->kswapd_failures >= MAX_RECLAIM_RETRIES ? "yes" : "no");
 	}
 
-	for_each_populated_zone(zone) {
+    for_each_populated_zone(zone)
+    {
 		int i;
 
 		if (show_mem_node_skip(filter, zone_to_nid(zone), nodemask))
@@ -5585,7 +5771,8 @@
 		printk(KERN_CONT "\n");
 	}
 
-	for_each_populated_zone(zone) {
+    for_each_populated_zone(zone)
+    {
 		unsigned int order;
 		unsigned long nr[MAX_ORDER], flags, total = 0;
 		unsigned char types[MAX_ORDER];
@@ -5596,7 +5783,8 @@
 		printk(KERN_CONT "%s: ", zone->name);
 
 		spin_lock_irqsave(&zone->lock, flags);
-		for (order = 0; order < MAX_ORDER; order++) {
+        for (order = 0; order < MAX_ORDER; order++)
+        {
 			struct free_area *area = &zone->free_area[order];
 			int type;
 
@@ -5604,13 +5792,15 @@
 			total += nr[order] << order;
 
 			types[order] = 0;
-			for (type = 0; type < MIGRATE_TYPES; type++) {
+            for (type = 0; type < MIGRATE_TYPES; type++)
+            {
 				if (!free_area_empty(area, type))
 					types[order] |= 1 << type;
 			}
 		}
 		spin_unlock_irqrestore(&zone->lock, flags);
-		for (order = 0; order < MAX_ORDER; order++) {
+        for (order = 0; order < MAX_ORDER; order++)
+        {
 			printk(KERN_CONT "%lu*%lukB ",
 			       nr[order], K(1UL) << order);
 			if (nr[order])
@@ -5643,10 +5833,12 @@
 	enum zone_type zone_type = MAX_NR_ZONES;
 	int nr_zones = 0;
 
-	do {
+    do
+    {
 		zone_type--;
 		zone = pgdat->node_zones + zone_type;
-		if (managed_zone(zone)) {
+        if (managed_zone(zone))
+        {
 			zoneref_set_zone(zone, &zonerefs[nr_zones++]);
 			check_highest_zone(zone_type);
 		}
@@ -5665,7 +5857,8 @@
 	 * if somebody still use the cmd line parameter so that we do
 	 * not fail it silently
 	 */
-	if (!(*s == 'd' || *s == 'D' || *s == 'n' || *s == 'N')) {
+    if (!(*s == 'd' || *s == 'D' || *s == 'n' || *s == 'N'))
+    {
 		pr_warn("Ignoring unsupported numa_zonelist_order value:  %s\n", s);
 		return -EINVAL;
 	}
@@ -5711,12 +5903,14 @@
 	int best_node = NUMA_NO_NODE;
 
 	/* Use the local node if we haven't already */
-	if (!node_isset(node, *used_node_mask)) {
+    if (!node_isset(node, *used_node_mask))
+    {
 		node_set(node, *used_node_mask);
 		return node;
 	}
 
-	for_each_node_state(n, N_MEMORY) {
+    for_each_node_state(n, N_MEMORY)
+    {
 
 		/* Don't want a node to appear more than once */
 		if (node_isset(n, *used_node_mask))
@@ -5736,7 +5930,8 @@
 		val *= (MAX_NODE_LOAD*MAX_NUMNODES);
 		val += node_load[n];
 
-		if (val < min_val) {
+        if (val < min_val)
+        {
 			min_val = val;
 			best_node = n;
 		}
@@ -5762,7 +5956,8 @@
 
 	zonerefs = pgdat->node_zonelists[ZONELIST_FALLBACK]._zonerefs;
 
-	for (i = 0; i < nr_nodes; i++) {
+    for (i = 0; i < nr_nodes; i++)
+    {
 		int nr_zones;
 
 		pg_data_t *node = NODE_DATA(node_order[i]);
@@ -5809,7 +6004,8 @@
 	prev_node = local_node;
 
 	memset(node_order, 0, sizeof(node_order));
-	while ((node = find_next_best_node(local_node, &used_mask)) >= 0) {
+    while ((node = find_next_best_node(local_node, &used_mask)) >= 0)
+    {
 		/*
 		 * We don't want to pressure a particular node.
 		 * So adding penalty to the first node in same
@@ -5870,13 +6066,15 @@
 	 * zones coming right after the local ones are those from
 	 * node N+1 (modulo N)
 	 */
-	for (node = local_node + 1; node < MAX_NUMNODES; node++) {
+    for (node = local_node + 1; node < MAX_NUMNODES; node++)
+    {
 		if (!node_online(node))
 			continue;
 		nr_zones = build_zonerefs_node(NODE_DATA(node), zonerefs);
 		zonerefs += nr_zones;
 	}
-	for (node = 0; node < local_node; node++) {
+    for (node = 0; node < local_node; node++)
+    {
 		if (!node_online(node))
 			continue;
 		nr_zones = build_zonerefs_node(NODE_DATA(node), zonerefs);
@@ -5925,10 +6123,14 @@
 	 * This node is hotadded and no memory is yet present.   So just
 	 * building zonelists is fine - no need to touch other nodes.
 	 */
-	if (self && !node_online(self->node_id)) {
+    if (self && !node_online(self->node_id))
+    {
 		build_zonelists(self);
-	} else {
-		for_each_online_node(nid) {
+    }
+    else
+    {
+        for_each_online_node(nid)
+        {
 			pg_data_t *pgdat = NODE_DATA(nid);
 
 			build_zonelists(pgdat);
@@ -5988,9 +6190,12 @@
 {
 	unsigned long vm_total_pages;
 
-	if (system_state == SYSTEM_BOOTING) {
+    if (system_state == SYSTEM_BOOTING)
+    {
 		build_all_zonelists_init();
-	} else {
+    }
+    else
+    {
 		__build_all_zonelists(pgdat);
 		/* cpuset refresh routine should be here */
 	}
@@ -6023,15 +6228,19 @@
 {
 	static struct memblock_region *r;
 
-	if (mirrored_kernelcore && zone == ZONE_MOVABLE) {
-		if (!r || *pfn >= memblock_region_memory_end_pfn(r)) {
-			for_each_mem_region(r) {
+    if (mirrored_kernelcore && zone == ZONE_MOVABLE)
+    {
+        if (!r || *pfn >= memblock_region_memory_end_pfn(r))
+        {
+            for_each_mem_region(r)
+            {
 				if (*pfn < memblock_region_memory_end_pfn(r))
 					break;
 			}
 		}
 		if (*pfn >= memblock_region_memory_base_pfn(r) &&
-		    memblock_is_mirror(r)) {
+            memblock_is_mirror(r))
+        {
 			*pfn = memblock_region_memory_end_pfn(r);
 			return true;
 		}
@@ -6067,7 +6276,8 @@
 	 * ZONE_DEVICE page initialization until after we have released
 	 * the hotplug lock.
 	 */
-	if (zone == ZONE_DEVICE) {
+    if (zone == ZONE_DEVICE)
+    {
 		if (!altmap)
 			return;
 
@@ -6077,12 +6287,14 @@
 	}
 #endif
 
-	for (pfn = start_pfn; pfn < end_pfn; ) {
+    for (pfn = start_pfn; pfn < end_pfn;)
+    {
 		/*
 		 * There can be holes in boot-time mem_map[]s handed to this
 		 * function.  They do not exist on hotplugged memory.
 		 */
-		if (context == MEMINIT_EARLY) {
+        if (context == MEMINIT_EARLY)
+        {
 			if (overlap_memmap_init(zone, &pfn))
 				continue;
 			if (defer_init(nid, pfn, end_pfn))
@@ -6099,7 +6311,8 @@
 		 * such that unmovable allocations won't be scattered all
 		 * over the place during system boot.
 		 */
-		if (IS_ALIGNED(pfn, pageblock_nr_pages)) {
+        if (IS_ALIGNED(pfn, pageblock_nr_pages))
+        {
 			set_pageblock_migratetype(page, migratetype);
 			cond_resched();
 		}
@@ -6128,12 +6341,14 @@
 	 * of the pages reserved for the memmap, so we can just jump to
 	 * the end of that region and start processing the device pages.
 	 */
-	if (altmap) {
+    if (altmap)
+    {
 		start_pfn = altmap->base_pfn + vmem_altmap_offset(altmap);
 		nr_pages = end_pfn - start_pfn;
 	}
 
-	for (pfn = start_pfn; pfn < end_pfn; pfn++) {
+    for (pfn = start_pfn; pfn < end_pfn; pfn++)
+    {
 		struct page *page = pfn_to_page(pfn);
 
 		__init_single_page(page, pfn, zone_idx, nid);
@@ -6165,7 +6380,8 @@
 		 * Please note that MEMINIT_HOTPLUG path doesn't clear memmap
 		 * because this is done early in section_activate()
 		 */
-		if (IS_ALIGNED(pfn, pageblock_nr_pages)) {
+        if (IS_ALIGNED(pfn, pageblock_nr_pages))
+        {
 			set_pageblock_migratetype(page, MIGRATE_MOVABLE);
 			cond_resched();
 		}
@@ -6179,7 +6395,8 @@
 static void __meminit zone_init_free_lists(struct zone *zone)
 {
 	unsigned int order, t;
-	for_each_migratetype_order(order, t) {
+    for_each_migratetype_order(order, t)
+    {
 		INIT_LIST_HEAD(&zone->free_area[order].free_list[t]);
 		zone->free_area[order].nr_free = 0;
 	}
@@ -6193,11 +6410,13 @@
 	unsigned long range_end_pfn = range_start_pfn + size;
 	int i;
 
-	for_each_mem_pfn_range(i, nid, &start_pfn, &end_pfn, NULL) {
+    for_each_mem_pfn_range(i, nid, &start_pfn, &end_pfn, NULL)
+    {
 		start_pfn = clamp(start_pfn, range_start_pfn, range_end_pfn);
 		end_pfn = clamp(end_pfn, range_start_pfn, range_end_pfn);
 
-		if (end_pfn > start_pfn) {
+        if (end_pfn > start_pfn)
+        {
 			size = end_pfn - start_pfn;
 			memmap_init_zone(size, nid, zone, start_pfn,
 					 MEMINIT_EARLY, NULL, MIGRATE_MOVABLE);
@@ -6366,7 +6585,8 @@
 	 * Otherwise, they will end up skewing the stats of
 	 * the nodes these zones are associated with.
 	 */
-	for_each_possible_cpu(cpu) {
+    for_each_possible_cpu(cpu)
+    {
 		struct per_cpu_pageset *pcp = &per_cpu(boot_pageset, cpu);
 		memset(pcp->vm_numa_stat_diff, 0,
 		       sizeof(pcp->vm_numa_stat_diff));
@@ -6435,7 +6655,8 @@
 	*start_pfn = -1UL;
 	*end_pfn = 0;
 
-	for_each_mem_pfn_range(i, nid, &this_start_pfn, &this_end_pfn, NULL) {
+    for_each_mem_pfn_range(i, nid, &this_start_pfn, &this_end_pfn, NULL)
+    {
 		*start_pfn = min(*start_pfn, this_start_pfn);
 		*end_pfn = max(*end_pfn, this_end_pfn);
 	}
@@ -6452,7 +6673,8 @@
 static void __init find_usable_zone_for_movable(void)
 {
 	int zone_index;
-	for (zone_index = MAX_NR_ZONES - 1; zone_index >= 0; zone_index--) {
+    for (zone_index = MAX_NR_ZONES - 1; zone_index >= 0; zone_index--)
+    {
 		if (zone_index == ZONE_MOVABLE)
 			continue;
 
@@ -6483,21 +6705,26 @@
 					unsigned long *zone_end_pfn)
 {
 	/* Only adjust if ZONE_MOVABLE is on this node */
-	if (zone_movable_pfn[nid]) {
+    if (zone_movable_pfn[nid])
+    {
 		/* Size ZONE_MOVABLE */
-		if (zone_type == ZONE_MOVABLE) {
+        if (zone_type == ZONE_MOVABLE)
+        {
 			*zone_start_pfn = zone_movable_pfn[nid];
 			*zone_end_pfn = min(node_end_pfn,
 				arch_zone_highest_possible_pfn[movable_zone]);
 
 		/* Adjust for ZONE_MOVABLE starting within this range */
-		} else if (!mirrored_kernelcore &&
+        }
+        else if (!mirrored_kernelcore &&
 			*zone_start_pfn < zone_movable_pfn[nid] &&
-			*zone_end_pfn > zone_movable_pfn[nid]) {
+                 *zone_end_pfn > zone_movable_pfn[nid])
+        {
 			*zone_end_pfn = zone_movable_pfn[nid];
 
 		/* Check if this whole range is within ZONE_MOVABLE */
-		} else if (*zone_start_pfn >= zone_movable_pfn[nid])
+        }
+        else if (*zone_start_pfn >= zone_movable_pfn[nid])
 			*zone_start_pfn = *zone_end_pfn;
 	}
 }
@@ -6550,7 +6777,8 @@
 	unsigned long start_pfn, end_pfn;
 	int i;
 
-	for_each_mem_pfn_range(i, nid, &start_pfn, &end_pfn, NULL) {
+    for_each_mem_pfn_range(i, nid, &start_pfn, &end_pfn, NULL)
+    {
 		start_pfn = clamp(start_pfn, range_start_pfn, range_end_pfn);
 		end_pfn = clamp(end_pfn, range_start_pfn, range_end_pfn);
 		nr_absent -= end_pfn - start_pfn;
@@ -6599,11 +6827,13 @@
 	 * Treat pages to be ZONE_MOVABLE in ZONE_NORMAL as absent pages
 	 * and vice versa.
 	 */
-	if (mirrored_kernelcore && zone_movable_pfn[nid]) {
+    if (mirrored_kernelcore && zone_movable_pfn[nid])
+    {
 		unsigned long start_pfn, end_pfn;
 		struct memblock_region *r;
 
-		for_each_mem_region(r) {
+        for_each_mem_region(r)
+        {
 			start_pfn = clamp(memblock_region_memory_base_pfn(r),
 					  zone_start_pfn, zone_end_pfn);
 			end_pfn = clamp(memblock_region_memory_end_pfn(r),
@@ -6629,7 +6859,8 @@
 	unsigned long realtotalpages = 0, totalpages = 0;
 	enum zone_type i;
 
-	for (i = 0; i < MAX_NR_ZONES; i++) {
+    for (i = 0; i < MAX_NR_ZONES; i++)
+    {
 		struct zone *zone = pgdat->node_zones + i;
 		unsigned long zone_start_pfn, zone_end_pfn;
 		unsigned long spanned, absent;
@@ -6692,7 +6923,8 @@
 {
 	unsigned long usemapsize = usemap_size(zone_start_pfn, zonesize);
 	zone->pageblock_flags = NULL;
-	if (usemapsize) {
+    if (usemapsize)
+    {
 		zone->pageblock_flags =
 			memblock_alloc_node(usemapsize, SMP_CACHE_BYTES,
 					    pgdat->node_id);
@@ -6703,7 +6935,9 @@
 }
 #else
 static inline void setup_usemap(struct pglist_data *pgdat, struct zone *zone,
-				unsigned long zone_start_pfn, unsigned long zonesize) {}
+                                unsigned long zone_start_pfn, unsigned long zonesize)
+{
+}
 #endif /* CONFIG_SPARSEMEM */
 
 #ifdef CONFIG_HUGETLB_PAGE_SIZE_VARIABLE
@@ -6773,7 +7007,9 @@
 	ds_queue->split_queue_len = 0;
 }
 #else
-static void pgdat_init_split_queue(struct pglist_data *pgdat) {}
+static void pgdat_init_split_queue(struct pglist_data *pgdat)
+{
+}
 #endif
 
 #ifdef CONFIG_COMPACTION
@@ -6782,7 +7018,9 @@
 	init_waitqueue_head(&pgdat->kcompactd_wait);
 }
 #else
-static void pgdat_init_kcompactd(struct pglist_data *pgdat) {}
+static void pgdat_init_kcompactd(struct pglist_data *pgdat)
+{
+}
 #endif
 
 static void __meminit pgdat_init_internals(struct pglist_data *pgdat)
@@ -6848,7 +7086,8 @@
 	pgdat_init_internals(pgdat);
 	pgdat->per_cpu_nodestats = &boot_nodestats;
 
-	for (j = 0; j < MAX_NR_ZONES; j++) {
+    for (j = 0; j < MAX_NR_ZONES; j++)
+    {
 		struct zone *zone = pgdat->node_zones + j;
 		unsigned long size, freesize, memmap_pages;
 		unsigned long zone_start_pfn = zone->zone_start_pfn;
@@ -6862,20 +7101,24 @@
 		 * and per-cpu initialisations
 		 */
 		memmap_pages = calc_memmap_size(size, freesize);
-		if (!is_highmem_idx(j)) {
-			if (freesize >= memmap_pages) {
+        if (!is_highmem_idx(j))
+        {
+            if (freesize >= memmap_pages)
+            {
 				freesize -= memmap_pages;
 				if (memmap_pages)
 					printk(KERN_DEBUG
 					       "  %s zone: %lu pages used for memmap\n",
 					       zone_names[j], memmap_pages);
-			} else
+            }
+            else
 				pr_warn("  %s zone: %lu pages exceeds freesize %lu\n",
 					zone_names[j], memmap_pages, freesize);
 		}
 
 		/* Account for reserved pages */
-		if (j == 0 && freesize > dma_reserve) {
+        if (j == 0 && freesize > dma_reserve)
+        {
 			freesize -= dma_reserve;
 			printk(KERN_DEBUG "  %s zone: %lu pages reserved\n",
 					zone_names[0], dma_reserve);
@@ -6918,7 +7161,8 @@
 	start = pgdat->node_start_pfn & ~(MAX_ORDER_NR_PAGES - 1);
 	offset = pgdat->node_start_pfn - start;
 	/* ia64 gets its own node_mem_map, before this, without bootmem */
-	if (!pgdat->node_mem_map) {
+    if (!pgdat->node_mem_map)
+    {
 		unsigned long size, end;
 		struct page *map;
 
@@ -6944,7 +7188,8 @@
 	/*
 	 * With no DISCONTIG, the global mem_map is just set as node 0's
 	 */
-	if (pgdat == NODE_DATA(0)) {
+    if (pgdat == NODE_DATA(0))
+    {
 		mem_map = NODE_DATA(0)->node_mem_map;
 		if (page_to_pfn(mem_map) != pgdat->node_start_pfn)
 			mem_map -= offset;
@@ -6952,7 +7197,9 @@
 #endif
 }
 #else
-static void __ref alloc_node_mem_map(struct pglist_data *pgdat) { }
+static void __ref alloc_node_mem_map(struct pglist_data *pgdat)
+{
+}
 #endif /* CONFIG_FLAT_NODE_MEM_MAP */
 
 #ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT
@@ -6961,7 +7208,9 @@
 	pgdat->first_deferred_pfn = ULONG_MAX;
 }
 #else
-static inline void pgdat_set_deferred_range(pg_data_t *pgdat) {}
+static inline void pgdat_set_deferred_range(pg_data_t *pgdat)
+{
+}
 #endif
 
 static void __init free_area_init_node(int nid)
@@ -7005,10 +7254,11 @@
 	unsigned long pfn;
 	u64 pgcnt = 0;
 
-	for (pfn = spfn; pfn < epfn; pfn++) {
-		if (!pfn_valid(ALIGN_DOWN(pfn, pageblock_nr_pages))) {
-			pfn = ALIGN_DOWN(pfn, pageblock_nr_pages)
-				+ pageblock_nr_pages - 1;
+    for (pfn = spfn; pfn < epfn; pfn++)
+    {
+        if (!pfn_valid(ALIGN_DOWN(pfn, pageblock_nr_pages)))
+        {
+            pfn = ALIGN_DOWN(pfn, pageblock_nr_pages) + pageblock_nr_pages - 1;
 			continue;
 		}
 		/*
@@ -7047,7 +7297,8 @@
 	 * Loop through unavailable ranges not covered by memblock.memory.
 	 */
 	pgcnt = 0;
-	for_each_mem_range(i, &start, &end) {
+    for_each_mem_range(i, &start, &end)
+    {
 		if (next < start)
 			pgcnt += init_unavailable_range(PFN_DOWN(next),
 							PFN_UP(start));
@@ -7116,8 +7367,10 @@
 	int last_nid = NUMA_NO_NODE;
 	int i, nid;
 
-	for_each_mem_pfn_range(i, MAX_NUMNODES, &start, &end, &nid) {
-		if (!start || last_nid < 0 || last_nid == nid) {
+    for_each_mem_pfn_range(i, MAX_NUMNODES, &start, &end, &nid)
+    {
+        if (!start || last_nid < 0 || last_nid == nid)
+        {
 			last_nid = nid;
 			last_end = end;
 			continue;
@@ -7162,7 +7415,8 @@
 	unsigned long start_pfn, end_pfn;
 	int i, nid;
 
-	for_each_mem_pfn_range(i, MAX_NUMNODES, &start_pfn, &end_pfn, &nid) {
+    for_each_mem_pfn_range(i, MAX_NUMNODES, &start_pfn, &end_pfn, &nid)
+    {
 		unsigned long pages = end_pfn - start_pfn;
 
 		totalpages += pages;
@@ -7196,17 +7450,17 @@
 	 * If movable_node is specified, ignore kernelcore and movablecore
 	 * options.
 	 */
-	if (movable_node_is_enabled()) {
-		for_each_mem_region(r) {
+    if (movable_node_is_enabled())
+    {
+        for_each_mem_region(r)
+        {
 			if (!memblock_is_hotpluggable(r))
 				continue;
 
 			nid = memblock_get_region_node(r);
 
 			usable_startpfn = PFN_DOWN(r->base);
-			zone_movable_pfn[nid] = zone_movable_pfn[nid] ?
-				min(usable_startpfn, zone_movable_pfn[nid]) :
-				usable_startpfn;
+            zone_movable_pfn[nid] = zone_movable_pfn[nid] ? min(usable_startpfn, zone_movable_pfn[nid]) : usable_startpfn;
 		}
 
 		goto out2;
@@ -7215,10 +7469,12 @@
 	/*
 	 * If kernelcore=mirror is specified, ignore movablecore option
 	 */
-	if (mirrored_kernelcore) {
+    if (mirrored_kernelcore)
+    {
 		bool mem_below_4gb_not_mirrored = false;
 
-		for_each_mem_region(r) {
+        for_each_mem_region(r)
+        {
 			if (memblock_is_mirror(r))
 				continue;
 
@@ -7226,14 +7482,13 @@
 
 			usable_startpfn = memblock_region_memory_base_pfn(r);
 
-			if (usable_startpfn < 0x100000) {
+            if (usable_startpfn < 0x100000)
+            {
 				mem_below_4gb_not_mirrored = true;
 				continue;
 			}
 
-			zone_movable_pfn[nid] = zone_movable_pfn[nid] ?
-				min(usable_startpfn, zone_movable_pfn[nid]) :
-				usable_startpfn;
+            zone_movable_pfn[nid] = zone_movable_pfn[nid] ? min(usable_startpfn, zone_movable_pfn[nid]) : usable_startpfn;
 		}
 
 		if (mem_below_4gb_not_mirrored)
@@ -7261,7 +7516,8 @@
 	 * will be used for required_kernelcore if it's greater than
 	 * what movablecore would have allowed.
 	 */
-	if (required_movablecore) {
+    if (required_movablecore)
+    {
 		unsigned long corepages;
 
 		/*
@@ -7289,7 +7545,8 @@
 restart:
 	/* Spread kernelcore memory as evenly as possible throughout nodes */
 	kernelcore_node = required_kernelcore / usable_nodes;
-	for_each_node_state(nid, N_MEMORY) {
+    for_each_node_state(nid, N_MEMORY)
+    {
 		unsigned long start_pfn, end_pfn;
 
 		/*
@@ -7308,7 +7565,8 @@
 		kernelcore_remaining = kernelcore_node;
 
 		/* Go through each range of PFNs within this node */
-		for_each_mem_pfn_range(i, nid, &start_pfn, &end_pfn, NULL) {
+        for_each_mem_pfn_range(i, nid, &start_pfn, &end_pfn, NULL)
+        {
 			unsigned long size_pages;
 
 			start_pfn = max(start_pfn, zone_movable_pfn[nid]);
@@ -7316,10 +7574,10 @@
 				continue;
 
 			/* Account for what is only usable for kernelcore */
-			if (start_pfn < usable_startpfn) {
+            if (start_pfn < usable_startpfn)
+            {
 				unsigned long kernel_pages;
-				kernel_pages = min(end_pfn, usable_startpfn)
-								- start_pfn;
+                kernel_pages = min(end_pfn, usable_startpfn) - start_pfn;
 
 				kernelcore_remaining -= min(kernel_pages,
 							kernelcore_remaining);
@@ -7327,7 +7585,8 @@
 							required_kernelcore);
 
 				/* Continue if range is now fully accounted */
-				if (end_pfn <= usable_startpfn) {
+                if (end_pfn <= usable_startpfn)
+                {
 
 					/*
 					 * Push zone_movable_pfn to the end so
@@ -7390,9 +7649,11 @@
 {
 	enum zone_type zone_type;
 
-	for (zone_type = 0; zone_type <= ZONE_MOVABLE - 1; zone_type++) {
+    for (zone_type = 0; zone_type <= ZONE_MOVABLE - 1; zone_type++)
+    {
 		struct zone *zone = &pgdat->node_zones[zone_type];
-		if (populated_zone(zone)) {
+        if (populated_zone(zone))
+        {
 			if (IS_ENABLED(CONFIG_HIGHMEM))
 				node_set_state(nid, N_HIGH_MEMORY);
 			if (zone_type <= ZONE_NORMAL)
@@ -7439,7 +7700,8 @@
 	start_pfn = find_min_pfn_with_active_regions();
 	descending = arch_has_descending_max_zone_pfns();
 
-	for (i = 0; i < MAX_NR_ZONES; i++) {
+    for (i = 0; i < MAX_NR_ZONES; i++)
+    {
 		if (descending)
 			zone = MAX_NR_ZONES - i - 1;
 		else
@@ -7461,7 +7723,8 @@
 
 	/* Print out the zone ranges */
 	pr_info("Zone ranges:\n");
-	for (i = 0; i < MAX_NR_ZONES; i++) {
+    for (i = 0; i < MAX_NR_ZONES; i++)
+    {
 		if (i == ZONE_MOVABLE)
 			continue;
 		pr_info("  %-8s ", zone_names[i]);
@@ -7473,12 +7736,14 @@
 				(u64)arch_zone_lowest_possible_pfn[i]
 					<< PAGE_SHIFT,
 				((u64)arch_zone_highest_possible_pfn[i]
-					<< PAGE_SHIFT) - 1);
+                     << PAGE_SHIFT) -
+                        1);
 	}
 
 	/* Print out the PFNs ZONE_MOVABLE begins at in each node */
 	pr_info("Movable zone start for each node\n");
-	for (i = 0; i < MAX_NUMNODES; i++) {
+    for (i = 0; i < MAX_NUMNODES; i++)
+    {
 		if (zone_movable_pfn[i])
 			pr_info("  Node %d: %#018Lx\n", i,
 			       (u64)zone_movable_pfn[i] << PAGE_SHIFT);
@@ -7490,7 +7755,8 @@
 	 * enable future "sub-section" extensions of the memory map.
 	 */
 	pr_info("Early memory node ranges\n");
-	for_each_mem_pfn_range(i, MAX_NUMNODES, &start_pfn, &end_pfn, &nid) {
+    for_each_mem_pfn_range(i, MAX_NUMNODES, &start_pfn, &end_pfn, &nid)
+    {
 		pr_info("  node %3d: [mem %#018Lx-%#018Lx]\n", nid,
 			(u64)start_pfn << PAGE_SHIFT,
 			((u64)end_pfn << PAGE_SHIFT) - 1);
@@ -7501,7 +7767,8 @@
 	mminit_verify_pageflags_layout();
 	setup_nr_node_ids();
 	init_unavailable_mem();
-	for_each_online_node(nid) {
+    for_each_online_node(nid)
+    {
 		pg_data_t *pgdat = NODE_DATA(nid);
 		free_area_init_node(nid);
 
@@ -7523,12 +7790,15 @@
 
 	/* Value may be a percentage of total memory, otherwise bytes */
 	coremem = simple_strtoull(p, &endptr, 0);
-	if (*endptr == '%') {
+    if (*endptr == '%')
+    {
 		/* Paranoid check for percent values greater than 100 */
 		WARN_ON(coremem > 100);
 
 		*percent = coremem;
-	} else {
+    }
+    else
+    {
 		coremem = memparse(p, &p);
 		/* Paranoid check that UL is enough for the coremem value */
 		WARN_ON((coremem >> PAGE_SHIFT) > ULONG_MAX);
@@ -7546,7 +7816,8 @@
 static int __init cmdline_parse_kernelcore(char *p)
 {
 	/* parse kernelcore=mirror */
-	if (parse_option_str(p, "mirror")) {
+    if (parse_option_str(p, "mirror"))
+    {
 		mirrored_kernelcore = true;
 		return 0;
 	}
@@ -7586,7 +7857,8 @@
 
 	start = (void *)PAGE_ALIGN((unsigned long)start);
 	end = (void *)((unsigned long)end & PAGE_MASK);
-	for (pos = start; pos < end; pos += PAGE_SIZE, pages++) {
+    for (pos = start; pos < end; pos += PAGE_SIZE, pages++)
+    {
 		struct page *page = virt_to_page(pos);
 		void *direct_map_addr;
 
@@ -7643,7 +7914,8 @@
 	 * 3) .rodata.* may be embedded into .text or .data sections.
 	 */
 #define adj_init_size(start, end, size, pos, adj) \
-	do { \
+    do                                               \
+    {                                                \
 		if (start <= pos && pos < end && size > adj) \
 			size -= adj; \
 	} while (0)
@@ -7753,17 +8025,20 @@
 	unsigned long reserve_pages = 0;
 	enum zone_type i, j;
 
-	for_each_online_pgdat(pgdat) {
+    for_each_online_pgdat(pgdat)
+    {
 
 		pgdat->totalreserve_pages = 0;
 
-		for (i = 0; i < MAX_NR_ZONES; i++) {
+        for (i = 0; i < MAX_NR_ZONES; i++)
+        {
 			struct zone *zone = pgdat->node_zones + i;
 			long max = 0;
 			unsigned long managed_pages = zone_managed_pages(zone);
 
 			/* Find valid and maximum lowmem_reserve in the zone */
-			for (j = i; j < MAX_NR_ZONES; j++) {
+            for (j = i; j < MAX_NR_ZONES; j++)
+            {
 				if (zone->lowmem_reserve[j] > max)
 					max = zone->lowmem_reserve[j];
 			}
@@ -7793,25 +8068,31 @@
 	struct pglist_data *pgdat;
 	enum zone_type j, idx;
 
-	for_each_online_pgdat(pgdat) {
-		for (j = 0; j < MAX_NR_ZONES; j++) {
+    for_each_online_pgdat(pgdat)
+    {
+        for (j = 0; j < MAX_NR_ZONES; j++)
+        {
 			struct zone *zone = pgdat->node_zones + j;
 			unsigned long managed_pages = zone_managed_pages(zone);
 
 			zone->lowmem_reserve[j] = 0;
 
 			idx = j;
-			while (idx) {
+            while (idx)
+            {
 				struct zone *lower_zone;
 
 				idx--;
 				lower_zone = pgdat->node_zones + idx;
 
 				if (!sysctl_lowmem_reserve_ratio[idx] ||
-				    !zone_managed_pages(lower_zone)) {
+                    !zone_managed_pages(lower_zone))
+                {
 					lower_zone->lowmem_reserve[j] = 0;
 					continue;
-				} else {
+                }
+                else
+                {
 					lower_zone->lowmem_reserve[j] =
 						managed_pages / sysctl_lowmem_reserve_ratio[idx];
 				}
@@ -7832,18 +8113,21 @@
 	unsigned long flags;
 
 	/* Calculate total number of !ZONE_HIGHMEM pages */
-	for_each_zone(zone) {
+    for_each_zone(zone)
+    {
 		if (!is_highmem(zone))
 			lowmem_pages += zone_managed_pages(zone);
 	}
 
-	for_each_zone(zone) {
+    for_each_zone(zone)
+    {
 		u64 tmp;
 
 		spin_lock_irqsave(&zone->lock, flags);
 		tmp = (u64)pages_min * zone_managed_pages(zone);
 		do_div(tmp, lowmem_pages);
-		if (is_highmem(zone)) {
+        if (is_highmem(zone))
+        {
 			/*
 			 * __GFP_HIGH and PF_MEMALLOC allocations usually don't
 			 * need highmem pages, so cap pages_min to a small
@@ -7858,7 +8142,9 @@
 			min_pages = zone_managed_pages(zone) / 1024;
 			min_pages = clamp(min_pages, SWAP_CLUSTER_MAX, 128UL);
 			zone->_watermark[WMARK_MIN] = min_pages;
-		} else {
+        }
+        else
+        {
 			/*
 			 * If it's a lowmem zone, reserve a number of pages
 			 * proportionate to the zone's size.
@@ -7934,13 +8220,16 @@
 	lowmem_kbytes = nr_free_buffer_pages() * (PAGE_SIZE >> 10);
 	new_min_free_kbytes = int_sqrt(lowmem_kbytes * 16);
 
-	if (new_min_free_kbytes > user_min_free_kbytes) {
+    if (new_min_free_kbytes > user_min_free_kbytes)
+    {
 		min_free_kbytes = new_min_free_kbytes;
 		if (min_free_kbytes < 128)
 			min_free_kbytes = 128;
 		if (min_free_kbytes > 262144)
 			min_free_kbytes = 262144;
-	} else {
+    }
+    else
+    {
 		pr_warn("min_free_kbytes is not updated to %d because user defined value %d is preferred\n",
 				new_min_free_kbytes, user_min_free_kbytes);
 	}
@@ -7973,7 +8262,8 @@
 	if (rc)
 		return rc;
 
-	if (write) {
+    if (write)
+    {
 		user_min_free_kbytes = min_free_kbytes;
 		setup_per_zone_wmarks();
 	}
@@ -8006,10 +8296,10 @@
 
 	for_each_zone(zone)
 		zone->zone_pgdat->min_unmapped_pages += (zone_managed_pages(zone) *
-						         sysctl_min_unmapped_ratio) / 100;
+                                                 sysctl_min_unmapped_ratio) /
+                                                100;
 }
 
-
 int sysctl_min_unmapped_ratio_sysctl_handler(struct ctl_table *table, int write,
 		void *buffer, size_t *length, loff_t *ppos)
 {
@@ -8034,7 +8324,8 @@
 
 	for_each_zone(zone)
 		zone->zone_pgdat->min_slab_pages += (zone_managed_pages(zone) *
-						     sysctl_min_slab_ratio) / 100;
+                                             sysctl_min_slab_ratio) /
+                                            100;
 }
 
 int sysctl_min_slab_ratio_sysctl_handler(struct ctl_table *table, int write,
@@ -8068,7 +8359,8 @@
 
 	proc_dointvec_minmax(table, write, buffer, length, ppos);
 
-	for (i = 0; i < MAX_NR_ZONES; i++) {
+    for (i = 0; i < MAX_NR_ZONES; i++)
+    {
 		if (sysctl_lowmem_reserve_ratio[i] < 1)
 			sysctl_lowmem_reserve_ratio[i] = 0;
 	}
@@ -8107,7 +8399,8 @@
 
 	/* Sanity checking to avoid pcp imbalance */
 	if (percpu_pagelist_fraction &&
-	    percpu_pagelist_fraction < MIN_PERCPU_PAGELIST_FRACTION) {
+        percpu_pagelist_fraction < MIN_PERCPU_PAGELIST_FRACTION)
+    {
 		percpu_pagelist_fraction = old_percpu_pagelist_fraction;
 		ret = -EINVAL;
 		goto out;
@@ -8173,7 +8466,8 @@
 	bool virt;
 
 	/* allow the kernel cmdline to have a say */
-	if (!numentries) {
+    if (!numentries)
+    {
 		/* round applicable memory size up to nearest megabyte */
 		numentries = nr_kernel_pages;
 		numentries -= arch_reserved_kernel_pages();
@@ -8183,7 +8477,8 @@
 			numentries = round_up(numentries, (1<<20)/PAGE_SIZE);
 
 #if __BITS_PER_LONG > 32
-		if (!high_limit) {
+        if (!high_limit)
+        {
 			unsigned long adapt;
 
 			for (adapt = ADAPT_SCALE_NPAGES; adapt < numentries;
@@ -8199,20 +8494,24 @@
 			numentries <<= (PAGE_SHIFT - scale);
 
 		/* Make sure we've got at least a 0-order allocation.. */
-		if (unlikely(flags & HASH_SMALL)) {
+        if (unlikely(flags & HASH_SMALL))
+        {
 			/* Makes no sense without HASH_EARLY */
 			WARN_ON(!(flags & HASH_EARLY));
-			if (!(numentries >> *_hash_shift)) {
+            if (!(numentries >> *_hash_shift))
+            {
 				numentries = 1UL << *_hash_shift;
 				BUG_ON(!numentries);
 			}
-		} else if (unlikely((numentries * bucketsize) < PAGE_SIZE))
+        }
+        else if (unlikely((numentries * bucketsize) < PAGE_SIZE))
 			numentries = PAGE_SIZE / bucketsize;
 	}
 	numentries = roundup_pow_of_two(numentries);
 
 	/* limit allocation size to 1/16 total memory by default */
-	if (max == 0) {
+    if (max == 0)
+    {
 		max = ((unsigned long long)nr_all_pages << PAGE_SHIFT) >> 4;
 		do_div(max, bucketsize);
 	}
@@ -8226,19 +8525,25 @@
 	log2qty = ilog2(numentries);
 
 	gfp_flags = (flags & HASH_ZERO) ? GFP_ATOMIC | __GFP_ZERO : GFP_ATOMIC;
-	do {
+    do
+    {
 		virt = false;
 		size = bucketsize << log2qty;
-		if (flags & HASH_EARLY) {
+        if (flags & HASH_EARLY)
+        {
 			if (flags & HASH_ZERO)
 				table = memblock_alloc(size, SMP_CACHE_BYTES);
 			else
 				table = memblock_alloc_raw(size,
 							   SMP_CACHE_BYTES);
-		} else if (get_order(size) >= MAX_ORDER || hashdist) {
+        }
+        else if (get_order(size) >= MAX_ORDER || hashdist)
+        {
 			table = __vmalloc(size, gfp_flags);
 			virt = true;
-		} else {
+        }
+        else
+        {
 			/*
 			 * If bucketsize is not a power-of-two, we may free
 			 * some pages at the end of hash table which
@@ -8284,7 +8589,8 @@
 	unsigned long pfn = page_to_pfn(page);
 	unsigned long offset = pfn % pageblock_nr_pages;
 
-	if (is_migrate_cma_page(page)) {
+    if (is_migrate_cma_page(page))
+    {
 		/*
 		 * CMA allocations (alloc_contig_range) really need to mark
 		 * isolate CMA pageblocks even when they are not movable in fact
@@ -8296,7 +8602,8 @@
 		return page;
 	}
 
-	for (; iter < pageblock_nr_pages - offset; iter++) {
+    for (; iter < pageblock_nr_pages - offset; iter++)
+    {
 		if (!pfn_valid_within(pfn + iter))
 			continue;
 
@@ -8325,14 +8632,18 @@
 		 * We need not scan over tail pages because we don't
 		 * handle each tail page individually in migration.
 		 */
-		if (PageHuge(page) || PageTransCompound(page)) {
+        if (PageHuge(page) || PageTransCompound(page))
+        {
 			struct page *head = compound_head(page);
 			unsigned int skip_pages;
 
-			if (PageHuge(page)) {
+            if (PageHuge(page))
+            {
 				if (!hugepage_migration_supported(page_hstate(head)))
 					return page;
-			} else if (!PageLRU(head) && !__PageMovable(head)) {
+            }
+            else if (!PageLRU(head) && !__PageMovable(head))
+            {
 				return page;
 			}
 
@@ -8347,7 +8658,8 @@
 		 * This check already skips compound tails of THP
 		 * because their page->_refcount is zero at all time.
 		 */
-		if (!page_ref_count(page)) {
+        if (!page_ref_count(page))
+        {
 			if (PageBuddy(page))
 				iter += (1 << buddy_order(page)) - 1;
 			continue;
@@ -8390,7 +8702,8 @@
 static unsigned long pfn_max_align_down(unsigned long pfn)
 {
 	return pfn & ~(max_t(unsigned long, MAX_ORDER_NR_PAGES,
-			     pageblock_nr_pages) - 1);
+                         pageblock_nr_pages) -
+                   1);
 }
 
 static unsigned long pfn_max_align_up(unsigned long pfn)
@@ -8415,21 +8728,27 @@
 
 	migrate_prep();
 
-	while (pfn < end || !list_empty(&cc->migratepages)) {
-		if (fatal_signal_pending(current)) {
+    while (pfn < end || !list_empty(&cc->migratepages))
+    {
+        if (fatal_signal_pending(current))
+        {
 			ret = -EINTR;
 			break;
 		}
 
-		if (list_empty(&cc->migratepages)) {
+        if (list_empty(&cc->migratepages))
+        {
 			cc->nr_migratepages = 0;
 			pfn = isolate_migratepages_range(cc, pfn, end);
-			if (!pfn) {
+            if (!pfn)
+            {
 				ret = -EINTR;
 				break;
 			}
 			tries = 0;
-		} else if (++tries == 5) {
+        }
+        else if (++tries == 5)
+        {
 			ret = ret < 0 ? ret : -EBUSY;
 			break;
 		}
@@ -8441,7 +8760,8 @@
 		ret = migrate_pages(&cc->migratepages, alloc_migration_target,
 				NULL, (unsigned long)&mtc, cc->mode, MR_CONTIG_RANGE);
 	}
-	if (ret < 0) {
+    if (ret < 0)
+    {
 		putback_movable_pages(&cc->migratepages);
 		return ret;
 	}
@@ -8553,15 +8873,18 @@
 
 	order = 0;
 	outer_start = start;
-	while (!PageBuddy(pfn_to_page(outer_start))) {
-		if (++order >= MAX_ORDER) {
+    while (!PageBuddy(pfn_to_page(outer_start)))
+    {
+        if (++order >= MAX_ORDER)
+        {
 			outer_start = start;
 			break;
 		}
 		outer_start &= ~0UL << order;
 	}
 
-	if (outer_start != start) {
+    if (outer_start != start)
+    {
 		order = buddy_order(pfn_to_page(outer_start));
 
 		/*
@@ -8575,7 +8898,8 @@
 	}
 
 	/* Make sure the range is really isolated. */
-	if (test_pages_isolated(outer_start, end, 0)) {
+    if (test_pages_isolated(outer_start, end, 0))
+    {
 		pr_info_ratelimited("%s: [%lx, %lx) PFNs busy\n",
 			__func__, outer_start, end);
 		ret = -EBUSY;
@@ -8584,7 +8908,8 @@
 
 	/* Grab isolated pages from freelists. */
 	outer_end = isolate_freepages_range(&cc, outer_start, end);
-	if (!outer_end) {
+    if (!outer_end)
+    {
 		ret = -EBUSY;
 		goto done;
 	}
@@ -8617,7 +8942,8 @@
 	unsigned long i, end_pfn = start_pfn + nr_pages;
 	struct page *page;
 
-	for (i = start_pfn; i < end_pfn; i++) {
+    for (i = start_pfn; i < end_pfn; i++)
+    {
 		page = pfn_to_online_page(i);
 		if (!page)
 			return false;
@@ -8676,12 +9002,15 @@
 
 	zonelist = node_zonelist(nid, gfp_mask);
 	for_each_zone_zonelist_nodemask(zone, z, zonelist,
-					gfp_zone(gfp_mask), nodemask) {
+                                    gfp_zone(gfp_mask), nodemask)
+    {
 		spin_lock_irqsave(&zone->lock, flags);
 
 		pfn = ALIGN(zone->zone_start_pfn, nr_pages);
-		while (zone_spans_last_pfn(zone, pfn, nr_pages)) {
-			if (pfn_range_valid_contig(zone, pfn, nr_pages)) {
+        while (zone_spans_last_pfn(zone, pfn, nr_pages))
+        {
+            if (pfn_range_valid_contig(zone, pfn, nr_pages))
+            {
 				/*
 				 * We release the zone lock here because
 				 * alloc_contig_range() will also lock the zone
@@ -8708,7 +9037,8 @@
 {
 	unsigned int count = 0;
 
-	for (; nr_pages--; pfn++) {
+    for (; nr_pages--; pfn++)
+    {
 		struct page *page = pfn_to_page(pfn);
 
 		count += page_count(page) != 1;
@@ -8737,8 +9067,10 @@
 
 	/* avoid races with drain_pages()  */
 	local_irq_save(flags);
-	if (zone->pageset != &boot_pageset) {
-		for_each_online_cpu(cpu) {
+    if (zone->pageset != &boot_pageset)
+    {
+        for_each_online_cpu(cpu)
+        {
 			pset = per_cpu_ptr(zone->pageset, cpu);
 			drain_zonestat(zone, pset);
 		}
@@ -8764,13 +9096,15 @@
 	offline_mem_sections(pfn, end_pfn);
 	zone = page_zone(pfn_to_page(pfn));
 	spin_lock_irqsave(&zone->lock, flags);
-	while (pfn < end_pfn) {
+    while (pfn < end_pfn)
+    {
 		page = pfn_to_page(pfn);
 		/*
 		 * The HWPoisoned page may be not in buddy system, and
 		 * page_count() is not 0.
 		 */
-		if (unlikely(!PageBuddy(page) && PageHWPoison(page))) {
+        if (unlikely(!PageBuddy(page) && PageHWPoison(page)))
+        {
 			pfn++;
 			continue;
 		}
@@ -8778,7 +9112,8 @@
 		 * At this point all remaining PageOffline() pages have a
 		 * reference count of 0 and can simply be skipped.
 		 */
-		if (PageOffline(page)) {
+        if (PageOffline(page))
+        {
 			BUG_ON(page_count(page));
 			BUG_ON(PageBuddy(page));
 			pfn++;
@@ -8803,7 +9138,8 @@
 	unsigned int order;
 
 	spin_lock_irqsave(&zone->lock, flags);
-	for (order = 0; order < MAX_ORDER; order++) {
+    for (order = 0; order < MAX_ORDER; order++)
+    {
 		struct page *page_head = page - (pfn & ((1 << order) - 1));
 
 		if (PageBuddy(page_head) && buddy_order(page_head) >= order)
@@ -8826,14 +9162,18 @@
 	unsigned long size = 1 << high;
 	struct page *current_buddy, *next_page;
 
-	while (high > low) {
+    while (high > low)
+    {
 		high--;
 		size >>= 1;
 
-		if (target >= &page[size]) {
+        if (target >= &page[size])
+        {
 			next_page = page + size;
 			current_buddy = page;
-		} else {
+        }
+        else
+        {
 			next_page = page;
 			current_buddy = page + size;
 		}
@@ -8841,7 +9181,8 @@
 		if (set_page_guard(zone, current_buddy, high, migratetype))
 			continue;
 
-		if (current_buddy != target) {
+        if (current_buddy != target)
+        {
 			add_to_free_list(current_buddy, zone, high, migratetype);
 			set_buddy_order(current_buddy, high);
 			page = next_page;
@@ -8861,11 +9202,13 @@
 	bool ret = false;
 
 	spin_lock_irqsave(&zone->lock, flags);
-	for (order = 0; order < MAX_ORDER; order++) {
+    for (order = 0; order < MAX_ORDER; order++)
+    {
 		struct page *page_head = page - (pfn & ((1 << order) - 1));
 		int page_order = buddy_order(page_head);
 
-		if (PageBuddy(page_head) && page_order >= order) {
+        if (PageBuddy(page_head) && page_order >= order)
+        {
 			unsigned long pfn_head = page_to_pfn(page_head);
 			int migratetype = get_pfnblock_migratetype(page_head,
 								   pfn_head);
diff --color -ruN -w -B '--exclude-from=.diff-exclude' linux-5.10/mm/vmstat.c HawkEye-5.10-cow/mm/vmstat.c
--- linux-5.10/mm/vmstat.c	2020-12-13 22:41:30.000000000 +0000
+++ HawkEye-5.10-cow/mm/vmstat.c	2025-03-23 07:53:49.813582445 +0000
@@ -1714,7 +1714,7 @@
 	.show	= zoneinfo_show,
 };
 
-#define NR_VMSTAT_ITEMS (NR_VM_ZONE_STAT_ITEMS + \
+#define NR_VMSTAT_ITEMS (500 + NR_VM_ZONE_STAT_ITEMS + \
 			 NR_VM_NUMA_STAT_ITEMS + \
 			 NR_VM_NODE_STAT_ITEMS + \
 			 NR_VM_WRITEBACK_STAT_ITEMS + \
@@ -1724,13 +1724,15 @@
 static void *vmstat_start(struct seq_file *m, loff_t *pos)
 {
 	unsigned long *v;
-	int i;
+	int i, stat_items_size;
 
 	if (*pos >= NR_VMSTAT_ITEMS)
 		return NULL;
 
-	BUILD_BUG_ON(ARRAY_SIZE(vmstat_text) < NR_VMSTAT_ITEMS);
-	v = kmalloc_array(NR_VMSTAT_ITEMS, sizeof(unsigned long), GFP_KERNEL);
+	//BUILD_BUG_ON(ARRAY_SIZE(vmstat_text) < NR_VMSTAT_ITEMS);
+	stat_items_size = ARRAY_SIZE(vmstat_text);
+        //v = kmalloc_array(NR_VMSTAT_ITEMS, sizeof(unsigned long), GFP_KERNEL);
+        v = kmalloc_array(stat_items_size, sizeof(unsigned long), GFP_KERNEL);
 	m->private = v;
 	if (!v)
 		return ERR_PTR(-ENOMEM);
diff --color -ruN -w -B '--exclude-from=.diff-exclude' linux-5.10/README.md HawkEye-5.10-cow/README.md
--- linux-5.10/README.md	1970-01-01 00:00:00.000000000 +0000
+++ HawkEye-5.10-cow/README.md	2025-03-23 07:53:29.734107119 +0000
@@ -0,0 +1,86 @@
+## 1 Installation of HawkEye based on Linux 5.10
+
+* Download and unzip the 5.10 linux kernel source code.
+
+  ```bash
+  cd ~
+  # Download
+  wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.10.tar.xz
+  # Unzip
+  tar -xvf linux-5.10.tar.xz
+  ```
+
+* Change the code of the memory deduplication module to the code of HawkEye.
+
+  ```bash
+  git clone https://github.com/ustcadsl/SmartMD.git
+  cp SmartMD/kernel-v5.10/HawkEye/Makefile linux-5.10/
+  cp SmartMD/kernel-v5.10/HawkEye/.config linux-5.10/
+  cp SmartMD/kernel-v5.10/HawkEye/mm/*  linux-5.10/mm
+  cp SmartMD/kernel-v5.10/HawkEye/kernel/fork.c linux-5.10/kernel
+  cp SmartMD/kernel-v5.10/HawkEye/include/linux/* linux-5.10/include/linux
+  cp SmartMD/kernel-v5.10/HawkEye/events/mmflags.h linux-5.10/events
+  cp SmartMD/kernel-v5.10/HawkEye/arch/x86/entry/syscalls/syscall_64.tbl linux-5.10/arch/x86/entry/syscalls/
+  cp -R SmartMD/kernel-v5.10/HawkEye/hawkeye_modules linux-5.10
+  ```
+
+* Compile HawkEye.
+
+  ```bash
+  cd linux-5.10/
+  
+  sudo make -j`getconf _NPROCESSORS_ONLN` && sudo make modules_install -j`getconf _NPROCESSORS_ONLN` && sudo make install
+  ```
+
+* Modify the booted kernel version to Linux 5.10.
+
+  ```bash
+  ```bash
+    # Method 1: install grub-customizer
+    sudo add-apt-repository ppa:danielrichter2007/grub-customizer
+    sudo apt-get update
+    sudo apt-get install grub-customizer
+    grub-customizer # This step will pop up a graphical interface, you can choose the kernel version to start first.
+    
+    # Method 2: update /etc/default/grub
+    # Check whether the newly compiled kernel is successfully installed
+  grep -A100 submenu  /boot/grub/grub.cfg |grep "Ubuntu, with Linux 5.10.0-HawkEye"
+    # The correct results is "Ubuntu, with Linux 5.10.0-HawkEye". Next, update /etc/default/grub with following contents.
+    #<<<
+    GRUB_DEFAULT="Advanced options for Ubuntu>Ubuntu, with Linux 5.10.0-HawkEye"
+    #GRUB_HIDDEN_TIMEOUT="5"
+    GRUB_HIDDEN_TIMEOUT_QUIET="true"
+    GRUB_TIMEOUT="10"
+    GRUB_DISTRIBUTOR="`lsb_release -i -s 2> /dev/null || echo Debian`"
+    GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
+    GRUB_CMDLINE_LINUX=""
+    #<<<
+    # Enable configuration.
+    sudo update-grub
+  ```
+
+* Use `sudo reboot` to reboot your machine.
+
+* After the machine restarts, use `uname -a` to check whether the current kernel version is Linux 5.10.0-HawkEye.
+
+## 2 Run HawkEye
+
+* Compile HawkEye module.
+
+  ```bash
+  cd linux-5.10/hawkeye_modules/async-zero
+  make
+  sudo insmod asynczero.ko &
+  cd ../bloat_recovery
+  make 
+  sudo insmod detect.ko
+  ```
+
+* Run HawkEye.
+
+  ```bash
+  sudo bash -c "echo always > /sys/kernel/mm/transparent_hugepage/enabled"
+  sudo bash -c "echo 100 > /sys/kernel/mm/transparent_hugepage/khugepaged/max_cpu"
+  ```
+
+Next, please refer to <https://github.com/ustcadsl/SmartMD> for the steps of the SmartMD Evaluation.
